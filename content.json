{"meta":{"title":"안피곤님의 블로그","subtitle":"코딩, 독서, 여행, 영화, 맛집","description":"시간이 천천히 갔으면 좋겠다.","author":"안피곤","url":"https://anpigon.github.io","root":"/"},"pages":[{"title":"About","date":"2019-10-31T15:43:09.225Z","updated":"2019-10-31T15:43:09.225Z","comments":true,"path":"/about/index.html","permalink":"https://anpigon.github.io//about/index.html","excerpt":"안녕하세요. 개발자 안피곤입니다.저는 Server Application Developer 입니다. 그러나 Blockchain, React, React Native에도 무척 관심을 가지고 있습니다.최근까지 금융권 SI 프로젝트에 참여하여 개발하였으며, 주로 Back-End API 서버와 Front-End 웹페이지 개발을 담당하였습니다.","text":"안녕하세요. 개발자 안피곤입니다.저는 Server Application Developer 입니다. 그러나 Blockchain, React, React Native에도 무척 관심을 가지고 있습니다.최근까지 금융권 SI 프로젝트에 참여하여 개발하였으며, 주로 Back-End API 서버와 Front-End 웹페이지 개발을 담당하였습니다. Contact me markan82@gmail.com 사이드 프로젝트 아래는 개인적으로 진행중인 사이드 프로젝트입니다. 스팀잇 펫 연구소 STEEM 블록체인에서 봇을 활용한 큐레이션 서비스 https://anpigon.github.io/pet Steem Engine Nitrous Instance STEEM의 사이드 블록체인, Steem Engine 기반의 Nitrous 오픈 소스 참여 https://www.steemzzang.com Github: https://github.com/steem-engine-exchange/nitrous 안드로이드 이더리움 모바일 지갑앱 React Native 기반의 이더리움 모바일 지갑앱 Google Play Store: https://play.google.com/store/apps/details?id=com.rn_ethereum_wallet BIP44 HD지갑 주소 생성 니모닉 시드 백업 기능 메인넷, 테스트넷(ropsten, kovan, rinkeby) 지원 Gas Station API를 이용한 수수료(Gas Price) 자동 계산 ERC20은 미지원(개발 미완료) 안드로이드 STEEM &amp; SCOT 보팅 파워 위젯 STEEM과 스팀엔진 기반의 토큰(SCOT) 보팅 파워를 볼 수 있는 안드로이드 바탕화면 위젯 앱 Google Play Store: https://play.google.com/store/apps/details?id=com.steem_widget 스팀엔진 토큰 거래소 스팀엔진 토큰 덱스 거래소(구현중) https://happigon.github.io"},{"title":"all-archives","date":"2019-10-31T13:42:43.555Z","updated":"2019-10-31T13:42:43.555Z","comments":false,"path":"all-archives/index.html","permalink":"https://anpigon.github.io/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2019-10-31T13:42:43.555Z","updated":"2019-10-31T13:42:43.555Z","comments":false,"path":"all-categories/index.html","permalink":"https://anpigon.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2019-10-31T13:42:43.555Z","updated":"2019-10-31T13:42:43.555Z","comments":false,"path":"all-tags/index.html","permalink":"https://anpigon.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"All categories","date":"2019-10-30T08:50:18.000Z","updated":"2019-10-31T13:42:43.555Z","comments":false,"path":"categories/index.html","permalink":"https://anpigon.github.io/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2019-10-30T08:49:50.000Z","updated":"2019-10-31T13:42:43.555Z","comments":false,"path":"tags/index.html","permalink":"https://anpigon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VSCode 단축키 5분 정리","slug":"/2019/11/11/vscode-keyboard-shortcuts","date":"2019-11-11T00:00:00.000Z","updated":"2019-11-11T14:06:13.963Z","comments":true,"path":"/2019/11/11/vscode-keyboard-shortcuts/","link":"","permalink":"https://anpigon.github.io/2019/11/11/vscode-keyboard-shortcuts/","excerpt":"아래 유튜브를 보고 VSCode에서 유용한 단축키를 정리해 보았습니다. 반복되는 코드를 한번에 수정하기 맥 단축키: Command + D 윈도우 단축키: CTRL + D 반복된 코드를 한번에 수정할 때 유용하다. 단축키를 누를 때마다 해당 코드가 반복 선택된다. 아래 화면은 preDocumentInfo 코드를 location으로 변경하고 있다.","text":"아래 유튜브를 보고 VSCode에서 유용한 단축키를 정리해 보았습니다. 반복되는 코드를 한번에 수정하기 맥 단축키: Command + D 윈도우 단축키: CTRL + D 반복된 코드를 한번에 수정할 때 유용하다. 단축키를 누를 때마다 해당 코드가 반복 선택된다. 아래 화면은 preDocumentInfo 코드를 location으로 변경하고 있다. 변수명/함수명 한번에 바꾸기 단축키: F2 함수나 변수명을 한번에 변경할 때 유용하다. 위의 단축키와는 다르게 선택한 변수명을 수정하면 해당 변수명이 모두 변경된다. 코드 위/아래로 이동하기 맥 단축키: Option + ↑ 또는 ↓ 윈도우 단축키: Alt + ↑ 또는 ↓ 이동할 코드에 커서를 두고 단축키를 누르면 해당 코드가 위/아래로 이동한다. 여러 줄의 코드를 선택하면 선택된 코드가 모두 이동한다. 코드 위/아래로 복사하기 맥 단축키: Shift + Option + ↑ 또는 ↓ 윈도우 단축키: Shift + ↑ 또는 ↓ 위와 다르게 코드를 위/아래로 복사한다. 같은 코드를 복사&amp;붙여넣기 할 때 유용하다. 코드를 한번에 주석 처리하기 맥 단축키: Command + / 윈도우 단축키: Ctrl+ / 해당 언어 문법에 맞게 자동으로 주석 처리해준다. 단축키를 다시 누르면 주석이 해제된다. 여러 곳에 커서를 두고 수정하기 맥 단축키: Option + 마우스 클릭 윈도우 단축키: Alt + 마우스 클릭 단축키를 누르고 마우스를 클릭하면, 클릭하는 곳마다 커서가 생성된다. 다중 커서 선택하여 수정하기 맥 단축키: Command + Option + ↑ 또는 ↓ 윈도우 단축키: Ctrl + Alt + ↑ 또는 ↓ 수정해야 할 세로 위치가 동일하다면, 다음 단축키를 사용하여 커서를 여러 곳에 두고 수정할 수 있다. 코드 맨 마지막에 커서 두기 맥 단축키: Shift + Option + I 윈도우 단축키: Shift + Alt + I 이 단축키도 매우 유용하다. 주로 변수를 복사&amp;붙여넣기 한 다음, 끝에 콤마(,)나 세미콜론(😉 을 넣을 때 자주 사용한다. 커서 위치에서 박스 형태로 선택하기 맥 단축키: Shift + Option + 마우스 드래그 윈도우 단축키: Shift + Alt + 마우스 드래그 코드를 커서 위치에서 박스 형태로 선택할 때 유용하다. 코드 맨 위 또는 맨 아래로 이동하기 맥 단축키: Command + ↑ 또는 ↓ 윈도우: 단축키: Ctrl + Home 또는 End import를 입력하기 위해 코드 맨 위로 이동하거나, 코드를 추가하기 위해 맨 아래로 이동할 때 유용하다. 사이드바 숨김/보이기 맥 단축키: Command + B 윈도우 단축키: Ctrl + B 코드 창을 넓게 보고 싶을 때 사용한다. 단축키 모두 확인하기 맥 기준으로 설명하겠습니다. 단축키를 볼 수 있는 페이지는 메뉴 Code &gt; Preferences &gt; Keyboard Shortcuts에 있다. Shift + Command + P 를 눌러서 keyboard shortcuts를 검색하면 쉽게 찾을 수 있다. 또는 단축키로 Command + S, Command + K 를 차례대로 입력하면 단축키 페이지로 이동한다. 이곳에서 모든 단축키를 볼 수 있다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"VSCode","slug":"vscode","permalink":"https://anpigon.github.io/tags/vscode/"},{"name":"단축키","slug":"단축키","permalink":"https://anpigon.github.io/tags/단축키/"}]},{"title":"[북클럽] 내 인생 가장 슬픈 책 ⟪미 비포 유⟫","slug":"/engrave/@anpigon/seujjang-bugkeulreob-misyeon-nae-insaeng-gajang-seulpeun-caeg-mi-bipo-yu","date":"2019-10-07T14:42:21.000Z","updated":"2019-11-11T13:41:49.865Z","comments":true,"path":"/engrave/@anpigon/seujjang-bugkeulreob-misyeon-nae-insaeng-gajang-seulpeun-caeg-mi-bipo-yu/","link":"","permalink":"https://anpigon.github.io/engrave/@anpigon/seujjang-bugkeulreob-misyeon-nae-insaeng-gajang-seulpeun-caeg-mi-bipo-yu/","excerpt":"죽음 앞에서 사랑이 물었다. 내 곁에서 그냥, 살아주면 안 되나요? 내가 읽었던 소설 중에 가장 슬픈 책은 바로 로맨스 소설 ⟪미 비포 유⟫ 입니다. 사실 로맨스 소설을 즐겨읽는 편은 아니지만, 하지만 이 책은 매우 슬펐습니다. ㅠㅠ","text":"죽음 앞에서 사랑이 물었다. 내 곁에서 그냥, 살아주면 안 되나요? 내가 읽었던 소설 중에 가장 슬픈 책은 바로 로맨스 소설 ⟪미 비포 유⟫ 입니다. 사실 로맨스 소설을 즐겨읽는 편은 아니지만, 하지만 이 책은 매우 슬펐습니다. ㅠㅠ 저에게 이렇게 감동적이고 가슴 깊은 곳에 울림을 주는 책은 ⟪나의 라임 오렌지 나무⟫, ⟪가시고기⟫, ⟪국화꽃 향기⟫, 김정현의 ⟪아버지⟫ 이후로 오랜만이었습니다. 사실 저의 가장 슬픈 책은 단연코 ⟪나의 라임 오렌지나무⟫라고 생각합니다. 하지만 다른 누군가가 북클럽 이벤트에 ⟪나의 라임 오렌지나무⟫를 쓸 것 같아서, 저는 가장 최근에 읽었던 ⟪미 비포 유⟫를 선택했습니다. ㅎㅎ 대충쓰는 ⟪미 비포 유⟫ 줄거리 주인공 M&amp;A 전문가 ⟨윌 트레이너⟩은 매우 오만했고 자기가 세상에서 제일 잘난 줄 알았다. 하지만, 갑작스런 교통사고로 한순간에 &quot;사지 마비 환자&quot;가 되어버린다. 그는 이제 팔다리를 전혀 움직일 수 없고, 간병인 도움 없이는 아무것도 할 수 없다. 그리고 사고 이후, 그는 아무런 삶의 의욕도 없이 하루하루를 겨우 버티며, 이 비참한 삶을 정리하는 방법만을 생각하며 살아간다. 영국 시골 마을의 작은 카페에서 항상 즐겁게 일하던 ⟨루이자⟩는 하루아침에 일자리를 잃고 백수가 된다. 그녀는 돈을 벌어 가족들을 먹여 살려야 하는 유일한 가장이다. 그래서 그녀는 바로 일자리를 구해야만 했다. 하지만 그녀가 시골 마을에서 당장 구할 수 있는 일자리는 바로 ‘사지 마비 환자의 6개월 임시 간병인’ 뿐이었다. 이렇게 그녀는 울며 겨자 먹기로 ⟨윌 트레이너⟩의 간병인으로서의 삶을 시작한다. 왜냐하면, 시급이 매우 높았고 6개월만 하면 되기 때문이었다. 매일 죽을 궁리만 하는 ⟨윌 트레이너⟩ 앞에 어느날 갑자기 ⟨루이자⟩라는 여자가 나타났다. 그는 ⟨루이자⟩를 매우 귀찮은 존재로 생각했다. 그래서 항상 그녀를 겁주고 매우 까칠하게 굴었다. 그녀는 그런 그가 무섭고 끔찍이 싫었지만, 그의 마음을 돌리기 위해 무단히 노력한다. 둘이 같이하는 시간이 점점 많아지고, 또 그녀의 노력 덕분인지 그는 그녀의 엉뚱함에 점점 익숙해져간다. 그리고 서로는 사랑의 감정을 느끼게 된다. 그러던 어느날 그녀는 그가 꽁꽁 숨겨왔던 비밀을 알게 되는데… 그 비밀은 바로… (소설책에서 확인하세요!) 돌아온 스짱 북클럽 미션: 내 인생 가장 슬픈 책","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"책","slug":"책","permalink":"https://anpigon.github.io/tags/책/"},{"name":"슬픈책","slug":"슬픈책","permalink":"https://anpigon.github.io/tags/슬픈책/"}],"author":"anpigon"},{"title":"조커 (2019)","slug":"/engrave/@anpigon/yeonghwa-iyagi-jokeo-2019","date":"2019-10-07T03:16:45.000Z","updated":"2019-11-11T13:41:49.852Z","comments":true,"path":"/engrave/@anpigon/yeonghwa-iyagi-jokeo-2019/","link":"","permalink":"https://anpigon.github.io/engrave/@anpigon/yeonghwa-iyagi-jokeo-2019/","excerpt":"“내 인생이 비극인줄 알았는데, 코미디였어” 영화를 보는 동안에는 호아킨 피닉스가 어떤 배우인지 전혀 알아차리지 못했어요. 그런데 배우 얼굴이 너무 익숙해서 필모그래피를 찾아보았습니다. 그런데 호아킨 피닉스 배우가 영화 ⟪HER⟫에 나왔던 주연 배우라는 사실을 알고 정말 “헐~” 했습니다. 같은 배우일거라고 생각 못했어요. 감상평 조커 영화는 너무 강렬했습니다. 극장에서 보는 동안 계속 긴장하면서 봤어요. 그동안은 항상 배트맨 영화에 나오는 악당 조커만 봤었는데, '조커’라는 케릭터가 만들어지는 과정은 정말 흥미로웠습니다. 그리고 주인공 아서 중심으로 흘러가는 영화의 스토리는 어떤게 진실이고 어떤게 거짓인지 알 수 없었습니다. 영화속 미쳐버린 세상에서 주인공 아서는 미쳐버렸고, 영화를 보는 저도 혼란에 빠졌습니다. 그리고 15세 관람가 영화인데 잔인한 장면들이 있어서 많이 놀랐습니다.","text":"“내 인생이 비극인줄 알았는데, 코미디였어” 영화를 보는 동안에는 호아킨 피닉스가 어떤 배우인지 전혀 알아차리지 못했어요. 그런데 배우 얼굴이 너무 익숙해서 필모그래피를 찾아보았습니다. 그런데 호아킨 피닉스 배우가 영화 ⟪HER⟫에 나왔던 주연 배우라는 사실을 알고 정말 “헐~” 했습니다. 같은 배우일거라고 생각 못했어요. 감상평 조커 영화는 너무 강렬했습니다. 극장에서 보는 동안 계속 긴장하면서 봤어요. 그동안은 항상 배트맨 영화에 나오는 악당 조커만 봤었는데, '조커’라는 케릭터가 만들어지는 과정은 정말 흥미로웠습니다. 그리고 주인공 아서 중심으로 흘러가는 영화의 스토리는 어떤게 진실이고 어떤게 거짓인지 알 수 없었습니다. 영화속 미쳐버린 세상에서 주인공 아서는 미쳐버렸고, 영화를 보는 저도 혼란에 빠졌습니다. 그리고 15세 관람가 영화인데 잔인한 장면들이 있어서 많이 놀랐습니다. 그리고 미국에서는 조커 영화 개봉과 관련하여 분위기가 심상치 않네요. 극장 주위로 경찰들이 경계 근무를 강화했다고 합니다. 조커가 영화속 인물들 뿐만 아니라 관객들에게까지 영향을 미치지 않을까 걱정됩니다. ㅎㅎ 관련 기사: [중앙일보] 영화 속 '조커’의 신들린 총구에, 극장 지키기 나선 美경찰 번역 논란 항상 있어왔던 번역 논란이 이번에도 역시 있었습니다. 저는 자막으로 영화를 보면서 내용을 이해하는데 불편함은 없었습니다. 하지만 아래 글을 읽고 나니 많이 아쉽습니다. 관련글: [에펨코리아] (자작) 걱정되는 조커 예고편 그 번역 문제점 비교 및 설명 총집합. 원작 만화에서 조커 탄생 배경 그리고 조커 탄생 배경에 대해서 &quot;원작 만화&quot;와 &quot;영화&quot;가 얼마나 비슷한지 인터넷에서 찾아봤습니다. 그런데 영화와는 내용이 완전 다르네요. ㅎㅎ 궁금하신 분은 아래 네이버 블로그를 읽어보세요. 관련글: [네이버 블로그] 조커의 탄생배경 -배트맨 킬링조크1- 대충 줄거리 주인공 아서 플렉은 모두에게 웃음을 줄 수 있는 스탠딩 코미디언을 꿈꾼다. 하지만 아서는 다른 사람들과의 유머 공감대가 전혀 없다. 왜냐하면 영화를 보다보면 다른 사람이 웃는 포인트에서 웃지 않고, 다른 포인트에서 혼자 웃는 장면이 나온다. 그의 직업은 코미디언이 아닌 광대다. 주로 가게 홍보를 하거나 아이들 축하 파티에서 공연한다. 한번은 폐업한 음반 가게를 홍보하다가 어린 불량소년들에게 강도를 당한적도 있다. 그는 번듯한 직장도 안정적인 수입도 없이 노모를 모시며 매우 힘든 삶을 살아간다. 아서는 거울을 보며 항상 억지로 입꼬리를 올려 웃는 척 해보지만, 잘 되지 않는다. 다른사람에게 항상 웃음을 줘야하는 광대이지만, 정작 본인은 즐겁지 않다. 조커 영화에서 가장 유명한 장면이라고 생각한다. 계단을 내려오면서 춤을 추는 아서는 점점 미치광이 조커로 변해간다. 영화 URL: https://www.themoviedb.org/movie/475557-joker?language=ko-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 리뷰","slug":"영화-리뷰","permalink":"https://anpigon.github.io/tags/영화-리뷰/"},{"name":"조커","slug":"조커","permalink":"https://anpigon.github.io/tags/조커/"},{"name":"호아킨 피닉스","slug":"호아킨-피닉스","permalink":"https://anpigon.github.io/tags/호아킨-피닉스/"}],"author":"anpigon"},{"title":"[소설] 헤르만 헤세 ⟪수레바퀴 아래서⟫","slug":"/engrave/@anpigon/dogseo-ilgi-surebakwi-araeseo---hereuman-hese","date":"2019-10-03T05:41:18.000Z","updated":"2019-11-11T13:41:49.865Z","comments":true,"path":"/engrave/@anpigon/dogseo-ilgi-surebakwi-araeseo---hereuman-hese/","link":"","permalink":"https://anpigon.github.io/engrave/@anpigon/dogseo-ilgi-surebakwi-araeseo---hereuman-hese/","excerpt":"자신을 짖누르는 가정과 학교의 종교적 전통, 고루하고 위선적인 권위에 맞서 싸우는 어린 소년을 주인공으로 한 작가의 자서전. 주인공 한스 기벤라트는 헤세의 분신일 뿐만 아니라 오늘을 사는 우리 젊은이들의 자화상이다. “이 책에는 내가 실제로 경험하고 괴로워했던 삶의 한 조각이 담겨 있다.” ___헤르만 헤세","text":"자신을 짖누르는 가정과 학교의 종교적 전통, 고루하고 위선적인 권위에 맞서 싸우는 어린 소년을 주인공으로 한 작가의 자서전. 주인공 한스 기벤라트는 헤세의 분신일 뿐만 아니라 오늘을 사는 우리 젊은이들의 자화상이다. “이 책에는 내가 실제로 경험하고 괴로워했던 삶의 한 조각이 담겨 있다.” ___헤르만 헤세 몇 달전에 감명깊게 읽었던 ⟪데미안⟫ 덕분에, 헤르만 헤세 작가의 소설을 하나씩 다시 읽고 있습니다. 헤르만 헤세의 소설은 주인공 내면의 갈등과 고뇌를 표현하는 심리 묘사가 매우 뛰어나다고 생각합니다. ⟪수레바퀴 아래서⟫는 헤르만 헤세의 자전 소설로 유명합니다. 자전 소설들의 대부분은 젊은 날의 고뇌와 방황, 사랑과 우정에 대한 이야기를 다루고 있습니다. ⟪수레바퀴 아래서⟫도 바로 이런 내용을 담고 있습니다. 그리고 소설 속에 나오는 인물 중에서 주인공 「한스 기벤라트」와 그의 친구 「헤르만 하일러」는 헤르만 헤세 바로 자신이라고 할 수 있다. 왜냐하면 소설 속 인물들이 겪었던 삶과 헤르만 헤세의 삶이 매우 비슷하기 때문입니다. 헤르만 헤세 내면의 대립되는 두 자아를 소설 속에서 두 인물로 나누어 표현한게 아닐까 생각됩니다. ⟪수레바퀴 아래서⟫는 19세기 말 독일 ‘빌헬름 제국 시대’의 교육 체계를 배경으로 하고 있습니다. 19세기 말 독일에서는 청소년의 자살이 크게 증가했습니다. 그래서 헤르만 헤세는 이 교육 체계에 대한 문제점을 비판하기 위해 소설을 썼다고 합니다. 소설은 모두 7장으로 되어 있습니다. 간략하게 줄거리를 초중반으로 정리했습니다. 참고로 인용문 뒤에 페이지 번호는 출판사 ⟪민음사⟫ 기준입니다. 초반 주인공 한스는 독일 시골마을에서 가장 재능있는 학생이다. 그 마을에서는 똑똑한 학생이 가야할 길은 하나 뿐이다. 주(州) 정부 시험에 합격하여 신학교와 튀빙겐 신학 대학을 졸업하고 목사나 교수가 되는 것이다. 한스는 이 시험을 치르기 위해서 학교 교장에게 그리스어를 배웠고, 오후에는 마을 목사에게 라틴어와 종교 과목의 보충 수업을 받았다. 그리고 일주일에 두 번은 한시간 동아 수학 교사의 지도를 받았다. 한스는 시험을 위해서 자신이 좋아하던 토끼 키우기, 낚시 등을 모두 포기했다. 그리고 피곤과 졸음, 그리고 두통과 싸워가며 매일 주 시험 준비에만 매진했다. “시험에 합격하게 되면, 원하는 건 뭐든지 내게 말해도 좋다” 아버지는 유쾌한 기분으로 라했다. “아녜요. 다 틀렸어요” 한스는 한숨을 내쉬며 말했다. “전 분명히 떨어졌을 거예요” “바보 같은 소리 좀 그만 해라. 어째서 그러니! 내 마음이 변하기 전에 어서 원하는 걸 말하는게 좋을 거야” “방학 때 다시 낚시하러 가고 싶어요. 허락하시는 거죠?” “그래. 좋아. 네가 시험에 합격하기만 하면” (p. 41) 한스는 주 시험에 2등으로 합격한다. 학교 교장과 아버지는 한스를 매우 자랑스러워 했다. 그리고 시험에 합격한 한스는 방학 동안 자신이 좋아하는 낚시를 할 수 있다는 생각으로 매우 즐거워한다. 한스는 발그레해진 얼굴로 눈을 반짝이며 신이 나서 낚싯대를 다듬었다. 그 일은 낚시하는 것만큼이나 그가 좋아하는 일이었다. 오후부터 저녁때까지 그는 내내 그 일에 매달렸다. (…) 이제 한스는 7주나 되는 긴 긴 방학을 지루하지 않게 보낼 수 있을 거라 확신했다. 낚싯대만 있으면 하루 종일 강가에 앉아 즐겁게 보낼 수 있기 때문이다. (p. 47) 시험에 합격하고 난 후 보내는 여름방학은 한스에게는 가장 안정적이고 달콤한 시간이었다. 한스의 여름방학을 잘 묘사하고 있다고 생각하는 문장을 몇개 발췌했다. 여름 방학은 이래야 한다! 산 위에는 용담(龍膽) 처럼 푸른 하늘이 펼쳐지고 눈부시게 빛나는 무더운 날들이 몇 주일이나 계속 되었다. 이따금 세찬 폭풍우가 갑작스럽게 몰아칠 뿐이다. 강물은 사암(砂岩) 바위들과 잣나무 숲의 그늘, 그리고 좁은 골짜기 사이로 흐르고 있었다. 하지만 무척이나 따뜻했기 때문에, 저녁 늦게라도 물에 들어갈 수가 있었다. 마른 풀과 베어놓은 풀의 내음이 마을을 휘감고 퍼져나갔다. 밀밭의 좁다란 두렁은 누렇게 금빛이 도는 갈색으로 변해 있었다. (p. 48) 한스는 철둑 위에서 멈추어 섰다. 둥근 양철통을 바지 주머니에서 끄집어내어 부지런히 메뚜기를 잡기 시작했다. 기차가 스쳐 지나갔다. 철길이 무척이나 가파르게 뻗어 있었기 때문에, 기차는 느긋한 속도로 천천히 움직였다. 기차는 흥겹게 나부끼는 깃발처럼 연기와 증기를 길게 내뿜으며 달리고 있었다. 빙빙 돌며 피어오르는 하얀 연기는 어느덧 햇살이 가득한 이른 차미의 맑은 하늘로 사라져갔다. 이 모든 풍경이 얼마나 오랜만이던가! 한스는 숨을 크게 들이마셨다. 마치 잃어버린 아름다운 시간을 이제 갑절로 다시 찾으려는 듯이. 그리고 전혀 거리낌이나 두려움 없이 다시 한 번 어린 시절의 세계로 되돌아가려는 듯이. (p. 50) 그리스어와 라틴어, 문법과 문체론, 산수와 암기, 그리고 오랫동안 쉬지도 못한 채 쫓기는 듯이 살아온 1년이라는 세월. 이 모든 괴로운 방황도 졸음에 잠긴 따스한 한나절 속으로 조용히 잠겨버렸다. (…) 이제 다시 예전처럼 강가에 앉은 한스는 둑에서 흘러내리는 하이얀 물거품이 물보라가 되어 흩날리는 광경을 바라보았다. 그리고 눈을 깜박거리며 드리운 낚싯줄을 지켜보았다. 그의 곁에서는 낚아올린 물고기들이 주전자 안에서 헤엄치고 있었다. 정말이지 무척 멋진 일이었다. (p. 54) 하지만 신학교에 입학하기 전 여름 방학을 신나게 즐기려던 한스의 꿈은 물건너 갔다. 교회 목사와 교장 선생을 비롯한 학교 교사들의 기대와 명예욕, 그리고 한스 자신의 야망 때문에 방학 동안에 즐기려던 낚시를 그만둔다. 교사들은 방학 때도 계속 공부하기를 요구했고, 신학교에서 배우게 될 과목에 대해서 선행학습하라고 압박한다. 이렇게 아버지와 교사들은 한스가 즐겁게 놀수 있는 유년시절을 빼앗가버렸다. 한스는 여름방학 동안 자신이 좋아하는 취미 생활을 포기하고 두통과 싸워가며 신학교에서 앞으로 배우게 될 과목을 공부한다. 성적 위주의 치열한 입시 경쟁 하에 있는 우리나라 청소년들에게 너무나 익숙한 광경이다. 찌는 듯이 무더운 오후 시간에 수영장 대신에 수학 교사의 후텁지근한 방을 찾아갔다. 거기에 틀어박혀 모기가 윙윙거리는 먼지투성이의 공기를 마시며 피곤한 머리를 부둥켜안은 채 텁텁한 목소리로 &quot;에이 플러스 비, 에이 마이너브 비&quot;를 중얼대야 하는 현실이 가혹스럽게 느껴졌다. 기분이 좋지 않은 날에는 무기력하고 갑갑한 분위기가 암울한 절망감으로 바뀌는 것이었다. (p. 76) 어느새 한스는 또다시 숙제 더미에 깔려 있었다. 어느때는 밤 늦게까지 책상에 앉아 이를 악물며 과제를 풀었다. 아버지 기벤라트는 열심히 공부하는 아들을 자랑스럽게 지켜보았다. 자신들의 줄기에서 뻗어난 가지가 자신들이 막연하게 존경해 마지 않던 높은 영역에까지 치솟기를 바라는 속인들의 이상이 아버지의 우둔한 머릿속에서도 어렴풋이 살아 숨쉬고 있었다. (p. 77) 여름 방학이 끝나고 그동안 교사들이 시키던 대로 공부만 했던 한스는 무척 야위었다. 그리고 그는 고향과 부모님의 집을 떠나 마울브론 신학교로 떠나게 된다. 중반 마울브론 신학교에서 유독 친구를 사귀지 못했던 두 친구, 한스 기벤라트와 헤르만 하일너는 서로에게 친밀함을 느끼고 친구가 된다. 하일너는 한스가 가지지 못했던 욕망을 거침없이 실현하는 존재이다. 하일너는 한스에게 매혹적이면서도 위험한 친구였다. 성격이 그리 복잡하지 않으면서도 눈에 띄는 인물은 슈바르츠발트에서 온 헤르만 하일너였다. 그는 훌륭한 가문에서 자란 아이였다. 벌써 첫날부터 주위에서 그가 문예 애호가이자 시인이라는 추측이 무성했다. 또한 주 시험에서 그가 육각운(六脚韻)으로 글을 썼다는 소문이 쫙 퍼져있었다. 그는 말하기를 즐기고, 활기가 넘쳤으며, 멋진 바이올린을 가지고 있었다. 또한 겉으로 드러나는 자신의 외양을 일부러 부각시키기 위하여 남다른 노력을 기울니는 것 같았다. 이러한 성향은 아직 성숙되지 못한 젊은이들의 경솔한 느낌들이 서로 불확실하게 뒤섞여 나타나게 되는 혼합물과 같았다. 하지만 그의 몸과 마음은 자신의 나이에 걸맞지 않게 성장해 있었다. 그는 벌써 나름대로 시행착오를 거치며 자기 길을 가기 시작했다. (p. 95) 하일너는 자기 나름대로의 사고와 언어를 가지고 있었으며, 남들보다 더 열정적이고 자유로운 생활을 누리고 있었다. 하지만 그는 남다른 고민으로 괴로워 했으며, 자기 주변을 둘러싼 환경을 경멸에 찬 눈초리로 쳐다보았다. 어느날 하일너는 다른 학우와 싸움을 하게 되고 눈물을 보이며 치욕스러운 일을 당하게 된다. 이날 저녁 하일너는 차갑고 어두운 침실이 창턱에 앉아 꼼짝도 않고 회랑을 내려다본다. 한스는 그런 하일너의 뒷모습을 보고 측은하게 여겨 다가간다. 그리고 그 둘은 키스를 한다. 이것은 한스 자신의 숨겨진 욕망에 키스하는 장면이다. 두 소년은 서로의 얼굴을 마주보았다. 아마 이 순간에 처음으로 상대방의 얼굴을 진지하게 바라본 것 같았다. 젊음이 넘치는 매끄러운 생김새 뒤에 깃들여 있을지도 모를, 특유의 성향을 지닌 남다른 인간적인 생명과 나름대로의 특징적인 영혼을 마음속에 그려보았다. 헤르만 하일너는 천천히 팔을 펴 한스의 어깨를 붙들었다. 그러고는 서로의 얼굴이 거의 닿을 만큼 한스를 끌어 당겼다. 한스는 갑자기 상대방의 입술이 자기의 입술에 닿는 느낌 때문에 소스라쳐 놀라고 말았다. 한스의 심장은 이제까지 느껴보지 못한 야릇한 감정을 이겨내지 못하고, 두근거리기 시작했다. 하일너와 어두운 침실에 함께 있다는 것, 그리고 갑자기 서로 입맞춤을 나눈다는 것은 한스의 모험심을 충족시켜 주면서도 새롭고 위험천만한 일이었다. 만일 누군가에게 들키기라도 한다면, 그야말로 끔찍스러운 꼴을 당하게 될지 모른다는 생각이 들었다. 왜냐하면 다른 사람에게는 두 소년의 입맞춤이 방금 전에 하일너가 흘렸던 눈물보다 훨씬 더 우스꽝스럽고 치욕스럽게 여겨질 것이기 틀림없기 때문이었다. 한스는 아무 말도 할 수 없었다. 단지 피가 머리 위로 솟구쳐 오르는 듯한 느낌을 받았을 뿐이다. 한스는 당장이라도 자리를 박차고, 도망치고 싶은 충동에 사로 잡혔다. (p.112 ~ 113) 어느 추운 겨울날 한스와 같은 방에 거처하고 있던 힌딩어가 연못에 빠져 익사하는 사고가 발생한다. 그날 오후 늦게서야 사람들은 힌딩어가 없어진 사실을 알아차린다. 마침내 뻣뻣하게 굳어버린 소년의 자그마한 시체가 발견되어 눈 덮인 갈대 숲에서 들것에 실렸을 때에는 이미 어둠이 짙게 깔린 뒤였다. 신학교 학생들은 놀란 새처럼 불안에 떨며 시체의 주위에 몰려들었다. 그리고 두 눈을 크게 뜨고 시체를 쳐다보며 파랗게 곱은 손가락을 문지르고 있었다. (p.133) 한스는 이 날 첫 죽음을 경험했다. 그날부터 몇일동안 신학교 내에는 적막적인 분위기가 감돌았다. 학생들의 모든 행위와 언어가 부드러워졌고, 이 기간에는 싸움이나 노여움, 야단법석이나 웃음 모두 자취를 감추었다. 모범 소년 한스는 가슴이 저리는 듯한 슬픔과 부끄러움을 느꼈다. 얼어붙은 들판길을 걸어 비틀거리며 계속 앞으로 나아갔다. 추위에 새파래진 뺨을 타고 하염없이 쏟아져내리는 눈물을 주체할 수가 없었다. 그는 잊을 수도 없고, 또 후회해도 돌이킬 수 없는 죄악과 태만이 있다는 사실을 깨달았다. 재단사의 아들 힌딩어가 아닌, 바로 자신의 친구 하일너가 맨 앞에서 높이 들린 들것 위에 실려가는 것처럼 여겨졌다. 마치 한스의 배신에 대한 고통과 분노를 한몸에 지고 또 다른 세계로 떠나가듯이. 성적이나 시험이나 성공의 의해서가 아니라, 양심의 순결이나 오욕에 의하여 인간이 평가되는 그러한 세계로. (p.134) 죽음을 경험한 이후 한스는 더욱 성숙해졌다. 그리고 하일너와의 우정은 더 깊어졌고 일상은 더 즐거워졌다. 하지만 학교 생활은 갈수록 한스에게 점점 더 낯설게만 여겨졌다. 그리고 지금까지 모범생이었던 한스가 하일너의 영향으로 점점 문제 학생으로 변해하는 모습을 보고 교사들은 모두 그를 안타까워했다. 조숙한 두 소년은 그들의 우정 속에서 가슴 벅찬 수줍음을 지닌 채 자신도 모르는 사이에 첫사랑의 달콤한 비밀을 다른 학우들에 앞서 맛본 것이다. 더욱이 이들의 ⟨동맹⟩은 성숙해 가는 남성다움의 거친 매력을 지니고 있었다. 또한 다른 학우들에 대한 반항심을 양념처럼 간직하고 있었다. 이들은 하일너를 꺼리고, 한스를 이해하지 못했다. 이들의 숱한 우정은 아직도 순박한 소년의 소꿉장난에 지나지 않았다. (p. 141) 학교 선생들은 두 젊은 소년들의 행위를 위험하다고 여기고 이들에게 사랑을 베푸는 대신에 오랫동안 유지되어 온 학교 규칙에 따라 곱절이나 엄하게 다스렸다. 하지만 한스를 자랑스럽게 여겨온 교장 선생만이 그를 구제하기 위해 대화를 시도 했다. 교장 선생과의 대화에서 소설 제목이 왜 ⟪수레바퀴 아래서⟫ 인지에 대한 이유가 나온다. “자네 앞으로 열시히 공부하겠다고 나한테 약속해 주겠나?” 한스는 교장 선생이 내민 오른손에 자신의 손을 얹어놓았다. 교장 선생은 그를 엄숙하면서도 부드러운 눈길로 쳐다보았다. “그럼, 그래야지. 아무튼 지치지 않도록 해야 하네. 그렇지 않으면 수레바퀴 아래 깔리게 될지도 모르니까” (p .146) 어느 날 학교생활에 싫증 난 하일너가 학교를 탈주하는 말썽을 부려 강제 퇴학을 당하게 된다. 하일너가 떠나간 후, 한스는 학교생활에서 아무런 의미를 찾지 못한다. 그리고 한스의 성적과 그에 대한 교사들의 평판은 점점 떨어졌다. 결국 한스는 건강이 점점 악화되고 극심한 신경쇠약증에 걸린다. 그 다음날, 수학 선생은 벽에 걸려 있는 칠판에 기하 도형을 그리고 나서 이 도형을 증명하도록 한스를 호명했다. 한스는 그만 칠판 앞에서 현기증을 일으키고 말았다. 백묵과 잣대를 들고 아무렇게나 칠판 위를 휘갈려 쓰다가 필기 도구를 떨어뜨렸다. 그것을 주우려고 몸을 굽혀 바닥에 무릎을 꿇고는 다시는 일어나지 못했다. (…) 마을 의사는 한스가 즉시 요양을 위해 휴가를 떠나야 한다고 말했다. 그리고 이제는 신경전문의와의 상담이 필요하다는 의견을 조심스럽게 내놓았다. “저 아이는 분명 무도병에 걸리고 말 거예요” 마을 의사는 교장 선생에게 귓속말로 이야기했다. 고개를 끄덕이던 교장 선생은 무자비하리만치 화난 표정을 아버지처럼 자상하고 동정어린 표정으로 바꾸는 것이 좋겠다고 생각했다. 그것이 교장 선생에게는 그리 어려운 일은 아니었다. 오히려 잘 어울리기조차 했다. (p. 173 ~ 174) 한스의 건강을 걱정한 의사와 교장 선생은 그를 고향 집으로 돌려보내기로 결정한다. 하지만 교장 선생은 한스가 학교를 떠나면 다시는 돌아오지 않으리라는 것을 잘 알고 있었다. 결국 한스는 고향으로 돌아와 살게 된다. 그는 공부와 우정 두가지 목표를 잃어버렸다. 그리고 즐겁지 않은 유년시절을 가진 그는 하루하루 흘러가는 세월을 그저 멍하니 바라보며 보낸다. 후반 가을이 깊어지고 한스의 삶의 의욕도 점점 사라져갈 무렵 그에게 구원의 손길이 다가왔다. 그가 3년전 무척 좋아했던 엠마가 고향에 돌아왔다는 소식을 듣는다. 그리고 한스는 플라이크 씨의 과즙 짜는 일터에 구경갔다가 우연히 엠마을 보게된다. 그녀는 열여덟이나 열아홉쯤 되어보였다. 여느 저지대 출신처럼 몸놀림도 가볍고, 성격도 쾌할해 보였다. 키는 그다지 크지 않았지만, 풍만하고 균형잡힌 몸매였다. 동그란 얼굴에 검고 따뜻한 눈빛과 입맞추고 싶어지는 아리따운 입은 활달하고 영리한 분위기를 자아내었다. 아무튼 그녀는 건강하고 명랑한 하일브론 아가씨처럼 보였다. (…) 그녀는 속세에 속한 존재였다. 그녀의 눈은 밤마다 버릇처럼 성경과 고소느의 &quot;보물상자&quot;를 읽는 사람의 눈은 아니었다. (p. 207) 한스와 엠마는 단둘이서 압축기 옆에 남게 되었다. 엠마는 어수룩한 한스를 상대로 장난을 치며 그를 유혹한다. 한스는 마법에 걸린 듯 사랑에 빠진다. 엠마는 그에게 첫사랑이자 마지막 사랑이었다. 모든 것이 이상하게도 다르게 변해 있었다. 아름다움을 자아내며 마음을 설레게 만들었다. (…) 하늘이 이처럼 높고, 아름답고, 그리움으로 푸르게 물들었던 적은 한 번도 없었다. 강물이 이다지도 맑고, 청록색의 거울처럼 미소짓던 적이 없었다. 둑이 이리도 눈이 부시리만치 하이얀 거품을 내뿜은 적이 없었다. 모든 것이 장식을 두른 그림처럼 새로이 그려져 투명하고, 산뜻한 유리판 뒤에 세워진 듯이 보였다. 또한 모든 것이 한바탕 축제가 벌어지기를 기다리고 있는 것 같았다. 한스의 가슴속에서도 이상하리만치 굳건한 감정과 처음 느껴보는 눈부신 희망의 파도가 세차게, 불안하게, 그리고 달콤하게 굽이쳣다. (…) 이 모순적인 감정은 희미하게 솟구치는 샘풀이 되어 있었다. 몹시도 강렬한 그 무엇이 한스의 가슴 깊숙이 묶여진 사슬을 끊고, 자유를 만끽하려는 듯했다. 그것은 아마도 흐느낌이너가 누래거나 부르짖음이거나, 아니면 떠들썩한 웃음이었을 것이다. (p. 213) 한스는 엠마가 보고 싶어 매일 밤 그녀의 집 앞을 서성였다. 그리고 그녀는 그런 그에게 매일 밤 키스를 해줬다. 그녀 덕분에 한스가 가지고 있던 마음의 병과 두퉁이 조금씩 치유되는 듯 했다. 그녀의 나지막한 목소리는 마치 머나먼 밤하늘의 저편에서 들려오는 것만 같았다. “나한테 뽀뽀해 주겠니?” 그녀의 밝은 얼굴이 가까이 다가왔다. (…) 은은한 향내를 풍기는 흐트러진 머리카락이 한스의 이마를 스쳤다. 넖게 퍼진 하얀 눈꺼풀과 까만 속눈썹으로 덮인 그녀의 눈은 살며시 감긴 채 바로 한스의 눈앞까지 다가와 있었다. 수줍은 듯이 내민 한스의 입술이 그 소녀의 입에 닿았을 때, 강렬한 전율이 그의 몸을 휘감고 지나갔다. (…) 한스는 그녀의 입술이 타오르는 것을 느겼다. 그리고 마치 한스의 생명을 삼켜버리기라도 하려는 듯이 그녀의 입이 자신의 입을 내리누르며 탐욕스럽게 빨아대는 느낌이 들었다. 낯선 입술이 자신의 입술에서 떨어지기도 전에 그처럼 전율에 휩싸인 환희는 견디기 힘든 피곤과 고통으로 변해 있었다. 엠마가 그의 입술을 자유롭게 놓아주었을 때, 한스는 비트적거리며 경련을 일으키는 듯한 손가락으로 울타리를 꼬옥 붙들었다. (p. 220 ~ 221) 어느날 갑자기 한스는 엠마가 고향을 떠나 집으로 돌아갔다는 소식을 듣는다. 그녀는 한 마디 말도 없이 작별 인사도 없이 떠나버렸고, 한스는 그녀가 진실된 마음으로 대하지 않았다는 것을 알아버렸다. 그는 무엇인가를 잃어버린듯 불행에 빠지고 말았다는 막연한 느낌에 사로잡혔다. 그리고 매일 밤 그는 엠마에 대한 그리움으로 몸부림쳤다. 결국 그녀와의 사랑은 그에게 강렬한 상흔을 남겼다. 왜 그 추억이 이처럼 아름답고 강렬한지, 왜 그 추억이 자신을 이다지도 비참하고 이처럼 아름답고 강렬한지, 왜 그 추억이 자신을 이다지도 비참하고 슬프게 만드는지 알 수 없었다. (…) 단지 그는 이 추억이 어젯밤에 있었던 엠마에 대한 기억과 조화를 이루지 못하고 있다는 것, 그리고 그 옛날의 행복과 일치하지 않는 무엇인가가 자신의 내면에서 꿈틀거리고 있다는 것을 느낄 뿐이었다. 다시 깃대가 황금빛으로 반짝이는 모습이 보이고, 친구 아우구스트가 웃는 소리가 들리고, 갓 구운 과자의 냄새가 나는 것만 같았다. 이 모든 것이 너무나도 즐겁고 행복했지만, 이제는 그로부터 멀리 떨어져 전혀 낯선 과거가 되어버렸다. 그래서 한스는 껍질이 거친 아름드리 잣나무에 기대어 절망에 싸인 채 흐느껴 울기 시작했다. 이 눈물도 그에게는 순간의 위안과 구원을 줄 뿐이었다. (p.224 ~ 225) 시작하자마자 허무하게 끝나버린 그의 안타까운 사랑의 기억을 가진채로, 한스는 다시 시작하려고 한다. 그는 아버지 권유로 기계공이 되기 위해 기계공장에 취직한다. 공부, 우정, 사랑 모두를 잃어버린 그는 더욱 방황하고 죽음에 대한 생각은 점점 더 강해진다. 어느날 한스는 술에 취해 강물에서 싸늘한 주검으로 발견된다. 한스의 죽음이 자살인지 사고였는지는 아무도 알 수 없었다. 같은 시각, 아머지가 마음속으로 그토록 꾸짖던 한스는 이미 싸늘한 시체가 되어 검푸른 강물을 따라 골짜기 아래로 조용히 내려가고 있었다. 구역질이나 부끄러움이나 괴로움도 모두 그에게서 떠나버렸다. 어둠 속에서 흘러 내려가는 한스의 메마른 몸뚱이 위로 푸른 빛을 띤 차가운 가을밤의 달빛이 비치고 있었다. (…) 그가 어떻게 물에 빠지게 되었는지는 알 수 없는 일이었다. (…) 평화와 깊은 안식이 가득한 밤, 그리고 창백한 달빛이 그를 향해 비추었기 때문에 피곤함과 두려움에 지친 나머지 어찔할 수 없이 죽음의 그림자에 휘말려 들었는지도 모른다. (p.260 ~ 261) 결국 그는 죽음을 선택함으로써 수레바퀴의 굴레를 벗어날 수 있었다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"},{"name":"헤르만 헤세","slug":"헤르만-헤세","permalink":"https://anpigon.github.io/tags/헤르만-헤세/"}],"author":"anpigon"},{"title":"제이콥님의 스팀 독서모임 블로그 소개","slug":"/engrave/@anpigon/jeikobnimyi-seutim-dogseomoim-beulrogeu-sogae","date":"2019-10-02T04:11:03.000Z","updated":"2019-11-11T13:41:49.865Z","comments":true,"path":"/engrave/@anpigon/jeikobnimyi-seutim-dogseomoim-beulrogeu-sogae/","link":"","permalink":"https://anpigon.github.io/engrave/@anpigon/jeikobnimyi-seutim-dogseomoim-beulrogeu-sogae/","excerpt":"스팀 독서모임요즘 제이콥님이 만든 ⎡스팀 독서모임⎦ 블로그에 가끔 들어갑니다. 그리고 올라온 글을 읽고 댓글 달고 보팅하고 있습니다. 하지만 해당 블로그에 생각보다 글이 많이 안 올라와서 조금 심심합니다. 여기에 글 올리면 제가 즐겁게 읽고 열심히 보팅 해 줄 수 있을 것 같습니다. ㅎㅎ","text":"스팀 독서모임요즘 제이콥님이 만든 ⎡스팀 독서모임⎦ 블로그에 가끔 들어갑니다. 그리고 올라온 글을 읽고 댓글 달고 보팅하고 있습니다. 하지만 해당 블로그에 생각보다 글이 많이 안 올라와서 조금 심심합니다. 여기에 글 올리면 제가 즐겁게 읽고 열심히 보팅 해 줄 수 있을 것 같습니다. ㅎㅎ 관련글: [필독] 온라인 독서모임 - @jacobyu 참고로 engrave 블로그는 태그를 최대 5개까지만 입력 가능합니다. 그래서 저는 글 작성할때 태그를 이렇게 입력했어요. 그러면 ZZAN, LIV, SCT 토큰 보상을 받을 수 있습니다. LIV 토큰은 #kr 태그를 입력해도 받을 수 있어요. 보트 가치 최근에 일부 임대하고 있었던 스파를 회수했습니다. 그리고 스파업도 조금 했습니다. 그러고 나서 제 보트 가치를 보니 약 $0.04 ~ $0.05 정도 됩니다. 그리고 현재(2019. 10. 2) 기준으로 SBD의 마켓가격은 ₩756 입니다. 제 보트 가치를 원화로 환산하면 약 30 ~ 38원이 됩니다. 글을 쓰고 싶게 만드는 금액은 아닙니다. 하지만 제이콥님을 비롯한 다른 분들도 보팅해줄 거라고 생각합니다. ㅎㅎ 리뷰쓰면 보상 주는 서비스: YES24 도서 리뷰를 쓰면 보상을 주는 서비스는 제가 알기로 YES24가 유일한 것으로 알고 있습니다. 대신 구매한 도서에 대해서만 리뷰를 남겨야합니다. 참고: YES24 리뷰/한줄평 리워드 YES24 블로그에 리뷰를 쓰고, 스팀잇에도 리뷰를 작성하면 더 많은 보상을 받아 갈 수 있어요. ⎡스팀 독서모임⎦에 리뷰를 작성해보세요. ㅎㅎ","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서모임","slug":"독서모임","permalink":"https://anpigon.github.io/tags/독서모임/"}],"author":"anpigon"},{"title":"세상에서 가장 재미있는 61가지 심리실험: 인간관계편","slug":"/engrave/@anpigon/61","date":"2019-09-25T13:38:33.000Z","updated":"2019-11-11T13:41:49.865Z","comments":true,"path":"/engrave/@anpigon/61/","link":"","permalink":"https://anpigon.github.io/engrave/@anpigon/61/","excerpt":"며칠 전에 우연히 서점에 갔다가 발견하고, 도서관에서 빌려서 읽었습니다.이 책은 인간관계에 대한 심리 실험에 관한 내용입니다.읽어보면 재미있는 실험이 정말 많습니다.제가 재미있다고 생각하는 실험 내용의 일부를 소개합니다. 호감을 얻고 싶다면 상대의 행동을 자연스럽게 흉내내라","text":"며칠 전에 우연히 서점에 갔다가 발견하고, 도서관에서 빌려서 읽었습니다.이 책은 인간관계에 대한 심리 실험에 관한 내용입니다.읽어보면 재미있는 실험이 정말 많습니다.제가 재미있다고 생각하는 실험 내용의 일부를 소개합니다. 호감을 얻고 싶다면 상대의 행동을 자연스럽게 흉내내라 미국 국립위생연구소 동물센터에서 꼬리감는 원숭이 몸짓을 흉내 내는 실험을 했다. 동전과 먹이를 교환하는 게임을 하자, 원숭이는 자신을 흉내내는 사람과 동전을 더 자주 교환했다. 동작을 흉내 내면 원숭이에게 호감을 얻는 셈이다. 암컷 파리에게 차인 수컷 파리가 알코올에 탐닉하는 이유 미국 제닐리아 팜 연구 캠퍼스 하워드 휴스 의학연구소에서는 수컷 파리를 대상으로 교미를 중단하게 하는 실험을 했다. 몇일 동안 이성과의 관계를 철저히 차단당한 수컷 파리에게 먹이를 선택할 기회를 주었다. 연구팀은 '파리가 늘 먹던 음식’과 ‘15% 알코올이 함유된 음식’ 2가지를 준비했다. 암컷에게 연이어 거부당한 수컷 파리는 알코올이 함유된 음식을 선택했다. '거짓말하지 마세요’보다 '거짓말쟁이가 되지 마세요’가 더 효과적인 이유 1에서 10까지 숫자 중에서 하나만 머리속에 떠올려보라고 하면 80퍼센트의 사람은 홀수를 떠올린다. 캘리포니아대학교 연구팀은 이것을 바탕으로 새로운 실험을 했다. 연구팀은 실험 참여자에게 방금 떠올린 숫자가 짝수라면 5,000원 준다는 제안을 했다. 그랬더니 '짝수’라고 응답한 사람 비율이 50%에 달했다. 이 사람들 중에서 30%는 거짓말 했다는 이야기이다. 그다음 연구팀에서는 '양심 경고등’을 사용해서 다시 실험을 했다. 양심 경고등 A에는 ‘거짓말 하지 마세요’, 양심 경고등 B에는 ‘거짓말쟁이가 되지 마세요’. 양심 경고등 B를 받은 사람들이 짝수라고 대답한 비율이 훨씬 낮았다. '빨강’이 여성의 성적 매력을 높여준다 로체스터대학교 연구팀은 컴퓨터로 여성의 옷 색깔을 다양하게 변화시켜 어떤 색이 남성에게 더 매력적으로 보이는지 실험했다. 그 결과 '빨강’이 가장 높은 점수를 얻었다. 연구팀은 이 실험의 연구 결과가 문화적 배경으로 비롯된 효과라고 판단하고, 서아프리카 부르키나파소 원주민을 대상으로 2차 실험을 했다. 참고로 부르키나파소 원주민은 미국 중심의 현대 문화와 동떨어져있고, 그들 문화에서 빨강은 '불길한 색’으로 여기기 때문에 실험대상으로 적합하였다. 놀랍게도 부르키나파소 원주민조차 빨강이 여성의 성적 매력을 높여주는 반응을 보여줌을 증명했다. 기분 전환하면 기억력이 향상된다 부에노스아이레스 대학교 연구팀은 실험용 쥐를 물건 2개와 함께 상자에 4분간 넣어두었다. 잠시 후 2개의 물건 중 하나를 바꾼 다음 다시 쥐를 상자에 넣는 방식으로 인지력과 기억력을 측정했다. 그 결과 쥐는 30분 정도 짧은 시간 안에 다시 본 물건만 정확하게 기억했다. 그 다음 연구팀은 쥐가 한 번도 가본 적 없는 장소에 쥐를 5분간 놓아두었다. 이틀 후 다시 쥐를 상자에 넣어 기억력을 테스트했다. 놀랍게도 기억력 성적이 70%까지 올랐다. 기분 전환 덕분에 기억력이 크게 향상되었다. 잠이 부족하면 뇌는 농떙이를 피운다. 위스콘신대학교 연구팀은 쥐의 수면 시간 중 하룻밤을 잠을 못자게 해보았다. 그리고 나서 쥐의 뇌 활동을 관찰했다. 쥐는 억지로 깨어있었지만 뇌는 부분적으로 잠을 자고 있었다. 그 증거로 뇌의 곳곳에서 조금씩 서파가 기록되었다. 서파는 깊은 수면 중일때 뇌 전체에서 고르게 관찰되는 뇌파이다. 수면 부족 상태에서는 모자라는 잠을 보충하기 위해서 뇌 신경세포들이 교대로 서파를 기록했다. 연구팀은 이러한 뇌이 부분적 수면에 '국소 수면’이라는 이름을 붙였다. 그리고 이 '국소 수면’이 나타나는 동안 학습 능력이 저하된다는 사실도 발견했다. 수면 시간이 줄어들면 왜 살이 찔까? 콜로라도 대학교 연구팀은 평소 7~8시간 자는 건강한 사람을 모집해 연속 닷새간 5시간만 자는 실험을 반복했다. 그 결과 실험에 참여한 사람들의 몸무게가 0.8Kg 늘어났다. 수면 부족은 비만을 유발하는 요인임을 밝혀냈다. 연구팀은 잠이 부족하면 왜 몸무게가 늘어나는지 밝히기 위해 실험에 참가한 사람들의 행동을 꾸준히 관찰하고 조사했다. 그 과정에 참여자들이 과자 등 군것질거리에 자꾸 손대는 것을 확인했다. 수면 부족은 활동으로 인해 에너지 소비가 증가하는 것 이상으로 쉽게 과식하게 만들어 비만을 유발한다고 볼 수 있다. 그리고 수면이 부족하면 이성적인 판단력과 자제력이 부족해지 때문에 필요 이상으로 섭식하게 된다. 언어 능력이 발달하면 예술 재능이 사라진다. 과학자들은 자폐증을 가진 사람이 뛰어난 능력을 발휘하는 순간의 뇌 활동을 측정했다. 그 결과, 정상적인 사람과는 다른 뇌 영역이 활성화된다는 사실을 밝혀냈다. 시각 연구자 슈나이더 박사는 전두측두엽이 언어와 개념을 관장하는 뇌 영역에 속해 있다는 사실에 주목했다. 그 연장선에서 그는 '언어가 초인적 능력을 발휘하지 못하도록 억제하는 역할을 할 가능성이 있다’라고 추정했다. 플린더스대학교 연구팀은 이 가설을 검증했다. 연구팀은 강력한 자기 자극 장치로 피실험자의 전두측두엽을 마비시켜 언어 능력을 상실하게 만들었다. 그 이후 기억력과 그림 실력, 계산 능력이 모두 눈에 띄게 향상샜다. 그러나 이 능력은 언어 마비가 회복되자마자 다시 평범한 수준으로 돌아갔다. 서번트 증후군(Savant Syndrome)이라는 말은 누구나 한 번쯤 들어본적이 있을 것입니다. 서번트 증후군은 나디아라는 천재 소녀 화가의 사례로 매우 유명해졌습니다. 나디아는 말 한마디 제대로 하지 못하고 다른 사람과 기본적인 소통도 매우 어려워했습니다. 하지만 그림 실력은 평범한 또래 아이들의 수준을 훨씬 뛰어넘었습니다. 그래서 그림 실력이 궁금하여 인터넷을 검색하여 찾아보았습니다. 왼쪽은 보통의 5살 어린이의 그림이고, 오른쪽은 나디아가 5살때 그린 그림입니다. 그림 실력이 넘사벽이네요. ㅎㅎ 게임에 빠진 사람이 게임을 안 하는 사람보다 인지력과 집중력이 뛰어나다 제네바 대학교 연구팀은 게임을 자주 하는 사람과 그렇지 않은 사람의 능력을 비교했다. 그 결과, 게임을 하는 사람이 다양한 방면에서 좋은 성적을 얻었다. 예를 들어 대비가 불명료한 줄무의를 0.5초간 보여주고 줄무늬 방향을 알아맞히는 실험을 했다. 평소에 게임을 즐긴 사람의 정답률이 30% 더 높았다. 특히 액션 게임을 즐기는 사람들에게 이러한 경향이 더 뚜력하게 나타났다. 그리고 액션 게임의 효과는 몇 가지 영역에서 확실한 향상이 있었다. 여러가지 임무를 동시에 수행하는 '다중작업 능력’과 머리속으로 입체 도형을 적절히 회전시키는 ‘공간 처리 능력’, 그리고 ‘수학 능력’ 등 이다. 인간이 지금보다 더 똑똑해질 수 없는 이유 스위스 바젤대학교 연구팀은 ⟪우리는 왜 지금보다 더 똑똑해질 수 없을까?⟫하는 논문을 발표했다. 연구팀은 이 논지의 근거를 '트레이드 오프’에서 찾았다. '트레이드 오프’란 무언가를 얻으려면 반드시 무언가를 잃어야 한다는 개념으로, 진화 과정에서 보편적으로 발견되는 원리이다. 기억력이 병적으로 뛰어난 환자는 현실과 뇌가 만들어낸 세계를 구별하지 못해 일상생활을 영위하기가 아렵다. 본래 인간은 기억력보다 '망각력’이 뛰어난 종이다. 두뇌의 작동 메커니즘과 존재 의미를 이해하면 망각력이 기억력 못지않게 중요한 능력이라는 것을 알게 된다. 뇌에 전기 자극을 가하면 '수포자’도 '수학 천재’가 된다 옥스퍼드 대학교 연구팀은 뇌에 전기 자극을 주어 수학 능력을 높이는 실험에 성공했다. 연구팀은 우뇌의 후두 두정엽을 자국해 활성화했다. 실험 방법은 가공의 숫자를 수치선 상에서 순서대로 늘여놓거나, 수의 대소를 대합하는 실험이다. 실험 결과 전기 자극을 받은 참여자는 성적이 올랐고, 반대로 전류를 역방향으로 흘려보내 해당 부위를 억제한 참여자는 성적이 떨어졌다. 그리고 이것은 일시적인 효과가 아니었고 6개월 후 재시험을 해도 효과는 유지되었다. 외국어 실력도 '유전자’가 결정한다 제 2 언어 습득은 환경보다 유적적 요인이 강하다. 유전의 기여가 71%에 달한다. 이것은 2009년 네덜란드 암스테르담 자유대학교 빈큐이젠 교수팀의 연구 결과이다. 이후 뉴멕시코 대학교 데일 교수팀에서 오랜 기간동안의 실험과 심층 연구를 거쳐 유전적 기여가 67%라고 발표했다. 이후 공동 연구팀은 '제 2 언어의 학습 능력은 모국어 습득 능력과 관계가 없다’라고 주정했다. 즉, 영유아기에 모국어에 일찍 말문이 트였다고 해서 외국어에 특별한 재능을 보인다는 보장이 없다는 말이다. 이쯤 되면, 영어 수업 시간에 교사가 학생들의 영어 실력을 평가하는 것은 노력으로 바꿀 수 없는 '유전자 우열’을 수치화할 뿐이라는 생각이 든다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"}],"author":"anpigon"},{"title":"[북클럽] 본문의 첫문장을 올리기 : 알베르 카뮈 ⟪이방인⟫","slug":"/zzan/@anpigon/3ddh7w","date":"2019-09-23T05:18:48.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/3ddh7w/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/3ddh7w/","excerpt":"요즘 읽고 있는 전자책입니다.알베르 카뮈의 ⟪이방인⟫ 입니다.⟪이방인⟫은 청소년 권장 도서로 중학교때 읽었던 기억이 있습니다.지금은 성인이 되서 다시 읽고 있습니다.하지만, 내용은 기억이 전혀 안납니다.이 책의 표지에 적힌 문장 “우리가 읽은 ⟨이방인⟩은 카뮈의 ⟨이방인⟩이 아니다. 25년을 속아 온 번역의 비밀, 이제 진실이 모습을 드러낸다!” 을 보고 다시 읽고 싶어졌습니다. 내용은 기억도 안나지만 기존 소설에는 아마도 오역이 많았나 봅니다.","text":"요즘 읽고 있는 전자책입니다.알베르 카뮈의 ⟪이방인⟫ 입니다.⟪이방인⟫은 청소년 권장 도서로 중학교때 읽었던 기억이 있습니다.지금은 성인이 되서 다시 읽고 있습니다.하지만, 내용은 기억이 전혀 안납니다.이 책의 표지에 적힌 문장 “우리가 읽은 ⟨이방인⟩은 카뮈의 ⟨이방인⟩이 아니다. 25년을 속아 온 번역의 비밀, 이제 진실이 모습을 드러낸다!” 을 보고 다시 읽고 싶어졌습니다. 내용은 기억도 안나지만 기존 소설에는 아마도 오역이 많았나 봅니다. 관련기사: HuffingtonPost - 알베르 카뮈 ‘이방인’ 번역 논쟁 이 소설을 시작하는 문장은 매우 충격적입니다. 그래서 이방인을 읽지 않은 사람들도 대부분 아는 유명한 문장입니다. 오늘, 엄마가 죽었다. 아니 어쩌면 어제인지도. 나도 모르겠다. 양로원으로부터 전보 한 통을 받았다. 스짱 북클럽 미션 | 첫문장","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"이방인","slug":"이방인","permalink":"https://anpigon.github.io/tags/이방인/"},{"name":"알베르 카뮈","slug":"알베르-카뮈","permalink":"https://anpigon.github.io/tags/알베르-카뮈/"}],"author":"anpigon"},{"title":"[북클럽] 가장 두꺼운 책 : 이지유럽","slug":"/zzan/@anpigon/steemzzang-bookclub-event-the-thickest-book","date":"2019-09-06T15:58:57.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/steemzzang-bookclub-event-the-thickest-book/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/steemzzang-bookclub-event-the-thickest-book/","excerpt":"스짱 북클럽 이벤트에 참여합니다.이지유럽은 너무 너무 두껍고 무거워서 팔 운동할때 사용하는 책입니다.이지유럽은 우리나라 최고의 유럽여행전문가 6명의 작가님들이 직접 쓰신 책입니다. 참고로 유럽 여행의 바이블이라고 불리우는 책입니다. (책소개에 이렇게 나와있습니다.)영국, 벨기에, 네델란드, 독일, 체코, 슬로바키아, 헝가리, 오스트리아, 이탈리아, 스위스, 스페인, 프랑스. 총 12개국을 여행하는 방법이 알차게 담겨있습니다.","text":"스짱 북클럽 이벤트에 참여합니다.이지유럽은 너무 너무 두껍고 무거워서 팔 운동할때 사용하는 책입니다.이지유럽은 우리나라 최고의 유럽여행전문가 6명의 작가님들이 직접 쓰신 책입니다. 참고로 유럽 여행의 바이블이라고 불리우는 책입니다. (책소개에 이렇게 나와있습니다.)영국, 벨기에, 네델란드, 독일, 체코, 슬로바키아, 헝가리, 오스트리아, 이탈리아, 스위스, 스페인, 프랑스. 총 12개국을 여행하는 방법이 알차게 담겨있습니다. 그리고 전체 페이지는 1087 쪽이 넘습니다. 매우 두껍네요. 그리고 무게는 1.6kg이며, 가격은 10%할인가로 21,600원입니다. 이 정도 가격이면 아령보다 이 책을 구입하는게 가성비가 훨씬 좋다고 생각합니다. 운동도 하면서 유럽 여행에 대한 정보도 얻을 수 있어요. 스짱 북클럽 미션 | 가장 두꺼운 책","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"}],"author":"anpigon"},{"title":"[이미지 매우 많음. 모바일 데이터 사용 주의!!!] 무료 &lt;hr&gt; 라인 이미지입니다.","slug":"/zzan/@anpigon/hr","date":"2019-09-06T04:58:48.000Z","updated":"2019-11-11T13:41:49.860Z","comments":true,"path":"/zzan/@anpigon/hr/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/hr/","excerpt":"블로그에 글 작성시 필요한 &lt;hr&gt; 라인 이미지를 가져왔습니다. &lt;hr&gt;은 포스팅에서 컨텐츠를 구분할 때 많이 사용합니다. 아래 출처에서 일부를 가져왔습니다. 무료라고 하니 마음껏 사용하세요.출처: https://www.smashingmagazine.com/2008/09/the-hr-contest-results-download-your-fresh-hr-line-now/","text":"블로그에 글 작성시 필요한 &lt;hr&gt; 라인 이미지를 가져왔습니다. &lt;hr&gt;은 포스팅에서 컨텐츠를 구분할 때 많이 사용합니다. 아래 출처에서 일부를 가져왔습니다. 무료라고 하니 마음껏 사용하세요.출처: https://www.smashingmagazine.com/2008/09/the-hr-contest-results-download-your-fresh-hr-line-now/","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[트립스팀]  강원도 양양 - 낙산사","slug":"/tripsteem/@anpigon/tt20190906t041552728z","date":"2019-09-06T04:15:54.000Z","updated":"2019-11-11T13:41:49.849Z","comments":true,"path":"/tripsteem/@anpigon/tt20190906t041552728z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@anpigon/tt20190906t041552728z/","excerpt":"지난 주말에 강원도 양양 낙산사에 다녀왔습니다.매표소에서 표를 샀습니다. 어른은 4천원이네요. ㅎ 천년고찰 낙산사 낙산사는 671년에 창건되었습니다. 창건 이래로 몽골 침입, 임진왜란, 병자호란, 6.25전쟁, 2005년 대형 산불로 많이 파괴되었는데, 2007년에 김홍도의 『낙산사도』를 참고하여 복원했다고 합니다.","text":"지난 주말에 강원도 양양 낙산사에 다녀왔습니다.매표소에서 표를 샀습니다. 어른은 4천원이네요. ㅎ 천년고찰 낙산사 낙산사는 671년에 창건되었습니다. 창건 이래로 몽골 침입, 임진왜란, 병자호란, 6.25전쟁, 2005년 대형 산불로 많이 파괴되었는데, 2007년에 김홍도의 『낙산사도』를 참고하여 복원했다고 합니다. 길에서 길을 묻다. 낙산사 가는 길입니다. 낙산사에는 거대한 불상 관음보살이 동해바다를 내려다 보고 있습니다. 가는 길에 꽃이 참 이뻐서 찍었습니다. 조금 걷다보면 절이 보이기 시작합니다. 낙산사 카페 다래헌 낙산사에 있는 카페 다래헌입니다. 낙산사를 구경하다가 잠시 쉬어갈 수 있는 곳입니다. 이곳에서는 전통차, 커피, 기념품 등을 살 수 있습니다. 이렇게 커피와 함께 바다를 보면서 잠깐 쉬었습니다. 의상 기념관 낙산사 의상기념관입니다. 낙산사를 창건한 의상대사는 한국 불교를 크게 빛낸 신라의 대표적인 고승이다. 그리고 이 땅에 화엄사상의 토대를 굳건히 세운 화엄종의 개조이다. 2015년 화재때 낙산사 동종이 이렇게 불탔다고 하네요. ㅠ 보물 제479호로 지정되었던 낙산사 동종은 조선시대 세조대왕이 낙산사에 행차하여 낙산사가 중창이 시작된 것을 기리기 위해 1469년 예종의 명에 의해 주조되었다. 현재 동종의 상태입니다. 원래 보물 479호 였는제 지금은 지정해제 되었다고 합니다. ㅠ 홍련암 안쪽까지 들어오면 홍련암에 도착합니다. 홍련암은 2015년 대형 산불 화재에서 살아남았다고 합니다. 그리고 홍련암에서 멋진 친구를 만났습니다. 기념으로 사진 한장을 찍었습니다. 낙산 해수욕장 바다를 보기위해 낙산사에 내려와서 해수욕장에 도착했습니다. 그리고 동해 바다를 영상에 담아왔습니다. 여행지 정보● 대한민국 강원도 양양군 강현면 낙산사로 낙산사[트립스팀] 강원도 양양 - 낙산사 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"},{"name":"강원도","slug":"강원도","permalink":"https://anpigon.github.io/tags/강원도/"}],"author":"anpigon"},{"title":"[리액트 네이티브 모바일앱 개발] 무료 동영상 강의를 소개합니다.","slug":"/zzan/@anpigon/7edyc","date":"2019-09-05T16:13:24.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/zzan/@anpigon/7edyc/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/7edyc/","excerpt":"리액트 네이티브 같이 공부해요~!니꼴라스 선생님의 리액트 네이티브 동영상 강의가 2019년도 최신 버전으로 업데이트 되었습니다.각 5분씩 총 17강입니다. 매일 5분씩 17일, 또는 딱 1시간 30분만 투자하면 바로 모바일앱 개발을 할 수 있습니다. 각 동영상도 짧고 초보 위주로 설명하기 때문에 코딩에 관심이 있다면 금방 배울 수 있습니다.","text":"리액트 네이티브 같이 공부해요~!니꼴라스 선생님의 리액트 네이티브 동영상 강의가 2019년도 최신 버전으로 업데이트 되었습니다.각 5분씩 총 17강입니다. 매일 5분씩 17일, 또는 딱 1시간 30분만 투자하면 바로 모바일앱 개발을 할 수 있습니다. 각 동영상도 짧고 초보 위주로 설명하기 때문에 코딩에 관심이 있다면 금방 배울 수 있습니다. 리액트 네이티브 세상에 온 것을 환영합니다. 이미 리액트 네이티브는 페이스북, 인스타그램 그리고 에어비앤비와 같은 핫한 회사들이 널리 쓰고있는 기술입니다. 개발시간을 절반으로 줄여줄 뿐만 아니라, 플래폼 전반에서 널리 쓰이는 코드를 다시 활용할 수도 있습니다. ___ 강의 소개말 중에서 https://www.youtube.com/playlist?list=PL7jH19IHhOLPEhP6oPSgK6r-neUVVA-pi 그리고 추가로 리액트 동영상 강의도 2019년 버전으로 업데이트 되었어요. https://www.youtube.com/playlist?list=PL7jH19IHhOLPp990qs8MbSsUlzKcTKuCf 나는 코알못이다. 코딩은 내 스타일이 아니다! 이런 분들은 glideapps 서비스를 이용해보세요. 코딩을 몰라도 매우 쉽게 모바일앱을 만들 수 있습니다. https://www.glideapps.com/ 다음과 같이 다양한 템플릿이 준비되어 있어요. PPT 만드는 것 처럼 클릭하고 바로 시작하면 됩니다. 아래 화면처럼 SNS 앱, 여행 가이드 앱을 매우 쉽게 만들 수 있어요. 필요한 컴포넌트를 드래그 앤 드롭으로 잘 조립하면 됩니다. ㅎㅎ 여기에서 샘플앱을 실행해 볼 수 있습니다. glideapps는 아래 1분 42초 동영상만 보고 나면, 코딩을 전혀 몰라도 모바일앱을 아주 쉽게 금방 만들 수 있습니다. 한번 해보세요.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"후오비 블록체인 폰 출시 예정","slug":"/sct/@anpigon/krwp","date":"2019-09-05T09:02:33.000Z","updated":"2019-11-11T13:41:49.860Z","comments":true,"path":"/sct/@anpigon/krwp/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/krwp/","excerpt":"중국 거래소 후오비에서 블록체인 스마트폰 Acute Angle을 출시 예정이라고 합니다. 그런데 아큐트 앵글(Acute Angle)은 작년에 출시했던 블록체인 컴퓨터가 아니었나요?? 헷갈리네요. ㅎㅎ후오비 블록체인 스마트폰은 2019년까지 동남아시아에 전 지역에 유통될 것이며, 앞으로 유럽 및 미국으로 시장을 확대할 계획이라고 합니다.","text":"중국 거래소 후오비에서 블록체인 스마트폰 Acute Angle을 출시 예정이라고 합니다. 그런데 아큐트 앵글(Acute Angle)은 작년에 출시했던 블록체인 컴퓨터가 아니었나요?? 헷갈리네요. ㅎㅎ후오비 블록체인 스마트폰은 2019년까지 동남아시아에 전 지역에 유통될 것이며, 앞으로 유럽 및 미국으로 시장을 확대할 계획이라고 합니다. 그리고 며칠 전에는 삼성도 블록체인 스마트폰을 10월에 공개할 것이라는 기사가 나왔었죠. 갤S10이 삼성의 블록체인 스마트폰은 아니었군요. ㅎㅎ 그럼 삼성에서 공개 예정인 진짜 블록체인 스마트폰이 뭔지 궁금합니다. 제 생각에는 블록체인 스마트폰에는 하드웨어 지갑이 기본 탑재되어 있고, 디앱(DApp)을 설치할 수 있을 것 같습니다. 브라우저는 브레이브(Brave)를 사용하고요. 그리고 삼성페이처럼 스마트폰에서 코인 결제를 쉽게 할 수 있지 않을까요? 관련기사 후오비, 동남 아시아 지역 블록체인 폰 출시 전망 - 블록체인투데이 후오비 ‘블록체인 스마트폰’ 내주 공개…동남아서 500달러 판매 - 블록체인 프레스 삼성전자, 오는 10월 ‘블록체인 스마트폰’ 공개 전망- 토큰포스트","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[트립스팀] 잠실 롯데타워 에비뉴엘 아트홀 - 픽셀 아티스트 주재범의  ＜PICK X CELL＞展","slug":"/tripsteem/@anpigon/tt20190905t061257794z","date":"2019-09-05T06:13:00.000Z","updated":"2019-11-11T13:41:49.849Z","comments":true,"path":"/tripsteem/@anpigon/tt20190905t061257794z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@anpigon/tt20190905t061257794z/","excerpt":"지난 주에 롯데타워에 갔다가 우연히 주재범 아티스트의 전시회를 보게 되었습니다. 픽셀 아트라고 하네요. ㅎㅎ전시회를 감상하면서 저는 어릴때 했던 8비트 게임이 생각났습니다. 그 추억때문인지 픽셀 아트를 보면 아련한 감성이 느껴집니다. 너무 너무 어릴적 이라서 기억은 잘 안나지만, 아직 마음속에 남아 있는 추억 때문인것 같습니다.","text":"지난 주에 롯데타워에 갔다가 우연히 주재범 아티스트의 전시회를 보게 되었습니다. 픽셀 아트라고 하네요. ㅎㅎ전시회를 감상하면서 저는 어릴때 했던 8비트 게임이 생각났습니다. 그 추억때문인지 픽셀 아트를 보면 아련한 감성이 느껴집니다. 너무 너무 어릴적 이라서 기억은 잘 안나지만, 아직 마음속에 남아 있는 추억 때문인것 같습니다. 한쪽 벽면에는 많은 액자가 붙어있습니다. 명화를 픽셀로 표현한 것 같습니다. 영화 ⟪베스트 오퍼⟫의 주인공이 된 느낌이었습니다. ㅎㅎ 그리고 반 고흐의 ⟪별이 빛나는 밤⟫을 픽셀로 표현한 걸 보고 놀랐습니다. 느낌을 정말 잘 살렸네요. 이 그림은 정말 갖고 싶었어요. ㅋ 이번 그림은 싸이월드의 미니룸 같아요. 반 고흐, 요하네스 페르메이르, 그리고 앤디 워홀의 방인것 같습니다. 방이 너무 작네요. ㅋㅋ 다음 그림은 좌우로 왔다 갔다 하면 낮과 밤이 보입니다. 궁금하면 동영상으로 감상해보세요. ㅎㅎ 여긴 별도로 만들어진 관람실입니다. 이곳은 정신이 먼가에 홀린것처럼 화면을 계속 보게됩니다. 영상 시간은 총 20분인데 금방 지나가네요. 여행지 정보● 대한민국 서울특별시 송파구 신천동 올림픽로 롯데월드타워[트립스팀] 잠실 롯데타워 에비뉴엘 아트홀 - 픽셀 아티스트 주재범의 ＜PICK X CELL＞展 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"전시회","slug":"전시회","permalink":"https://anpigon.github.io/tags/전시회/"},{"name":"잠실 롯데타워","slug":"잠실-롯데타워","permalink":"https://anpigon.github.io/tags/잠실-롯데타워/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree #17 : Dynamic Types을 정의하고 Type Composition을 사용하여 공통 Functionality 추출하기","slug":"개발 이야기/React/Mobx/2019-09-04---manage-application-state-with-mobx-state-tree-17","date":"2019-09-03T15:00:00.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"개발 이야기/React/Mobx/2019-09-04---manage-application-state-with-mobx-state-tree-17/","link":"","permalink":"https://anpigon.github.io/개발 이야기/React/Mobx/2019-09-04---manage-application-state-with-mobx-state-tree-17/","excerpt":"17번째 마지막 레슨입니다. Let’s make sure our changes get persisted. We will use the window.fetch api to store our changes in the json-server. And onSnapshot to do this automatically","text":"17번째 마지막 레슨입니다. Let’s make sure our changes get persisted. We will use the window.fetch api to store our changes in the json-server. And onSnapshot to do this automatically Since MST offers a runtime type system, it can create and compose types on the fly, making it possible to reuse logic in new and powerful ways. 우리는 이번 레슨에서 다음을 배우게 됩니다. That MST types are immutable and composed together behind the scenes How to compose types explicitly by using types.compose How to create dynamic, parameterized types by leveraging that MST types are first class javascript citizens 이 포스팅은 제가 학습한 내용을 기록한 글입니다. 이전글 &quot;[React] Mobx-state-tree #16 : Use Volatile State and Lifecycle Methods to Manage Private State&quot;에서 이어지는 내용입니다. Create Dynamic Types and use Type Composition to Extract Common Functionality 강의 링크: https://egghead.io/lessons/react-create-dynamic-types-and-use-type-composition-to-extract-common-functionality User 모델에서 데이터와 액션을 분리할 수 있습니다. src/models/Group.js 12345678910111213141516171819import &#123; types, flow, applySnapshot, getSnapshot, onSnapshot &#125; from \"mobx-state-tree\";import &#123; WishList &#125; from \"./WishList\";const UserBase = types .model(&#123; id: types.identifier, // add here name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"]), wishList: types.optional(WishList, &#123;&#125;), recipient: types.maybe(types.reference(types.late(() =&gt; User))) &#125;);const User = UserBase.actions(self =&gt; (&#123; getSuggestions: flow(function* getSuggestions() &#123; // (...) &#125;), save: flow(function* save() &#123;// (...) &#125;), afterCreate() &#123; // ... &#125; &#125;));// (...) 또는 types.compose를 사용하여 이렇게 작성도 가능합니다. src/models/Group.js 123456789101112131415161718192021import &#123; types, flow, applySnapshot, getSnapshot, onSnapshot &#125; from \"mobx-state-tree\";import &#123; WishList &#125; from \"./WishList\";const UserBase = types .model(&#123; id: types.identifier, // add here name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"]), wishList: types.optional(WishList, &#123;&#125;), recipient: types.maybe(types.reference(types.late(() =&gt; User))) &#125;);const UserActions = types.model(&#123;&#125;).actions(self =&gt; (&#123; getSuggestions: flow(function* getSuggestions() &#123; // (...) &#125;), save: flow(function* save() &#123;// (...) &#125;), afterCreate() &#123; // (...) &#125; &#125;));const User = types.compose(UserBase, UserActions);// (...) 그다음 Storable.js 파일을 새로 생성한다. 여기서 REST-specific logic을 위한 dedicated type 소개하려고 한다. src/models/Storable.js 12345678910111213141516171819import &#123; types &#125; from 'mobx';import &#123; flow, getSnapshot, onSnapshot &#125; from 'mobx-state-tree';export const Storable = types.model(&#123;&#125;).actions(self =&gt; (&#123; save: flow(function* save() &#123; try &#123; yield window.fetch(`http://localhost:3001/users/$&#123;self.id&#125;`, &#123; method: \"PUT\", headers: &#123; \"content-type\": \"application/json\" &#125;, body: JSON.stringify(getSnapshot(self)) &#125;); &#125; catch (e) &#123; console.error(\"Uh oh, failed to save: \" + e); &#125; &#125;), afterCreate() &#123; onSnapshot(self, self.save); &#125;&#125;)); 다시 Group.js 파일을 수정한다. UserAction에서 save와 afterCreate를 제거한다. 그리고 types.compose를 사용하여 UserBase, UserAction, Storable를 병합한다. src/models/Group.js 1234567891011121314151617181920import // (...)import &#123; Storable &#125; from './Storable'; // add hereconst UserBase = types.model(&#123; // (...) &#125;);const UserAction = types.model(&#123;&#125;).actions(self =&gt; (&#123; getSuggestions: flow(function* getSuggestions() &#123; const response = yield window.fetch(`http://localhost:3001/suggestions_$&#123;self.gender&#125;`); const suggestions = yield response.json(); self.wishList.items.push(...suggestions); &#125;), // save: flow(function* save() &#123;// (...) &#125;), // remove here // afterCreate() &#123; // (...) &#125; // remove here&#125;));export const User = types.compose( UserBase, UserAction, Storable); 다음과 같이 액션을 일반화 할 수 있습니다. 그 다음 내용은 그냥 구글 번역기의 도움을 받았습니다. ㅋ 03:28 사실 이것은 아직 재사용 할 수 없습니다. 문제는 여기에 여전히 하드 코딩 된 정보가 있다는 것입니다.이 storable는 항상 users’ collection에 stuff을 저장합니다. 03:38 항상 ID property 아래에 저장합니다. 애플리케이션의 모든 엔터티에 적용되지 않을 수 있습니다. 실제로, 나는 이 타입을 보다 일반적인 것으로 만들고 싶습니다. 03:49 여기 멋진 것이 있습니다. 이것은 모두 JavaScript 일 뿐이며 형식화되지 않은 시스템이며 컴파일러에 의해 강제 실행되므로 저장 가능한 함수를 생성하는 함수를 만드는 것과 같은 멋진 작업을 수행 할 수 있습니다. 04:01 createStorable 함수를 생성하고, 해당 컬렉션의 해당 attribute에 stuff을 저장해야 하도록 합니다. 04:11 이제 이 함수를 export합니다. src/models/Storable.js 123456789101112131415161718192021import &#123; types &#125; from 'mobx';import &#123; flow, getSnapshot, onSnapshot &#125; from 'mobx-state-tree';export function createStorable(collection, attribute) &#123; return types.model(&#123;&#125;).actions(self =&gt; (&#123; save: flow(function* save() &#123; try &#123; yield window.fetch(`http://localhost:3001/users/$&#123;collection&#125;/$&#123;self[attribute]&#125;`, &#123; method: \"PUT\", headers: &#123; \"content-type\": \"application/json\" &#125;, body: JSON.stringify(getSnapshot(self)) &#125;); &#125; catch (e) &#123; console.error(\"Uh oh, failed to save: \" + e); &#125; &#125;), afterCreate() &#123; onSnapshot(self, self.save); &#125; &#125;));&#125; 04:27 이제 이 기능은 완전히 일반화되었습니다. 04:46 자,이 user type을 선언하면 즉시 새로운 유형이 생성됩니다. 여전히 동일한 동작을 하는 응용 프로그램이 있지만 이제는 매우 일반적인 논리를 가지므로이 유형과 같이 REST와 유사한 모든 유형에 대해 다른 유형에도 재사용 할 수 있습니다. src/models/Group.js 1234567891011121314import // (...)import &#123; createStorable &#125; from './Storable';const User = types.compose( types .model(&#123; // (...) &#125;), .actions(self =&gt; (&#123; getSuggestions: flow(function* getSuggestions() &#123; const response = yield window.fetch(`http://localhost:3001/suggestions_$&#123;self.gender&#125;`); self.wishList.items.push(...(yield response.json())); &#125;) &#125;)), createStorable(\"users\", \"id\")); 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}]},{"title":"[북클럽] 지금 읽고 있는 책 22쪽 2째줄 : 김영하 ⟪퀴즈쇼⟫","slug":"/zzan/@anpigon/hf22-or-22-2","date":"2019-09-03T13:18:12.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/hf22-or-22-2/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/hf22-or-22-2/","excerpt":"스팀짱 북클럽 이벤트에 참여합니다.요즘 출퇴근하면서 읽는 책입니다.소설가 김영하의 장펴소설 ⟪퀴즈쇼⟫ 입니다.최근에는 김영하 작가님 책만 읽었네요. ㅎㅎ 주인공 이민수는 1980년 5.18 광주민주화운동이 있던 해에 태어났다. 그리고 경제적 풍요 속에 성장했으며 인터넷이라는 새로운 매체를 통해 세상을 경험했다. 이 소설은 1980년 생이 바라보는 2007년 한국 풍경을 그려냈다.","text":"스팀짱 북클럽 이벤트에 참여합니다.요즘 출퇴근하면서 읽는 책입니다.소설가 김영하의 장펴소설 ⟪퀴즈쇼⟫ 입니다.최근에는 김영하 작가님 책만 읽었네요. ㅎㅎ 주인공 이민수는 1980년 5.18 광주민주화운동이 있던 해에 태어났다. 그리고 경제적 풍요 속에 성장했으며 인터넷이라는 새로운 매체를 통해 세상을 경험했다. 이 소설은 1980년 생이 바라보는 2007년 한국 풍경을 그려냈다. 다음은 이 책의 22쪽 2째줄 문장입니다. 처음엔 야속하다는 생각도 들지 않았다. 너무 오랫동안 빛나 주위로 살아온 탓일까. 빛나가 문자메세지로 변명을 늘어놓을때 마다 나는. 괜찮다. 오지 않아도 된다. 발표나 잘하라며 오히려 그녀의 사정을 헤아려주었다. 그리고 나는 마치 『이방인』의 뫼르소처럼, 친척 하나 없이 오직 최여사의 남자친구들만 득실거리는 쓸쓸한 장례를 마치고 집으로 돌아와 아무도 없는 방에 혼자 누어 있었다. 음. 뫼르소는 이럴 때 바다에 해수욕을 하러 가던데… 그러자 마음속의 제정신이 나에게 충고했다. ‘바로 그것 때문에 뫼르소는 사형을 당하는 거야. 엄마를 묻고 와서 해수욕이나 하러 갔다고 말이야.’ 스짱 북클럽 HF22 기념 | 지금 읽고 있는 책 22쪽 2째줄","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"김영하","slug":"김영하","permalink":"https://anpigon.github.io/tags/김영하/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #16 : Use Volatile State and Lifecycle Methods to Manage Private State","slug":"/zzan/@anpigon/react-mobx-state-tree-16-use-volatile-state-and-lifecycle-methods-to-manage-private-state","date":"2019-09-03T02:07:54.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-16-use-volatile-state-and-lifecycle-methods-to-manage-private-state/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-16-use-volatile-state-and-lifecycle-methods-to-manage-private-state/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #15 : Use Volatile State and Lifecycle Methods to Manage Private State&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #15 : Use Volatile State and Lifecycle Methods to Manage Private State&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Use Volatile State and Lifecycle Methods to Manage Private State 강의 링크: https://egghead.io/lessons/react-automatically-send-changes-to-the-server-by-using-onsnapshot 16번째 레슨입니다. Let’s make sure our changes get persisted. We will use the window.fetch api to store our changes in the json-server. And onSnapshot to do this automatically Group.js를 수정합니다. User에 새로운 액션 save를 추가합니다. 이 액션은 async 이므로 flow를 사용합니다. 고유한 ID $｛self.id｝로 User를 저장하는 API를 호출합니다. src/models/Group.js 12345678910111213141516171819202122export const User = types .model(｛ // (...) ｝) .actions(self =&gt; (｛ getSuggestions: flow(function* getSuggestions() ｛ // (...) ｝), // save 액션 추가 save: flow(function* save() ｛ try ｛ yield window.fetch(`http://localhost:3001/users/$｛self.id｝`, ｛ method: \"PUT\", headers: ｛ \"content-type\": \"application/json\" ｝, body: JSON.stringify(getSnapshot(self)) ｝); ｝ catch (e) ｛ console.error(\"Uh oh, failed to save: \" + e); ｝ ｝) ｝)); 그 다음은 save액션을 언제 호출해야할지 고민해야합니다. 하지만 간단하게 할 수 있는 방법이 있습니다. afterCreate와 onSnapshot를 사용하여, 인스턴스 생성 후, 이 인스턴스에서 새 스냅샷이 생성될 때마다 리스닝합니다. 그리고 새로운 스냅샷이 생성 될 때 save 액션을 실행합니다. 이제 User 인스턴스가 변경 될 때마다 서버로 데이터를 보낼 것 입니다. src/models/Group.js 12345678910111213141516171819export const User = types .model(｛ // (...) ｝) .actions(self =&gt; (｛ // (...) .actions(self =&gt; (｛ getSuggestions: flow(function* getSuggestions() ｛ // (...) ｝), save: flow(function* save() ｛ // (...) ｝), // 다음 액션 추가 afterCreate() ｛ onSnapshot(self, self.save); ｝ ｝)); 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[사진] Yesterday sky in any alley in Seoul.","slug":"/zzan/@anpigon/yesterday-sky-in-any-alley-in-seoul","date":"2019-09-03T01:38:12.000Z","updated":"2019-11-11T13:41:49.860Z","comments":true,"path":"/zzan/@anpigon/yesterday-sky-in-any-alley-in-seoul/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/yesterday-sky-in-any-alley-in-seoul/","excerpt":"","text":"A Flaming Sunset When I look at the setting glowing red sun, I think your sad face I can’t say anything as I lower my head with tears down my face I love you. I scream saying “You are my world” But there is no reply as the sunset is the only thing there","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[봉평 허브나라] - 2019 이문세의 숲속음악회","slug":"/tripsteem/@anpigon/tt20190901t133854738z","date":"2019-09-01T13:38:57.000Z","updated":"2019-11-11T13:41:49.849Z","comments":true,"path":"/tripsteem/@anpigon/tt20190901t133854738z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@anpigon/tt20190901t133854738z/","excerpt":"이문세 숲속음악회에 다녀왔습니다.그리고 공연 티켓이 있으면, 허브나라에 4시 30분부터는 무료 입장입니다.어제는 비가 보슬보슬 내리더니, 공연 당일날 날씨는 매우 좋았습니다.공연 티켓은 요렇게 생겼어요.독서할때 책갈피로 쓰면 딱 좋을 것 같아요.그리고 티켓 수령할때 선물도 줬어요. 메모지와 필기할수 있는 연필입니다.","text":"이문세 숲속음악회에 다녀왔습니다.그리고 공연 티켓이 있으면, 허브나라에 4시 30분부터는 무료 입장입니다.어제는 비가 보슬보슬 내리더니, 공연 당일날 날씨는 매우 좋았습니다.공연 티켓은 요렇게 생겼어요.독서할때 책갈피로 쓰면 딱 좋을 것 같아요.그리고 티켓 수령할때 선물도 줬어요. 메모지와 필기할수 있는 연필입니다. 이문세님 공연에는 팬들을 위한 선물이 항상 준비되어 있어서 기분이 좋네요. 이제 다리를 건너 허브나라에 들어가는 길입니다. 구름 하늘과 저 멀리 뻗어있는 계곡을 보니, 제 마음에 막힌 기분도 뻥 뚫린 느낌입니다. 이곳은 허브나라입니다. 꽃이랑 허브를 사진으로 마음껏 구경하세요~ ⟪이문세의 숲속음악회⟫ 의 수익금은 네팔의 '날랑 학교’와 '툴로바로크 학교’에 100% 기부할 예정이라고 합니다. 공연은 저녁 7시 30분부터입니다. 공연을 보기 위해서 허브나라의 별빛무대 공연장으로 이동합니다. 이 작은 공연장에 700명의 관객이 조밀하게 앉았습니다. 참고로 이곳 별빛무대는 오직 이문세님을 위해서 지어졌다고 합니다. 이제 이문세님이 나오길 기다립니다. 공연 중에는 사진 촬영이 불가능해서 공연 사진은 못찍었습니다. 초대 가수로 헤이즈가 나왔습니다. 이문세님의 16집 앨법의 ⟪희미해서⟫는 헤이즈가 작사/작곡 했다고 하네요. 앵콜 공연은 사진 촬영이 가능하다고 해서 동영상을 찍어왔습니다. 공연이 끝나고 난 뒤 텅빈 공연장을 찍어보았습니다. 나의 기억 속에 날 아프게 하는 모든 것들까지도 희미해서 희미해서 더 아름다운 거라고 희미해서 희미해서 희미해서~ 여행지 정보● 대한민국 강원도 평창군 봉평 흥정계곡길 허브나라농원[봉평 허브나라] - 2019 이문세의 숲속음악회 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"이문세","slug":"이문세","permalink":"https://anpigon.github.io/tags/이문세/"},{"name":"콘서트","slug":"콘서트","permalink":"https://anpigon.github.io/tags/콘서트/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #15 : Use Volatile State and Lifecycle Methods to Manage Private State","slug":"/zzan/@anpigon/react-mobx-state-tree-15-use-volatile-state-and-lifecycle-methods-to-manage-private-state","date":"2019-09-01T05:11:45.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-15-use-volatile-state-and-lifecycle-methods-to-manage-private-state/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-15-use-volatile-state-and-lifecycle-methods-to-manage-private-state/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #14 : 서버에서 데이터 가져오기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #14 : 서버에서 데이터 가져오기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Use Volatile State and Lifecycle Methods to Manage Private State 강의 링크: https://egghead.io/lessons/react-use-volatile-state-and-lifecycle-methods-to-manage-private-state 15번째 레슨입니다. MST에는 매우 유니크한 기능이 있습니다. It allows you to capture private state on models, and manage this state by using lifecycle hooks. For example by setting up a WebSocket connection and disposing of the connection automatically as soon as the instance gets removed from the store. In this lesson, we will leverage cancellable fetches to abort in-flight requests when appropriate 우리는 이번 레슨에서 다음을 배우게 됩니다. window.fetch 요청을 중단하는 방법. Storing private, volatile, internal state in the function closure A second life-cycle hook: beforeDestroy 이번에는 새로고침 버튼을 추가하고, 새로고침 버튼을 누를 때마다 서버에서 데이터를 받아오도록 해보겠습니다. Group.js 파일을 수정합니다. Group 모델에 reload 액션을 추가합니다. src/models/Group.js 123456789101112export const Group = types.model(｛ users: types.map(User)｝).actions(self =&gt; (｛ // (...) // reload 액션 추가 reload() ｛ self.load(); ｝,｝)); 그리고 화면에 Reload 버튼을 추가합니다. Reload을 누르면 group의 reaload 액션을 호출할 것입니다. src/components/App.js 123456789101112class App extends React.Component ｛ // (...) render() ｛ // (...) return ( &lt;div&gt; &lt;h1 className=\"App-title\"&gt;WishList&lt;/h1&gt; &lt;button onClick=｛group.reload｝&gt;Reload&lt;/button&gt; 이제 서버에서 데이터를 다시 로드 할 수 있습니다. 개발자 도구에서 네트워크 요청을 살펴보면 데이터를 멋지게 가져 오는 것을 볼 수 있습니다. 사실 문제가 하나 있습니다. 리로드 버튼을 많이 클릭하면 많은 요청이 진행됩니다. 다시 요청할 때 이전 요청을 취소하면 좋을 것입니다. 새로운 요청이 들어오면 현재 요청은 중단되어야합니다. Fetch API에는 이를 지원하는 라이브러리가 있습니다. 이를 수행하는 방법은 AbortController를 작성하는 것입니다. fetch를 생성할 때 signal를 전달합니다. AbortController에서 나온 signal을 Fetch API에 바인딩합니다. 이제 AbortController에서 abort을 호출하면 Fetch API가 취소됩니다. 요청이 중단되면 에러가 발생할 것입니다. try / catch를 사용하여 요청이 중단되었음을 알 수 있습니다. 그렇지 않은 경우에만 성공으로 처리합니다. 다음과 같이 AbortController 를 사용합니다. src/models/Group.js 123456789101112131415161718192021222324252627282930313233export const Group = types .model(｛ users: types.map(User) ｝) .actions(self =&gt; ｛ let controller; // 컨트롤러 return ｛ afterCreate() ｛ self.load(); ｝, // load 액션 수정 load: flow(function*() ｛ controller = window.AbortController &amp;&amp; new window.AbortController(); try ｛ const response = yield window.fetch(\"http://localhost:3001/users\", ｛ signal: controller.signal ｝); applySnapshot(self.users, yield response.json()); console.log(\"success\"); ｝ catch (e) ｛ console.log(\"aborted\", e.name); ｝ ｝), reload() ｛ // abort current request if (controller) controller.abort(); self.load(); ｝ ｝; ｝); 그리고 어떤 이유에서 group이 메모리에서 언로드되면 우리는 보류중인 요청을 중단 할 수 있어야 합니다. 여기에는 beforeDestroy 후크를 활용할 수 있습니다. 123456789101112131415export const Group = types .model(｛ users: types.map(User) ｝) .actions(self =&gt; ｛ let controller; return ｛ // (...) beforeDestory() ｛ if (controller) controller.abort(); ｝ ｝); 이제 많은 요청을 실행하면 마지막 요청만 완료되고 다른 요청들은 중단됩니다. 콘솔 로그를 확인하면 이것이 우리가 기대했던 동작을 확인할 수 있습니다. 새로운 요청이 발생하여 일부는 성공하고 일부는 중단된 것을 볼 수 있습니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #14 : 서버에서 데이터 가져오기","slug":"/zzan/@anpigon/react-mobx-state-tree-14","date":"2019-08-31T06:54:27.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-14/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-14/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #13 : References와 Identifiers를 사용하여 데이터에 Relationships 만들기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #13 : References와 Identifiers를 사용하여 데이터에 Relationships 만들기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Loading Data from the Server 강의 링크: https://egghead.io/lessons/react-loading-data-from-the-server 14번째 레슨입니다. Let’s stop hardcoding our initial state and fetch it from the server instead. 우리는 이번 레슨에서 다음을 배우게 됩니다. Set up basic data fetching Leverage the afterCreate lifecycle hook to automatically run any setup logic a model instance needs to do after creation *** 우선 하드 코딩되어 있던 user 데이터를 코드에서 제거 합니다. 그리고 서버에서 받아오도록 수정해봅시다. 다음은 store에 액세스 할 수 있도록 하는 간단한 방법입니다. group을 윈도우 전역 변수에 할당합니다. 1let group = window.group = Group.create(initialState); 그럼 브라우저 개발자 콘솔에서 접근 가능합니다. 기본적으로 &quot;스냅샷 가져 오기&quot;호출과 동일합니다. 다음은 현재 state입니다. db.json 파일을 수정합니다. 이 파일에 users 를 추가합니다. db.json 1234567891011121314151617181920212223\"users\": ｛ \"a342\": ｛ \"id\": \"a342\", \"name\": \"Homer\", \"gender\": \"m\", \"recipient\": \"ba32\", \"wishList\": ｛ \"items\": [ ｛ \"name\": \"Machine Gun Preacher\", \"price\": 7.35, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/1gEP9ZC7jpSiuMWNfbOfXTWWF5n.jpg\" ｝, ｛ \"name\": \"Avengers: Endgame\", \"price\": 17.29, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/or06FN3Dka5tukK1e9sl16pB3iy.jpg\" ｝ ] ｝ ｝, // ... ｝ 그다음 Group.js 파일을 수정합니다. Mobx-state-tree의 내장 함수 applySnapshot를 사용합니다. applySnapshot은 매우 유용한 기능입니다. 이미 가지고 있는 state와 수신한 state를 비교합니다. 가능한 적은 변경 사항으로 업데이트를 시도합니다. src/models/Group.js 123456789101112131415// applySnapshot를 importimport ｛ types, flow, applySnapshot ｝ from \"mobx-state-tree\";// ...// load actions을 추가export const Group = types.model(｛ users: types.map(User)｝).actions(self =&gt; (｛ load: flow(function*() ｛ const response = yield window.fetch('http://localhost:3001/users'); applySnapshot(self.users, yield response.json()); ｝),｝)); 코드에서 initialState의 users 데이터를 삭제합니다. 그리고 Group 모델 인스턴스를 생성하고 나서 바로 group.load() 액션 를 호출해봅시다. src/index.js 123456789// ...// 이제 initialState는 비어있는 users 속성만 가지고 있다.let initialState = ｛ users: ｛｝ ｝;// ...let group = (window.group = Group.create(initialState));group.load(); 하지만 Group을 만들 때 데이터를 로드하는 것은 항상 일어나야 할 일입니다. 이 경우에 life cycle hooks를 사용할 수 있습니다. MobX-state-tree에 미리 정의된 특별한 액션을 사용할 수 있습니다. 미리 정의된 특별한 액션 중에서 afterCreate를 사용해봅시다. afterCreate는 인스턴스가 생성되고 전체 객체가 셋팅될 때마다 항상 호출됩니다. 인스턴스 생성시에 자동으로 self.load를 호출 할 수 있습니다. src/models/Group.js 12345678910111213export const Group = types.model(｛ users: types.map(User)｝).actions(self =&gt; (｛ // afterCreate 후크 정의 afterCreate() ｛ self.load(); ｝, load: flow(function*() ｛ const response = yield window.fetch('http://localhost:3001/users'); applySnapshot(self.users, yield response.json()); ｝),｝)); 마지막으로 `src/index.js` 파일에서 `group.load();` 코드는 삭제합니다. 이제 Group은 인스턴스를 생성하고 나서 afterCreate 후크를 통해 자동으로 서버에서 데이터를 가져옵니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #13 : References와 Identifiers를 사용하여 데이터에 Relationships 만들기","slug":"/zzan/@anpigon/react-mobx-state-tree-13-references-identifiers-relationships","date":"2019-08-30T08:47:24.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-13-references-identifiers-relationships/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-13-references-identifiers-relationships/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #12 : Flow를 사용하여 비동기 프로세스 정의하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #12 : Flow를 사용하여 비동기 프로세스 정의하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Create Relationships in your Data with mobx-state-tree Using References and Identifiers 강의 링크: https://egghead.io/lessons/react-create-relationships-in-your-data-with-mobx-state-tree-using-references-and-identifiers 13번째 레슨입니다. MST stores all data in a tree, where each piece of data lives at one unique location. In most state management solutions, this means you need to introduce weakly typed, primitive ‘foreign keys’ to refer to other parts of the state tree. But in MST you can leverage the concepts of references and identifiers to relate model instances to each other. MST will do the normalization behind the scenes for you. 우리는 이번 레슨에서 다음을 배우게 됩니다. types.identifier를 사용하여 특정 타입의 인스턴스를 유니크하게 식별한다. types.reference를 사용하여 다른 데이터를 참조하고 트리의 다른 부분과 상호 작용할 수 있다. types.maybe를 사용하여 “… 또는 null” 타입을 만들 수 있다. types.late를 사용하여 circular 타입을 정의할 수 있다. > **types.optional과 types.maybe의 차이** `x : types.optional (types.number, 3)`에서 `x`는 항상 숫자이고, 제공되지 않으면 3임을 의미합니다. 반대로 `x : types.maybe (types.number)`는 `x`가 숫자 일 수도 있지만 \"null\"일 수도 있음을 의미합니다. 그리고 types.optional은 값이 스냅 샷에서 제외 될 수 있음을 의미합니다. 이제 누구를 위해 선물을 사야하고 어떤 선물을 사야하는지 확인할 수 있는 기능을 만들어 봅겠습니다. types.reference 사용하기 Group.js 파일을 수정합니다. 그리고 User 모델에 recipient 필드를 추가합니다. recipient에는 선물을 받는 사람을 저장할 것입니다. 모델 참조에는 types.reference 를 사용합니다. recipient는 User를 참조하도록 정의합니다. 일종의 재귀 모델의 형태를 가지게 됩니다. 1recipient: types.reference(User) 하지만 User 모델이 아직 정의되지 않았습니다. 그래서 User 상수가 아직 할당 되지 않았다는 오류가 발생합니다. types.late를 사용하면 유형 참조를 연기할 수 있습니다. types.late 를 사용하여 다시 정의합니다. 1recipient: types.reference(types.late(() =&gt; User)) 그리고 User 가 처음 생성될때는 recipient가 비어있을 것이기 때문에 types.maybe를 사용하여 문제를 해결합니다. 1recipient: types.maybe(types.reference(types.late(() =&gt; User))) 그래서 User 모델은 다음과 같이 작성됩니다. src/models/Group.js 1234567891011export const User = types .model(｛ id: types.identifier, // add here name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"]), wishList: types.optional(WishList, ｛｝), recipient: types.maybe(types.reference(types.late(() =&gt; User))), // add here ｝) .actions(self =&gt; (｛ // ... ｝)); UI 수정하기 이제 UI 를 수정할 차례입니다. 다음과 같이 User 컴포넌트를 분리합니다. src/components/App.js 123456789101112131415161718192021222324252627282930313233343536373839import ｛ observer ｝ from 'mobx-react';//...class App extends React.Component ｛ //... render() ｛ //... return ( &lt;div&gt; &lt;h1 className=\"App-title\"&gt;WishList&lt;/h1&gt; &lt;select onChange=｛this.onSelectUser｝&gt; &lt;option value=\"\"&gt;- Select user -&lt;/option&gt; ｛values(group.users).map(user =&gt; ( &lt;option key=｛user.id｝ value=｛user.id｝&gt; ｛user.name｝ &lt;/option&gt; ))｝ &lt;/select&gt; ｛selectedUser &amp;&amp; &lt;User user=｛selectedUser｝ /&gt;｝ &lt;/div&gt; ); ｝ //...｝const User = observer((｛ user ｝) =&gt; ( &lt;div&gt; &lt;WishListView wishList=｛user.wishList｝ /&gt; &lt;button onClick=｛user.getSuggestions｝&gt;Suggestions&lt;/button&gt; &lt;hr/&gt; &lt;h2&gt;｛user.recipient &amp;&amp; user.recipient.name｝&lt;/h2&gt; &lt;/div&gt;));export default App; 그리고 선물 받을 사람(recipient)의 위시 리스트를 보여주기 위해 User 컴포넌트에 WishListView 컴포넌트를 추가합니다. 참고로 WishListView에 readonly 속성이 추가되었습니다. src/components/App.js 123456789const User = observer((｛ user ｝) =&gt; ( &lt;div&gt; &lt;WishListView wishList=｛user.wishList｝ /&gt; &lt;button onClick=｛user.getSuggestions｝&gt;Suggestions&lt;/button&gt; &lt;hr/&gt; &lt;h2&gt;｛user.recipient &amp;&amp; user.recipient.name｝&lt;/h2&gt; ｛user.recipient &amp;&amp; &lt;WishListView wishList=｛user.recipient.wishList｝ readonly /&gt;｝ &lt;/div&gt;)); 나머지 컴포넌트도 차례대로 수정합니다. src/components/WishListView.js 12345678910111213// ...const WishListView = (｛ wishList, readonly ｝) =&gt; ( &lt;div className=\"list\"&gt; &lt;ul&gt; ｛wishList.items.map((item, idx) =&gt; ( &lt;WishListItemView key=｛idx｝ item=｛item｝ readonly=｛readonly｝ /&gt; ))｝ &lt;/ul&gt; Total: ｛wishList.totalPrice｝ 💲 ｛!readonly &amp;&amp; &lt;WishListItemEntry wishList=｛wishList｝ /&gt;｝ &lt;/div&gt;); src/components/WishListItemView.js 123456789101112131415161718192021// ...render() ｛ const ｛ item, readonly ｝ = this.props; return this.state.isEditing ? ( this.renderEditable() ) : ( &lt;li className=\"item\"&gt; ｛item.image &amp;&amp; &lt;img src=｛item.image｝ alt=\"\" /&gt;｝ &lt;h3&gt;｛item.name｝&lt;/h3&gt; &lt;span&gt;｛item.price｝&lt;/span&gt;&lt;br/&gt; ｛!readonly &amp;&amp; ( &lt;span&gt; &lt;button onClick=｛this.onTooleEdit｝&gt;✏️&lt;/button&gt; ｛/* add here */｝ &lt;button onClick=｛item.remove｝&gt;❎&lt;/button&gt; &lt;/span&gt; )｝ &lt;/li&gt; );｝ **실행화면** 이제 선택박스에서 사용자를 선택하면, 선물할 사람과 그 사람의 위시 리스트를 볼수 있습니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"모든 Nitrous 커뮤니티에 “All In One Claim” 기능이 업데이트 되었습니다.","slug":"/zzan/@anpigon/nitrous-all-in-one-claim","date":"2019-08-30T00:39:09.000Z","updated":"2019-11-11T13:41:49.836Z","comments":true,"path":"/zzan/@anpigon/nitrous-all-in-one-claim/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/nitrous-all-in-one-claim/","excerpt":"스팀엔진 토큰을 한방에 클레임할 수 있는 “All In One Claim” 기능이 스팀짱 뿐만 아니라, 이제 모든 Nitrous 커뮤니티에서 사용가능합니다. 관련글: https://steempeak.com/nitrous/@eonwarped/all-in-one-claim-in-nitrous-instances","text":"스팀엔진 토큰을 한방에 클레임할 수 있는 “All In One Claim” 기능이 스팀짱 뿐만 아니라, 이제 모든 Nitrous 커뮤니티에서 사용가능합니다. 관련글: https://steempeak.com/nitrous/@eonwarped/all-in-one-claim-in-nitrous-instances 많은 이용 부탁드립니다. 스팀짱 트리플 A 스팀코인판","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #12 : Flow를 사용하여 비동기 프로세스 정의하기","slug":"/zzan/@anpigon/react-mobx-state-tree-12-flow","date":"2019-08-29T15:26:54.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-12-flow/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-12-flow/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #11 : 더 많은 mobx-state-tree Types 배우기: map, literal, union, enumeration&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #11 : 더 많은 mobx-state-tree Types 배우기: map, literal, union, enumeration&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Defining Asynchronous Processes Using Flow 강의 링크: https://egghead.io/lessons/react-defining-asynchronous-processes-using-flow 12번째 레슨입니다. 실제 시나리오에서는 데이터를 가져오는 작업이 대부분 비동기 방식입니다. 예를 들면 get fetched를 사용하여 서버에서 additional recourses을 가져옵니다. MST는 asynchronous actions에 대한 first class support을 제공합니다. 우리는 이제 naively implemented async process부터 시작하여 MST flows와 generators로 async / await 과정을 배우게 됩니다. 우리는 이번 레슨에서 다음을 배우게 됩니다. 이 비동기 프로세스는 MST의 'only actions can modify’의 semantics를 respect해야 하는 경우 painful합니다.(사실 무슨말인지 저도 잘모르겠습니다.ㅠ) Flows은 MST에서 비동기 프로세스를 describe하는 idiomatic way입니다. Flows는 robust합니다. 프로세스 lifecycle을 완벽하게 control 할 수 있습니다. 간단한 API 서비스 만들기 비동기 작업을 위해서 간단한 API 서비스를 먼저 구현하겠습니다. json-server 모듈을 사용하면 JSON API 서비스를 쉽고 빠르게 만들 수 있습니다. json-server는 JSON 파일을 사용하여 API 서비스를 생성 할 수 있습니다. json-server 모듈 설치 1$ yarn add json-server 그다음 샘플 json 파일을 생성합니다. 이 json 파일을 사용하여 간단한 JSON API 서비스를 시작할 수 있습니다. db.json 1234567891011121314151617181920212223242526｛ \"suggestions_m\": [ ｛ \"name\": \"Machine Gun Preacher\", \"price\": 7.35, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/1gEP9ZC7jpSiuMWNfbOfXTWWF5n.jpg\" ｝, ｛ \"name\": \"Avengers: Endgame\", \"price\": 17.29, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/or06FN3Dka5tukK1e9sl16pB3iy.jpg\" ｝ ], \"suggestions_f\": [ ｛ \"name\": \"The Notebook\", \"price\": 10.31, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/gMfstesBXKdsHToAUXVPHujUDfb.jpg\" ｝, ｛ \"name\": \"La La Land\", \"price\": 15.79, \"image\": \"https://image.tmdb.org/t/p/w185_and_h278_bestv2/ylXCdC106IKiarftHkcacasaAcb.jpg\" ｝ ]｝ 포트 3000은 리액트앱이 사용하고 있기 때문에, 포트 3001를 사용하여 json-server를 구동합니다. 1$ yarn run json-server --port 3001 db.json **실행화면** ![](https://files.steempeak.com/file/steempeak/anpigon/5WlBrI2j-_2019-08-27__12.59.34.png) 이제 브라우저에서 [http://localhost:3001/suggestions_m](http://localhost:3001/suggestions_m) 를 호출해서 데이터를 확인해봅시다. ![](https://files.steempeak.com/file/steempeak/anpigon/n7ErNv2S-_2019-08-27__12.58.40.png) # UI 수정하기 App.js 을 열고 UI 를 수정합니다. App 컴포넌트 맨 아래에 [Suggestions] 버튼을 추가합니다. src/components/App.js 123456789101112131415161718192021222324252627282930// ...class App extends React.Component ｛ constructor(props) ｛ // ... ｝ render() ｛ const ｛ group ｝ = this.props; const selectedUser = group.users.get(this.state.selectUser); return ( &lt;div&gt; &lt;h1 className=\"App-title\"&gt;WishList&lt;/h1&gt; &lt;select onChange=｛this.onSelectUser｝&gt; &lt;option value=\"\"&gt;- Select user -&lt;/option&gt; ｛values(group.users).map(user =&gt; ( &lt;option key=｛user.id｝ value=｛user.id｝&gt; ｛user.name｝ &lt;/option&gt; ))｝ &lt;/select&gt; ｛selectedUser &amp;&amp; &lt;WishListView wishList=｛selectedUser.wishList｝ /&gt;｝ ｛selectedUser &amp;&amp; &lt;button onClick=｛selectedUser.getSuggestions｝&gt;Suggestions&lt;/button&gt;｝ &lt;/div&gt; ); ｝// ... 이제 화면에 [Suggestions] 버튼이 보입니다. 하지만 아직은 버튼을 눌러도 아무런 일이 발생하지 않습니다. 액션 추가하기 이제 User 모델로 가서 새로운 액션을 만들겠습니다. Group.js 파일을 열고 getSuggestions 액션을 추가합니다. 비동기 액션을 위해서는 generators 함수를 사용해야합니다. 그리고 generators 함수를 사용하기 위해서, mobx-state-tree에서 제공하는 flow를 사용합니다. flow는 이것이 비동기 프로세스임을 나타냅니다. generators 함수는 async / await와 동일하게 작동합니다. src/models/Group.js 12345678910111213141516171819import ｛ types, flow ｝ from \"mobx-state-tree\"; // add here// ...export const User = types .model(｛ // ... ｝) .actions(self =&gt; (｛ getSuggestions: flow(function*() ｛ const response = yield window.fetch( `http://localhost:3001/suggestions_$｛self.gender｝` ); const suggestions = yield response.json(); self.wishList.items.push(...suggestions); ｝) ｝));// ... 미들웨어 사용하기 간단한 미들웨어를 추가하고 이 호출에 대한 로그를 기록하여 살펴보겠습니다. index.js 파일을 수정합니다. 그리고 mobx-state-tree 패키지에서 addMiddleware를 가져옵니다. 그다음 addMiddleware를 사용하여 group 모델에서 호출되는 액션 type과 name을 콘솔 로그에 출력합니다. src/index.js 12345678910111213// ...import ｛ getSnapshot, addMiddleware ｝ from 'mobx-state-tree';// ...let group = Group.create(initialState);addMiddleware(group, (call, next) =&gt; ｛ console.log(`[$｛call.type｝] [$｛call.name｝]`); next(call);｝);// ... 마지막으로 테스트 하기 [Suggestions] 버튼을 눌러서 getSuggestions 액션을 호출합니다. 콘솔 로그를 살펴보면, 첫 번째 yield 후에 resumes하고 두 번째 yield 후에 다시 resumes한 다음 returns 합니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #11 : 더 많은 mobx-state-tree Types 배우기: map, literal, union, enumeration","slug":"/zzan/@anpigon/react-mobx-state-tree-11-mobx-state-tree-types-map-literal-union-enumeration","date":"2019-08-29T06:07:54.000Z","updated":"2019-11-11T13:41:49.826Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-11-mobx-state-tree-types-map-literal-union-enumeration/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-11-mobx-state-tree-types-map-literal-union-enumeration/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #10 : Model Definitions Change되면 Hot Module Reloading를 사용하여 Model Tree State 복원하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #10 : Model Definitions Change되면 Hot Module Reloading를 사용하여 Model Tree State 복원하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree More mobx-state-tree Types: map, literal, union, and enumeration 강의 링크: https://egghead.io/lessons/react-more-mobx-state-tree-types-map-literal-union-and-enumeration 11번째 레슨입니다. 이번 레슨에서는 그룹 및 사용자의 개념을 소개합니다. 그룹 내에 여러 사용자를 관리할 수 있습니다. 그리고 각 사용자들은 각각의 위시 리스트를 가질 수 ​​있습니다. 또한 union 타입과 타입 discrimination의 강력한 기능을 간단히 살펴볼 것입니다. 우리는 이번 레슨에서 다음을 배우게 됩니다. key로 데이터를 저장하기 위해 type map 사용하기 single value types를 생성하기 위해 literals 사용하기 type discrimination 하기 위해 literals 과 unions을 Combining 하기 quick coding experiments를 위해 Quokka를 scratchpad로 사용하기 enumerations 사용하기 Enumerations는 literals의 union에 대한 just sugar 이다. 🤔 이제 사용자 그룹을 만들고 각 사용자가 각자의 위시 리스트를 가지도록 모델을 개선해 봅시다. User 모델 만들기 groups.js 파일을 새로 생성합니다. 그리고 User 모델을 정의 합니다. User 모델은 id 와 name, 그리고 gender 속성을 가집니다. src/models/Group.js 1234567import ｛ types ｝ from 'mobx-state-tree';const User = types.model(｛ id: types.string, name: types.string, gender: types.union(types.literal('m'), types.literal('f'))｝); 타입을 선택할 수 있는 유형을 일반적으로 union이라 합니다. 두 가지 타입을 결합하여 gender을 표현하게 됩니다. 여기서 gender 값은 반드시 m 또는 f 여야합니다. Quokka 사용하여 빠르게 테스트해보기 VSCode의 익스텐션 프로그램 Quokka를 사용하면 자바스크립트 또는 타입스크립트를 스크래치 패드에서 빠르게 만들고 실행할 수 있습니다. VSCode에 Quokka 익스텐션을 설치합니다. Quokka 익스텐션 설치 하기: https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode 그다음 단축키 Cmd + Shift + P를 눌러 Quokka에서 New File를 생성합니다. 위에서 작성한 코드를 Quokka에 복사&amp;붙여넣기 합니다. 그리고 User 모델 인스턴스를 생성하고 genger 속성에 m 또는 f 외에 엉뚱한 값을 넣어보세요. 그럼 다음과 같이 잘못된 타입이라는 에러가 발생합니다. 하지만 genger에 m 값을 입력하면 다음과 같이 에러가 발생하지 않습니다. 이제 Man과 Woman 모델을 각각 정의하고, 이 두 모델을 다시 union하여 Human을 정의해봅시다. 그리고 나서 Human 인스턴스를 생성할때 gender에 m을 입력하여 somebody를 생성합니다. 우리는 somebody가 man인지 아닌지 간단히 확인할 수 있습니다. 123456789101112131415161718192021222324import ｛ types ｝ from 'mobx-state-tree';const Man = types.model(｛ id: types.string, name: types.string, gender: types.literal('m')｝);const Woman = types.model(｛ id: types.string, name: types.string, gender: types.literal('f')｝);const Human = types.union(Man, Woman);const someone = Human.create(｛ id: \"123\", name: \"michel\", gender: \"m\"｝)console.log(Man.is(someone))console.log(Woman.is(someone)) Man.is(someone)은 true, 그리고 Woman.is(someone)는 flase가 출력됩니다. enumeration 사용하기 literal을 union하는 방식인 types.union(types.literal('m'), types.literal('f')) 이 가장 일반적인 패턴입니다. 하지만 더 간단한 표기법이 있습니다. 이를 enumeration이라고 합니다. User 모델의 gender Type을 enumeration를 사용하여 다시 표현하면 types.enumeration(&quot;gender&quot;, [&quot;m&quot;, &quot;f&quot;])가 됩니다. src/models/Group.js 1234567import ｛ types ｝ from 'mobx-state-tree';export const User = types.model(｛ id: types.string, name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"])｝); 그다음 User 모델에 wishList 속성을 정의합니다. wishList는 optional 이며, 디폴트값은 비어있는 Object ｛｝입니다. src/models/Group.js 1234567891011import ｛ types ｝ from 'mobx-state-tree';import ｛ WishList ｝ from \"./WishList\"; // add hereexport const User = types.model(｛ id: types.string, name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"]) wishList: types.optional(WishList, ｛｝) // add here｝); Group 모델 만들기 이제 Group을 정의 합니다. Group은 User 그룹이라고 할 수 있습니다. 여기에서는 Map를 사용하였습니다. 하지만 우리는 Array를 사용할 수도 있습니다. Group.js 파일 맨 아래에 다음 코드를 입력합니다. src/models/Group.js 12345// ...export const Group = types.model(｛ users: types.map(User)｝); 다음은 지금까지 작성된 Group.js 파일의 전체 내용입니다. src/models/Group.js 12345678910111213import ｛ types ｝ from \"mobx-state-tree\";import ｛ WishList ｝ from \"./WishList\";export const User = types.model(｛ id: types.string, name: types.string, gender: types.enumeration(\"gender\", [\"m\", \"f\"]), wishList: types.optional(WishList, ｛｝)｝);export const Group = types.model(｛ users: types.map(User)｝); UI 수정하기 모델을 재구성했으니 이제 UI를 수정해야합니다. index.js 파일을 편집합니다. Group 모델을 import 합니다. 그리고 간단한 작업을 위해 initialState에는 심슨 가족 데이터 셋트를 미리 준비했습니다. src/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...import ｛ Group ｝ from \"./models/Group\";let initialState = ｛ usres: ｛ \"a342\": ｛ id: \"a342\", name: \"Homer\", gender: \"m\" ｝, \"5fc2\": ｛ id: \"5fc2\", name: \"Marge\", gender: \"f\" ｝, \"663b\": ｛ id: \"663b\", name: \"Bart\", gender: \"m\" ｝, \"65aa\": ｛ id: \"65aa\", name: \"Maggie\", gender: \"f\" ｝, \"ba32\": ｛ id: \"ba32\", name: \"Lisa\", gender: \"f\" ｝ ｝｝// ...let group = Group.create(initialState);function renderApp() ｛ ReactDOM.render(&lt;App group=｛group｝ /&gt;, document.getElementById(\"root\"));｝// ... 그다음 선택 박스에서 사용자를 선택하면 위시 리스트 목록, 편집 화면이 보이도록 고쳐보겠습니다. App.js 파일을 수정합니다. 참고로 동영상 강의에서는 group.users.values().map 를 사용하고 있습니다. 하지만 Mobx 2에서 사용방법이 변경되었습니다. Array.from(group.users.values()).map 또는 values(group.users).map 를 사용하세요. src/components/App.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React from \"react\";import ｛ values ｝ from 'mobx';import \"./App.css\";import WishListView from \"./WishListView\";class App extends React.Component ｛ constructor(props) ｛ super(props); this.state = ｛ selectUser: null ｝; ｝ render() ｛ const ｛ group ｝ = this.props; const selectedUser = group.users.get(this.state.selectUser) return ( &lt;div&gt; &lt;h1 className=\"App-title\"&gt;WishList&lt;/h1&gt; &lt;select onChange=｛this.onSelectUser｝&gt; &lt;option&gt;- Select user -&lt;/option&gt; ｛｛values(group.users).map(user =&gt; ( &lt;option key=｛user.id｝ value=｛user.id｝&gt; ｛user.name｝ &lt;/option&gt; ))｝ &lt;/select&gt; ｛ selectedUser &amp;&amp; &lt;WishListView wishList=｛selectedUser.wishList｝ /&gt; ｝ &lt;/div&gt; ); ｝ onSelectUser = event =&gt; ｛ this.setState(｛ selectUser: event.target.value ｝) ｝;｝export default App; 실행화면 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #10 : Model Definitions Change되면 Hot Module Reloading를 사용하여 Model Tree State 복원하기","slug":"/zzan/@anpigon/react-mobx-state-tree-10-model-definitions-change-hot-module-reloading-model-tree-state","date":"2019-08-28T21:39:12.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-10-model-definitions-change-hot-module-reloading-model-tree-state/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-10-model-definitions-change-hot-module-reloading-model-tree-state/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #9 : 로컬 저장소에 저장소 저장&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #9 : 로컬 저장소에 저장소 저장&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Restore the Model Tree State using Hot Module Reloading when Model Definitions Change 강의 링크: https://egghead.io/lessons/react-restore-the-model-tree-state-using-hot-module-reloading-when-model-definitions-change 10번째 레슨입니다. 이번 레슨에서는 HMR(Hot Module Reloading)을 설정하는 방법을 배웁니다. React components와 MST models를 새로 정의하면, HMR에서 이를 다시 로드하여 실행중인 애플리케이션에 적용하게 됩니다. 우리는 다음을 배우게 됩니다. HMR(Hot Module Reloading) 설정 방법 components의 변경 사항을 accept 하는 방법 state를 유지하면서 changing model definitions의 변경 사항을 accept하는 방법 이전에 우리는 state를 보존하기 위해서 로컬 스토리지를 사용했습니다. 하지만 현재 개발 방식에는 단점이 있습니다. 무언가를 변경할 때 마다 앱을 다시 로드해야 한다는 것입니다. hot module reloading 라고 불리는 기술이 mobx-state-tree 에서 잘 작동하도록 설정할 수 있습니다. hot module reloading는 대략 다음과 같이 작동합니다. JS 파일을 수정하면 webpack은 변경 사항을 반환 application으로 보내고 메모리의 모듈을 대체합니다. 이전에 개발했던 로컬 스토리지 구현을 제거합니다. 그런 다음 renderApp 함수를 작성합니다. renderApp는 단순히 initial render을 래핑한 함수입니다. 우리는 핫 모듈 리로딩에서 두가지 변경의 경우를 처리해야 합니다. 첫번째는 컴포넌트가 변경되는 경우입니다. 이 경우에는 루트에서 application을 다시 렌더링하면 됩니다. 두번째는 모델이 변경된 경우입니다. 이 경우에는 스냅샷을 사용하여 현재 state tree가 유지되도록 해야 합니다. index.js 파일을 다음과 같이 수정합니다. src/index.js 123456789101112131415161718192021222324252627282930313233343536import React from \"react\";import ReactDOM from \"react-dom\";import ｛ getSnapshot ｝ from 'mobx-state-tree'; // add hereimport App from \"./components/App\";import ｛ WishList ｝ from \"./models/WhishList\";let initialState = ｛ items: [ // ... ]｝let wishList = WishList.create(initialState);function renderApp() ｛ ReactDOM.render(&lt;App wishList=｛wishList｝ /&gt;, document.getElementById(\"root\"));｝renderApp();if(module.hot) ｛ module.hot.accept([\"./components/App\"], () =&gt; ｛ // new compoennts renderApp(); ｝); module.hot.accept([\"./models/WhishList\"], () =&gt; ｛ // new model definitions const snapshot = getSnapshot(wishList); wishList = WishList.create(snapshot); renderApp(); ｝);｝ 이제는 모델을 수정해도 현재 작업하고 있던 state tree를 그대로 유지 할 수 있습니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"스팀짱 업데이트 공지 : 개발자를 위한 코드 하이라이트","slug":"/zzan/@anpigon/6jogvv","date":"2019-08-27T14:45:54.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/6jogvv/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/6jogvv/","excerpt":"안녕하세요. 안피곤입니다.이번에는 개발자를 위한 기능이 업데이트 되었습니다. 사실 개인적으로 제가 필요해서 업데이트 했습니다. ㅎㅎ 업데이트 내용 : 코드 하이라이트이제 스팀짱에서는 소스코드를 이쁘게 보여줍니다.지금 코드 하이라이트가 가능한 개발언어는 javascript, css, html, graphql, php, python, java, json, c, dart, sql, bash 입니다. 개발언어를 다 지원하고 싶지만, 다 넣으면 앱이 무거워지기 때문에 많이 사용되는 개발언어만 포함하였습니다. 혹시 다른 개발언어도 코드 하이라이트를 사용하고 싶다면 댓글로 요청해주세요.","text":"안녕하세요. 안피곤입니다.이번에는 개발자를 위한 기능이 업데이트 되었습니다. 사실 개인적으로 제가 필요해서 업데이트 했습니다. ㅎㅎ 업데이트 내용 : 코드 하이라이트이제 스팀짱에서는 소스코드를 이쁘게 보여줍니다.지금 코드 하이라이트가 가능한 개발언어는 javascript, css, html, graphql, php, python, java, json, c, dart, sql, bash 입니다. 개발언어를 다 지원하고 싶지만, 다 넣으면 앱이 무거워지기 때문에 많이 사용되는 개발언어만 포함하였습니다. 혹시 다른 개발언어도 코드 하이라이트를 사용하고 싶다면 댓글로 요청해주세요. 참고로 코드 하이라이트 기능은 prismjs 모듈을 사용하여 개발하였습니다. 지원 가능한 개발언어는 여기를 참고하세요. https://prismjs.com/#supported-languages # 사용 방법 만약 개발언어가 HTML 이면 ```html ```사이에 코드를 작성하면 됩니다. 이렇게 작성하면 이렇게 보입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #9 : 로컬 저장소에 저장소 저장","slug":"/zzan/@anpigon/react-mobx-state-tree-9","date":"2019-08-26T16:24:18.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-9/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-9/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #8 : Create an Entry Form to Add Models to the State Tree&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #8 : Create an Entry Form to Add Models to the State Tree&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Store Store in Local Storage 강의 링크: https://egghead.io/lessons/react-store-store-in-local-storage 9번째 레슨입니다. 최적의 사용자 및 개발자 경험을 위해 로컬 스토리지에 상태(state)를 저장해야하는 경우가 있습니다. 이번 레슨에서 우리는 다음을 배우게 됩니다. onSnapshot를 사용하여 새 스냅 샷에 대한 알림을 받을 수 있습니다 로컬 스토리지에 스냅샷 저장하기 로컬 스토리지에서 상태 트리 복원하기 Model.is(...)을 사용하여 스냅샷이 모델을 준수하는지 확인하기 로컬 스토리지에 스냅샷 저장하고 가져오기 index.js 파일을 수정합니다. 그다음 초기 상태(initial state)를 담을 initialState 변수를 만듭니다. 그리고 로컬 스토리지에서 가져온 데이터를 initialState 에 담아 WishList 모델을 초기화합니다. src/index.js 1234567891011121314151617181920// ...import ｛ WishList ｝ from \"./models/WhishList\";// 초기 State 정의let initialState = ｛ items: [ // ... ]｝// 로컬 스토리지에 데이터가 있으면 가져와서 JSON 파싱하기if(localStorage.getItem(\"wishlistapp\")) ｛ initialState = JSON.parse(localStorage.getItem(\"wishlistapp\")); ｝// initialState 로 WishList 모델 인스턴스 초기화하기const wishList = WishList.create(initialState);ReactDOM.render(&lt;App wishList=｛wishList｝ /&gt;, document.getElementById(\"root\")); 그다음 mobx-state-tree 모듈의 onSnapshot 를 import 합니다. 그리고 onSnapshot 를 사용하여 스냅샷이 발생하면 스냅샷을 로컬 스토리지에 저장합니다. onSnapshot(model, callback)는 새 스냅샷이 발생할 때 마다 이벤트 리스너가 생성됩니다. 자세한 내용은 mobx-state-tree gitbook snapshots 문서를 참고하세요. src/index.js 123456789// ...import ｛ onSnapshot ｝ from 'mobx-state-tree'; // add here// ...onSnapshot(wishList, snapshot =&gt; ｛ localStorage.setItem(\"wishlistapp\", JSON.stringify(snapshot));｝) 이제 새 스냅샷이 발생하면 onSnapshot 함수에서 현재 state를 가져와서 로컬 스토리지에 저장하게 됩니다. 그다음 로컬 스토리지에서 가져온 데이터가 WishList 모델의 데이터에 준수하는지 검증 코드를 입력합니다. 이런 코드를 보통 방어 로직이라고 합니다. 123456if(localStorage.getItem(\"wishlistapp\")) ｛ const json = JSON.parse(localStorage.getItem(\"wishlistapp\")); if( WishList.is(json) ) ｛ initialState = json; ｝｝ 실행 화면 이제 데이터를 입력하고 Add 버튼을 누르면 현재 State가 로컬 스토리이에 저장됩니다. 그래서 새로고침을 해도 등록한 데이터가 유지됩니다. 로컬 스토리지에 저장된 데이터는 개발자 브라우저 콘솔창에서 확인 가능합니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #8 : Create an Entry Form to Add Models to the State Tree","slug":"/zzan/@anpigon/react-mobx-state-tree-8-create-an-entry-form-to-add-models-to-the-state-tree","date":"2019-08-26T02:57:03.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-8-create-an-entry-form-to-add-models-to-the-state-tree/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-8-create-an-entry-form-to-add-models-to-the-state-tree/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #7 : Remove Model Instances from the Tree&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #7 : Remove Model Instances from the Tree&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Create an Entry Form to Add Models to the State Tree 강의 링크: https://egghead.io/lessons/react-create-an-entry-form-to-add-models-to-the-state-tree 8번째 레슨입니다. 위시 리스트에 새 항목을 추가 할 시간입니다. 우리는 지금까지 작성한 입력폼과 모델을 재사용할 것입니다. 우리는 다음을 배우게 됩니다. MST는 단일 상태 트리(single state tree)로 제한되지 않습니다. 모든 모델은 자체적인 트리를 가질 수 있습니다 상태 트리(state tree)에 모델 인스턴스 추가하기 새 파일 WishListItemEntry.js을 생성합니다. 여기서 WishListItemEdit 컴포넌트를 재활용합니다. 그리고 Add 버튼을 만들었습니다. 입력양식을 작성하고 Add 버튼을 누르면 WishList 모델에 새 항목을 추가하게 됩니다. src/components/WishListItemEntry.js 123456789101112131415161718192021222324252627282930313233343536373839import React, ｛ Component ｝ from \"react\";import ｛ observer ｝ from \"mobx-react\";import WishListItemEdit from \"./WishListItemEdit\";import ｛ WishListItem, WishList ｝ from \"../models/WhishList\";class WishListItemEntry extends Component ｛ constructor() ｛ super(); this.state = ｛ entry: WishListItem.create(｛ name: \"\", price: 0 ｝) ｝; ｝ render() ｛ return ( &lt;div&gt; &lt;WishListItemEdit item=｛this.state.entry｝ /&gt; &lt;button onClick=｛this.onAdd｝&gt;Add&lt;/button&gt; &lt;/div&gt; ); ｝ onAdd = () =&gt; ｛ this.props.wishList.add(this.state.entry); this.setState(｛ entry: WishListItem.create(｛ name: \"\", price: 0 ｝) ｝); ｝;｝export default WishListItemEntry; 그다음 WishListView.js 파일을 수정합니다. WishListView 컴포넌트에는 방금 만든 WishListItemEntry 컴포넌트를 추가하여 화면에 보여줍니다. src/components/WishListView.js 123456789101112131415161718import React from \"react\";import ｛ observer ｝ from \"mobx-react\";import WishListItemView from \"./WishListItemView\";import WishListItemEntry from './WishListItemEntry'; // add hereconst WishListView = (｛ wishList ｝) =&gt; ( &lt;div className=\"list\"&gt; &lt;ul&gt; ｛wishList.items.map((item, idx) =&gt; ( &lt;WishListItemView key=｛idx｝ item=｛item｝ /&gt; ))｝ &lt;/ul&gt; Total: ｛wishList.totalPrice｝ 💲 &lt;WishListItemEntry wishList=｛wishList｝ /&gt; &lt;/div&gt;);export default observer(WishListView); 실행화면 이제 새로운 항목을 작성하고 Add 버튼을 눌러보세요. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #7 : Remove Model Instances from the Tree","slug":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-7","date":"2019-08-25T11:23:36.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-7/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-7/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #6 : Views를 사용하여 모델에서 정보 보여주기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #6 : Views를 사용하여 모델에서 정보 보여주기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Remove Model Instances from the Tree 강의 링크: https://egghead.io/lessons/react-remove-model-instances-from-the-tree 7번째 레슨입니다. 이번 레슨에서는 MST의 tree semantics에 대해서 좀더 깊이 배워봅니다. 우리는 다음을 배우게 됩니다. 액션(Actions) 자신의 하위트리(subtree)만 변경 가능합니다. getParent를 사용해서 현재 모델 인스턴스의 부모를 찾아봅니다. destroy를 사용하여 트리에서 현재 인스턴스를 완전히 제거해봅니다. 먼저 WishListItemView.js 파일을 수정합니다. WishListItemView 컴포넌트에 삭제 ❎ 버튼을 만듭니다. src/components/WishListItemView.js 12345678910111213141516171819202122232425class WishListItemView extends Component ｛ // ... render() ｛ const ｛ item ｝ = this.props; return this.state.isEditing ? ( this.renderEditable() ) : ( &lt;li className=\"item\"&gt; ｛item.image &amp;&amp; &lt;img src=｛item.image｝ alt=\"\" /&gt;｝ &lt;h3&gt;｛item.name｝&lt;/h3&gt; &lt;span&gt;｛item.price｝&lt;/span&gt;&lt;br/&gt; &lt;span&gt; &lt;button onClick=｛this.onTooleEdit｝&gt;✏️&lt;/button&gt; ｛/* add here */｝ &lt;button onClick=｛item.remove｝&gt;❎&lt;/button&gt; &lt;/span&gt; &lt;/li&gt; ); ｝ // ...｝ 앱을 실행하면 이제 항목에 삭제 ❎ 버튼이 보입니다. 하지만 지금은 삭제 ❎ 버튼을 눌러도 아무런 일도 일어나지 않습니다. 모델에 삭제 액션을 추가합니다. 먼저 WishListItem 모델을 수정합니다. 그리고 WishListItem 모델에 remove() 액션을 추가합니다. 자신(self)을 제거할 수 없기 때문에, remove() 액션에서 다시 부모의 remove() 액션을 호출합니다. 부모를 찾기 위해서 getParent를 사용합니다. src/models/WhishList.js 123456789101112import ｛ types, getParent ｝ from \"mobx-state-tree\"; // add hereexport const WishListItem = types .model(｛ // ... ｝) .actions(self =&gt; (｛ // ... remove() ｛ getParent(self, 2).remove(self); // add here ｝ ｝)); getParent(self, 2)에서 2번째 인자값 2의 의미는 getParent(getParent(self)) 입니다. 현재 모델 트리구조가 WishList: ｛ items: [｛ self ｝] ｝ 이기 때문에, WishList 모델에 접근하기 위해서 Parent를 2번 수행합니다. 그다음 WishList 모델을 수정합니다. 여기에도 remove() 액션을 추가합니다. src/models/WhishList.js 123456789101112export const WishList = types.model(｛ // ...｝).views(self =&gt; (｛ // ...｝)).actions(self =&gt; (｛ // ... remove(item) ｛ self.items.splice(self.items.indexOf(item), 1); // add here ｝｝)); splice는 ES6에 추가된 문법입니다. 현재 인덱스의 1개 아이템을 제거합니다. 자세한 사용방법은 mozilla 개발자 문서를 참고하세요 mobx-state-tree의 destroy를 사용하면, remove()를 더 간단하게 구현할 수 있습니다. src/models/WhishList.js 1234567891011121314import ｛ types, getParent, destroy ｝ from \"mobx-state-tree\"; // add hereexport const WishList = types.model(｛ // ...｝).views(self =&gt; (｛ // ...｝)).actions(self =&gt; (｛ // ... remove(item) ｛ destroy(item); // add here ｝｝)); 실행결과 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #6 : React에서 mobx-state-tree Models 수정하기","slug":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-6","date":"2019-08-25T09:12:39.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-6/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-6/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #5 : React에서 mobx-state-tree 모델 렌더링하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #5 : React에서 mobx-state-tree 모델 렌더링하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Render mobx-state-tree Models in React 강의 링크: https://egghead.io/lessons/react-build-forms-with-react-to-edit-mobx-state-tree-models 6번째 레슨입니다. 이번 레슨에서는 observer 래퍼를 사용하여, React 컴포넌트가 자동으로 업데이트되는 과정을 배웁니다. 우리는 다음을 배우게 됩니다. 컴포넌트(component)에서 모델 액션(model actions)을 호출하는 방법을 배웁니다. clone를 사용하여 모델 인스턴스(model instance)를 완전하게 복제하는 방법을 배웁니다. applySnapshot은 스냅샷에 제공된 모델 인스턴스의 상태(the state of a model instance)를 업데이트하는 데 사용합니다. 먼저 WishListItemEdit.js 파일을 생성합니다. 정보를 수정할 수 있는 컴포넌트입니다. src/components/WishListItemEdit.js 123456789101112131415161718192021222324252627282930313233import React, ｛ Component ｝ from 'react';import ｛ observer ｝ from 'mobx-react';class WishListItemEdit extends Component ｛ render() ｛ const ｛ item ｝ = this.props; return ( &lt;div classname=\"item-edit\"&gt; Thing: &lt;input value=｛item.name｝ onChange=｛this.onNameChange｝ /&gt; &lt;br/&gt; Price: &lt;input value=｛item.price｝ onChange=｛this.onPriceChange｝ /&gt; &lt;br/&gt; Image: &lt;input value=｛item.image｝ onChange=｛this.onImageChange｝ /&gt; &lt;br/&gt; &lt;/div&gt; ) ｝ onNameChange = event =&gt; ｛ this.props.item.changeName(event.target.value); ｝ onPriceChange = event =&gt; ｛ const price = parseInt(event.target.value); if(!isNaN(price)) this.props.item.changePrice(price); ｝ onImageChange = event =&gt; ｛ this.props.item.changeImage(event.target.value); ｝｝export default observer(WishListItemEdit); 그다음 WishListItemView.js 파일을 수정합니다. 그리고 방금 만든 WishListItemEdit 컴포넌트를 사용합니다. src/components/WishListItemView.js 1234567891011121314151617181920212223242526272829303132333435363738394041import React, ｛ Component ｝ from \"react\";import ｛ observer ｝ from \"mobx-react\";import WishListItemEdit from \"./WishListItemEdit\";class WishListItemView extends Component ｛ constructor() ｛ super(); this.state = ｛ isEditing: false ｝; ｝ render() ｛ const ｛ item ｝ = this.props; return this.state.isEditing ? ( this.renderEditable() ) : ( &lt;li className=\"item\"&gt; ｛item.image &amp;&amp; &lt;img src=｛item.image｝ alt=\"\" /&gt;｝ &lt;h3&gt;｛item.name｝&lt;/h3&gt; &lt;span&gt;｛item.price｝&lt;/span&gt; &lt;span&gt; &lt;button onClick=｛this.onTooleEdit｝&gt;✏️&lt;/button&gt; &lt;/span&gt; &lt;/li&gt; ); ｝ renderEditable = () =&gt; ｛ return ( &lt;li className=\"item\"&gt; &lt;WishListItemEdit item=｛this.props.item｝ /&gt; &lt;/li&gt; ); ｝; onTooleEdit = () =&gt; ｛ this.setState(｛ isEditing: true ｝); ｝;｝export default observer(WishListItemView); 이제 수정 ✏️버튼을 누르면 WishListItemEdit 컴포넌트로 전환됩니다. 그다음 취소 ❎버튼을 추가합니다. 12345678910renderEditable = () =&gt; ｛ return ( &lt;li className=\"item\"&gt; &lt;WishListItemEdit item=｛this.props.item｝ /&gt; &lt;span&gt; &lt;button onClick=｛this.onCancelEdit｝&gt;❎&lt;/button&gt; &lt;/span&gt; &lt;/li&gt; );｝; 이제 취소 ❎버튼을 누르면 원래 컴포넌트로 돌아갑니다. 하지만 한가지 문제점이 있습니다. 취소 ❎버튼을 눌렀는데 데이터가 변경됩니다. 이제 mobx-state-tree의 clone을 사용하여 원본 데이터가 변경되지 않도록 해봅시다. onTooleEdit 함수에서 this.props.item를 복제(clone)합니다. 그리고 WishListItemEdit 컴포넌트에는 복제한 아이템 this.state.clone 를 넘겨줍니다. 123456789101112131415161718192021222324252627import ｛ clone ｝ from 'mobx-state-tree'; // add hereclass WishListItemView extends Component ｛ // ... renderEditable = () =&gt; ｛ return ( &lt;li className=\"item\"&gt; &lt;WishListItemEdit item=｛this.state.clone｝ /&gt; &lt;span&gt; &lt;button onClick=｛this.onCancelEdit｝&gt;❎&lt;/button&gt; &lt;/span&gt; &lt;/li&gt; ); ｝; onTooleEdit = () =&gt; ｛ this.setState(｛ isEditing: true, clone: clone(this.props.item) // add here ｝); ｝; // ...｝ 앱을 실행하고 다시 확인해 봅시다. 이제는 데이터를 수정하고 취소를 해도 원본 데이터가 변경되지 않습니다. 마지막입니다. 이제 변경된 clone 데이터를 mobx-state-tree Models에 적용해야합니다. 여기에는 mobx-state-tree의 getSnapshot, applySnapshot를 사용합니다. renderEditable에 저장 💾 버튼을 추가합니다. 그리고 onSaveEdit 함수를 추가합니다. onSaveEdit에서는 clone 스냅샷을 만들고(getSnapshot), 그 스넵샷을 모델에 적용(applySnapshot)합니다. 1234567891011121314151617181920212223242526import ｛ clone, getSnapshot, applySnapshot ｝ from \"mobx-state-tree\"; // add hereclass WishListItemView extends Component ｛ // ... renderEditable = () =&gt; ｛ return ( &lt;li className=\"item\"&gt; &lt;WishListItemEdit item=｛this.state.clone｝ /&gt; &lt;span&gt; &lt;button onClick=｛this.onSaveEdit｝&gt;💾&lt;/button&gt; &lt;button onClick=｛this.onCancelEdit｝&gt;❎&lt;/button&gt; &lt;/span&gt; &lt;/li&gt; ); ｝; // ... onSaveEdit = () =&gt; ｛ const snapshot = getSnapshot(this.state.clone); applySnapshot(this.props.item, snapshot); this.setState(｛ isEditing: false, clone: null ｝); ｝;｝ 앱을 실행하고 취소 ❎, 저장 💾버튼을 눌러보면 잘 작동하는 것을 확인할 수 있습니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"스팀짱 업데이트 공지 : 미체결 주문 취소 버튼 추가","slug":"/zzan/@anpigon/6hci56","date":"2019-08-25T02:21:27.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/6hci56/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/6hci56/","excerpt":"안녕하세요. 안피곤입니다.오늘 오전에 스팀짱 업데이트가 있었습니다. 업데이트를 너무 자주 하는게 아닌가 생각이 드네요. 미체결 주문에 취소 버튼미체결 주문에 취소 버튼이 추가되었습니다. 주문 취소를 하려고 스팀엔진 마켓에 들어갈 필요가 없습니다.사용방법은 매우 간단합니다. 취소하고 싶은 주문에 있는 CANCEL 버튼을 눌러주세요. 그리고 키체인 서명 팝업이 나타나면 CONFIRM을 눌러주세요. 그러고 취소가 완료되고 나면 해당 주문은 목록에서 사라집니다.","text":"안녕하세요. 안피곤입니다.오늘 오전에 스팀짱 업데이트가 있었습니다. 업데이트를 너무 자주 하는게 아닌가 생각이 드네요. 미체결 주문에 취소 버튼미체결 주문에 취소 버튼이 추가되었습니다. 주문 취소를 하려고 스팀엔진 마켓에 들어갈 필요가 없습니다.사용방법은 매우 간단합니다. 취소하고 싶은 주문에 있는 CANCEL 버튼을 눌러주세요. 그리고 키체인 서명 팝업이 나타나면 CONFIRM을 눌러주세요. 그러고 취소가 완료되고 나면 해당 주문은 목록에서 사라집니다. 모바일 UI 업데이트 그리고 눈치채신 분들도 계시지만 모바일 UI에 대한 변화가 있었습니다. 스팀짱을 모바일에서 좀 더 편하게 사용하기 위해 수정했습니다. 참고로 피드 목록 화면만 수정되었어요. 변경 전과 변경 후 화면을 비교해보면 변화를 바로 알 수 있습니다. 변화를 바로 알아채신 분은 천재입니다. 엔젤님? 변경 전 변경 후 이미지 사이즈 높이를 고정했습니다. 스크롤 양을 줄여 스크롤 하는 엄지손가락의 피로를 줄여줍니다. 그리고 눈의 피로를 줄이기 위해서 이미지 색감을 살짝 어둡게 하였습니다. 블루 라이트 차단 기능이라고 생각하면 됩니다.ㅋ 가독성을 위해서 제목 크기를 키웠습니다. 사실 저는 제목부터 읽는 편이라서… ㅎㅎ 본문 글자 색상을 그레이 색으로 변경했습니다. 마지막으로 전체적으로 줄 간격과 여백 조정이 있었습니다. 많은 이용 부탁드립니다. 그리고 오류나 버그는 댓글에 피드백 부탁합니다. 짠파워가 얼마안되지만 댓글에 풀보팅드리겠습니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon [![](https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmZQ23ei2dyBhaxFXs8XBKiUdfFv3LcuXUa9mv2sHDeDf2/image.png)](https://www.steemzzang.com)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[북클럽] 책 사진을 예쁘게 찍어서 올려주세요 : 김영하 ⟪오빠가 돌아왔다⟫","slug":"/zzan/@anpigon/5y7rlq","date":"2019-08-24T11:11:24.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/5y7rlq/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/5y7rlq/","excerpt":"","text":"스팀짱 북클럽 이벤트에 참여합니다.소설가 김영하님의 제16회 이산문학상 수상작 “오빠가 돌아왔다” 책입니다.아직 읽지는 않았습니다. ㅎㅎ노트북이랑 같이 예쁘게 사진 찍어서 올립니다. 스짱 북클럽 이벤트 | 지금 이순간 나와 가장 가까운 곳에 있는 책 표지를 찍어서 올려주세요","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"김영하","slug":"김영하","permalink":"https://anpigon.github.io/tags/김영하/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #5 : React에서 mobx-state-tree 모델 렌더링하기","slug":"/zzan/@anpigon/react-mobx-state-tree-5-react-mobx-state-tree","date":"2019-08-24T01:51:39.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-5-react-mobx-state-tree/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-5-react-mobx-state-tree/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #4 : Views를 사용하여 모델에서 정보 보여주기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #4 : Views를 사용하여 모델에서 정보 보여주기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Render mobx-state-tree Models in React 강의 링크: https://egghead.io/lessons/react-render-mobx-state-tree-models-in-react 5번째 레슨입니다. 이번 레슨에서는 observer 래퍼를 사용하여, React 컴포넌트가 자동으로 업데이트되는 과정을 배웁니다. 우리는 다음을 배우게 됩니다. mobx-react의 옵저버(observer)를 사용하여, React 컴포넌트를 업데이트하고 재렌더링하는 방법을 알아보자. 컴포넌트에 모델을 사용하면 컴포넌트는 멍청해진다. 그래서 가끔 stateless function components처럼 된다. mobx devtools를 사용하여, mobx-react에서 자동으로 재렌더링 해야할 최소 컴포넌트 셋트를 찾는 것을 visualize하는 방법을 알아보자. 우선 몇가지 단일 컴포넌트를 만들어 보겠습니다. 먼저 WishListItemView.js 파일을 생성합니다. src/components/WishListItemView.js 1234567891011import React from \"react\";const WishListItemView = (｛ item ｝) =&gt; ( &lt;li className=\"item\"&gt; ｛item.image &amp;&amp; &lt;img src=｛item.image｝ alt=\"\" /&gt;｝ &lt;h3&gt;｛item.name｝&lt;/h3&gt; &lt;span&gt;｛item.price｝&lt;/span&gt; &lt;/li&gt;);export default WishListItemView; 그다음 components/WishListView.js 파일을 생성합니다. src/components/WishListView.js 12345678910111213141516import React from \"react\";import WishListItemView from \"./WishListItemView\";const WishListView = (｛ wishList ｝) =&gt; ( &lt;div className=\"list\"&gt; &lt;ul&gt; ｛wishList.items.map((item, idx) =&gt; ( &lt;WishListItemView key=｛idx｝ item=｛item｝ /&gt; ))｝ &lt;/ul&gt; Total: ｛wishList.totalPrice｝ 💲 &lt;/div&gt;);export default WishListView; 그리고 나서 components/App.js 파일을 생성합니다. src/components/App.js 1234567891011121314import React from \"react\";import WishListView from \"./WishListView\";function App(props) ｛ return ( &lt;div&gt; &lt;h1 className=\"App-title\"&gt;WishList&lt;/h1&gt; &lt;WishListView wishList=｛props.wishList｝ /&gt; &lt;/div&gt; );｝export default App; 그리고 index.js 파일을 수정합니다. src/index.js 12345678910111213141516171819202122232425import React from \"react\";import ReactDOM from \"react-dom\";import App from \"./components/App\";import ｛ WishList ｝ from \"./models/WhishList\";const wishList = WishList.create(｛ items: [ ｛ name: \"LEGO Mindstorems EV3\", price: 349.95, image: \"https://www.justbricks.com.au/images/thumbnails/280/229/detailed/14/31313LEGOMINDSTORMSNXTEV3.png\" ｝, ｛ name: \"Miracles - C.S. Lewis\", price: 12.91, image: \"https://store.vision.org.au/5438-large_default/miracles-do-they-really-happen-c-s-lewis-paperback.jpg\" ｝ ]｝);ReactDOM.render(&lt;App wishList=｛wishList｝ /&gt;, document.getElementById(\"root\")); 이제 앱을 실행하면 다음과 같이 보입니다. MobX observer 사용하기 index.js 파일에 다음 코드를 추가합니다. 1초마다 가격에 변화를 주는 코드입니다. src/index.js 123setInterval(() =&gt; ｛ wishList.items[0].changePrice(wishList.items[0].price + 1);｝, 1000); 지금은 위에 코드를 입력하고 실행하면 화면에 아무런 변화가 없습니다. observer를 설정해서 컴포넌트의 데이터 변화를 감지해야합니다. WishListView 모델에 observer를 설정합니다. observer는 모델의 데이터 변경을 감지하고 해당 컴포넌트를 재렌더링 할 것입니다. src/components/WishListView.js 12345import ｛ observer ｝ from 'mobx-react'// ...export default observer(WishListView); 아래 화면에서 LEGO 가격이 증가하는 것이 보이나요? 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"스팀짱 업데이트 공지 : 미체결 주문 내역 보기","slug":"/zzan/@anpigon/2giv4u","date":"2019-08-23T13:30:42.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/2giv4u/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/2giv4u/","excerpt":"안녕하세요. 안피곤입니다.오늘 스팀짱에 업데이트된 내용을 알려드립니다.사용자가 스팀엔진 마켓에 등록한 미체결 주문 내역(매수/매도)을 볼 수 있는 메뉴를 스팀짱에 추가했습니다.사실 며칠 전에 매수/매도 정보를 모아 볼 수 있는 앱을 원사마님이 뚝딱 만드셨죠. 키위파이(kiwifi)님이 요청하자 마자 바로 앱을 내놓는 것을 보면, 원사마님은 앱을 자동으로 만들어 주는 마법의 도구를 가지고 있는 것 같습니다. ㅎㅎ","text":"안녕하세요. 안피곤입니다.오늘 스팀짱에 업데이트된 내용을 알려드립니다.사용자가 스팀엔진 마켓에 등록한 미체결 주문 내역(매수/매도)을 볼 수 있는 메뉴를 스팀짱에 추가했습니다.사실 며칠 전에 매수/매도 정보를 모아 볼 수 있는 앱을 원사마님이 뚝딱 만드셨죠. 키위파이(kiwifi)님이 요청하자 마자 바로 앱을 내놓는 것을 보면, 원사마님은 앱을 자동으로 만들어 주는 마법의 도구를 가지고 있는 것 같습니다. ㅎㅎ 관련글: [wengine] 스팀엔진 계정기준 매수/매도정보 전량 모아보기 by wonsama 스팀엔진 마켓 미체결 주문 내역 보기 스팀엔진에 사용자가 등록한 매수/매도에 대한 미체결 주문 내역을 볼 수 있습니다. 참고로 [주문 취소] 버튼은 나중에 추가될 계획입니다. 미체결 주문 내역을 확인하는 방법입니다. 메인화면 오른쪽 Links 에서 “내 주문” 을 눌러주세요. 그리고 모바일이나 작은 노트북에서는 Links 영역이 안보입니다. 그래서 또 준비했습니다. 드랍다운 메뉴에서 “미체결 주문” 을 눌러주세요. 외부 유용한 앱 링크 추가 마지막으로 햄버거≡ 메뉴를 열어보면, ZZAN Rish List 앱과 Steem Engine Block Explorer 링크가 추가되어 있습니다. 많은 이용 부탁드립니다 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[북클럽] 지금 읽고 있는 책 21쪽 21째줄 : 김영하 ⟪말하다⟫","slug":"/zzan/@anpigon/21-21","date":"2019-08-22T02:28:03.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/21-21/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/21-21/","excerpt":"스짱 북클럽 이벤트에 참여합니다.지금 읽고 있는 책은 소설가 김영하님의 “말하다” 입니다. &quot;말하다&quot;는 김영하 작가님의 인터뷰와 강연, 대담의 내용을 글로 적은 책입니다.이 책에서 김영하 작가님은 이렇게 말합니다. 지금은 내가 함부로 꿈꾸지 못하는 시대이다. 그렇기 때문에 내가 누릴 수 있는 최대치의 즐거움을 찾아야 한다. 그러기 위해서는 '감성 근육’을 키워야 한다.","text":"스짱 북클럽 이벤트에 참여합니다.지금 읽고 있는 책은 소설가 김영하님의 “말하다” 입니다. &quot;말하다&quot;는 김영하 작가님의 인터뷰와 강연, 대담의 내용을 글로 적은 책입니다.이 책에서 김영하 작가님은 이렇게 말합니다. 지금은 내가 함부로 꿈꾸지 못하는 시대이다. 그렇기 때문에 내가 누릴 수 있는 최대치의 즐거움을 찾아야 한다. 그러기 위해서는 '감성 근육’을 키워야 한다. '감성 근육 기르는 방법’은 김영하님이 알쓸신잡에서도 한번 언급한 적이 있습니다. 그리고 관련 내용을 간략하게 정리해놓은 포스트가 있어서 링크를 공유합니다. 네이버 포스트 - 감성 근육 기르는 법! 다음은 21 페이지 21번째 줄에 해당하는 내용입니다. 한번은 어느 독자가 저에게 이메일을 보냈습니다. 편의점에서 알바로 일하고 있는데 제 책을 한 권 사서 점장에게 선물했다고요. 이상적인 세상이라면 점장이 책을 사서 알바들에게 선물했겠지만, 현실에서는 법정 최저시급도 제대로 못 받는 알바가 그 얼마 안 되는 돈을 아껴 점장에게 선물을 하더군요. 스짱 북클럽 이벤트 | 지금 읽고 있는 책 21쪽 21째줄을 올려주세요","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"김영하","slug":"김영하","permalink":"https://anpigon.github.io/tags/김영하/"}],"author":"anpigon"},{"title":"스팀짱 업데이트 공지","slug":"/zzan/@anpigon/6z7pkp","date":"2019-08-21T03:17:00.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/6z7pkp/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/6z7pkp/","excerpt":"안녕하세요. 안피곤입니다.스팀짱 커뮤니티에 업데이트된 기능을 알려드립니다. 필현(philhyuntd)님 요청으로 모든 토큰을 한방에 클레임할 수 있는 기능을 업데이트 했습니다. 많은 이용 부탁드립니다. 모든 토큰을 한방에 클레임하기Steem Engine Token의 오른쪽 영역에 ALL IN ONE CLAIM 버튼이 생겼습니다. 이제 ALL IN ONE CLAIM 버튼을 누르면 모든 토큰을 클레임 요청 합니다.","text":"안녕하세요. 안피곤입니다.스팀짱 커뮤니티에 업데이트된 기능을 알려드립니다. 필현(philhyuntd)님 요청으로 모든 토큰을 한방에 클레임할 수 있는 기능을 업데이트 했습니다. 많은 이용 부탁드립니다. 모든 토큰을 한방에 클레임하기Steem Engine Token의 오른쪽 영역에 ALL IN ONE CLAIM 버튼이 생겼습니다. 이제 ALL IN ONE CLAIM 버튼을 누르면 모든 토큰을 클레임 요청 합니다. 만약 클레임할 토큰이 없으면, 다음 화면과 같이 ALL IN ONE CLAIM 버튼이 비활성화됩니다. 하지만!!! 클레임 토큰이 있으면 ALL IN ONE CLAIM 버튼이 활성화됩니다. 활성화 버튼이 보이면 바로 눌러주세요. 참고로 ZZAN 토큰도 클레임 대상에 포함됩니다. ALL IN ONE CLAIM 버튼을 누르면 하단에 다음 메시지가 출력됩니다. 그리고 몇 초 후 바로 다음 메시지가 보입니다. 클레임 요청이 완료되었습니다. 하지만 실제 요청한 토큰이 내 지갑에 들어오기 까지는 수분의 시간이 소요됩니다. 그리고 전체 클레임 요청 기능을 구현하는데 아래 글이 도움이 되었습니다. 다른 니트러스 개발자분도 참고하면 좋을 것 같습니다. 관련글: How to claim all pending token rewards at once - improved claim command 구글 애널리틱스 적용 스팀짱에 구글 애널리틱스가 적용되었습니다. 구글 통계 데이터를 이용하여 커뮤니티에 필요한 기능을 개발할 수 있을 것 같습니다. 예를 들면 통계 데이터를 사용하여 인기 작가, 인기 글을 뽑아내고 싶습니다. 니트러스에 구글 애널리틱스를 적용하기 위해서는 스팀엔진팀에 요청해야합니다. 저는 eonwarped님에게 문의했더니 바로 적용해줬습니다. 아직 구글 애널리틱스를 적용하지 않은 니트러스 운영팀에서는 스팀엔진팀에 요청해보세요. ㅋ 기타 수정 내용 눈에 보이지 않는 몇가지 오류와 일부 UI를 수정하였습니다. 지갑 화면이 모바일에서는 아래 스샷에서 보는 것처럼 오른쪽에 여백(공간?)이 있었는데 수정되었습니다. 모바일에서 사용하는데 내가 신경 쓰여서… 그리고 예전에 글작성 페이지에서 미리보기가 오른쪽에 위치하도록 수정했습니다. 그런데 의도하지 않게 댓글도 같이 변경되었어요. 그래서 댓글은 원래대로 미리보기가 아래쪽에 위치하도록 수정했습니다. 댓글 쓸때 입력박스가 작아서 내가 불편해서… 수정전 수정후 마지막으로 원사마님이 내가 등록한 매수/매도 정보를 한눈에 볼 수 있는 앱을 개발했습니다. 많은 이용 부탁드립니다. 관련글: [wengine] 스팀엔진 계정기준 매수/매도정보 전량 모아보기 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React]  Mobx-state-tree 학습하기 #4 :  Views를 사용하여 모델에서 정보 보여주기","slug":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-4","date":"2019-08-20T02:29:36.000Z","updated":"2019-11-11T13:41:49.825Z","comments":true,"path":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-4/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-4/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #3 : Snapshots 또는 Patches를 Recording하여 mobx-state-tree 모델 테스트하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #3 : Snapshots 또는 Patches를 Recording하여 mobx-state-tree 모델 테스트하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Derive Information from Models Using Views 강의 링크: https://egghead.io/lessons/react-derive-information-from-models-using-views 4번째 레슨입니다. 이번 레슨에서는 데이터를 선언적으로 derive하고 캐싱하는 views 사용 방법에 대해 학습합니다. 우리는 다음을 배우게 됩니다. 모델에서 views를 introduce하는 방법. 계산된 값(computed properties)은 Mobx computed fields에 의해 작동. reaction 처럼 MST를 Mobx 유틸리티와 결합(combine)하는 방법 WhishList 모델에 총 가격(totalPrice) 필드를 추가합니다. src/models/WhishList.js 12345const WishList = types .model(｛ items: types.optional(types.array(WishListItem), []), totalPrice: types.number, // add here ｝) 하지만 이렇게 사용하면 WishList 모델이 변경될 때마다 totalPrice를 매번 계산해야합니다. 그래서 다음과 같이 views를 사용합니다. views 이미 계산된 값을 캐싱합니다. 그래서 item이 추가되거나 price 가 변경되지 않으면 totalPrice를 다시 계산하지 않고 캐싱하고 있는 값을 리턴합니다. 12345678910export const WishList = types .model(｛ items: types.optional(types.array(WishListItem), []) // totalPrice: types.number, ｝) .views(self =&gt; (｛ get totalPrice() ｛ return self.items.reduce((sum, entry) =&gt; sum + entry.price, 0); ｝ ｝)) 모델의 view 테스트 하기 다음과 같이 WhishList.test.js에 테스트 케이스를 작성합니다. src/models/WhishList.test.js 12345678910111213141516it(\"can calculate the total price of a wishlist\", () =&gt; ｛ const list = WishList.create(｛ items: [ ｛ name: \"Chesterton\", price: 7.35 ｝, ｛ name: \"Book of G.K. Chesterton\", price: 349.95 ｝ ] ｝); expect(list.totalPrice).toBe(357.3);｝); reaction 사용하여 모델의 view 테스트 하기 mobx에서 제공하는 reaction 유틸은 모델의 데이터 변화를 감지합니다. 모델에 변화가 발생하였을때 totalPrice 값의 변화를 살펴봅시다. 12345678910111213141516import ｛ reaction ｝ from 'mobx';it(\"can calculate the total price of a wishlist\", () =&gt; ｛ // ... let changed = 0; // totalPrice 변화가 발생하면 changed 증가 reaction(() =&gt; list.totalPrice, () =&gt; changed++); expect(changed).toBe(0); // 변화 없음 console.log(list.totalPrice); list.items[0].changeName(\"Test\"); // 이름 변경 expect(changed).toBe(0); // 변화 없음 list.items[0].changePrice(10); // 가격 변경 expect(changed).toBe(1); // 계산됨｝); 위 테스트를 수행해보면 price 값에 변화가 발생하였을때만, totalPrice가 동작하는 것을 확인할 수 있습니다. 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React] Mobx-state-tree 학습하기 #3 : Snapshots 또는  Patches를 Recording하여 mobx-state-tree 모델 테스트하기","slug":"/zzan/@anpigon/react-mobx-state-tree-3-snapshots-patches-recording-mobx-state-tree","date":"2019-08-19T04:55:36.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/zzan/@anpigon/react-mobx-state-tree-3-snapshots-patches-recording-mobx-state-tree/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-mobx-state-tree-3-snapshots-patches-recording-mobx-state-tree/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #2 : Mobx-state-tree 모델에서 Actions을 사용하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다.","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #2 : Mobx-state-tree 모델에서 Actions을 사용하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree Test mobx-state-tree Models by Recording Snapshots or Patches 강의 링크: https://egghead.io/lessons/react-test-mobx-state-tree-models-by-recording-snapshots-or-patches 3번째 레슨입니다. 모델을 테스트하는 것은 매우 간단합니다. MST는 state가 어떻게 변하는지 정확하게 추적 할 수 있는 도구를 제공합니다. snapshots, 액션 호출 또는 patches를 추적하여 액션이 올바르게 작동하는 지를 확인 할 수 있습니다. 우리는 다음을 배우게 됩니다. getSnapshot를 사용하여 state의 immutable한 snapshots 얻기 onSnapshot을 사용하여 snapshots 기록하기 onPatch를 사용하여 시간의 흐름에 따른 변화을 저장하고 테스트하기 Jest의 snapshots 테스트 기능을 사용하여 snapshots과 patches 검증하기 That MST can infer the type of a snapshot for you getSnapshot 함수를 사용하여 테스트 하기 Model의 전체 속성을 테스트하기 위해서 getSnapshot 함수를 사용합니다. getSnapshot는 모델의 전체 트리 상태를 immutable하고 순수한 JSON 데이터로 만들어줍니다. 테스트 코드는 다음과 같이 작성합니다. 여기에 추가 설명이 있습니다. src/models/WhishList.test.js 123456789101112131415161718192021import ｛ getSnapshot ｝ from 'mobx-state-tree';it(\"can add new items\", () =&gt; ｛ const list = WishList.create(); list.add( WishListItem.create(｛ name: \"Chesterton\", price: 10 ｝) ); expect(getSnapshot(list)).toEqual(｛ items: [ ｛ name: \"Book of G.K. Chesterton\", price: 10, image: \"\" ｝ ] ｝);｝); 그리고 toMatchSnapshot 함수를 사용하면 스냅샷을 기록합니다. 123456it(\"can add new items\", () =&gt; ｛ const list = WishList.create(); // ... expect(getSnapshot(list)).toMatchSnapshot();｝); 위 테스트를 실행하면 다음과 같이 __snapshots__ 폴더에 스냅샷 파일이 생성됩니다. onSnapshot 함수를 사용하여 테스트하기 onSnapshot 함수를 사용하여 모델이 변경될 때마다 스냅샷을 states에 저장합니다. 그리고 toMatchSnapshot 함수를 사용하여 스냅샷이 어떻게 변화 했는지 기록합니다. 1234567891011121314import ｛ getSnapshot, onSnapshot ｝ from \"mobx-state-tree\";it(\"can add new items\", () =&gt; ｛ const list = WishList.create(); const states = []; onSnapshot(list, snapshot =&gt; ｛ states.push(snapshot); ｝); //... expect(states).toMatchSnapshot();｝ 테스트를 수행하고 나서 스냅샷 기록을 보면 스냅샵이 어떻게 바뀌었는지를 살펴볼 수 있습니다. onPatch 함수를 사용하여 테스트하기 123456789101112131415161718192021import ｛ getSnapshot, onSnapshot, onPatch ｝ from \"mobx-state-tree\";it(\"can add new items - 2\", () =&gt; ｛ const list = WishList.create(); const patches = []; onPatch(list, patch =&gt; ｛ patches.push(patch); ｝) list.add( WishListItem.create(｛ name: \"Chesterton\", price: 10 ｝) ); list.items[0].changeName(\"Book of G.K. Chesterton\"); expect(patches).toMatchSnapshot();｝); onPatch 함수를 사용한 테스트를 수행하고 나서 기록을 보면 모델의 변화에 대해서 살펴볼 수 있습니다. 어떤 작업을 수행했는지, 몇번째 항목의 값이 어떻게 변경되었는지를 확인 할 수 있습니다. 오늘의 학습 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #3 : React Native Firebase SDK 사용하기","slug":"/zzan/@anpigon/react-native-3-react-native-firebase-sdk","date":"2019-08-18T09:27:45.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/zzan/@anpigon/react-native-3-react-native-firebase-sdk/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-3-react-native-firebase-sdk/","excerpt":"이전 글 &quot;[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #2&quot;에서 이어지는 내용입니다.이번에는 리액트 네이티브에 Firebase SDK를 설정합니다. Firebase에서는 리액트 네이티브를 공식 지원하지 않기 때문에 오픈소스인 React Native Firebase 모듈을 사용합니다.","text":"이전 글 &quot;[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #2&quot;에서 이어지는 내용입니다.이번에는 리액트 네이티브에 Firebase SDK를 설정합니다. Firebase에서는 리액트 네이티브를 공식 지원하지 않기 때문에 오픈소스인 React Native Firebase 모듈을 사용합니다. https://rnfirebase.io/ https://github.com/invertase/react-native-firebase React Native Firebase는 현재 v6.0까지 나와있습니다. 하지만 최신 안정 릴리스(v5.3.x)를 사용하기를 권장합니다. 그리고 처음 시작하는 사용자는 React Native Firebase 스타터 키트를 사용해서 프로젝트를 생성해도 됩니다. 스타터 키트에는 Firebase 연동에 필요한 모든 설정이 미리 되어 있습니다. 아래 설치 방법은 React Native Firebase 가이드 문서를 보고 진행합니다. react-native-firebase 설치하기 1yarn add react-native-firebase 그리고 Firebase 콘솔에 접속합니다. App Project를 생성하고 Firebase &gt; 설정(Settings) &gt; 일반 &gt; 내앱 메뉴로 이동합니다. 그리고 안드로이드앱을 선택합니다. Android 패키지 이름을 입력합니다. 패키지 이름은 android/app/build.gradle 또는 android/app/src/main/AndroidManifest.xml 파일에서 확인 가능합니다. 그다음 화면에서 google-service.json 파일을 다운로드 합니다. 그리고 그 파일을 android/app/google-services.json 경로에 복사합니다. 안내 페이지의 설명을 따라서 진행하면 됩니다. 그다음 안내 페이지 설명에 따라 소스 코드에 Firebase SDK를 설정합니다. 다음 파일에 아래 내용을 추가합니다. android/build.gradle 1234567buildscript ｛ dependencies ｛ ... // Add this line classpath 'com.google.gms:google-services:4.2.0' ｝｝ `android/app/build.gradle` 1234567dependencies ｛ // Add this line implementation 'com.google.firebase:firebase-core:17.0.0'｝...// Add to the bottom of the fileapply plugin: 'com.google.gms.google-services' 이 화면이 보이면 앱을 빌드하고 실행합니다. 앱이 실행되면 다음 화면으로 자동 이동합니다. 하지만 이 단계 건너뛰기 를 선택해도됩니다. 설정이 완료하고 나면 콘솔에 Android 앱이 추가된 것을 확인할 수 있습니다. 그리고 google-service.json 파일은 언제든지 다시 다운로드 할 수 있습니다. 리액트 네이티브에서는 다음과 같이 사용합니다. 12345678import firebase from 'react-native-firebase';//... const firebaseAuth = await firebase .auth() .createUserWithEmailAndPassword(email, secret); console.log('firebaseAuth', firebaseAuth); Firebase를 연동하여 모바일앱을 개발해보고 싶은 초보 개발자에게 매우 좋은 튜토리얼이 있습니다. 간단한 TO-DO List를 관리하는 앱입니다. 쉽게 따라서 만들 수 있을 것 같습니다. Getting started with Cloud Firestore on React Native 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"카카오 로그인","slug":"카카오-로그인","permalink":"https://anpigon.github.io/tags/카카오-로그인/"}],"author":"anpigon"},{"title":"[React]  Mobx-state-tree 학습하기 #2 : Mobx-state-tree 모델에서 Actions을 사용하기","slug":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-2","date":"2019-08-17T17:26:39.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-2/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-2/","excerpt":"이전글 &quot;[React] Mobx-state-tree 학습하기 #1 : Mobx-state-tree를 사용해서 Reat State 관리하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ","text":"이전글 &quot;[React] Mobx-state-tree 학습하기 #1 : Mobx-state-tree를 사용해서 Reat State 관리하기&quot;에서 이어지는 내용입니다. 참고로 이 포스팅은 제가 학습한 내용을 노트에 정리하듯이 기록하여 올리는 글이기 때문에 보팅 안해주셔서 됩니다. 많은 분들이 코딩에 흥미를 느꼈으면 좋겠습니다. ㅋ 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree 2번째 레슨입니다. Model의 데이터를 수정하기 위해서는 actions를 정의하고 사용해야 합니다. 우리는 다음을 배우게 됩니다. models에 actions을 정의하는 방법 self를 사용하여 문제를 해결하는 방법 Models은 오직 actions에서만 수정할 수 있는 읽기 전용입니다. Models에 Actions 정의하기 WhishList 모델에 changeName() actions를 정의합니다. src/models/WhishList.js 123456789101112const WishListItem = types .model(｛ // ... ｝) .actions(self =&gt; ｛ function changeName(newName) ｛ self.name = newName ｝ return ｛ changeName ｝｝); actions에 changeName() 함수를 입력하고 그 함수를 return 합니다. ES6 Syntax를 사용하면 다음과 같이 코드를 더 간단하게 작성할 수 있습니다. 123456789const WishListItem = types .model(｛ // ... ｝) .actions(self =&gt; (｛ changeName(newName) ｛ self.name = newName; ｝ ｝)); 그다음 나머지 changePrice(), changeImage() actions도 추가로 입력합니다. 123456789101112131415const WishListItem = types .model(｛ // ... ｝) .actions(self =&gt; (｛ changeName(newName) ｛ self.name = newName; ｝, changePrice(newPrice) ｛ self.price = newPrice; ｝, changeImage(newImage) ｛ self.image = newImage; ｝ ｝)); 그리고 WishList 모델에도 add() 액션을 정의합니다. 123456789const WishList = types.model(｛ items: types.optional(types.array(WishListItem), [])｝).actions(self =&gt; (｛ add(item) ｛ self.items.push(item); ｝｝));` Actions 테스트 하기 테스트 파일에 다음을 입력하고 테스트 합니다. src/models/WhishList.test.js 12345678910111213141516it(\"can add new items\", () =&gt; ｛ // WishList 모델 생 const list = WishList.create(); // WishList에 아이템 추가 list.add( WishListItem.create(｛ name: \"Chesterton\", price: 10 ｝) ); expect(list.items.length).toBe(1); // 리스트 길이는 1 expect(list.items[0].name).toBe(\"Chesterton\"); // 첫번째 항목이 이름은 Chesterton list.items[0].changeName(\"Book of G.K. Chesterton\"); 첫번째 항목이 이름 수정 expect(list.items[0].name).toBe(\"Book of G.K. Chesterton\"); 첫번째 항목이 이름은 Book of G.K. Chesterton｝); 오늘 수업 끝. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"스팀짱 지갑에 업데이트된 기능을 알려드립니다.","slug":"/zzan/@anpigon/5n7jrw","date":"2019-08-17T13:15:18.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/5n7jrw/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/5n7jrw/","excerpt":"안녕하세요. 안피곤입니다.ZZAN 지갑에 추가한 기능이 적용된 것을 이제 발견했습니다. 어제 작업해서 올렸는데 기쁘게도 빠르게 적용되었네요. ㅎㅎZZAN 지갑 관련하여 업데이트된 기능에 대해서 &quot;스팀짱의 유용한 툴 장착에 대한 공지&quot;와 &quot;[ZZAN] 촛불 잔치를 벌려보자, 촛불 잔치야~ 25 / 스팀짱의 지갑을 보여주세요~&quot;에서도 공지한바 있습니다. 여기에 업데이트된 기능에 대해서 조금더 설명을 하려고 글을 씁니다. 사실은 보팅 받으려고 글을 씁니다. ㅎㅎ","text":"안녕하세요. 안피곤입니다.ZZAN 지갑에 추가한 기능이 적용된 것을 이제 발견했습니다. 어제 작업해서 올렸는데 기쁘게도 빠르게 적용되었네요. ㅎㅎZZAN 지갑 관련하여 업데이트된 기능에 대해서 &quot;스팀짱의 유용한 툴 장착에 대한 공지&quot;와 &quot;[ZZAN] 촛불 잔치를 벌려보자, 촛불 잔치야~ 25 / 스팀짱의 지갑을 보여주세요~&quot;에서도 공지한바 있습니다. 여기에 업데이트된 기능에 대해서 조금더 설명을 하려고 글을 씁니다. 사실은 보팅 받으려고 글을 씁니다. ㅎㅎ 이제 스팀짱 지갑에서 ZZAN, ZZAN POWER, STEEM, STEEM POWER, STEEM DOLLARS, Steem Engine Token, SNAX Token 잔액 확인이 가능합니다. 클레임 가능한 토큰은 ZZAN 색상으로 표시됩니다. 토큰을 누르면 클레임을 요청할 수 있습니다. 그리고 토큰에 마우스를 올리면 SCOT API에서 가져온 정보를 모두 보여주고 있습니다. 스팀엔진 거래소 이동 메뉴 추가 ZZAN 드롭다운 메뉴에서 거래소를 선택하면 스팀엔진 거래소로 이동합니다. 사실 이 기능은 제가 필요해서 넣었습니다. (잔액 확인하고 나서 바로 거래소에서 거래하고 싶어서…) 많은 이용 부탁드립니다. ㅎㅎ 스팀 지갑, 스팀 거래소 이동 ZZAN 지갑에서 아직은 스팀, 스팀달러, 스팀파워 송금 기능이 안됩니다. 구현하려고 보니 작업량 많아서 일단 기능 구현을 미래의 나에게 미뤘습니다. 지금은 잔액을 누르면 스팀 지갑으로 이동하합니다. 그래서 ZZAN 지갑에서는 스팀, 스팀달러, 스팀파워 잔액 확인만 가능합니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #2","slug":"/zan/@anpigon/grar9-react-native-2","date":"2019-08-17T10:31:06.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/zan/@anpigon/grar9-react-native-2/","link":"","permalink":"https://anpigon.github.io/zan/@anpigon/grar9-react-native-2/","excerpt":"이전 글 &quot;[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #1&quot;에서 이어지는 내용입니다.카카오톡 로그인으로 스팀잇을 사용하기 위해서는 백엔드 서버가 필요합니다.![](https://steemitimages.com/0x200/https://files.steempeak.com/file/steempeak/anpigon/Fw3GT9H9-social.png)","text":"이전 글 &quot;[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #1&quot;에서 이어지는 내용입니다.카카오톡 로그인으로 스팀잇을 사용하기 위해서는 백엔드 서버가 필요합니다.![](https://steemitimages.com/0x200/https://files.steempeak.com/file/steempeak/anpigon/Fw3GT9H9-social.png) ___ 처음에는 서버 비용과 백엔드(back-end) 개발을 최소하기 위해서 Google Firebase 서비스만 사용해서 개발하려고 생각을 했습니다. 그리고 Google Firebase에서는 다음 서비스를 무료로 제공합니다. Authentication: 10k/월 Cloud Firestore: 총 용량 1GiB, 대역폭 10GiB/월, 쓰기 20K/일, 읽기 50K/일, 삭제 20K/일 Cloud Functions: 호출 125K/월, GB-초 40K/월, CPU-초 40K/월, 발신 네트워킹는 구글 서비스만 가능 Cloud Messaging (FCM): 무료 Storage: 총 용량 5GB, 다운로드 크기 1GB/일, 업로드 작업 20K/일, 다운로드 작업 50K/일 기타 등등 그리고 [Firebase 사이트]에서 더 많은 무료 서비스를 확인 할 수 있습니다. 하지만 무료 버전의 Cloud Functions에서는 구글 서비스만 연동 가능합니다. 그래서 외부 서비스인 카카오톡 API 서비스나 스팀 API를 연동해서 서비스하는 것이 불가능합니다.ㅠ 사실 유료 서비스를 이용하면 가능합니다. 하지만 우리는 가난한 개발자이므로 무료 서비스를 최대한 활용해서 서비스를 만들어보겠습니다. ㅎㅎ Firebase와 함께 GCP 무료 서비스도 사용하기로 결정 했습니다. 이제는 Firebase와 GCP는 같은 서비스라고 봐도 무방합니다. 그리고 GCP에서 제공하는 서비스가 Firebase보다 훨씬 많습니다. Firebase에는 사용자 인증과 Push 서비스가 있습니다. ![](https://steemitimages.com/0x200/https://files.steempeak.com/file/steempeak/anpigon/wZ8wVqUg-99A5D4405B78FDBB33.png) GCP에 대해서 매우 잘 설명한 글이 있습니다. 아래 이정운님이 작성한 글을 읽어보세요. [GCP]가난한 개발자를 위한 GCP free tier 활용 방법 1/2 [GCP]가난한 개발자를 위한 GCP free tier 활용 방법 2/2 GCP는 Firebase보다 훨씬 더 많은 서비스를 제공합니다. 그리고 GCP도 당연히 무료 서비스들을 제공합니다. 구글은 매우 관대합니다. 하지만 아래 서비스를 사용하면 구글 서비스에 완전 종속된 앱이 되어버립니다. 출처: https://cloud.google.com/free/docs/gcp-free-tier#always-free Firebase Authentication 사용하기 Firebase Authentication 에는 다음 인증 방식을 제공합니다. 대부분의 인증이 있는데 카카오톡 인증이 없는 것이 많이 아쉽습니다. 저는 다음과 같은 방법으로 카카오톡 인증을 구현해 볼까 합니다. 참고로 카카오톡은 클라이언트 인증과 서버 인증이 연동이 안되고 따로 동작합니다. 만약 서버에서 카카오톡 인증을 처리하게 되면, 모바일앱에서는 웹뷰에서 로그인 하는 형태로 구현됩니다. 이런 인증방식은 제가 싫어합니다.ㅋ 그래서 모바일 SDK를 사용하여 카카오톡앱 연동하여 간편하게 인증하고, 발급 받은 액세스 토큰을 서버에서 다시 검증하여 사용자 등록 및 인증을 처리하고 있습니다. 덕분에 시퀀스 다이어그램이 매우 복잡해졌습니다. ㅠ 무료 버전의 Cloud Functions에서 외부 API 연동이 안되기 때문에 어쩔 수 없이 **GAE(Google App Engine)**를 사용했습니다. 그래서 카카오톡 API나 Steem API 처럼 외부 연동이 필요한 부분은 GAE에서 처리합니다. 그리고 사용자 인증 및 관리는 Firebase Authentication에서 모두 관리됩니다. 덕분에 사용자 가입 및 인증은 제가 따로 더 구현할 것이 없습니다. 그리고 서비스를 이용하는데 필요한 사용자 추가 데이터는 Firestore에 저장합니다. 그리고 외부 연동이 필요 없는 단순한 함수는 Cloud Functions를 사용할 생각입니다. 무료 제공 임계치를 넘으면 비용이 발생하기 때문에, 무료 서비스를 골고루 사용할 생각입니다. 서버에서 Firease Admin SDK 사용하기 서버에서 Firebase 인증(Auth)과 Firestore를 사용하기 위해서 다음 절차를 진행합니다. Firebase Console 설정 페이지에서 [새 비공개 키 생성]을 눌러 키를 생성합니다. 그럼 json 파일이 다운로드 됩니다. json 파일은 한 번만 다운로드 가능하기 때문에 분실하면 다시 생성하여 다운로드해야 합니다. 그리고 해당 json 파일은 반드시 서버에서만 사용해야합니다. 위에서 다운로드 받은 json 파일을 사용하여 firebaseAdmin를 초기화 합니다. 이제 서버에서는 firebase의 auth와 firestore를 사용할 수 있습니다. (Firebase Admin SDK에 대한 자세한 설명은 공식 사이트를 참고하세요.) 백엔드 API 서버는 Apollo GraphQL를 사용하여 구현했습니다. Apollo GraphQL를 사용하면 백엔드나 클라이언트를 좀 더 빠르고 쉽게 개발할 수 있습니다. 게다가 API Console 페이지까지 자동으로 생성해줍니다. Apollo GraphQL를 사용해서 개발하면 시간을 많이 절약할 수 있습니다. 지금은 API 서버에 **“사용자 등록(registerUser)”**과 “글 조회(getPosts)” 기능만 구현되어 있습니다. (내용이 너무 길어지는 것 같아서 다음 글에서 이어서 작성하겠습니다.) 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"카카오 로그인","slug":"카카오-로그인","permalink":"https://anpigon.github.io/tags/카카오-로그인/"}],"author":"anpigon"},{"title":"[React]  Mobx-state-tree 학습하기 #1 : Mobx-state-tree를 사용해서 Reat State 관리하기","slug":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-1","date":"2019-08-16T11:38:48.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-1/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-manage-application-state-with-mobx-state-tree-1/","excerpt":"안녕하세요. 안피곤입니다.저는 최근에 mobx-state-tree를 열심히 공부하고 있습니다. 제이콥님이 알려주신 Mobx는 너무 매력적입니다. 그래서 학습 중이던 Redux, Redux-Thunk, Redux-Saga를 그만두고, Mobx 동영상 강의를 찾아서 열심히 배우고 있습니다. 개발자에게 기술 공부는 끝이 없습니다. 기술 트렌드는 매년 바뀝니다. 그리고 유투브에는 새로운 무료 강의가 계속 업로드되고 있습니다.","text":"안녕하세요. 안피곤입니다.저는 최근에 mobx-state-tree를 열심히 공부하고 있습니다. 제이콥님이 알려주신 Mobx는 너무 매력적입니다. 그래서 학습 중이던 Redux, Redux-Thunk, Redux-Saga를 그만두고, Mobx 동영상 강의를 찾아서 열심히 배우고 있습니다. 개발자에게 기술 공부는 끝이 없습니다. 기술 트렌드는 매년 바뀝니다. 그리고 유투브에는 새로운 무료 강의가 계속 업로드되고 있습니다. 저는 작년부터 Front-End, Node.js, React 세계에 발 담그면서 새로운 기술을 계속 공부하고 있습니다. 매일매일 새로운 기술이 쏟아져 나오고 있고, 새로운 기술들은 또 저에게 신선함을 안겨줍니다. 새로운 기술을 처음 배울때는 어렵지만, 이 기술에 익숙해지고 나면 그 다음 개발할 때는 매우 편합니다. 출처: https://egghead.io/courses/manage-application-state-with-mobx-state-tree 이 레슨은 위시리스트 앱을 만드는 과정을 안내합니다. 그리고 우리는 mobx-state-tree(MST)의 핵심 모델을 살펴볼 것입니다. 모델(Model)은 상태(state)의 형태(shape)을 정의하고 타입 유효성 검사를 수행합니다. 우리는 다음을 배우게 됩니다. types.Model를 사용하여 모델을 정의하기 Model.create를 사용하여 JSON에서 모델 인스턴스화하기 Primitive types : types.string 와 types.number Type inference for primitive types types.array types.optional Composing models into a model tree mobx-state-tree(MST) Models를 사용하여 어플리케이션 도메인 정의하기 wishlist 프로젝트 생성하기 우선 React App 프로젝트를 생성합니다. 1$ npx create-react-app wishlist (npx는 npm 5.2+ 이상 부터 사용가능합니다. 이전 버전을 사용중이라면 “instructions for older npm versions” 문서를 참고하세요.) 아래와 같이 필요한 모듈이 설치되면서 프로젝트가 생성됩니다. Mobx 모듈 설치하기 다음 명령어를 입력하여 mobx와 mobx-state-tree 모듈을 설치합니다. 1$ yarn add mobx mobx-react mobx-state-tree 아래 화면처럼 설치가 진행됩니다. model 생성하기 ./src 폴더 아래에 model 폴더를 생성합니다. 그리고 WhishList.js 파일을 생성합니다. WhishList.js 파일에는 다음 내용을 입력합니다. 123456789101112131415// src/models/WhishList.jsimport ｛ types ｝ from \"mobx-state-tree\";// WishListItem 모델 정의export const WishListItem = types.model(｛ name: types.string, price: types.number, image: types.optional(types.string, \"\"),｝);// WishList 모델 정의export const WishList = types.model(｛ items: types.optional(types.array(WishListItem), [])｝); WishListItem의 image 속성은 optional이며 기본값은 &quot;&quot;입니다. 그리고 image를 아래와 같이 입력할 수도 있습니다. 1234export const WishListItem = types.model(｛ // ... image: \"\"｝); WhishList 모델 테스트 하기 WhishList.test.js 파일을 생성합니다. WhishList.test.js 파일에는 다음 내용을 입력합니다. 12345678910111213141516171819202122232425import ｛ WishListItem, WishList ｝ from \"./WhishList\";it(\"can create a instance of a model\", () =&gt; ｛ const item = WishListItem.create(｛ name: \"Reat Native - anpigon\", price: 28.73 ｝); expect(item.price).toBe(28.73); expect(item.image).toBe(\"\");｝);it(\"can create a wishlist\", () =&gt; ｛ const list = WishList.create(｛ items: [ ｛ name: \"Reat Native - anpigon\", price: 28.73 ｝ ] ｝); expect(list.items.length).toBe(1); expect(list.items[0].price).toBe(28.73);｝); 테스트 하기 위해서 `yarn test`를 입력합니다. 테스트에 성공하면 다음과 같은 메세지가 콘솔에 출력됩니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"},{"name":"Mobx","slug":"개발-이야기/react/mobx","permalink":"https://anpigon.github.io/categories/개발-이야기/react/mobx/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"블록체인 게임 ROR 알파 테스터 후기","slug":"/zzan/@anpigon/ror","date":"2019-08-15T16:15:09.000Z","updated":"2019-11-11T13:41:49.860Z","comments":true,"path":"/zzan/@anpigon/ror/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/ror/","excerpt":"저도 “스티미 AI - 봄” 카드를 획득했습니다. 저는 출퇴근하면서 모바일에서 게임을 즐겼습니다. 사실 모바일에서는 게임을 하기 힘들었습니다. 아이템 드래그하다가 잘못하면 페이지가 새로 고침되면서 로그인 창으로 튕깁니다. ㅠ그리고 알파 버전이라서 그런지 즐길 수 있는 콘텐츠가 많지 않았습니다. 용병을 사냥터에 사냥 보내고, 사냥 끝나면 수집품을 상점에 팔고, 카드 조합해서 상위 카드를 얻고, 2주 동안 이 작업만 무한 반복했습니다. 초반에는 재료 수집도 하고 장비도 생산했으나, 필요성을 못느껴서 그냥 용병 렙업만 했습니다. 오직 스티미 AI 카드를 얻겠다는 집녑으로 게임을 즐겼던 것 같습니다.","text":"저도 “스티미 AI - 봄” 카드를 획득했습니다. 저는 출퇴근하면서 모바일에서 게임을 즐겼습니다. 사실 모바일에서는 게임을 하기 힘들었습니다. 아이템 드래그하다가 잘못하면 페이지가 새로 고침되면서 로그인 창으로 튕깁니다. ㅠ그리고 알파 버전이라서 그런지 즐길 수 있는 콘텐츠가 많지 않았습니다. 용병을 사냥터에 사냥 보내고, 사냥 끝나면 수집품을 상점에 팔고, 카드 조합해서 상위 카드를 얻고, 2주 동안 이 작업만 무한 반복했습니다. 초반에는 재료 수집도 하고 장비도 생산했으나, 필요성을 못느껴서 그냥 용병 렙업만 했습니다. 오직 스티미 AI 카드를 얻겠다는 집녑으로 게임을 즐겼던 것 같습니다. 사냥터에서 용병을 레벨 20까지 만들고, 그 레벨 20 용병 카드 4개를 조합하여 레어 카드를 얻고, 다시 레벨 20인 레어 카드 4개를 조합하면, **“레나 카드”**를 얻습니다. 그리고 레벨 20 레나 카드 4개를 조합하면 최종 카드인 **“스티미 AI”**를 얻을 수 있습니다. 스티미 AI 카드 한 장을 얻기까지 약 2주가 걸렸습니다. 한동안 ROR 하면서 카드 모으고 조합하는 재미가 있었네요. ㅋ ROR팀 화이팅입니다~!","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"zzan","slug":"zzan","permalink":"https://anpigon.github.io/tags/zzan/"},{"name":"game","slug":"game","permalink":"https://anpigon.github.io/tags/game/"},{"name":"iv","slug":"iv","permalink":"https://anpigon.github.io/tags/iv/"},{"name":"liv","slug":"liv","permalink":"https://anpigon.github.io/tags/liv/"},{"name":"palnet","slug":"palnet","permalink":"https://anpigon.github.io/tags/palnet/"},{"name":"neoxian","slug":"neoxian","permalink":"https://anpigon.github.io/tags/neoxian/"},{"name":"busy","slug":"busy","permalink":"https://anpigon.github.io/tags/busy/"},{"name":"jjm","slug":"jjm","permalink":"https://anpigon.github.io/tags/jjm/"},{"name":"kr","slug":"kr","permalink":"https://anpigon.github.io/tags/kr/"}],"author":"anpigon"},{"title":"[북클럽] 지금 이순간 나와 가장 가까운 곳에 있는 책은?","slug":"/zzan/@anpigon/krwfw","date":"2019-08-14T12:53:24.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/krwfw/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/krwfw/","excerpt":"","text":"스짱 북클럽 이벤트에 참여합니다.지금 제 책상에는 책 3권이 올려져 있습니다. 백민서 작가의《헤밍웨이》, 김영하 작가의《보다》 그리고 이현우 작가의《모르면 호구 되는 경제상식》 이 있습니다.아직 다 읽지는 못했어요. ㅎㅎ 열심히 독서 중입니다. 스짱 북클럽 이벤트 | 지금 이순간 나와 가장 가까운 곳에 있는 책 표지를 찍어서 올려주세요","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"}],"author":"anpigon"},{"title":"[React Native] MobX State Tree 학습하기 #3","slug":"/zzan/@anpigon/react-native-mobx-state-tree-3","date":"2019-08-14T04:32:45.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/zzan/@anpigon/react-native-mobx-state-tree-3/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-mobx-state-tree-3/","excerpt":"https://img.youtube.com/vi/snBvYS6eC2E/mqdefault.jpg이전글 &quot;[React Native] MobX State Tree 학습하기 #2&quot; 에서 이어지는 내용입니다. 시리즈 [React Native] MobX State Tree 학습하기 #1 [React Native] MobX State Tree 학습하기 #2 [React Native] MobX State Tree 학습하기 #3","text":"https://img.youtube.com/vi/snBvYS6eC2E/mqdefault.jpg이전글 &quot;[React Native] MobX State Tree 학습하기 #2&quot; 에서 이어지는 내용입니다. 시리즈 [React Native] MobX State Tree 학습하기 #1 [React Native] MobX State Tree 학습하기 #2 [React Native] MobX State Tree 학습하기 #3 본 포스팅은 아래 강의를 보면서 정리한 노트입니다. 이번 포스팅이 마지막입니다. https://www.youtube.com/watch?v=snBvYS6eC2E Book 읽음(read) 표시 기능 구현하기 해당 도서(book)에 대한 읽음 표시를 Yes/No 로 토글 할 수 있는 기능을 구현합니다. BookStore에 toogleRead 액션 등록하기 BookStore.js 파일을 수정합니다. 그리고 Book에 toogleRead 액션을 추가합니다. toogleRead 은 해당 Book의 read 값을 true/false 로 토글하는 액션입니다. 1234567891011const Book = types .model('Book', ｛ title: types.string, author: types.string, read: false, ｝) .actions(self =&gt; (｛ toggleRead() ｛ self.read = !self.read; ｝, ｝)); 화면에 toggleRead 기능 붙이기 App.js 파일를 수정합니다. 그리고 App 클래스에 toggleRead 함수를 추가합니다. toggleRead 함수에서는 BookStore의 toogleRead 액션을 실행합니다. 123456class App extends React.Component ｛ ... toggleRead = book =&gt; ｛ book.toggleRead(); ｝; 그다음 render에 Read 여부를 출력할 Text 컴포넌트를 추가합니다. 그리고 Read를 출력하는 &lt;Text&gt; 컴포넌트의 onPress 이벤트에 toggleRead 함수를 등록합니다. 이제 Read 텍스트를 누를때마다 Read 값이 바뀌게 됩니다. 1234567891011121314 render() ｛ ... return ( ... ｛books.map((book, index) =&gt; ( &lt;React.Fragment key=｛index｝&gt; &lt;Text&gt;｛book.title｝&lt;/Text&gt; &lt;Text onPress=｛() =&gt; this.toggleRead(book)｝&gt; Read: ｛book.read ? 'Yes' : 'No'｝ &lt;/Text&gt; &lt;/React.Fragment&gt; ))｝... 실행결과 화면에서 Read를 누르면 Yes 또는 No 값으로 변경됩니다. Book 삭제(delete) 기능 구현하기 Book을 등록을 했으니 이제 삭제 기능을 구현합니다. BookStore에 removeBook 액션 등록하기 BookStore.js 파일을 수정합니다. 그리고 BookStore에 removeBook 액션을 추가합니다. removeBook 액션은 해당 Book을 BookStore에서 제거합니다. 12345678910111213const BookStore = types .model('Books', ｛ books: types.array(Book), ｝) .actions(self =&gt; (｛ addBook(book) ｛ self.books.push(book); ｝, removeBook(book) ｛ destroy(book); ｝, ｝)) ... 화면에 removeBook 기능 붙이기 App.js 파일를 수정합니다. App 클래스에 delete 함수를 추가합니다. delete 함수에서는 BookStore의 removeBook 액션을 실행합니다. 12345class App extends React.Component ｛ ... delete = book =&gt; ｛ BookStore.removeBook(book); ｝; 그다음 Text 컴포넌트를 사용하여 render에 삭제 버튼을 추가합니다. 그리고 삭제 버튼인 &lt;Text&gt; 컴포넌트의 onPress 이벤트에 delete 함수를 등록합니다. 이제 Delete 텍스트를 누르면 해당 book 데이터가 BookStore에서 삭제됩니다. 123456789｛books.map((book, index) =&gt; ( &lt;React.Fragment key=｛index｝&gt; &lt;Text&gt;｛book.title｝&lt;/Text&gt; &lt;Text onPress=｛() =&gt; this.toogleRead(book)｝&gt; Read: ｛book.read ? 'Yes' : 'No'｝ &lt;/Text&gt; &lt;Text onPress=｛() =&gt; this.delete(book)｝&gt;Delete&lt;/Text&gt; &lt;/React.Fragment&gt;))｝ 실행결과 새로운 Book을 추가합니다. 그리고 해당 Book의 Delete를 누르면 해당 Book이 삭제됩니다. Mobx의 views 속성 사용하기 Mobx에서는 계산된 값(computed values)이나 필터된 값이 필요한 경우, 재렌더링하지 않게 하기 위해 views 속성을 제공합니다. 다음과 같이 사용합니다. BookStore.js 파일을 수정합니다. 그리고 BookStore에 views 속성을 추가합니다. get readBooks 함수는 read==true인 Books 데이터를 리턴합니다. Books 데이터가 바뀌지 않으면 이전에 계산된 값을 바로 리턴합니다. 그리고 booksByAuthor 는 인자값으로 받은 Author에 해당하는 Books를 리턴합니다. 이 함수 또한 Books 데이터가 바뀌지 않으면 재렌더링하지 않습니다. 123456789101112const BookStore = types .model('Books', ｛ books: types.array(Book), ｝) .views(self =&gt; (｛ get readBooks() ｛ return self.books.filter(book =&gt; book.read); ｝, booksByAuthor(author) ｛ return self.books.filter(book =&gt; book.author === author); ｝, ｝)) 위 데이터는 컴포넌트를 사용하지 않고 **Console.log** 에 출력해보겠습니다. 123456class App extends React.Component ｛ ... render() ｛ const ｛ books ｝ = BookStore; console.log('readBooks:', BookStore.readBooks); console.log('booksByAuthor Anpigon:', BookStore.booksByAuthor('Anpigon')); **실행결과** 다음과 같이 Console.log 에서 출력된 값을 확인 할 수 있습니다. 동영상 강의 내용은 여기까지 입니다. 총 20분으로 짧은 강의였지만, 매우 훌륭한 MobX 튜토리얼 강의입니다. 그리고 Redux 사용할때 보다 코딩량이 훨씬 적어서 매우 만족스럽습니다. 하지만 아직 MobX에 대한 이해가 낮아서 다른 강의를 찾아서 좀더 공부 해야겠습니다. Redux와 달리 MobX는 마법처럼 처리해주는 기능이 있어서 이해가 잘안되는 부분이 있습니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[React Native] MobX State Tree 학습하기 #2","slug":"/zzan/@anpigon/react-native-mobx-state-tree-2","date":"2019-08-12T13:25:48.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/zzan/@anpigon/react-native-mobx-state-tree-2/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-mobx-state-tree-2/","excerpt":"https://img.youtube.com/vi/snBvYS6eC2E/mqdefault.jpg이전글 &quot;[React Native] MobX State Tree 학습하기 #1&quot; 에서 이어지는 내용입니다.본 포스팅은 아래 강의를 보면서 정리한 노트입니다. https://www.youtube.com/watch?v=snBvYS6eC2E","text":"https://img.youtube.com/vi/snBvYS6eC2E/mqdefault.jpg이전글 &quot;[React Native] MobX State Tree 학습하기 #1&quot; 에서 이어지는 내용입니다.본 포스팅은 아래 강의를 보면서 정리한 노트입니다. https://www.youtube.com/watch?v=snBvYS6eC2E BookStore에 초기 데이터 등록하기 BookStore.js 파일을 수정합니다. books 배열에 다음과 같이 Book 정보를 입력합니다. 이제 BookStore는 book 데이터 하나를 가지고 생성됩니다. 1234567891011121314const BookStore = types .model('Books', ｛ books: types.array(Book), ｝) .create(｛ books: [ // book 정보 등록 ｛ title: 'Ready Player One', author: 'Ernest Cline', read: true, ｝, ], ｝); 이제 앱을 실행하고 Console 에서 값을 확인해봅니다. Target의 첫번째 항목을 살펴보면, value에 우리가 입력한 Book 데이터가 보입니다. BookStore에 addBook 액션(action) 추가하기 다시 BookStore.js 파일을 수정합니다. 그리고 actions에 addBook 함수를 추가합니다. actions에는 store에서만 호출할 수 있는 private 함수를 생성 할 수 있습니다. 이제 BookStore의 addBook 함수를 호출하면 books 배열에 새로운 book 객체가 추가됩니다. 12345678910111213141516171819const BookStore = types .model('Books', ｛ books: types.array(Book), ｝) // actions 추가 .actions(self =&gt; (｛ addBook(book) ｛ self.books.push(book); ｝, ｝)) .create(｛ books: [ ｛ title: 'Ready Player One', author: 'Ernest Cline', read: true, ｝, ], // 초기 값 ｝); 입력 화면 만들기 App.js 파일을 수정합니다. 그리고 react-native에서 StyleSheet, SafeAreaView, TextInput, Text, Button 컴포넌트를 import 합니다. 1234567import ｛ SafeAreaView, StyleSheet, TextInput, Text, Button｝ from 'react-native'; 그리고 initialState 값을 설정합니다. initialState는 title와 author 속성을 가집니다. 1const initialState = ｛ title: '', author: '' ｝; 그다음 state를 생성합니다. state의 기본값으로는 initialState 를 입력합니다. 그리고 onChangeText 함수와 addBook 함수를 생성합니다. 123456789101112131415161718class App extends React.Component ｛ state = initialState; // TextInput 입력 이벤트 함수 onChangeText = (key, value) =&gt; ｛ this.setState(｛ [key]: value, ｝); ｝; // book 추가하기 함수 addBook = () =&gt; ｛ BookStore.addBook(this.state); this.setState(initialState); ｝; ... 그 다음 화면 UI에 적용할 StyleSheet를 정의합니다. &lt;TextInput&gt; 컴포넌트의 높이는 50, 배경색은 회색 그리고 위아래 여백으로 10을 주었습니다. 1234567const styles = StyleSheet.create(｛ input: ｛ height: 50, backgroundColor: '#ededed', marginVertical: 10, ｝,｝); 그리고 화면에 보여줄 입력 박스(TextInput) 2개와 버튼을 입력합니다. 첫번째 TextInput는 제목(title)를 입력받습니다. 두번째 TextInput는 저자(author)를 입력받습니다. 12345678910111213141516171819class App extends React.Component ｛ ... render() ｛ return ( &lt;SafeAreaView&gt; &lt;TextInput style=｛styles.input｝ value=｛this.state.title｝ onChangeText=｛value =&gt; this.onChangeText('title', value)｝ /&gt; &lt;TextInput style=｛styles.input｝ value=｛this.state.author｝ onChangeText=｛value =&gt; this.onChangeText('author', value)｝ /&gt; &lt;Button title=\"Add Book\" onPress=｛this.addBook｝ /&gt; &lt;/SafeAreaView&gt; );｝; MobX observer 클래스 등록하기 mobx-react에서 observer를 import합니다. 그리고 대상 클래스 바로 위에 어노테이션 @observer를 입력합니다. 123456import ｛ observer ｝ from 'mobx-react';@observerclass App extends React.Component ｛... 그리고 다음은 지금까지 구현한 전체 소스코드입니다. 아래는 결과 화면입니다. 제목과 저자를 입력하고 Add Book를 누르면 아래에 추가된 정보가 표시됩니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"스팀짱에 최근 업데이트된 기능을 소개합니다. (스짱소)","slug":"/zzan/@anpigon/zzan-nitrous-update-1","date":"2019-08-12T06:48:33.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/zzan-nitrous-update-1/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/zzan-nitrous-update-1/","excerpt":"안녕하세요. 안피곤입니다.최근에 스팀짱 커뮤니티에 2가지 기능이 업데이트 되었습니다. 니트러스에는 지난주에 적용되었는데 소개가 늦었습니다. 저자 최근글 10개 보여주기최근 글 보여주기는 원사마님 아이디어를 내고 제안한 기능입니다. 그리고 저도 이 기능이 있으면 좋을 것 같아서 구현했습니다. 개발하면서 UI에 신경을 정말 많이 썼습니다. 그리고 기능 구현에는 eonwarped님의 도움을 받았습니다. 구현하고 보니 매우 만족스럽습니다.","text":"안녕하세요. 안피곤입니다.최근에 스팀짱 커뮤니티에 2가지 기능이 업데이트 되었습니다. 니트러스에는 지난주에 적용되었는데 소개가 늦었습니다. 저자 최근글 10개 보여주기최근 글 보여주기는 원사마님 아이디어를 내고 제안한 기능입니다. 그리고 저도 이 기능이 있으면 좋을 것 같아서 구현했습니다. 개발하면서 UI에 신경을 정말 많이 썼습니다. 그리고 기능 구현에는 eonwarped님의 도움을 받았습니다. 구현하고 보니 매우 만족스럽습니다. 글 본문 하단에 현재 글을 제외하고, 저자가 작성한 글을 최신 순으로 10개를 보여줍니다. 그리고 괄호 안의 숫자는 댓글 수를 나타냅니다. 사용해보면 매우 만족하실 것입니다. 토큰 임대 내역 보기 지갑에서 눈(eye) 모양의 아이콘을 눌러주세요. 임대 내역이 있어야 아이콘이 보입니다. 아래와 같이 임대 내역을 볼 수 있습니다. Delegation Out은 붉은색, Delegation In은 푸른색으로 표시했습니다. 그리고 임대내역 보기는 모든 니트러스에 적용되었습니다. 지금 확인해보세요.ㅎㅎ 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React Native] MobX State Tree 학습하기 #1","slug":"/zzan/@anpigon/react-native-mobx-state-tree-1","date":"2019-08-11T04:18:15.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/zzan/@anpigon/react-native-mobx-state-tree-1/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-mobx-state-tree-1/","excerpt":"이제 여러분은 본 포스팅을 보면서 같이 학습을 하게 됩니다. 그리고 제가 겪은 시행착오나 문제 해결에 시간을 뺏길 필요가 없습니다. 저는 여러분 모두를 앱 개발자로 만들고 싶습니다. 그래서 STEEM 블록체인 기반의 좀 더 다양한 DApp이 출시되었으면 합니다.참고로 SI 프로젝트에 투입된 개발자들과 이야기 해보면 디자인, 음악, 경영학 등 전공이 다양합니다. 생각보다 컴퓨터 전공자들이 적습니다. 다들 코딩을 시작해서 개발자가 된 계기는 비슷합니다. 하다보니... 어쩌다보니... 정신차리고 보니... 회사에서 시켜서... 일부 디자이너는 개발자와 이야기하다가 답답해서...","text":"이제 여러분은 본 포스팅을 보면서 같이 학습을 하게 됩니다. 그리고 제가 겪은 시행착오나 문제 해결에 시간을 뺏길 필요가 없습니다. 저는 여러분 모두를 앱 개발자로 만들고 싶습니다. 그래서 STEEM 블록체인 기반의 좀 더 다양한 DApp이 출시되었으면 합니다.참고로 SI 프로젝트에 투입된 개발자들과 이야기 해보면 디자인, 음악, 경영학 등 전공이 다양합니다. 생각보다 컴퓨터 전공자들이 적습니다. 다들 코딩을 시작해서 개발자가 된 계기는 비슷합니다. 하다보니... 어쩌다보니... 정신차리고 보니... 회사에서 시켜서... 일부 디자이너는 개발자와 이야기하다가 답답해서... 여러분은 스팀잇을 하다보면... 곧 개발자가 될 것 같습니다. 제 생각에는 복잡한 스팀잇 시스템을 이해할 수 있다면, 분명히 코딩에 재능이 있습니다. 지금 바로 시작하세요! ![](https://steemitimages.com/350x0/https://files.steempeak.com/file/steempeak/anpigon/5LN9JYqS-ANPIGON201.png) 이전글 **《[React Native] Redux-Saga 학습하기 #1 #2》**에서는 Redux-Saga 를 학습하면서 포스팅 했습니다. Redux 를 사용하면서 느낀 점을 이전 포스팅에서도 밝혔지만, 비동기 액션 기능 하나 구현하는데 생성하는 파일과 코드량이 무척 많습니다. 저처럼 혼자 개발하는 프로젝트에서는 시간 소모가 커서 매우 비효율적입니다. 그리고 최근에 “React에서 Mobx 경험기 (Redux와 비교기) - 우아한형제들 기술 블로그” 글을 읽었습니다. MobX의 observable를 사용하면 Redux-Saga 미들웨어를 사용하지 않아도 될 것 같습니다. 그리고 Redux 처럼 코딩량도 많지 않을 것 같습니다. 그래서 지금 바로 Redux에서 MobX로 갈아타기로 결정했습니다. 제 귀는 팔랑귀이며 제 마음은 갈대와도 같습니다. 하지만 MobX를 사용하다가 불편하면 다시 Redux로 돌아갈지도 모릅니다. 본 포스팅은 아래 강의를 보면서 정리한 노트입니다. https://www.youtube.com/watch?v=snBvYS6eC2E 의존성 모듈 설치하기 MobX State Tree에 필요한 모듈을 설치합니다. 그리고 MobX State Tree를 사용하기 위해 babel-plugin-transform-decorators-legacy를 설치합니다. 그리고 ES7 decorators babel plugin을 설정합니다. 1$ yarn add mobx mobx-react mobx-state-tree babel-plugin-transform-decorators-legacy 모듈 설치가 완료되면 다음과 같이 package.json에 설치된 것을 확인 할 수 있습니다. 그다음 .babelrc 파일에 babel plugin 설정을 입력합니다. 1234｛ \"presets\": [\"react-native\"], \"plugins\": [\"transform-decorators-legacy\"]｝ MobX State Tree에 Store 생성하기 BookStore.js 파일을 생성합니다. 1234567891011121314151617import ｛ types ｝ from 'mobx-state-tree';const Book = types.model('Book', ｛ title: types.string, author: types.string, read: false,｝);const BookStore = types .model('Books', ｛ books: types.array(Book), ｝) .create(｛ books: [], // 초기 값(빈 배열) ｝);export default BookStore; mobx-state-tree 모듈에서 types를 import 합니다. types은 모델(model)을 정의하고 항목(properties)의 타입을 지정하는데 사용됩니다. 그리고 model에서 create 함수를 사용하여 초기 값(빈 배열)을 전달합니다. 실행 그리고 오류 발생 및 문제 해결하기 실행하니 다음과 같은 에러가 발생했습니다. 그래서 에러 내용 대로 babel-preset-react-native 모듈을 추가로 설치했습니다. 1$ yarn add --dev babel-preset-react-native 이번에는 다른 에러가 발생했습니다. babel-plugin-transform-decorators-legacy 사이트에 가서 확인해보니 Babel 7.x 이상이면 다음과 같이 안내하고 있습니다. @babel/plugin-proposal-decorators 모듈을 설치합니다. 1$ yarn add --dev @babel/plugin-proposal-decorators 그다음 .babelrc 파일에 @babel/plugin-proposal-decorators 플러그인을 추가합니다. 123456｛ \"presets\": [\"react-native\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", ｛ \"legacy\": true ｝] ]｝ 여전히 에러가 발생합니다. 이 오류의 해결 방법은 아래 링크에서 찾았습니다. https://github.com/facebook/react-native/issues/20588#issuecomment-448218111 필요한 의존성 모듈을 설치합니다. 1$ yarn add -dev @babel/plugin-transform-flow-strip-types @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties 그 다음 .babelrc 파일을 다음과 같이 수정합니다. 12345678｛ \"presets\": [\"module:metro-react-native-babel-preset\"], \"plugins\": [ [\"@babel/plugin-transform-flow-strip-types\"], [\"@babel/plugin-proposal-decorators\", ｛ \"legacy\": true｝], [\"@babel/plugin-proposal-class-properties\", ｛ \"loose\": true｝] ]｝ 여전히 같은 에러가 발생하면 cache를 reset 하고 실행해보세요. 1$ react-native start --reset-cache 앱 실행하기 저는 개발할때는 ios 에뮬레이터를 많이 사용합니다. 안드로이드 에뮬레이터보다 가볍고 개발하기 편합니다. $ react-native run-ios 앱을 실행하고 나서 브라우저 Console을 확인하면 우리가 출력한 books가 보입니다. 그런데 Object 형태가 유튜브 강의 내용과 다릅니다. 유튜브 강의가 1년 전임을 감안하면 그 동안 많은 변화가 있었을 것 같습니다. 오류를 해결하면서 학습하다보니 1시간이 금방 지나갔습니다. 그런데 동영상 강의는 5분 밖에 못들었습니다. ㅠ 하지만 오후에는 다른 일정이 있어서 오늘 학습은 여기까지 입니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Mobx","slug":"mobx","permalink":"https://anpigon.github.io/tags/mobx/"},{"name":"Mobx State Tree","slug":"mobx-state-tree","permalink":"https://anpigon.github.io/tags/mobx-state-tree/"}],"author":"anpigon"},{"title":"[북클럽] 만약 무인도에서 한 달을 보내야 한다면 갖고 가고 싶은 책","slug":"/zzan/@anpigon/2gkge4","date":"2019-08-10T15:40:00.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/2gkge4/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/2gkge4/","excerpt":"&quot;스짱 북클럽 이벤트 | 만약 무인도에서 한 달을 보내야 한다면 갖고 가고 싶은 책은?&quot; 이벤트에 참여합니다.저는 무인도에 “무인도에서 살아남기” 책을 가져가겠습니다. 저는 매우 현실적이기 때문입니다. 소설, 인문학, 역사책 이런 종류의 책은 무인도에서는 불 피는 용도밖에 사용 못 합니다. ㅋ","text":"&quot;스짱 북클럽 이벤트 | 만약 무인도에서 한 달을 보내야 한다면 갖고 가고 싶은 책은?&quot; 이벤트에 참여합니다.저는 무인도에 “무인도에서 살아남기” 책을 가져가겠습니다. 저는 매우 현실적이기 때문입니다. 소설, 인문학, 역사책 이런 종류의 책은 무인도에서는 불 피는 용도밖에 사용 못 합니다. ㅋ 책 내용을 살펴봤는데 내용이 매우 알찹니다. 이 책 하나만 있으면 무인도에서 한 달 살기에 문제없을 것 같습니다. 만화의 주요 내용은 무인도에 표류하게 된 일행이 자연과 과학을 이용하여 생존하는 내용입니다. 주인공들이 실제 상황에 처했다는 가정 하에 생존을 위한 정보를 제공하고 연관된 과학 지식을 함께 다루고 있습니다. 그리고 만화 속의 사건과 과학 정보를 결합시켜 물을 구하는 방법, 정수기 제조법, 증류와 여과의 원리, 렌즈로 불 피우는 방법, 구조 신호 보내기와 날씨 예측법, 식량을 오래 저장하는 방법 등 다양한 생활 과학 원리를 설명하고 있습니다. 목차 곤충 채집 여행 - 아르키메데스의 원리와 배가 물에 뜨는 원리인 부력 난파 - 동물들의 초감각, 쥐에 관한 상식 표류 - 해류란? 해류를 일으키는 원인 무인도의 첫날 - 무인도란? 무인도에서 알아야 할 생존 방식 탐험 - 방향 탐지법 집짓기 - 야외에서 자연물을 이용해 지을 수 있는 여러 가지 집의 종류 책 내용 발췌 물 정수하는 법 무인도에서 물을 발견했을 때, 그 물을 먹을 수 있느냐 없느냐를 판단하는 것은 매우 중요한 일입니다. 물 속에 불순물이 섞여 있을 경우, 그것을 제거하는 방법은 여러 가지가 있는데, 물의 상태를 보고 적절한 방법을 선택해야 합니다. 가. 침전 물에 단순히 작은 모래나 흙 알갱이가 섞여 있을 때 사용하는 가장 기초적인 방법으로 몇 시간, 혹은 하루 정도 가만히 놔두어 모래나 흙을 가라앉힌 후(침전), 위쪽 부분의 맑은 물을 마십니다. 나. 여과 필터를 만들어 더러운 불순물들을 걸러 내는 방법으로, 야외에서는 오른쪽 그림과 같은 여과 장치를 이용하여 간이 정수기를 만들어 사용할 수 있습니다. 특히, 숯의 표면에는 아주 미세한 작은 구멍들이 무수히 많이 뚫려 있는데, 바로 이 구멍들이 이물질을 걸러 내는 역할을 합니다. —p.57 그리고 오래전에 방송에서 무인도 한 달 살기 실험을 한 적이 있습니다. 생각난 김에 검색해보니 누가 블로그에 정리한 글이 있네요. 읽어보면 정말 재미있습니다. 리얼실험 프로젝트 X - 문명탈출 무인도에서 1달살기 감사합니다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"}],"author":"anpigon"},{"title":"[SCT 이벤트 참여] 1억이 생기면 어디에 펑펑 쓰고싶나요? (본인에게만 사용)","slug":"/sct/@anpigon/sct-1","date":"2019-08-10T15:07:48.000Z","updated":"2019-11-11T13:41:49.859Z","comments":true,"path":"/sct/@anpigon/sct-1/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/sct-1/","excerpt":"&quot;[스판 유쾌한 이벤트] 총상금 330 SCT. 마! 자신있나! NB/OB 전부 드루와!&quot; 이벤트에 참여합니다. 본론에 들어가기 전…현재 저의 블로그 광고 수익보다 스팀잇 수익이 더 높기 때문에 모든 글을 스팀잇에 먼저 올리고 있습니다. 그러고나서 카테고리를 분류하고 정리해서 티스토리에 다시 올리고 있습니다. 참고로 티스토리는 하루 방문자 수가 약 200명 정도입니다. 그리고 하루 광고 수익은 30 ~ 50원입니다. 블로그 광고 수익은 파워 블로거가 아닌 이상 수익내기 정말 힘듭니다.","text":"&quot;[스판 유쾌한 이벤트] 총상금 330 SCT. 마! 자신있나! NB/OB 전부 드루와!&quot; 이벤트에 참여합니다. 본론에 들어가기 전…현재 저의 블로그 광고 수익보다 스팀잇 수익이 더 높기 때문에 모든 글을 스팀잇에 먼저 올리고 있습니다. 그러고나서 카테고리를 분류하고 정리해서 티스토리에 다시 올리고 있습니다. 참고로 티스토리는 하루 방문자 수가 약 200명 정도입니다. 그리고 하루 광고 수익은 30 ~ 50원입니다. 블로그 광고 수익은 파워 블로거가 아닌 이상 수익내기 정말 힘듭니다. ___ 아래 차트는 제 블로그에서 벌어들이는 광고 수익입니다. 광고 요청수가 방문자 수라고 보면 됩니다. 방문자가 10배가 되면 수익도 10배가 되겠지요? ㅎㅎ 그리고 아래는 최근 스팀잇 보상 금액입니다. 하루에 글 1개씩 올린다고 가정하고 평균 보상이 $1라고 합시다. 그리고 저자 보상은 총 보상에서 75％이므로 작성한 글에 대한 실제 보상은 $0.75입니다. 현재 스팀달러가 1,015원이므로 하루에 약 761원 정도 수익이 생긴다고 보면 됩니다. 사실 큐레이터 보상과 SCOT 토큰 보상까지 합치면 하루에 약 1천원 이상의 수익이 발생합니다. 확실히 스팀 수익이 블로그 광고 수익보다 높습니다. 나에게 1억이 생긴다면? 나에게 1억이 생긴다면 업비트 거래소에서 1억 원어치의 STEEM을 매수할 것입니다. 사실 하루에 이 정도 금액의 STEEM을 매수하려면 바이낸스 거래소에서 거래해야 할 것 같습니다. ㅋ 그리고 STEEM을 STEEM POWER로 전환합니다. 현재 452,488 STEEM POWER를 가지고 있으면 보팅 금액이 약 $6가 찍힙니다. 이 스팀파워로 제가 좋아하는 작가님들의 글에는 보상이 $6가 찍히도록 보팅 해드릴 것을 약속합니다. 저는 스팀잇에서 고래를 꿈꿉니다. 1억이 생기면 스팀잇 고래가 되겠습니다. 그리고 구글에서 거위의 꿈 가사를 검색했더니 요렇게 보이네요. 저만 이런가요? 할머니 유모 이쿠미의 이쎄옽죠~ 🎵 베오례오지고 찥계오 남루하예오도~ 🎵🎶 이런 가사라면 한국인이라도 따라 부르기 힘들 것 같습니다. 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] 리액트 네이티브에 카카오 로그인 구현하기 #1","slug":"/zzan/@anpigon/6np73q-react-native","date":"2019-08-10T10:20:51.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/zzan/@anpigon/6np73q-react-native/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/6np73q-react-native/","excerpt":"안녕하세요. 안피곤입니다.카카오톡 로그인으로 스팀잇을 사용할 수 있다면 “일반 사용자가 쉽게 접근할 수 있지 않을까?” 생각했습니다. 카카오톡 로그인을 시작으로 가능하면 구글, 페이스북, 트위터 로그인도 구현하고 싶어요.카카오톡 로그인 API는 공식적으로 리액트 네이티브를 지원하지 않습니다. 그래서 사용하려면 안드로이드 또는 iOS 코드를 조금 수정해야합니다. 저는 안드로이드 앱만 개발할 생각이라서 안드로이드만 살펴봤습니다.","text":"안녕하세요. 안피곤입니다.카카오톡 로그인으로 스팀잇을 사용할 수 있다면 “일반 사용자가 쉽게 접근할 수 있지 않을까?” 생각했습니다. 카카오톡 로그인을 시작으로 가능하면 구글, 페이스북, 트위터 로그인도 구현하고 싶어요.카카오톡 로그인 API는 공식적으로 리액트 네이티브를 지원하지 않습니다. 그래서 사용하려면 안드로이드 또는 iOS 코드를 조금 수정해야합니다. 저는 안드로이드 앱만 개발할 생각이라서 안드로이드만 살펴봤습니다. 안드로이드 설정 방법은 카카오 공식 가이드 문서를 참고하였습니다. https://developers.kakao.com/docs/android/getting-started#gradle-％ED％99％98％EA％B2％BD％EC％84％A4％EC％A0％95 그리고 리액트 네이티브 모듈은 react-native-kakao-logins를 사용했습니다. https://github.com/react-native-seoul/react-native-kakao-logins react-native-kakao-logins 모듈 설치하기 npm install로 모듈을 설치하고 react-native link를 실행합니다. 12$ npm install react-native-kakao-logins --save$ react-native link react-native-kakao-logins 안드로이드 Gradle 환경 설정하기 android/build.gradle 파일에 다음 내용을 추가합니다. 123456subprojects ｛ repositories ｛ mavenCentral() maven ｛ url 'http://devrepo.kakao.com:8088/nexus/content/groups/public/' ｝ ｝｝ 혹시 프로가드를 사용한다면 android/app/proguard-rules.pro 에 다음 내용도 추가합니다. 1234567-keep class com.kakao.** ｛ *; ｝-keepattributes Signature-keepclassmembers class * ｛ public static &lt;fields&gt;; public *;｝-dontwarn android.support.v4.**,org.slf4j.**,com.google.android.gms.** 앱 설정하기 android/app/src/main/res/values/kakao_strings.xml 파일을 생성하고 아래 내용 입력합니다. 앱생성시 발급된 네이티브 앱키를 kakao_app_key 이름으로 정의하고 등록합니다. 123&lt;resources&gt; &lt;string name=\"kakao_app_key\"&gt;AAAAAAAAAAAAAAAAAAAAAA&lt;/string&gt;&lt;/resources&gt; 앱키 값은 개발자 웹사이트에서 제공하는 대쉬보드의 설정 &gt; 일반 &gt; 앱 키 &gt; 네이티브 앱 키 메뉴를 통해 확인 가능합니다. 마지막으로 android/app/src/main/AndroidManifest.xml 파일을 수정합니다. allowBackup을 true로 설정합니다. 그리고 &lt;meta-data&gt;에 com.kakao.sdk.AppKey를 등록합니다. 123456789101112131415&lt;application android:name=\".MainApplication\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:allowBackup=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;! -- com.kakao.sdk.AppKey 이름으로 앱키를 등록 --&gt; &lt;meta-data android:name=\"com.kakao.sdk.AppKey\" android:value=\"@string/kakao_app_key\" /&gt; &lt;activity … 로그인 화면 개발하기 src/screens/login.js 파일을 수정합니다. 1234567891011121314151617181920212223242526272829303132import RNKakaoLogins from 'react-native-kakao-logins';…class LoginScreen extends Component ｛ … // 카카오 로그인 하기 kakaoLogin = () =&gt; ｛ RNKakaoLogins.login((err, result) =&gt; ｛ if (err) ｛ Alert.alert('error', err.toString()); return; ｝/Users/anpigon/ReactNative/steewitter/src/screens/login.example.js Alert.alert('result', JSON.stringify(result)); ｝); ｝; render() ｛ return ( … &lt;Button block style=｛｛ backgroundColor: '#F7E314' ｝｝ onPress=｛() =&gt; this.kakaoLogin()｝&gt; &lt;Text style=｛｛ color: '#3C1E1E', fontWeight: 'bold' ｝｝&gt; 카카오 로그인 &lt;/Text&gt; &lt;/Button&gt; 카카오 로그인 버튼을 누르면, 카카오톡 앱과 연동하여 인증 후 액세스 토큰을 가져옵니다. 그리고 카카오톡 API 가이드 문서에는 액세스 토큰과 관련하여 이렇게 나와있습니다. access_token은 발급 받은 후 12시간-24시간(정책에 따라 변동 가능)동안 유효합니다. 안드로이드의 경우에는 sdk내에서 토큰이 만료되면 알아서 필요한 시점에 갱신을 해주고 있습니다. 구현 결과 원래 처음 로그인시 아래와 같이 사용자 동의 화면이 나타납니다. 그런데 위 예제 화면에서는 제가 이미 동의해서 바로 로그인 되네요. ㅋ 다음 번에는 사용자 관리를 위한 서버를 개발할 생각입니다. 그리고 사용자 인증에는 google firebase auth를 사용할 것입니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"카카오 로그인","slug":"카카오-로그인","permalink":"https://anpigon.github.io/tags/카카오-로그인/"}],"author":"anpigon"},{"title":"[React Native] Redux-Saga 학습하기 #2","slug":"/zzan/@anpigon/react-native-redux-saga-2","date":"2019-08-09T02:23:18.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/zzan/@anpigon/react-native-redux-saga-2/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-redux-saga-2/","excerpt":"Redux-saga를 학습하기 적당한 샘플 앱을 깃허브에서 찾았습니다. 이제 Twitter Clone 코딩을 하면서 Redux Saga에 익숙해져보겠습니다. 실제 앱에 어떻게 사용하는지를 파악하고 이론 공부를 병행하면 좀 더 쉽게 배울 수 있습니다. 혹시 이해가 안 되는 내용은 댓글에 질문하면 제가 답변하겠습니다.","text":"Redux-saga를 학습하기 적당한 샘플 앱을 깃허브에서 찾았습니다. 이제 Twitter Clone 코딩을 하면서 Redux Saga에 익숙해져보겠습니다. 실제 앱에 어떻게 사용하는지를 파악하고 이론 공부를 병행하면 좀 더 쉽게 배울 수 있습니다. 혹시 이해가 안 되는 내용은 댓글에 질문하면 제가 답변하겠습니다. Twitter Clone App 사이트: https://startreact.com/themes/twitter-clone-app/ 로그인 리듀서(Reducer) 정의하기 reducers.js에는 로그인에 필요한 State를 설계합니다. 아래 코드를 보면, 로그인 State는 username, password, loginStatus, user(Object) 데이터를 관리합니다. 그리고 나서 Reducer를 추가합니다. Reducer는 이전 상태와 액션을 받아서 다음 상태를 반환하는 함수입니다. Reducer 함수의 기본 구조는 (previousState, action) =&gt; newState 입니다. 아래와 같이 사용자ID 입력, 패스워드 입력, 로그인 요청, 로그인 성공, 로그인 실패에 대한 액션을 각각 정의합니다. reducer(state = initialState)와 같이 초기 State를 initialState로 초기화합니다. 이 기능은 ES6에서 추가된 Default Parameters Syntax입니다. 그리고 리듀서에서 반환하는 Object ｛ ...state, username: action.payload ｝는 ES7의 Object Rest/Spread Syntax을 사용했습니다. 만약 ES6를 사용한다면 Object.assign(state, ｛ username: action.payload ｝)로 작성하면됩니다. Redux Saga 액션(Action) 정의하기 sagas.js에는 Redux Saga에서 수행할 액션을 정의합니다. 그 다음 `sagas.js`에 액션에 대한 watch를 추가합니다. watch는 Store로 dispatch되는 모든 액션들을 잡아내서 처리할 것입니다. parallel로 처리하기 위해서 watch를 모두 all 함수에 담아 export 합니다. 여기에 사용된 all은 Promise.all과 비슷합니다. 리듀서(Reducer) Store 정의하기 마지막으로 store.js에 store를 생성합니다. 그리고 sagaMiddleware를 생성하여 store에 추가합니다. 그다음 rootSaga를 실행합니다. Redux-saga 사용하기 App.js에서는 앞에서 생성한 Store를 import 합니다. 그리고 Provider를 사용하여 Store를 App에 주입합니다. 그리고 로그인 화면 screens/login.js을 생성합니다. 마지막으로 LoginScreen 컴포넌트를 Reducer에 연결(connect) 합니다. 이렇게 Resux-saga를 사용하여 action, state, view를 분리하였습니다. 로그인 기능 하나 만드는게 많은 파일과 코드를 생성해야합니다. 다음에 같은 기능을 mobx나 apollo-graphql 로도 구현해봐야겠습니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Redux Saga","slug":"redux-saga","permalink":"https://anpigon.github.io/tags/redux-saga/"}],"author":"anpigon"},{"title":"[북클럽] 지금 읽고 있는 책 뒷표지 : 김영하 ⟪보다⟫","slug":"/zzan/@anpigon/5nf9b3","date":"2019-08-08T03:51:57.000Z","updated":"2019-11-11T13:41:49.864Z","comments":true,"path":"/zzan/@anpigon/5nf9b3/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/5nf9b3/","excerpt":"","text":"오늘도 스짱 북클럽 이벤트에 참여합니다. 지금 읽고 있는 책 뒷표지 사진입니다.김영하 작가님의 “보다” 입니다. 원래는 표지 커버가 있었는데 제가 벗겨버려서 이렇습니다. 뒷표지, 앞표지 사진 모두 올립니다. 뒷표지 앞표지 스짱 북클럽 이벤트 | 지금 읽고 있는 책 뒷표지를 올려주세요","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"김영하","slug":"김영하","permalink":"https://anpigon.github.io/tags/김영하/"}],"author":"anpigon"},{"title":"[React Native] Redux-Saga 학습하기 #1","slug":"/zzan/@anpigon/react-native-redux-saga-1","date":"2019-08-08T01:48:24.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/zzan/@anpigon/react-native-redux-saga-1/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-redux-saga-1/","excerpt":"React를 공부하면서 그동안 미뤄왔던 Redux-Saga 학습을 시작했습니다. 사실 저는 React와 Redux도 어렵습니다. 그런데 여기에 Redux-Saga까지 더 해지니 더 어렵습니다. 지금도 Redux-Saga 코드를 보고 있으면 머리가 멍해집니다. effect, channel, task, blocking, non-blocking, watcher, worker 등 용어들도 무척 생소합니다. 이 어려운 걸 공부해야 하는지 가끔 의문도 듭니다.","text":"React를 공부하면서 그동안 미뤄왔던 Redux-Saga 학습을 시작했습니다. 사실 저는 React와 Redux도 어렵습니다. 그런데 여기에 Redux-Saga까지 더 해지니 더 어렵습니다. 지금도 Redux-Saga 코드를 보고 있으면 머리가 멍해집니다. effect, channel, task, blocking, non-blocking, watcher, worker 등 용어들도 무척 생소합니다. 이 어려운 걸 공부해야 하는지 가끔 의문도 듭니다. Redux-Saga는 Redux 미들웨어고 Redux 액션에 의해서 실행되고 취소됩니다. 그리고 ES6 Generator 형태의 비동기 함수를 사용합니다. 참고로 Generator 함수는 이렇게 생겼습니다. function* asyncFunc(obj) ｛ yield; ｝. Generator 함수를 사용하면 ES8의 async/await 와 비슷합니다. 그리고 Redux-Saga의 Flow는 다음과 같습니다. 출처: https://www.freecodecamp.org/news/login-using-react-redux-redux-saga-86b26c8180e/ 사용자가 액션을 수행하면, Redux-saga가 받아서 처리합니다. 그리고 그 결과값을 Reducer Store에 전달합니다. Store는 전달 받은 값을 State 저장하고, Provider를 통해 컴포넌트 UI를 업데이트 합니다. * * * 사실 저는 Redux-saga가 복잡하고 이해하기가 어려웠습니다. 그래서 사용하지 않으려고 했어요. Redux-saga 보다 배우기 쉬운 react-trunk를 사용하고 있었습니다. 하지만 구글 검색을 하면 React 앱 개발에 대부분 Redux-saga를 추천하고 있습니다. 그리고 Redux 보다 배우기 쉽고 사용이 편한 Mobx도 추천하고 있습니다. 하지만 Mobx는 아직은 Redux 보다 레퍼런스가 많이 없습니다. 그래서 Redux를 마스터 하고 나서 Mobx를 학습할 생각입니다. 그때는 Mobx 강의 자료나 레퍼런스가 많이 생겨있길 바랍니다. ㅋ 그리고 가능하다면 지금 개발하고 있는 완댑에 Redux-Saga를 적용할 계획입니다. react-trunk로 예외처리 하기 힘든 비동기 통신 부분을 Redux-Saga를 사용하면 좀더 쉽게 처리할 수 있을 것으로 생각됩니다. 예를 들어 사용자가 지갑화면에서 잔액조회를 요청하고 서버에서 응답을 받기 전에 다른 화면으로 이동하는 경우, 저는 이것에 대한 예외 처리가 아직 부족합니다. 이때 FC가 가끔 발생합니다. ㅠㅠ 하지만 요즘 soct-api 상태가 좋지 않아서 완댑 개발에 흥미를 완전 잃었습니다. scot-bot이 많이 아픈것 같습니다. soct-api 서버가 안정화 될 때까지 기다려야겠습니다. 지금은 다시 초연으로 돌아가 Steem 기반의 모바일앱을 개발하고 싶네요. * * * Redux Saga를 학습하기 위해 적당한 샘플 앱을 깃허브에서 검색해봤습니다. 저의 경우에는 실제 앱을 개발하면서 이론 공부를 병행합니다. 본업에서도 이런 방식으로 개발을 하다보니 그냥 습관이 되었습니다. 실제 SI 프로젝트에서도 개발 업무를 수행 중에 학습이 필요한 기술이 있으면 그때그때 실시간으로 자료를 찾아서 공부하면서 개발합니다. SI 프로젝트에서 개발하시는 개발자분들은 아시겠지만, 프로젝트마다 개발 환경, 개발 언어, 플랫폼이 다 다릅니다. 그리고 가끔은 듣보잡 프레임워크를 사용하여 개발하기도 합니다. 게다가 일부 프로젝트에서는 백엔드/프런트엔드 개발자의 구분이 없습니다. 그래서 SI 개발을 오래 하다 보면 기술 스펙트럼이 많이 넓어지는 장점이 있지만, 기술에 대한 깊이가 부족합니다. 제가 그런 경우입니다. 그래서 저는 제 스스로 개발자라기보다는 저를 코더라고 생각합니다. 개인적으로 React는 마스터 하고 싶습니다. React만 학습하면 웹, 앱, 모바일 모두 개발할 수 있습니다. Vue나 Flutter도 있지만, 유튜브에는 React가 강의 자료가 더 많아서 저는 React를 공부합니다. 하지만 저의 학습 속도가 새로운 기술이 나오는 속도를 못따라 가고 있습니다. 그러나 부지런히 쫓아가면 어느정도 높은 레벨에 올라갈 수 있을 것이라고 생각합니다. 지금도 저는 코딩 고수를 꿈꿉니다. 고수님들 많이 도와주세요. ㅎㅎ 그리고 만약 여러분이 리액트를 시작하게 된다면 읽어 볼만한 글을 소개합니다. ‘리액트(ReactJS) 개발자가 걷게 되는 길’ 바로 리액트 하는 사람들이 걷게 되는 모종의 공통 코스가 있다는거다. 간략히 적어보면 이렇다. 리액트를 배운다 -&gt; 예제를 봤더니 괜찮다. 신기하다. 그리고 할 수 있을것 같다! -&gt; 리덕스(Redux)가 있다는 걸 봤다. 읽어보니 이거이거~ 왠지 안쓰면 안될것 같은 느낌이 든다. 리덕스를 배운다. -&gt; 한동안 미친듯이 헷갈려 하기 시작한다 (Action/ActionCreator, state, props, setState,getState, store, reducer) 이건 아쉽지만 Redux 만든 dan abramov의 예제도 여기에 한몫한다… 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Redux Saga","slug":"redux-saga","permalink":"https://anpigon.github.io/tags/redux-saga/"}],"author":"anpigon"},{"title":"[북클럽] 지금 읽는 책 77쪽 7번째 줄 : 위대한 개츠비","slug":"/zzan/@anpigon/77-7","date":"2019-08-07T08:06:39.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"/zzan/@anpigon/77-7/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/77-7/","excerpt":"오늘도 스짱 북클럽 이벤트에 참여합니다.책 제목은 위대한 개츠비입니다. 책이 매우 크고 두껍습니다.위대한 개츠비 책의 77쪽 7줄 내용입니다. 뉴욕에서 온 차들은 다섯 겹으로 주차되어 있었고, 홀과 복도와 베란다는 화려한 원색으로 가득 찼고, 최신 유행의 기묘한 헤어스타일, 카스티야의 최상품도 울고갈 최고급 숄을 걸친 여자들로 붐볐다.","text":"오늘도 스짱 북클럽 이벤트에 참여합니다.책 제목은 위대한 개츠비입니다. 책이 매우 크고 두껍습니다.위대한 개츠비 책의 77쪽 7줄 내용입니다. 뉴욕에서 온 차들은 다섯 겹으로 주차되어 있었고, 홀과 복도와 베란다는 화려한 원색으로 가득 찼고, 최신 유행의 기묘한 헤어스타일, 카스티야의 최상품도 울고갈 최고급 숄을 걸친 여자들로 붐볐다. 스짱 북클럽 이벤트 | 지금 읽는 책 77쪽 7번째 줄을 공유해주세요","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"}],"author":"anpigon"},{"title":"[개발] 소스 코드를 이미지로 바꿔주는 서비스 : Carbon","slug":"/zzan/@anpigon/carbon","date":"2019-08-07T06:16:45.000Z","updated":"2019-11-11T13:41:49.859Z","comments":true,"path":"/zzan/@anpigon/carbon/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/carbon/","excerpt":"안녕하세요. 안피곤입니다.그동안 소스 코드를 이쁘게 만들기 위해서 VSCode 확장 프로그램인 Polacode를 사용했습니다. 그런데 이미지를 생성할때 크기(width) 지정이 안되니 불편합니다.아래는 polacode 앱을 사용하는 화면입니다. 출처: https://marketplace.visualstudio.com/items?itemName=pnp.polacode","text":"안녕하세요. 안피곤입니다.그동안 소스 코드를 이쁘게 만들기 위해서 VSCode 확장 프로그램인 Polacode를 사용했습니다. 그런데 이미지를 생성할때 크기(width) 지정이 안되니 불편합니다.아래는 polacode 앱을 사용하는 화면입니다. 출처: https://marketplace.visualstudio.com/items?itemName=pnp.polacode 코드를 이미지로 만들어주는 또 다른 서비스나 앱이 있는지 찾아봤습니다. 검색 결과, 매우 훌륭한 사이트를 찾았습니다. Caron https://carbon.now.sh C, Python, Java, Javascript 등 다양한 개발 언어 선택이 가능합니다. 그리고 다양한 테마 선택이 가능합니다. Window 형태, 라인 넘버, 사이즈 조절 등 옵션 선택에 의해서 커스터 마이징도 가능합니다. 마지막으로 여러가지 export 방법을 제공합니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"꿀팁","slug":"꿀팁","permalink":"https://anpigon.github.io/tags/꿀팁/"},{"name":"유용한 도구","slug":"유용한-도구","permalink":"https://anpigon.github.io/tags/유용한-도구/"}],"author":"anpigon"},{"title":"[북클럽] 칼 세이건 님의 코스모스 읽고 있습니다.","slug":"/zzan/@anpigon/31f8xl","date":"2019-08-06T14:40:18.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"/zzan/@anpigon/31f8xl/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/31f8xl/","excerpt":"짠 북클럽의 이벤트에 응모합니다.최근에 카알 사강 님의 코스모스를 읽고 있습니다. 도서 구입한지는 벌써 약 1년 된 것 같습니다. 그리고 읽기 시작한 지 3일 되었습니다. 벌써 3페이지나 읽었네요. 이 두꺼운 책을 언제 다 읽을 수 있을지 모르겠습니다.그리고 칼 세이건 님의 한국 이름은 카알 사강이라고 합니다.","text":"짠 북클럽의 이벤트에 응모합니다.최근에 카알 사강 님의 코스모스를 읽고 있습니다. 도서 구입한지는 벌써 약 1년 된 것 같습니다. 그리고 읽기 시작한 지 3일 되었습니다. 벌써 3페이지나 읽었네요. 이 두꺼운 책을 언제 다 읽을 수 있을지 모르겠습니다.그리고 칼 세이건 님의 한국 이름은 카알 사강이라고 합니다. 짠 북클럽의 첫번째 이벤트!!! 와우~~~ 책사진을 올려주세요~~~ 풀봇 드립니다!!!","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"북클럽","slug":"북클럽","permalink":"https://anpigon.github.io/tags/북클럽/"},{"name":"칼 세이건","slug":"칼-세이건","permalink":"https://anpigon.github.io/tags/칼-세이건/"},{"name":"코스모스","slug":"코스모스","permalink":"https://anpigon.github.io/tags/코스모스/"}],"author":"anpigon"},{"title":"[코딩/개발] 깃허브에서 eonwarped에게 코드 리뷰 받은 이야기","slug":"/zzan/@anpigon/eonwarped","date":"2019-08-06T14:23:33.000Z","updated":"2019-11-11T13:41:49.835Z","comments":true,"path":"/zzan/@anpigon/eonwarped/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/eonwarped/","excerpt":"안녕하세요. 안피곤입니다.&quot;본문 하단에 작가의 최근 글 보기 기능 구현&quot; 글에서 밝혔지만, 작가의 최신 글 10개를 본문 하단에 출력하는 기능을 개발하여 깃허브에 PR을 하였습니다. 그리고 작성한 코드에 대해서 eonwarped에게 코드 리뷰를 받았습니다. “네가 구현한 코드가 기존 패턴을 위배한다. Reducer를 사용하는게 좋다.” 라는 내용인 것 같습니다. 그리고 내가 Reducer를 잘 모르니 도와달라고 했습니다. 그랬더니 매우 친절하게 알려주네요. 쪼금 감동했습니다.","text":"안녕하세요. 안피곤입니다.&quot;본문 하단에 작가의 최근 글 보기 기능 구현&quot; 글에서 밝혔지만, 작가의 최신 글 10개를 본문 하단에 출력하는 기능을 개발하여 깃허브에 PR을 하였습니다. 그리고 작성한 코드에 대해서 eonwarped에게 코드 리뷰를 받았습니다. “네가 구현한 코드가 기존 패턴을 위배한다. Reducer를 사용하는게 좋다.” 라는 내용인 것 같습니다. 그리고 내가 Reducer를 잘 모르니 도와달라고 했습니다. 그랬더니 매우 친절하게 알려주네요. 쪼금 감동했습니다. 다른 개발자에게는 쉬울 수도 있겠지만, 저는 니트러스 소스코드가 매우 복잡하고 어렵다고 생각합니다. 게다가 니트러스는 서버에서 데이터를 가져오는 비동기 작업에 Redux-Saga를 사용하고 있습니다. Redux-Saga는 학습 곡선에 매우 높습니다. 이해하는 것도 잘 사용하는 것도 어렵습니다. 그래서 저는 Redux-Saga vs Redux-Thunk 기술을 고민하다가 상대적으로 학습하기 쉬운 Redux-Thunk를 선택했습니다. 지금도 Redux-Thunk를 계속 사용하고 있었습니다. 이번 기회에 eonwarped가 가르쳐준 데로 Redux-Saga를 사용해봤습니다. 그동안 React 경험이 쌓여서 그런지 예전보다 금방 익숙해졌습니다. 그리고 Redux-Thunk에서 처리하기 힘든 예외 처리가 쉽게 가능해 보입니다. Redux-Thunk에서는 세세한 에러를 잡아내서 처리하기가 어렵습니다. 그리고 Redux-Thunk는 참고할 수 있는 레퍼런스가 Redux-Saga 보다 상대적으로 적습니다. 깃허브에서 검색해보면 대부분 샘플 코드가 Redux-Saga로 구현되어 있는 것을 알 수 있습니다. 저는 기술 선택의 기로에서 항상 고민합니다. Node를 막 학습하기 시작했을 때, Vue vs React vs Angular에서 고민했습니다. 그리고 학습하기 쉬운 Vue를 선택했습니다. 그런데 그 당시 Vue는 구현에 필요한 자료를 찾을 때 레퍼런스가 거의 없었습니다. 강의 자료나 레퍼런스는 React가 훨씬 많은 것을 알았습니다. 결국에는 React로 갈아탔습니다. 그리고 모바일 앱 개발에 필요한 기술, Native Script vs React Native vs Flutter에서도 고민했습니다. 결국 다 경험해보고 React Native를 선택했습니다. 지금은 어떤 기술이 학습하기 쉬운지? 어떤 프레임워크 속도가 더 빠른지?를 고민할 필요가 없다고 생각합니다. 이제는 개발자들이 가장 많이 사용하는 기술을 선택할 것입니다. 이제 Redux-Saga 동영상 강의가 있는지 찾아보고 공부를 해야겠습니다. 저는 동영상 강의를 보고 학습하는 게 가장 편하네요. ㅋ 참고로 제 코딩 실력은 유튜버에서 코딩 고수에게 배운 것입니다. 저는 강의를 보고 따라할 뿐입니다. 여기까지 읽어주셔서 감사합니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon Sponsored ( Powered by dclick ) 퀴어자유도시 제주를 상상하다! 제 3회 제주퀴어문화축제 응원, 공유하면 카카오가 대신 기부합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React Native] WHAN APP 개발 이야기 #8 : react-native-cache  사용하기","slug":"/zzan/@anpigon/react-native-whan-app-8-react-native-cache","date":"2019-08-04T09:49:45.000Z","updated":"2019-11-11T13:41:49.819Z","comments":true,"path":"/zzan/@anpigon/react-native-whan-app-8-react-native-cache/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-whan-app-8-react-native-cache/","excerpt":"안녕하세요. 안피곤입니다.스팀잇에 글을 올려서 보상받기 위해서 시작한 시리즈 글의 8번째 포스팅입니다. 스팀잇 초기에는 글을 써서 보상받는 게 목적이었다면, 지금은 보상받기 위해 글을 씁니다.이번 포스팅은 react-native-cache 사용하는 개발 이야기입니다. 개발 시리즈를 계속 진행하다 보면 Whan Dapp의 완성도가 올라갈 거라고 생각합니다. 지금 개발 속도로 보았을때 앱을 완성하기까지 약 1년으로 예상합니다. 이 시리즈 글도 1년 정도 유지할 수 있겠네요. ㅋ","text":"안녕하세요. 안피곤입니다.스팀잇에 글을 올려서 보상받기 위해서 시작한 시리즈 글의 8번째 포스팅입니다. 스팀잇 초기에는 글을 써서 보상받는 게 목적이었다면, 지금은 보상받기 위해 글을 씁니다.이번 포스팅은 react-native-cache 사용하는 개발 이야기입니다. 개발 시리즈를 계속 진행하다 보면 Whan Dapp의 완성도가 올라갈 거라고 생각합니다. 지금 개발 속도로 보았을때 앱을 완성하기까지 약 1년으로 예상합니다. 이 시리즈 글도 1년 정도 유지할 수 있겠네요. ㅋ Whan Dapp 구현 방향 고민하기 최근 Whan Dapp을 사용하다가 불편해서, 하단 탭에서 지갑과 프로필 화면으로 이동할 수 있게 변경했습니다. 저는 앱에서 지갑과 프로필 화면을 자주 봅니다. 그래서 하단 탭에서 이동할 수 있으니 사용하기 편해졌습니다. 제가 사용하면서 불편한 부분을 조금씩 고치고 새로운 기능을 붙여나가는 중입니다. Feed 화면은 카테고리(태그?)를 어떻게 구현하는 게 사용면에서 좋을지 계속 고민 중입니다. 제가 자주 보는 태그는 #kr, #kr-dev, #sct, #zzan, #liv, #aaa, #movie, #coin, #book, #kr-book, #booksteem, #literature, #kr-hobby, #hobby, #arts 등 입니다. 게다가 다른 태그도 마찬가지겠지만, 도서(book)는 태그 파편화가 심해서 조금 불편합니다. 저는 zzan 커뮤니티의 태그 분류가 가장 잘되어 있다고 생각합니다. 하지만 nitrous에서는 페이 아웃된 글은 볼 수가 없어서 매우 불편하네요. 이렇게 불편한 게 한두 개가 아닌데 스팀잇을 열심히 하고 있는 제가 신기합니다. 아마도 돼지꼬리만한 보상 때문인 것 같습니다. 제 스팀 파워로는 스팀잇에서 돌고래도 안됩니다. 그래서 zzan에서라도 돌고래가 되고 싶어서, zzan 토큰을 소량 매수하였습니다. 덕분에 zzan 홀더 0.1％에 겨우 도달했습니다. 하지만 zzan 토큰을 지속적으로 매수하지 않으면 곧 밀려나갈 것 같아요. ㅠ 하지만 열심히 하면 언젠가 짠고래(ZZAN Whale)가 되겠죠. ㅎㅎ 매번 포스팅에서 이야기했지만, 최근 scot-api가 많이 느려졌습니다. 그래서 토큰 지갑은 잔액을 확인하는 데에는 기다림이 필요합니다. 가끔 API에서 응답을 못 받아서 화면에 데이터가 안보이면 새로고침 한번씩 해주세요. ㅋ Whan Dapp 테스트 사용자는 3명 Whan Dapp은 현재 저를 포함하여 3분이 테스트 하고 계십니다. 누군지 알 것 같습니다. ㅋ 테스트앱을 사용하고 싶은 분은 저에게 discord로 요청해주세요. 단, 안드로이드만 테스트 가능합니다. - discord 링크: https://discord.gg/a37gG7f 앱 퀄리티가 너무 낮아서 아직 공개하기 민망합니다. 그리고 개인적인 시간이 많지 않아서, 앱 안정화보다는 기능 구현에 집중하고 있습니다. 그러다 보니 앱을 사용하다가 가끔 FC(Force Close)가 발생합니다. FC가 발생하면 자동으로 Stack Trace를 남기고, 해당 로그를 개발자 이메일로 전송하고 싶은데 방법을 모르겠습니다. ㅠ Whan Dapp 개발 내용 react-native-cache 사용하기 리액트 네이티브 캐시 기능 구현을 위해서 react-native-cache 모듈을 사용합니다. 설치방법 1npm install --save react-native-cache 사용방법 123456789import ｛ Cache ｝ from \"react-native-cache\";var cache = new Cache(｛ namespace: \"myapp\", policy: ｛ maxEntries: 50000 ｝, backend: AsyncStorage｝); 적용하기 먼저 cache의 setItem과 getItem 함수를 Promise 형태로 만듭니다. 현재 react-native-cache 모듈은 Callback 함수만 제공합니다. 저는 코드에서async/await를 정말 많이 사용합니다. 그래서 callback 함수는 대부분 Promise wrapper 함수를 만들어 사용합니다. 아래는 제가 구현하여 사용한 코드입니다. 내용을 살펴보면 캐시 데이터가 있으면 캐시된 데이터를 먼저 사용합니다. 그리고나서 서버에서 가져온 데이터를 사용합니다. 그리고 서버에서 가져온 데이터를 캐시 저장소에 업데이트합니다. scot-api의 느린 속도 때문에 답답해서, 마켓 정보를 가져오는 marketMetrics API 에 캐시를 적용했습니다. 사실 마켓 정보는 실시간으로 보여줘야 합니다. 하지만 whan dapp은 scot-api에 의존하기 때문에 다른 방법이 없습니다. 최근 업데이트한 일시와 함께 캐시된 정보를 먼저 보여준다면, 앱 사용하는데 불편함을 줄일 수 있을 거라고 생각합니다. 아래는 구현된 화면입니다. 마켓 정보를 가져와서 보여주고 있습니다. 상단 헤더가 없으니, iOS 단말에서는 화면과 Status Bar이 겹쳐서 보입니. 하지만 Whan Dapp은 안드로이드 앱으로만 출시 할 것이라서, iOS에서는 화면이 이렇게 보여도 그냥 진행하고 있습니다. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon 이전글 WHAN APP 기획 개발 이야기 #1 WHAN APP 개발 이야기 #2 WHAN APP 개발 이야기 #3 WHAN APP 개발 이야기 #4 WHAN APP 개발 이야기 #5 WHAN APP 개발 이야기 #6 WHAN APP 개발 이야기 #7 Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"zzan 0.1% 이상 홀더인지 확인 하는 방법 ","slug":"/zzan/@anpigon/zzan-0-1","date":"2019-08-03T07:11:36.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/zzan-0-1/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/zzan-0-1/","excerpt":"안녕하세요. 안피곤입니다.ZZAN 스테이킹 0.1％ 이상 상위 홀더에 대한 기본 보팅 프로그램이 진행되고 있습니다. 이 보팅 프로그램 개발에는 원사마님이 고생 많이 하셨습니다.저는 지갑앱에 Effect Stake 항목을 추가하였습니다. 여기서 Effect Stake는 Stake + Delefated In 값입니다. 그리고 전체 스테이킹에 대한 Effect Stake 비율을 보여줍니다.","text":"안녕하세요. 안피곤입니다.ZZAN 스테이킹 0.1％ 이상 상위 홀더에 대한 기본 보팅 프로그램이 진행되고 있습니다. 이 보팅 프로그램 개발에는 원사마님이 고생 많이 하셨습니다.저는 지갑앱에 Effect Stake 항목을 추가하였습니다. 여기서 Effect Stake는 Stake + Delefated In 값입니다. 그리고 전체 스테이킹에 대한 Effect Stake 비율을 보여줍니다. 여기에서 확인 가능합니다. https://happigon.github.io/#/token/ZZAN Market Depth 차트 추가 Exchange 페이지에 Market Depth 차트를 추가하였습니다. 욕심은 캔들 차트를 추가하고 싶었습니다. 그런데 scot-api 에서 모든 거래 데이터를 조회할 수 있는 게 아니더군요. 2일 동안의 거래내역만 조회 가능한 것 같습니다. 그래서 캔들 차트를 포기하고 스팀 엔진과 동일하게 Market Depth 차트를 보여줍니다. 차트 구현에는 Highchart를 사용했습니다. ![](https://steemitimages.com/300x0/https://steemitimages.com/DQmT13qHqTU2Ra6MC8ucFrePXPqF21kQzkr72kedVoxRJLN/％EA％B5％AC％EB％B6％84％EC％84％A0_％EC％9B％94％EA％B3％84％EA％B4％80.png) 사실 happigon 앱은 해피베리보이님과 이야기하다가 재미로 만든 앱입니다. 그동안 학습한 React.js를 사용해보고, 또 scot-api를 연구하는 겸 만들어 보았습니다. 그런데 최근 scot-api가 많이 느려졌습니다. 그리고 응답 없음(timeout)도 너무 자주 발생해서 happigon 앱을 개발하는 게 재미있지가 않네요. scot-api 가 안정화될 때까지 더 이상 기능 추가는 안 할 생각입니다. 최근 제가 많이 바빠져서 개인적으로 코딩할 시간이 없는 부분도 있습니다. 휴가철이니 휴가도 가야하구요. ㅋ 그리고 Google 애널리틱스에서 확인하니 happigon 앱의 하루 평균 방문자 수는 10 ~ 20입니다. 사용자가 적지도 많지도 않네요. 구글 광고 배너를 넣을까 했는데 생각을 접었습니다. ㅎㅎ 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"본문 하단에 작가의 최근글 보기 기능 구현","slug":"/zzan/@anpigon/4kwmuf","date":"2019-07-31T14:21:57.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/4kwmuf/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/4kwmuf/","excerpt":"안녕하세요. 안피곤입니다.글을 읽고나서 이 작가의 글이 마음에 든다면 다음 글도 바로 읽고 싶지 않을까요?이 기능은 원사마님이 낸 아이디어입니다. 저도 구현되면 좋을 것 같아서 개발했습니다. 글 본문 하단에 작가님의 최근 글 10개를 보여주고 있습니다. 그리고 작가가 작성한 글이 없다면 보이지 않습니다.","text":"안녕하세요. 안피곤입니다.글을 읽고나서 이 작가의 글이 마음에 든다면 다음 글도 바로 읽고 싶지 않을까요?이 기능은 원사마님이 낸 아이디어입니다. 저도 구현되면 좋을 것 같아서 개발했습니다. 글 본문 하단에 작가님의 최근 글 10개를 보여주고 있습니다. 그리고 작가가 작성한 글이 없다면 보이지 않습니다. 아직 니트러스에는 반영되지 않았습니다. 제가 사용해 보고, 그리고 ZZAN 운영팀의 의견을 들어보고 반영하겠습니다. 개발서버에서 바로 확인 가능합니다. https://anpigon.herokuapp.com 아이디어를 모집합니다. 제가 생각한 아이디어는 kr 사용자에게 태그를 한글로 번역해서 보여주면 어떨까 생각하고 있습니다. 이렇게 하면 태그를 이용한 카테고리 분류를 좀더 명확하게 할 수 있지 않을까 생각했습니다. 이런 기능이 있으면 좋겠다 하시면 댓글을 달아주세요. 댓글은 제가 잘 메모해 놓겠습니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"SCOT 토큰 임대 정보를 볼 수 있는 앱을 개발한 이야기","slug":"/zzan/@anpigon/scot","date":"2019-07-29T13:49:24.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/scot/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/scot/","excerpt":"안녕하세요. 안피곤입니다.르바(rabggo)님의 요청으로 SCOT 토큰 임대 정보를 볼 수 있는 페이지를 개발했습니다. https://happigon.github.io/#/wallet/아이디로 접속하면 내 지갑 정보를 볼 수 있습니다.지갑 페이지에는 어떤 정보를 보여주는게 좋은지 잘 모르겠어요. 그래서 API에서 주는 정보는 최대한 보여주고 있습니다. 그런데 STEEM과 USD 가격을 같이 표시하니 정보가 너무 많아서 오히려 불편하네요. [STEEM/USD] 스위치 버튼을 넣어야 할 것 같아요. 참고로 저의 편의나 외부 요청에 의해서 UI는 자주 변경될 수 있습니다. .","text":"안녕하세요. 안피곤입니다.르바(rabggo)님의 요청으로 SCOT 토큰 임대 정보를 볼 수 있는 페이지를 개발했습니다. https://happigon.github.io/#/wallet/아이디로 접속하면 내 지갑 정보를 볼 수 있습니다.지갑 페이지에는 어떤 정보를 보여주는게 좋은지 잘 모르겠어요. 그래서 API에서 주는 정보는 최대한 보여주고 있습니다. 그런데 STEEM과 USD 가격을 같이 표시하니 정보가 너무 많아서 오히려 불편하네요. [STEEM/USD] 스위치 버튼을 넣어야 할 것 같아요. 참고로 저의 편의나 외부 요청에 의해서 UI는 자주 변경될 수 있습니다. . 샘플로 천사(sct1004)님의 지갑을 살펴보겠습니다. 남의 지갑을 함부로 훔쳐봐서 죄송합니다.ㅠㅠ 임대 정보는 Delegations 항목에서 ℹ️아이콘을 누르면 볼 수 있습니다. 예) https://happigon.github.io/#/wallet/sct1004 지갑 앱에서 구현된 기능은 다음과 같습니다. 총 자산 환산 가격(스팀, USD) 보유한 코인만 보기(스테이킹+잔액이 0 이상) 토큰(심볼) 검색 토큰 마켓 변동률/가격 토큰 총 자산(스테이킹+잔액+임대) 임대 정보 팝업 정렬 기능 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"⟪라이언킹 (2019)⟫ - 내셔널지오그래픽","slug":"/aaa/@wangpigon/ckt8b","date":"2019-07-28T04:24:12.000Z","updated":"2019-11-11T13:41:49.851Z","comments":true,"path":"/aaa/@wangpigon/ckt8b/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/ckt8b/","excerpt":"내셔널지오그래픽을 자주 보는 분들에게 적극 추천합니다.요즘은 동물도 연기를 너무 잘합니다. 그래서 놀랬습니다. 그리고 극장 분위기는 소극장 연극 관람하듯이 다 같이 깔깔깔 웃는 분위기였습니다. 그래서 또 놀랬습니다. 저는 디즈니 실사화 영화 중에서 라이언킹이 최고라고 생각하고 싶습니다.","text":"내셔널지오그래픽을 자주 보는 분들에게 적극 추천합니다.요즘은 동물도 연기를 너무 잘합니다. 그래서 놀랬습니다. 그리고 극장 분위기는 소극장 연극 관람하듯이 다 같이 깔깔깔 웃는 분위기였습니다. 그래서 또 놀랬습니다. 저는 디즈니 실사화 영화 중에서 라이언킹이 최고라고 생각하고 싶습니다. 저번주 주말에 애니매이션 라이언킹 감동의 향수를 품고 극장에 영화를 보러갔습니다. 영화는 원작에 정말 충실했습니다. 그리고 영화 도입부 유명한 장면의 영상은 제 기대 이상이었습니다. 다른 사람들 말처럼 정말 내셔널지오그래픽를 보는 것 같았습니다. 영화에는 노래와 음악이 정말 많이 나옵니다. 뮤지컬 영화를 보는 느낌입니다. 정말 라이온킹에는 명곡이 많습니다. 그리고 그 노래를 듣고 있으면 어릴적 추억이 생각납니다. 저는 아마도 한 동안 라이언킹 OST를 계속 들을 것 같습니다. 품바와 그의 단짝 티몬의 캐미도 너무 재미있습니다. 만약 이 둘이 없었다면 살짝 지루할 뻔했습니다. 이 둘을 주인공으로 하는 영화도 실사화 했으면 좋겠네요. 마지막으로 저는 보고 나서 어릴적 재미있게 했던, 라이언킹 게임이 생각났습니다. 혹시나 하고 안드로이드 마켓에 검색해보았습니다. 하지만 라이언킹 게임은 없습니다. ㅠ 이상 짧은 리뷰였습니다. 영화 URL: https://www.themoviedb.org/movie/420818-the-lion-king?language=ko-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"},{"name":"디즈니","slug":"디즈니","permalink":"https://anpigon.github.io/tags/디즈니/"}],"author":"wangpigon"},{"title":"니트러스에서 글작성시 미리보기가 오른쪽에 위치하면 좋을 것 같습니다.","slug":"/zzan/@anpigon/52wsdf","date":"2019-07-28T03:21:42.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/52wsdf/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/52wsdf/","excerpt":"안녕하세요. 안피곤입니다.인사가 많이 늦었습니다. 저는 최근에 스팀짱에 합류하여 같이 일하게 되었습니다.약 3주 전에 스팀짱에 기여한 &quot;[소수투고] 태그 선택 자동 입력 기능&quot;이 팀에 참여할 수 있게 된 계기가 되었을 것으로 생각합니다. 다른 분에 비해 실력이 부족해서 고민을 많이 했습니다. 하지만 좋은 분들과 같이 일하는 것이 이득이 될 것 같다는 생각에 참여하기로 하였습니다. 여유 시간이 많지 않아 풀타임 참여는 어렵습니다. 하지만 파트 타임으로 간단한 코드 기여는 할 수 있을 것 같네요.","text":"안녕하세요. 안피곤입니다.인사가 많이 늦었습니다. 저는 최근에 스팀짱에 합류하여 같이 일하게 되었습니다.약 3주 전에 스팀짱에 기여한 &quot;[소수투고] 태그 선택 자동 입력 기능&quot;이 팀에 참여할 수 있게 된 계기가 되었을 것으로 생각합니다. 다른 분에 비해 실력이 부족해서 고민을 많이 했습니다. 하지만 좋은 분들과 같이 일하는 것이 이득이 될 것 같다는 생각에 참여하기로 하였습니다. 여유 시간이 많지 않아 풀타임 참여는 어렵습니다. 하지만 파트 타임으로 간단한 코드 기여는 할 수 있을 것 같네요. 제가 생각하기에 니트러스 소스는 굉장이 복잡하고 어렵습니다. 코드를 봐도 잘 모르겠습니다. 그래서 가장 간단한 기능을 하나 수정했습니다. 미리보기가 아래쪽에 있어서 저도 불편했지만, 르바님도 한번 언급한 적이 있어서 바로 수정했습니다. 수정한 코드는 깃허브에 PR 해둔 상태입니다. 제 생각으로는 금방 반영 될 것 같습니다. PR: https://github.com/steem-engine-exchange/nitrous/pull/58 개발 중인 앱은 이곳에서 확인 가능합니다. https://anpigon.herokuapp.com 그리고 원사마님이 언급한 기능도 개발하고 싶은데, 사실 엄두가 안납니다. ㅠ 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"스팀엔진 토큰 DEX 거래소 개발 이야기","slug":"/zzan/@anpigon/dex","date":"2019-07-27T15:57:36.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/dex/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/dex/","excerpt":"안녕하세요. 안피곤입니다. 이번에도 재미있는 앱을 하나 만들었습니다. 앱 이름은 Happigon이라고 지었습니다. 서론제가 스팀잇을 시작하게 된 계기는 저자 보상 때문이었습니다. 지금도 여전히 그렇습니다. 다른 블로그에 올리는 것보다 스팀잇에 글을 올리면 보상이 100원이라도 발생했습니다. 그리고 블록체인 기술에 대한 관심도 한몫했습니다.","text":"안녕하세요. 안피곤입니다. 이번에도 재미있는 앱을 하나 만들었습니다. 앱 이름은 Happigon이라고 지었습니다. 서론제가 스팀잇을 시작하게 된 계기는 저자 보상 때문이었습니다. 지금도 여전히 그렇습니다. 다른 블로그에 올리는 것보다 스팀잇에 글을 올리면 보상이 100원이라도 발생했습니다. 그리고 블록체인 기술에 대한 관심도 한몫했습니다. 스팀로그(Steemlog) 앱 스팀잇을 처음 접했을 때 이곳은 너무 불편하고 촌스러운 UI를 가지고 있었습니다. 지금도 여전히 그렇습니다. 그리고 스팀 API을 이용해서 제가 좀 더 나은 플랫폼을 만들 수 있다는 생각도 했었습니다. 그래서 Steemlog 앱을 개발했었습니다. 아래가 그 결과물입니다. 사실 개발하는 도중에 busy와 steempeak를 알게 되면서, 개발을 중단했습니다. 이게 벌써 1년 전이네요. ㅎㅎ [https://steemlog.github.io](https://steemlog.github.io) ![](https://files.steempeak.com/file/steempeak/anpigon/KC2g6Dp4-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-07-2720E1848BE185A9E18492E185AE2010.20.36.png) 스팀잇 펫 연구소 그다음에 스팀잇 보팅을 연구하면서 재미난 앱을 하나 만들었습니다. 바로 스팀잇 펫 연구소입니다. 원래 계획은 부계정을 생성하면서 펫을 하나씩 늘려나갈 계획이었습니다. 스팀잇에 HF20이 업데이트된 후, 흥미를 잃고 개발을 중단했습니다. 만든 지 오래되었지만, 아직도 연구소를 꾸준하게 이용하는 사람이 있네요. 만들 당시에는 거북이랑 토끼가 보팅해주는 금액이 합치면 $0.001였는데, 이제는 $0.0005가 되어버렸네요.ㅎㅎ [https://anpigon.github.io/pet/](https://anpigon.github.io/pet/#/)![](https://files.steempeak.com/file/steempeak/anpigon/3ar4ix6B-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-07-2820E1848BE185A9E1848CE185A5E186AB2012.05.34.png) 스팀잇 커뮤니티 그다음은 스팀잇에 등록된 글 분류와 개인 블로그가 최대 관심사였습니다. 글 분류는 AI로 풀어보려고 머신러닝을 학습했었습니다. 결국에는 복잡하고 어려운 머신러닝을 구현하는 대신 태그 기반으로 글을 분류했습니다. 글을 분류해서 제공하기 위해서는 결국 API 서버가 필요합니다. 저는 개인적으로 나가는 비용이 아까워 최대한 무료 서비스를 이용해서 시스템을 구축했습니다. 결국 무료 DB 서버 계정이 차단당했습니다. 아무래도 스팀 블록을 모니터링하면서 실시간으로 데이터를 insert 했던 부분이 원인이 되지 않았을까 생각합니다. 계획했던 것보다 개발을 빨리 포기했습니다. [https://anpigon.github.io/steemit-community](https://anpigon.github.io/steemit-community) ![](https://files.steempeak.com/file/steempeak/anpigon/VtEbcVkG-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-07-2720E1848BE185A9E18492E185AE2010.06.18.png) 본론 서론이 길었습니다. 최근 니트러스가 다수 등장하면서 스팀잇 태그의 글을 분류 기능은 거의 상실했습니다. 읽고 싶은 글만 필터링해서 보는 것이 더 어려워졌습니다. 그리고 스팀잇에서 채굴이나 SCOT토큰에 관한 글이 많이 보입니다. 그래서 저도 요즘은 SCOT 토큰 관련 앱 개발에 재미를 느끼고 있습니다. 최근에 토큰 정보(홀더계정, 오더북, 거래이력)을 볼 수 있는 앱을 의뢰받았었습니다. 참고로 해당 앱 개발은 드랍했습니다. 그런데 개발을 하다 보니 약간의 욕심이 생겼습니다. 그래서 개발하던 코드를 재활용하여 재미있는 앱을 개발했습니다. 앱 이름은 Happigon 입니다. Happigon은 해피베리보이님과 채팅하다가 갑자기 생각난 이름입니다. Happy + Pigon = Happygon 입니다. 그런데 Github 계정을 생성하려고 하니 Happygon이 있습니다. 그래서 그냥 Happigon으로 만들었습니다. [https://happigon.github.io/](https://happigon.github.io/)![](https://files.steempeak.com/file/steempeak/anpigon/lKg8bp72-1.png) 개발할 시간만 충분히 있다면 이 앱에 커뮤니티와 지갑 기능도 구현해보고 싶네요. 그리고 가능하다면 부르주아의 끝을 보여주는 커뮤니티를 만들어보고 싶어요. 빈부 격차를 매우 심하게 보여줄 겁니다. 예를 들면 축적한 보유 자산에 따라서 UI가 다르게 보입니다. 스팀 파워 + 스팀 잔액이 15이하는 UI가 없을 수도 있습니다. 그리고 계급에 따라 사용할 수 있는 기능이 제한됩니다. 사실 이 앱도 개발하다가 중단될 가능성이 매우 큽니다. steem-engine API가 불안정해서 개발하기 너무 불편합니다. 최근 야근이 많아져서 수면시간이 줄었습니다. 그래서 피로가 누적되어 피곤함을 많이 느끼고 있습니다. 다시 한번 왕피곤으로 변신할 때가 온 것 같습니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #7","slug":"/zzan/@anpigon/20190721033641041z","date":"2019-07-21T03:36:42.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/zzan/@anpigon/20190721033641041z/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/20190721033641041z/","excerpt":"안녕하세요. 안피곤입니다.이전에 개발했던 지갑 기능을 Whan Dapp 앱에 포함시켰습니다. 원래 Whan Dapp은 커뮤니티 기능에 집중해서 개발하려고 생각했습니다. 하지만 지금은 제가 필요한 기능을 그냥 막 넣고 있습니다. 이러다가 커뮤니티 앱도 지갑 앱도 아닌 짬뽕 앱이 될 것 같습니다. 짬짜면 같은 앱을 만들고 싶습니다.","text":"안녕하세요. 안피곤입니다.이전에 개발했던 지갑 기능을 Whan Dapp 앱에 포함시켰습니다. 원래 Whan Dapp은 커뮤니티 기능에 집중해서 개발하려고 생각했습니다. 하지만 지금은 제가 필요한 기능을 그냥 막 넣고 있습니다. 이러다가 커뮤니티 앱도 지갑 앱도 아닌 짬뽕 앱이 될 것 같습니다. 짬짜면 같은 앱을 만들고 싶습니다. 사실 전 단순한 디자인과 단순한 기능을 가지고 있는 앱을 더 선호하는 편입니다. 복잡한 UI와 복잡한 기능은 앱을 사용하기 어렵게 만들기 때문입니다. 하지만 혼자서 이것 저것 앱을 다 개발할 시간이 없으니, 모든 필요한 기능을 하나의 앱에 다 구현할 계획입니다. 완벽한 기획이나 설계를 통해 방향을 잡고 개발하고 있지는 않습니다. 그냥 생각나는 기능이 있으면 개발하고 있습니다. 또는 스팀잇에 포스팅하기 위해서 개발하고 있다고 생각해도 됩니다. 개발하면서 업보팅이라도 받아야지 개발하고 싶은 의욕이 조금이라도 생기네요. ㅋ 그리고 저는 PC보다는 스마트폰에서 스팀잇을 더 자주 이용하는 편입니다. 제가 바로 스마트폰이 만든 신인류 **포노 사피엔스(Phono Sapiens)**에 해당합니다. 금융 업무부터 시작해서, 간편결제, 전자책, 커뮤니티 활동 등 대부분을 스마트폰에서 이용합니다. 생각해보니 완댑은 제가 필요하기 때문에 개발하고 있네요. Nitrous에서 토큰 보상주는 태그 현재2019.7.21 Scot에는 토큰 보상을 받을 수 있는 태그가 총 26개가 존재합니다. 26개 태그 모두 입력하여 글을 작성해 보고 싶어요. ㅋ 현재 완댑에서는 커뮤니티를 구분을 SCOT TAG 태그 기준으로 구분하고 있습니다. 하지만 이제는 태그로 커뮤니티를 구분하는 것이 의미가 없습니다. 왜냐하면, 각 커뮤니티의 글 목록이 대부분 비슷합니다. 저를 포함한 많은 분이 토큰 보상을 받을 수 있는 태그를 다수 입력하기 때문입니다. 하여튼 이제 태그로 커뮤니티를 구분하는 것은 의미가 없다고 생각합니다. 그래서 제가 생각하는 나름의 규칙을 바탕으로 카테고리 분류를 해볼 생각입니다. 그리고 요즘 Nitrous에서 태그를 10까지 입력해서 그런지는 모르겠지만, API에서 해당 태그의 글을 제대로 못 가져 오고 있습니다. 예를 들면, 팥쥐암호님이 5일 전에 작성한 책 리뷰글이 최신 글 목록에 표시되지 않습니다. #book 태그의 최신 글에는 단지 2개의 글만 보입니다. 이 오류는 커뮤니티에서 매우 치명적이라고 생각합니다. 그리고 저는 5개 이상의 태그 입력이 원인이라고 생각하고 있습니다. 정확한 원인을 아는 분은 알려주세요. ㅎ Whan Dapp 개발 내용 다음은 지갑 앱 화면입니다. 이전에 구현했던 UI가 마음에 들지 않아서 몇 번을 갈아엎었습니다. 아래가 완성된 화면입니다. 지금은 송금, 파워업/다운, 임대 등 기능은 구현되어 있지 않습니다. 언젠가는 구현되겠죠. ㅎㅎ 코인마켓캡 기준으로 현재 STEEM/SBD 가격과 최근 일주일간의 그래프를 보여줍니다. 그리고 스팀과 스팀 엔진 지갑의 총 자산 보유금액(USD)를 각각 보여줍니다. 마지막으로 스팀 엔진 토큰의 자산, 잔액, 스테이킹, 마켓 가격(전일 대비 변동률), 하루 거래량 등을 보여줍니다. GIF는 용량을 최대한 줄이다 보니 화질 저하가 많이 발생하였습니다. Whan Dapp이 유용할 거라고 생각되면 댓글, 팔로우, 좋아요 많이 해주세요. 댓글, 팔로우, 좋아요 해 주시는 모든 분께 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon 이전글 WHAN APP 기획 개발 이야기 #1 WHAN APP 개발 이야기 #2 WHAN APP 개발 이야기 #3 WHAN APP 개발 이야기 #4 WHAN APP 개발 이야기 #5 WHAN APP 개발 이야기 #6","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #6","slug":"/zzan/@anpigon/react-native-whan-app-6","date":"2019-07-18T03:50:21.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/zzan/@anpigon/react-native-whan-app-6/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-whan-app-6/","excerpt":"안녕하세요. 안피곤입니다.간만에 업데이트 했습니다. 이번에는 사용자 프로필 화면을 추가했습니다. 상단에서 팝업 메뉴에서 Profile을 선택하면 내 프로필 화면으로 이동합니다. 그리고 글 목록에서 저자를 클릭하면 저자의 프로필 화면으로 이동합니다.아래 스크린샷도 첨부합니다. 아이언맨 프로필이 너무 멋져서 리얼맨권님 프로필 화면 스샷을 같이 첨부했습니다. ㅋ 요즘 SCT에서 열일하시는 모습이 존경스럽습니다.","text":"안녕하세요. 안피곤입니다.간만에 업데이트 했습니다. 이번에는 사용자 프로필 화면을 추가했습니다. 상단에서 팝업 메뉴에서 Profile을 선택하면 내 프로필 화면으로 이동합니다. 그리고 글 목록에서 저자를 클릭하면 저자의 프로필 화면으로 이동합니다.아래 스크린샷도 첨부합니다. 아이언맨 프로필이 너무 멋져서 리얼맨권님 프로필 화면 스샷을 같이 첨부했습니다. ㅋ 요즘 SCT에서 열일하시는 모습이 존경스럽습니다. 그리고 이전에 개발했던 Whan Wallet 앱에서 보유 코인과 환산 가격을 보여줬습니다. 이 기능을 가져와서 Whan Dapp에 포함할 계획입니다. 요즘 어떻게 하면 좀더 편하게 모바일앱에서 스팀잇을 이용할 수 있을까 고민을 많이 하고 있습니다. 그리고 전 요즘 SCOT 토큰 모으는 재미에 스팀잇을 하고 있습니다. 그래서 보유하고 있는 SCOT 토큰을 Whan Dapp에서 확인 할 수 있는 기능 구현에 집중할 생각입니다. 최근에 스팀 가격이 많이 떨어져서 속상합니다. 하지만 스팀에서 앞으로 재미있는 일들이 많이 발생할 것 같습니다. ScrollView에서 무한 스크롤 구현하기 상단 프로필 영역과 글 목록을 같이 스크롤링 하기위해서 ScrollView를 사용했습니다. 그래서 글 더 보기 기능에서 FlatList.onEndReached를 사용하지 않고 ScrollView.onScroll 를 사용했습니다. 그래서 onScroll에서 화면 높이를 계산해서 글 더보기 함수 onLoadMore()를 호출하고 있습니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #5","slug":"/zzan/@anpigon/react-native-whan-app-5","date":"2019-07-14T11:39:06.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/zzan/@anpigon/react-native-whan-app-5/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-whan-app-5/","excerpt":"안녕하세요. 안피곤입니다.며칠 전에 React Native 버전 0.60.2가 릴리즈 되었습니다. v0.60.2 버전에는 Chain React Conf 2019에서 발표된 Hermes JavaScript Engine이 포함되었습니다. Hermes는 React Native 앱을 실행하기 위해 최적화된 자바 스크립트 엔진입니다. Hermes를 사용하면 앱 시작 시간이 빨라지고 메모리 사용량이 줄고 앱 크기가 줄어듭니다. (참고: https://facebook.github.io/react-native/docs/hermes)","text":"안녕하세요. 안피곤입니다.며칠 전에 React Native 버전 0.60.2가 릴리즈 되었습니다. v0.60.2 버전에는 Chain React Conf 2019에서 발표된 Hermes JavaScript Engine이 포함되었습니다. Hermes는 React Native 앱을 실행하기 위해 최적화된 자바 스크립트 엔진입니다. Hermes를 사용하면 앱 시작 시간이 빨라지고 메모리 사용량이 줄고 앱 크기가 줄어듭니다. (참고: https://facebook.github.io/react-native/docs/hermes) 그리고 다음은 v0.60.x의 주요 변경 사항입니다. AndroidX support (this will be a Breaking Change!) Full removal of WebView &amp; Geolocation, you now need to rely on the extracted versions CocoaPods integration by default Autolinking of packages React Native 코어에서 WebView와 Geolocation가 제거 되었습니다. 이제 WebView은 별도로 설치해서 사용해야합니다. (참고: https://github.com/react-native-community/react-native-webview, https://github.com/react-native-community/react-native-geolocation) https://github.com/react-native-community 를 들어가보면 아시겠지만, 대부분의 모듈이 React Native에서 분리되었습니다. 라이브러리 크기가 점점 커져서 어쩔수 없는 선택이라고 생각합니다. 그리고 제가 사용하고 있는 FastImage 라이브러리도 몇 일전에 React Native 0.60.0에 대응하여 CocoaPods와 Android X 패치가 적용되었습니다. (참고: https://github.com/DylanVann/react-native-fast-image/commit/5489f9ec4bbc80c657ac351130771637d1f61672) Hermes 엔진을 사용하고 싶었습니다. 그래서 개발하고 있는 Whan Dapp도 React Native 버전 0.60.2으로 업그레이드하려고 시도했습니다. 하지만 Android X를 아직 지원하지 않는 라이브러리가 있어서 빌드에서 오류가 발생합니다. ㅠㅠ 다행이 stackoverflow 에서 해결 방법을 찾았습니다. (참고: https://stackoverflow.com/a/56956104) jetifier를 사용하여 node_modules 라이브러리를 AndroidX 로 변환하였습니다. 이 방법으로 빌드에는 성공했습니다. 하지만 실행하자마자 앱이 죽고 화면이 백지에서 넘어가지 않는 등… 심각한 오류가 발생합니다. 그래서 다시 React Native 0.59.x로 다운그레이드 하였습니다. ㅠㅠ 아직 스킬이 많이 부족하다고 생각이 들었습니다. 그리고 금일 다음 기능을 Whan Dapp에 추가하였습니다. 아직 구글 플레이 스토어에 배포는 하지 않았습니다. 오늘 밤이나 내일 중에 할 것 같습니다. 댓글 수정 기능 이제 내가 작성한 댓글을 수정할 수 있습니다. 내가 만든 댓글 수정 기능을 테스트하면서 햅뽀이님이 만든 happy-pick을 테스트했습니다. ㅋ 햅뽀이님의 happy-pick도 많이 이용해주세요. - 관련글: “happy-pick 추첨기능 한번 이용해보세요.(wdice와 유사한 기능입니다.)” 업보팅 기능 업보팅 기능을 추가하였습니다. 다음번 업데이트에는 좀 더 보완해서 토큰별 보팅 파워를 보여줄 계획입니다. 본문에 사용된 태그를 파악하여 토큰별 보팅 파워와 토큰 수량 정보를 보여주면 매우 편리할 것 같습니다. 참고로 아직 다운 보팅이나 보팅 취소 기능은 없습니다. 활동(Activties) 내역 사용자 메뉴에서 activties 메뉴를 선택하면 Activties 화면으로 이동합니다. 아직 Activtiy 상세 내역 화면을 구현하지 않았습니다. 그래서 Activties 목록 중 하나를 선택하면 브라우저가 실행되면서 스팀잇 사이트로 이동합니다. 검색 제가 필요하다고 생각하여 검색 기능을 추가하였습니다. 아직 검색 기능이 많이 미흡합니다. 차츰 업그레이드해볼 계획입니다. 가능할지는 잘 모르겠습니다. 스팀잇은 검색 엔진이 없기 때문에 구글 검색에 의존하고 있습니다. 포스팅, 댓글 검색이 가능합니다. 차후 @사용자 검색과 #태그 검색을 추가할 계획입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"[소설] 더글라스 케네디 ⟪더 잡⟫","slug":"/zzan/@wangpigon/727v8a","date":"2019-07-13T15:46:33.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"/zzan/@wangpigon/727v8a/","link":"","permalink":"https://anpigon.github.io/zzan/@wangpigon/727v8a/","excerpt":"&quot;다시 성공하겠다는 마음만 있다면 반드시 다시 성공한다! 『더 잡』 은 약 560 페이지의 약간 두꺼운 소설입니다. 그리고 1부, 2부, 3부로 나누어져있습니다. 너무 재미있어서 이틀만에 다 읽어버렸습니다. 스토리가 진행되는 중반부터 눈을 땔수가 없었습니다. 전체적인 줄거리는 더글라스 케네디 소설 중 『템테이션』과 비슷하다고 생각합니다.","text":"&quot;다시 성공하겠다는 마음만 있다면 반드시 다시 성공한다! 『더 잡』 은 약 560 페이지의 약간 두꺼운 소설입니다. 그리고 1부, 2부, 3부로 나누어져있습니다. 너무 재미있어서 이틀만에 다 읽어버렸습니다. 스토리가 진행되는 중반부터 눈을 땔수가 없었습니다. 전체적인 줄거리는 더글라스 케네디 소설 중 『템테이션』과 비슷하다고 생각합니다. 소설은 맨해튼의 비즈니스 세계를 배경으로 합니다. 그리고 90년대 중반 자주 뉴스에 자주 오르내렸던 구조조정, 빅딜, 적대적 M&amp;A, 정리해고 등의 내용을 다루고 있습니다. 주인공 네드 앨런은 뉴욕에서 성공한 세일즈맨입니다. 그는 우수한 능력을 인정받고 급속 승진을 하며 승승장구합니다. 하지만 그가 근무하는 《컴퓨월드》가 적대적 M&amp;A를 통해 경쟁 회사에 인수합병을 당합니다. 그 과정에서 네드는 불쌍한 희생양이 됩니다. 그리고 정리해고 과정에서 네드는 상사를 폭행하면서 실패의 나락으로 끝없이 추락합니다. 그런 네드에게 고교 동창생 제리가 구원의 손길을 내밉니다. 하지만 구원의 손길인 줄 알았던 제리가 네드를 각종 범죄에 연루시키면서 점점 악의 구렁텅이로 빠트리는데… 이야기는 반전에 반전을 거듭하며 계속 긴장하게 만듭니다. 이 긴장감 때문에 마지막까지 손에서 책을 놓을 수가 없었습니다. 하지만 결말이 조금 아쉬웠습니다. 그리고 책의 마지막 문장이 마음에 들었습니다. 커피를 앞에 두고 다른 사람과 함께 앉아 있을 때, 그 순간은 언제나 새로운 시작이다. 별점: ⭐️⭐️⭐️⭐️","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"더글라스 케네디","slug":"더글라스-케네디","permalink":"https://anpigon.github.io/tags/더글라스-케네디/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"}],"author":"wangpigon"},{"title":"그 동안의 스팀잇 활동을 돌아보며...","slug":"/zzan/@anpigon/czw7w","date":"2019-07-13T13:55:15.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/czw7w/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/czw7w/","excerpt":"안녕하세요. 안피곤입니다.작년에 스팀잇을 시작하던 시기에는 블록체인, 머신러닝, Front-End(Vue.js)에 모두 관심을 가지고 있었습니다. 이 중에서 머신러닝과 블록체인에 가장 흥미가 있지만, 이 분야는 학습하고 이해하는데 정말 어려웠습니다.그나마 상대적으로 학습하기 쉬운 Front-End 분야는 하면 할수록 점점 더 재미있습니다. 작년에 Vue.js를 배우면서 React.js를 처음 알게 되었습니다. 그리고는 Vue.js를 버리고는 React.js로 갈아탔습니다. React.js 강의 자료가 훨씬 더 많았기 때문입니다. 그리고 지금은 React Native가 가장 재미있습니다.","text":"안녕하세요. 안피곤입니다.작년에 스팀잇을 시작하던 시기에는 블록체인, 머신러닝, Front-End(Vue.js)에 모두 관심을 가지고 있었습니다. 이 중에서 머신러닝과 블록체인에 가장 흥미가 있지만, 이 분야는 학습하고 이해하는데 정말 어려웠습니다.그나마 상대적으로 학습하기 쉬운 Front-End 분야는 하면 할수록 점점 더 재미있습니다. 작년에 Vue.js를 배우면서 React.js를 처음 알게 되었습니다. 그리고는 Vue.js를 버리고는 React.js로 갈아탔습니다. React.js 강의 자료가 훨씬 더 많았기 때문입니다. 그리고 지금은 React Native가 가장 재미있습니다. 작년 7월쯤에 스팀잇에서 활동하기 시작했습니다. 그리고 이제 스팀잇에서 시작한 지 약 1년 정도 되었습니다. 처음 스팀잇을 알게 되었을 때, 글을 작성하면 보상이 생기는 스팀잇 플랫폼이 무척 매력적이었습니다. 그래서 스팀잇에 많은 글을 올렸습니다. 그리고 이전보다 더 많은 결과물을 생산했습니다. 스팀잇 이전에는 티스토리에 구글 광고를 붙여서 블로그를 운영했었습니다. 하지만 출금 가능 최소 금액에 도달하지 못해서 한 번도 출금해본 적이 없습니다. 그리고 약 3달 전에는 Whan Team에 합류하면서 능력(개발)자들을 알게 되었습니다. 현재 Whan 팀에 속해있는 개발자그맨 들과 대화하면 무척 재미있습니다. 그리고 이분들과 함께 있으면 생산력이 2.5배가 됩니다. 다들 너무 열심히 하셔서 항상 제가 뒤처지는 느낌을 받습니다. 스팀잇을 활동하면서 얻은 가장 큰 선물라고 생각합니다. 마지막으로 스팀잇에서 그동안 활동했던 흔적을 돌아봤습니다. 그리고 제가 올렸던 글을 시리즈별로 정리했습니다. 날씨 앱 만들기 리액트 네이티브를 맨 처음 학습하면서 만들었던 첫 모바일앱입니다. 위치 기반으로 현재 날씨를 보여주는 입니다. 디자인이 정말 뷰티풀 합니다. 이 강의를 듣기 시작하면서 리액트 네이티브 매력에 빠지기 시작했습니다. ㅋ [React Native] 리액트 네이티브 시작하기 [React Native] 리액트 네이티브 날씨앱 만들기 #1 [React Native] 리액트 네이티브 날씨앱 만들기 #2 [React Native] 리액트 네이티브 날씨앱 만들기 #3 [React Native] 리액트 네이티브 날씨앱 만들기 #4 TO-DO 앱 만들기 리액트 네이티브 학습하고 만든 두 번째 모바일앱입니다. 이 앱을 마지막으로 그다음부터는 제가 만들고 싶은 앱을 만들기 시작했습니다. 이것 다음에 무비 앱도 만들었는데 시리즈 글은 작성하지 않았네요. “리액트 네이티브로 무비앱을 만들어서 스토어에 올렸어요!” [React Native] 리액트 네이티브 TO-DO 앱 만들기 #1 [React Native] 리액트 네이티브 TO-DO 앱 만들기 #2 [React Native] 리액트 네이티브 TO-DO 앱 만들기 #3 [React Native] 리액트 네이티브 TO-DO 앱 만들기 #4 [React Native] 리액트 네이티브 TO-DO 앱 만들기 #5 인스타그램 UI 모바일앱 만들기 스팀잇을 인스타그램 UI처럼 만들고 싶어서 유튜브 무료 강의를 보면서 따라 만들었습니다. 아직 스킬이 부족해서 그 이상의 기능은 업데이트는 못했습니다. 지금 생각하면 많이 아쉽습니다. 이 시리즈 이후부터 리액트 네이티브 스킬을 올리기 위해 부지런히 노력했습니다. [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 이더리움 모바일 지갑앱 만들기 제가 보유하고 있는 다양한 코인들을 하나의 지갑 앱에서 관리하고 싶어서 만들기 시작했습니다. 이더리움 지갑 앱을 시작으로 비트코인, 이오스, 트론, 스텔라 루멘 등 코인을 하나의 앱에서 관리하는 지갑 앱을 만들고 싶었습니다. 하지만 만들다 보니 블록체인마다 규격이 너무 다릅니다. 그래서 앱 구조가 점점 복잡해지고 구현 난이도가 너무 높아졌습니다. 그리고 블록체인마다 다른 UI를 어떻게 표현해야 할지가 제일 고민이었습니다. 비트코인 잔액(UTXO) 조회, 네트워크 수수료 조회, 블록체인 트랜잭션 모니터링 등… 앞으로 구현해야 할 기술적 부채도 있습니다. 그리고 마켓에 검색해보면 훌륭한 모바일 지갑 앱이 다수 존재합니다. 그래서 지갑 앱 구현은 이 정도 구현 수준에서 마무리했습니다. 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #1 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #2 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #3 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #4 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #5 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #6 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #7 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #8 - 배포하기 Steem 모바일 지갑앱 만들기 이때쯤 다양한 SCOT 토큰들이 등장했습니다. SCOT 토큰 잔액을 모바일앱에서 확인하고 싶어서 시작했습니다. 바로 이더리움 지갑을 개발하면서 얻은 경험을 바탕으로 금방 구현할 것 같았습니다. 하지만 scot-api가 너무 불안정했습니다. 잦은 HTTP 404 오류와 json 파싱 오류가 심각했습니다. 지금 스팀과 토큰 잔액 조회 기능 외에는 구현되어 있지 않습니다. 시간 날 때마다 가끔씩 코드를 들여다보며 기능을 조금씩 추가하고 있습니다. 하지만 지갑 개발에 시간을 많이 할애하지 않아서 진도는 거의 안 나가고 있네요. 그리고 개발의신👑원사마님께서 스팀 지갑을 개발하기 시작했으니, 저의 Steem 모바일 지갑 앱 만들기 시리즈는 여기서 마무리합니다. 원사마님 화이팅입니다. - 참고글: “원사마님의 [flutter] 스팀 지갑 개발 #001 - START” Steem 모바일 지갑앱 만들기 #1 Steem 모바일 지갑앱 만들기 #2 Steem 모바일 지갑앱 만들기 #3 Steem 모바일 지갑앱 만들기 #4 STEEM/SCT 보팅파워(VP) 안드로이드 위젯 만들기 각 Nitrous의 보팅 파워를 모바일에서 확인하기 위해 개발을 시작했습니다. 리액트 네이티브로 개발하기 시작했지만, 기술적인 문제로 결국 안드로이드 Java로 다시 구현했습니다. Android Oreo 버전부터 백그라운드 제약이 심해져서 조금 힘들었던 프로젝트였습니다. 지금은 개인적으로 Whan 팀원들의 보팅 파워를 모니터링하고 감시하는데 사용하고 있습니다. 팀원들의 보팅 파워가 떨어지면 CHEER UP 해주고 있습니다. STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #1 STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #2 - 앱 업데이트 이야기 STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #3 - Doze와 앱 대기(App Standby) 이야기 STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #4 - 마지막 업데이트 이야기 영화 리뷰 모바일 앱 개발 이야기 저는 소설책과 영화 보는 것을 매우 좋아합니다. 그래서 Triple A 커뮤니티가 오픈했을 때 기존에 만들고 있던 도서 리뷰 앱을 영화 리뷰 앱으로 바꾸어 시리즈를 연재했습니다. 도서 리뷰 앱은 만들기 바빠서 스팀잇에 글을 안 올렸네요. ㅎㅎ 구현하면서 어떻게 하면 사용자들이 영화 리뷰를 쉽게 올리고 리뷰를 편하게 볼 수 있을까 고민을 했습니다. 그래서 다른 영화 리뷰 모바일앱들을 벤치마킹하면서 UI 고민을 정말 많이 했습니다. 스팀 블록체인 위에 동작하는 앱 UX를 기획하는 건 쉽지 않네요. 욕심은 왓챠같은 앱을 만들고 싶으나 기획 방향을 틀어야 할 것 같습니다. 결국은 아이디어가 부족해서 잠시 시리즈 진행을 멈췄습니다. 여기서 기획 스킬의 부족함을 절실히 느꼈습니다. 하지만 아이디어 영감이 떠오르면 다시 진행할 계획입니다. ps. 또한 만드시는 과정을 지켜보는 분이 계셔서 큰 부담이 작용한 것 같습니다. 엄청난 앱을 만들어야하는데 그게 잘 안되네요. ㅎㅎ 영화 리뷰 모바일 앱 개발 이야기 #1 영화 리뷰 모바일 앱 개발 이야기 #2 영화 리뷰 모바일 앱 개발 이야기 #3 영화 리뷰 모바일 앱 개발 이야기 #4 WHAN APP 개발 이야기 최근에 오픈한 LIV 커뮤니티는 Nitrous UI를 일반 게시판처럼 바꿔버렸습니다. 여기서 아이디어를 얻었습니다. 그래서 스팀잇을 블로그나 SNS가 아닌 게시판이라는 관점으로 바라보고 개발하기 시작했습니다. 모두의 커뮤니티 모바일앱을 벤치마킹했습니다. 한동안은 이 시리즈를 계속 연재할 생각입니다. 많은 관심 바랍니다. 제 앱에 큰 관심을 보여주신 philhyuntd님 너무 감사합니다. 단순히 앱 개발 시리즈로 끝날 뻔한 Whan Dapp을 살려주셨습니다. 그리고 적극적으로 테스트해주셔서 감사합니다. - “WHAN Dapp 첫 테스트” 앞으로 philhyuntd님은 묻지도 따지지도 않고 풀보팅하겠습니다. ㅋ 보팅 파워가 작아서 금액이 적지만 언젠가 커지겠죠. ㅎㅎ WHAN APP 기획 개발 이야기 #1 WHAN APP 개발 이야기 #2 WHAN APP 개발 이야기 #3 WHAN APP 개발 이야기 #4 오픈소스 활동 올 상반기에 오픈소스에 기여했던 내용입니다. 이전에 잘 사용했던 스팀 툴을 다시 살리고 싶어서 시작했습니다. 첫 번째 타깃이 해피 베리 보이님의 스팀 툴이었습니다. 햅보이님께 스팀 툴을 업그레이드해보자고 조심스럽게 손을 내밀었는데 그 손을 꽉 잡아주셔서 감사합니다. 그리고 steeme와 steem.apps도 버리기 너무 아까워 소스를 포크 하여 제가 기능을 추가했습니다. 이 두 앱은 스팀잇을 처음 시작할 때부터 시작해서 지금도 잘 사용하고 있는 앱입니다. 그리고 ayogom님, realmankwon님 영향으로 Nitrous에 소스 투고도 하였습니다. Nitrous는 기능 추가보다 우선 UI부터 바꿨으면 좋겠습니다. ㅋ [Steem Tools] 크롬 익스텐션 개발 : 커스텀 폰트 기능 추가 [Steem Tools] 크롬 익스텐션 개발 : 스팀 엔진 토큰 목록 추가 nhj12311님이 만든 steem.apps에 #aaa, #stc 태그 추가. nhj12311님이 만든 steem.apps에 토큰 보상을 추가. asbear님이 만든 steeme에 티스토리 업로드 기능 추가. [소스투고] SCT 소스 수정 : 임대 금액 표시 오류(NaN) 수정 [소스투고] SCT 소스 수정 : SCT 앱 아이콘 표시 기능과 토큰(Token) 잔액 Style 변경 [소스 투고] Nitrous 태그를 색상으로 구분하기 [소스 투고] Steemzzang 태그 선택 자동 입력 기능 긴 글을 읽어주셔서 감사합니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #4","slug":"/zzan/@anpigon/react-native-whan-app-4","date":"2019-07-11T02:05:21.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/zzan/@anpigon/react-native-whan-app-4/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-whan-app-4/","excerpt":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.어느 정도 기본 기능(로그인, 글쓰기)이 완성됬다고 판단하여, 내부 테스트를 진행하고 있습니다. 앱개발을 완료했을때 실사용자가 있을지는 모르겠습니다. 하지만 필요한 앱이라고 생각해서 개발을 진행하고는 있습니다.","text":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.어느 정도 기본 기능(로그인, 글쓰기)이 완성됬다고 판단하여, 내부 테스트를 진행하고 있습니다. 앱개발을 완료했을때 실사용자가 있을지는 모르겠습니다. 하지만 필요한 앱이라고 생각해서 개발을 진행하고는 있습니다. *** 그리고 제 기분에 따라서 언제든지 개발이 중단될 수 있습니다. 왜냐하면 스팀잇에 시리즈 글을 연재하기 위해서 개발하고 있기 때문입니다. 다른 개발 시리즈도 연재하고 싶네용. ㅋ 테스트 하고 싶으신 분은 구글 계정을 저에게 알려주시면 됩니다. 테스트 그룹에 등록하겠습니다. 참고로 참여하셔도 아무런 혜택은 없습니다. ㅋ 테스트 앱 다운로드 링크: https://play.google.com/apps/internaltest/4698408089604846898 다음은 앱을 구동하여 글을 작성하고 댓글을 쓰는 화면입니다. 해당 커뮤니티에서 글을 작성하면 메인 태그는 자동으로 입력됩니다. 예를 들어 zzan 탭에서 작성하면 메인태그는 #zzan이 됩니다. 기본 기능만 개발하고 시리즈를 끝내려고 했습니다. 하지만 만들다보니 점점 욕심이 생깁니다. 이전글 SNAX토큰 에어드랍받기 위한 글 : WHAN APP 기획 개발 이야기 [React Native] WHAN APP 개발 이야기 #2 [React Native] WHAN APP 개발 이야기 #3 ![](https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmNpcHsY4vBGAxKez3HgK3B9k1MouVQ2YSqCHHVFi4QvPD/newLOGO_％EC％96％87％EC％9D％80.png) 개발 내용 댓글을 작성하고 화면을 새로고침 했을때 댓글이 바로 보이지 않습니다. 아마도 블럭생성되고 나서 보이는듯 합니다. 그래서 작성된 댓글을 이전 화면의 콜백함수로 전달하여 다시 렌더링하도록 구현했습니다. 텍스트로 설명하려니 어렵네요. 다음은 상세 화면에서 댓글 작성 화면으로 이동하는 코드입니다. 코드를 보면 onUpdate에 콜백함수를 param에 담아서 이동하고 있습니다. _onGoReplyEditorCallback 함수는 댓글을 인자값으로 받아서 화면을 렌더링 하는 로직을 수행 할 것입니다. 그 다음 댓글 등록이 완료되면, 이전 화면에서 넘겨받은 콜백 함수를 호출하여 이전 화면을 업데이트 합니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"[소수투고] 태그 선택 자동 입력 기능 ","slug":"/zzan/@anpigon/7e4ab827f87e8","date":"2019-07-09T06:46:54.000Z","updated":"2019-11-11T13:41:49.834Z","comments":true,"path":"/zzan/@anpigon/7e4ab827f87e8/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/7e4ab827f87e8/","excerpt":"안녕하세요. 안피곤입니다.어제 [스팀짱 커뮤니티 태그 정리 Again!] 글을 읽고나서, 필요한 기능이 갑자기 생각나서 댓글로 의견을 달았습니다. 그리고 기능 구현해서 Github에 PR도 요청했습니다. steemzzang 커뮤니티에도 Github의 PR을 승인하고 merge 하는 담당자가 있는지는 잘 모르겠습니다.","text":"안녕하세요. 안피곤입니다.어제 [스팀짱 커뮤니티 태그 정리 Again!] 글을 읽고나서, 필요한 기능이 갑자기 생각나서 댓글로 의견을 달았습니다. 그리고 기능 구현해서 Github에 PR도 요청했습니다. steemzzang 커뮤니티에도 Github의 PR을 승인하고 merge 하는 담당자가 있는지는 잘 모르겠습니다. steemcoinpan에는 realmankwon, ayogom 등 많은 멋진분들이 코드를 기여하고 있습니다. 그리고 triplea.reviews는 segyepark님이 멋진 기능을 계속 업데이트 하고 있습니다. 이에 비해 steemzzang이나 liv.steempeople는 상대적으로 Github에 커밋이 거의 없습니다. 그래서 커밋이 적은 곳에 소스투고를 가끔 해보려고 합니다. 저는 스팀엔진 기반의 모든 Nitrous 서비스가 비슷한 수준으로 기능이 업데이트 되었으면 좋겠습니다. ![](https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmNpcHsY4vBGAxKez3HgK3B9k1MouVQ2YSqCHHVFi4QvPD/newLOGO_％EC％96％87％EC％9D％80.png) 개발 내용 태그 입력박스 바로 아래에 태그를 선택 입력할 수 있는 링크를 넣었습니다. 이 기능은 Nitrous 전체에 사용해도 될 것 같습니다. 그리고 locales 메세지를 수정했습니다. 이제 Nitrous에서는 태그를 최대 10개까지 입력가능합니다. 그래서 메세지를 모두 찾아서 수정했습니다. 태그는 최대 5개까지 입력 할 수 있습니다. -&gt; 태그는 최대 10개까지 입력 할 수 있습니다 # 나중에 구현되면 좋을 것 같은 기능 busy나 steempeak 같은 태그 입력 UI를 구현하고 싶었습니다. 하지만 구현 시간이 많이 걸릴 것 같습니다. 구현하기 위해서는 Nitrous 컴포넌트 구조와 스타일을 많이 수정해야합니다. busy steempeak 그리고 태그를 counterpart 모듈의 translate 기능을 사용해서 태그를 한글명으로 치환해서 보여주면 더 좋을 것 같습니다. 예를 들면 notice는 &quot;공지사항&quot;으로 newbie는 &quot;신규 가입자&quot;로 보이면 좋을 것 같습니다. 실제 데이터는 영소문자 태그값으로 입력되어 있고 한국어 사용자에게는 태그명이 한글로 보이겠죠? ㅎㅎ 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #3","slug":"/test/@anpigon/20190709t020445612z","date":"2019-07-09T02:04:45.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/test/@anpigon/20190709t020445612z/","link":"","permalink":"https://anpigon.github.io/test/@anpigon/20190709t020445612z/","excerpt":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.스팀 커넥트로 로그인합니다. 그리고 글을 선택하면 상세화면으로 이동합니다. 그리고 리액트 네이티브에서 Markdown &amp; html 파싱을 완변하게 처리 못하고 있습니다. 그래서 WEB으로 이동할 수 있는 버튼을 넣었습니다. WEB 버튼을 누르면 각 Nitrous 사이트로 이동합니다. 예를들면, SCT은 http://steemscoinpan으로 AAA는 http://triplea.reviews로 이동합니다.","text":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.스팀 커넥트로 로그인합니다. 그리고 글을 선택하면 상세화면으로 이동합니다. 그리고 리액트 네이티브에서 Markdown &amp; html 파싱을 완변하게 처리 못하고 있습니다. 그래서 WEB으로 이동할 수 있는 버튼을 넣었습니다. WEB 버튼을 누르면 각 Nitrous 사이트로 이동합니다. 예를들면, SCT은 http://steemscoinpan으로 AAA는 http://triplea.reviews로 이동합니다. *** 이전글 SNAX토큰 에어드랍받기 위한 글 : WHAN APP 기획 개발 이야기 [React Native] WHAN APP 개발 이야기 #2 ![](https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmNpcHsY4vBGAxKez3HgK3B9k1MouVQ2YSqCHHVFi4QvPD/newLOGO_％EC％96％87％EC％9D％80.png) 개발 내용 Markdown 파싱에는 remarkable 라이브러리를 사용합니다. 참고로 Steemit과 Busy에서 사용하고 있는 라이브러리입니다. 제 경험으로도 파싱 속도와 결과물이 가장 괜찮았습니다. 그리고 HTML 렌더링에는 react-native-render-html를 사용합니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/zzan/@wangpigon/or","date":"2019-07-08T05:42:06.000Z","updated":"2019-11-11T13:41:49.859Z","comments":true,"path":"/zzan/@wangpigon/or/","link":"","permalink":"https://anpigon.github.io/zzan/@wangpigon/or/","excerpt":"원래 habit 앱으로 올리려고 했는데 업로드가 안되었네용. ㅠㅠ그래서 스팀잇에서 다시 작성합니다.오늘 날씨 맑음. 기온 32도. 서울의 하늘입니다.너무 이뻐서 찍었습니다. 사진에 잘 담겼는지 모르겠네요.오늘은 하늘에 구름이 무척 많았습니다.저는 가끔씩 하늘을 보며 힐링 합니다.","text":"원래 habit 앱으로 올리려고 했는데 업로드가 안되었네용. ㅠㅠ그래서 스팀잇에서 다시 작성합니다.오늘 날씨 맑음. 기온 32도. 서울의 하늘입니다.너무 이뻐서 찍었습니다. 사진에 잘 담겼는지 모르겠네요.오늘은 하늘에 구름이 무척 많았습니다.저는 가끔씩 하늘을 보며 힐링 합니다. 하늘을 보고 있으면 바다 처럼 풍덩 빠지고 싶을 때가 가끔 있습니다. 오늘도 그런 상상을 하면서 삶의 여유를 느낍니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"사진","slug":"사진","permalink":"https://anpigon.github.io/tags/사진/"}],"author":"wangpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #2","slug":"/zzan/@anpigon/react-native-whan-app-2","date":"2019-07-08T05:01:36.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/zzan/@anpigon/react-native-whan-app-2/","link":"","permalink":"https://anpigon.github.io/zzan/@anpigon/react-native-whan-app-2/","excerpt":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.SCOT 등장 이전에는 스팀잇글을 태그별로 볼 수 있는 앱이 필요하다고 생각했었습니다. 하지만 요즘 SCOT 기반 Nitrous 사이트가 계속 생겨나고 있습니다. 그래서 해당 사이트의 글을 모아 볼 수 있는 앱이 필요하다고 생각하고 있습니다. 물론 각 서비스의 특성을 지닌 앱도 필요하다고 생각하고 있습니다. 예를 들면 왓차같은 영화 리뷰앱, 비블리(Bibly)같은 독서 리뷰앱, 아하 같은 QnA앱 이런 앱들도 만들어 보고 싶습니다.","text":"![whan_dapp_dev.png](https://files.steempeak.com/file/steempeak/anpigon/PA0Z9o93-whan_dapp_dev.png)안녕하세요. 안피곤입니다.SCOT 등장 이전에는 스팀잇글을 태그별로 볼 수 있는 앱이 필요하다고 생각했었습니다. 하지만 요즘 SCOT 기반 Nitrous 사이트가 계속 생겨나고 있습니다. 그래서 해당 사이트의 글을 모아 볼 수 있는 앱이 필요하다고 생각하고 있습니다. 물론 각 서비스의 특성을 지닌 앱도 필요하다고 생각하고 있습니다. 예를 들면 왓차같은 영화 리뷰앱, 비블리(Bibly)같은 독서 리뷰앱, 아하 같은 QnA앱 이런 앱들도 만들어 보고 싶습니다. *** 스팀잇 블록기반의 댑(Dapp)의 장점은 크게 2가지라고 생각합니다. 첫번째는 사용자가 컨텐츠를 생산하면 보상(STEEM)이 주어집니다. 두번째는 해당 서비스 앱이 없어지더라도 데이터는 블록체인에 남아있습니다. 그래서 다른 앱이 그자리를 대신할 수가 있습니다. 이전글 SNAX토큰 에어드랍받기 위한 글 : WHAN APP 기획 개발 이야기 뉴비존님께서 예전에 한 장의 기획서를 저에게 전달해주셨습니다. 이게 벌써 한 달전이네요. 시간이 참 빠르다고 느껴졌습니다. 먼 미래에는 이 기획서를 AI에 입력하면 앱이 자동으로 생성되는 날이 왔으면 좋겠습니다. 그럼 앱개발자는 할일이 없어지겠지요? ㅎㅎ 이전에 올렸던 글 &quot;WHAN APP 기획 개발 이야기&quot;에 이어서 개발을 조금 더 진행했습니다. 우선 앱의 첫 화면은 피드 화면입니다. 그리고 각 SCOT 전환은 탭 스크롤링으로 바꿔봤습니다. 사실 개발은 조금 더 많이 진행했습니다. 하지만 조금씩 보여드리곘습니다. 왜냐하면 개발 시리즈를 써야하기 때문입니다. 한번에 다 보여주면 글쓸 분량이 없어지기 때문에… ㅎㅎㅎ ![](https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmNpcHsY4vBGAxKez3HgK3B9k1MouVQ2YSqCHHVFi4QvPD/newLOGO_％EC％96％87％EC％9D％80.png) 개발 내용 우선 SCOT 사이트 정보를 정리해서 config.js을 생성했습니다. SCOT 서비스 정보는 https://scot-api.steem-engine.com 에서 조회해서 확인했습니다. 그리고 StackNavigator를 생성합니다. 여기서 SCOT 토큰명이 탭 이름이 됩니다. 그리고 각 토큰에 해당하는 &lt;FeedScreen&gt; 컴포넌트를 생성합니다. 그 다음 TopTabNavigator 를 생성합니다. lazy: true 옵션을 사용하여 우선 렌더링을 하지 않습니다. 그리고 scrollEnabled: true 옵션으로 탭이 스크롤이 되도록 합니다. 나머지는 style 코드 내용은 탭 style에 대한 내용입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"이승환 “사랑이 어떻게 그래요” 비하인드 스토리","slug":"/zzan/@wangpigon/49hsst","date":"2019-07-08T02:11:15.000Z","updated":"2019-11-11T13:41:49.859Z","comments":true,"path":"/zzan/@wangpigon/49hsst/","link":"","permalink":"https://anpigon.github.io/zzan/@wangpigon/49hsst/","excerpt":"최근에 이승환 노래를 듣다가 “사랑이 어떻게 그래요” 노래의 비하인드 스토리를 이제서야 알게 되었습니다. 이승환은 2014년 히든싱어에서 “사랑이 어떻게 그래요” 노래가 2006년에 방송된 ‘MBC 휴먼다큐 사랑: 너는 내 운명’ 편을 보고 15분만에 만든 곡이라고 밝혔습니다.","text":"최근에 이승환 노래를 듣다가 “사랑이 어떻게 그래요” 노래의 비하인드 스토리를 이제서야 알게 되었습니다. 이승환은 2014년 히든싱어에서 “사랑이 어떻게 그래요” 노래가 2006년에 방송된 ‘MBC 휴먼다큐 사랑: 너는 내 운명’ 편을 보고 15분만에 만든 곡이라고 밝혔습니다. 간암 말기 시한부 선언을 받은 아내를 무척 사랑하는 남편의 모습과, 그런 아내를 위해서 결혼식을 준비하는 남편을 보면서 너무 가슴 아팠습니다. &quot;어떻게 사랑이 그래요&quot;의 제작 비하인드 스토리를 알고나니 이 노래가 너무 좋아졌습니다. 영상출처: 《휴먼다큐 사랑》 '너는 내 운명' 영상출처: 《휴먼다큐 사랑》 '너는 내 운명'","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"wangpigon"},{"title":"스파이더맨: 파 프롬 홈","slug":"/aaa/@wangpigon/4dpkse","date":"2019-07-07T14:36:18.000Z","updated":"2019-11-11T13:41:49.851Z","comments":true,"path":"/aaa/@wangpigon/4dpkse/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/4dpkse/","excerpt":"오늘 스파이더맨: 파 프롬 홈을 보고 왔습니다. 전작인 스파이더맨: 홈커밍을 재미있게 본 기억이 있어서 이번 영화도 기대가 컸습니다. 최근에 개봉했기 때문에 스포일러를 하지않고 매우 짧게 리뷰하겠습니다.스파이더맨: 파 프롬 홈는 MCU 페이즈 3의 마지막 편입니다. 그리고 영화가 끝나면 쿠키영상이 2개 있습니다. 쿠키 영상의 내용은 조금 충격이었습니다. 아마도 다음에 상영할 페이즈 4를 예고하는 영상이라고 생각됩니다. 벌써 MCU 페이즈 4가 기대되네요.","text":"오늘 스파이더맨: 파 프롬 홈을 보고 왔습니다. 전작인 스파이더맨: 홈커밍을 재미있게 본 기억이 있어서 이번 영화도 기대가 컸습니다. 최근에 개봉했기 때문에 스포일러를 하지않고 매우 짧게 리뷰하겠습니다.스파이더맨: 파 프롬 홈는 MCU 페이즈 3의 마지막 편입니다. 그리고 영화가 끝나면 쿠키영상이 2개 있습니다. 쿠키 영상의 내용은 조금 충격이었습니다. 아마도 다음에 상영할 페이즈 4를 예고하는 영상이라고 생각됩니다. 벌써 MCU 페이즈 4가 기대되네요. 영화는 어벤져스: 엔드게임에서 사건이 있고나서, 8개월이 지난 시점의 이야기입니다. 그리고 주인공 피터 파커가 진정한 히어로로 성장해가는 모습을 보여주고 있습니다. 영화에서 아직 10대인 피터 파커가 청소년기때 흔히 하는 고민들을 잘 표현한 것 같습니다. 영화를 보는 내내 하이틴 영화를 보는 듯한 느낌을 계속 받았습니다. 영화에는 가볍고 유머러스한 장면과 함께 로맨스도 살짝 있습니다. 로맨스는 10대들의 풋풋한 사랑처럼 매우 가볍습니다. 히어로물과 로맨스, 그리고 유머의 적절한 균형를 유지하려고 노력한 흔적이 보입니다. 이번 영화에는 전작에서 많이 아쉬웠던 웹스윙 액션씬이 굉장히 많습니다. 시원 시원 액션이 매우 마음에 듭니다. 아래 화면은 영화의 장면이 아닌 스파이더맨 게임의 한 장면입니다. 이번 스파이더맨은 토비 맥과이어가 연기한 스파이더맨이나 앤드루 가필드가 연기한 어메이징 스파이더맨보다 훨씬 잘 만든 영화라고 생각합니다. 홈 홀랜드가 스파이더맨 시리즈를 계속 이어갔으면 좋겠습니다. 그리고 메가박스 이벤트로 스파이더맨 오리지널 티켓을 받아왔습니다. 이상 짧은 리뷰였습니다. 영화 URL: https://www.themoviedb.org/movie/429617-spider-man-far-from-home?language=ko-KR 별점: AA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"},{"name":"스파이더맨","slug":"스파이더맨","permalink":"https://anpigon.github.io/tags/스파이더맨/"},{"name":"마블","slug":"마블","permalink":"https://anpigon.github.io/tags/마블/"}],"author":"wangpigon"},{"title":"[소설] 도로시 길먼 ⟪폴리팩스 부인과 꼬마 스파이⟫","slug":"/kr/@wangpigon/6vmgts","date":"2019-07-05T02:44:06.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"/kr/@wangpigon/6vmgts/","link":"","permalink":"https://anpigon.github.io/kr/@wangpigon/6vmgts/","excerpt":"“폴리팩스 부인, 새로운 임무가 생겼습니다. 지금 당장 떠나실 수 있나요?” 《뜻밖의 스파이 폴리팩스 부인》부터 시작해서 《폴리팩스 부인 미션 이스탄불》, 《폴리팩스 부인 여덟개의 여권》에 이어 4번째 시리즈입니다. 4번째 시리즈도 저를 실망시키지 않았습니다. 이번에도 역시 시간 가는 줄 모르고 읽었습니다.","text":"“폴리팩스 부인, 새로운 임무가 생겼습니다. 지금 당장 떠나실 수 있나요?” 《뜻밖의 스파이 폴리팩스 부인》부터 시작해서 《폴리팩스 부인 미션 이스탄불》, 《폴리팩스 부인 여덟개의 여권》에 이어 4번째 시리즈입니다. 4번째 시리즈도 저를 실망시키지 않았습니다. 이번에도 역시 시간 가는 줄 모르고 읽었습니다. 이번 소설의 무대는 스위스에 있는 호텔식 병원입니다. 그리고 미션은 병원에 숨어있는 플루토늄 도둑을 찾고 세계를 위험에서 구해내는 일입니다. 폴리팩스 부인은 평소에 병원 자원봉사단, 환경 보호 협회, 원예 모임, 가라테, 요가 할 것 없이 매우 바쁘게 살고 있습니다. 하지만 CIA 에서 비밀 임무 지령이 내려오면 어떤 스파이보다 능력이 뛰어난 스파이로 변신합니다. 그리고 비밀 임수를 항상 성공적으로 수행합니다. 다른 사람이 보기에는 엉뚱하고 호기심 많은 할머니로 보이겠지만, 폴리팩스 할머니은 그 누구에게도 없는 비범한 직관력과 관찰력을 가지고 있습니다. 이번에도 임무를 수행해가는 과정이 매우 위태 위태합니다. 모험과 미션을 좋아하는 폴리팩스 부인이 이번에는 부상 투혼까지 하면서 정말 스파이 다운 면모를 보여줬습니다. 폴리팩스 부인은 매우 엉뚱하지만 사랑할 수 밖에 없는 케릭터입니다. 그리고 한글 제목이 내용과 다른 부분이 있어서, 원제를 찾아보았습니다. 원제는 A Palm For Mrs. Pollifax 입니다. &quot;웃음과 위로, 용기 그 모든 것을 폴리팩스 부인이 드립니다&quot; 이 글은 Busy에서 작성하였습니다. https://busy.org/@wangpigon","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"도로시 길먼","slug":"도로시-길먼","permalink":"https://anpigon.github.io/tags/도로시-길먼/"},{"name":"영미소설","slug":"영미소설","permalink":"https://anpigon.github.io/tags/영미소설/"},{"name":"추리소설","slug":"추리소설","permalink":"https://anpigon.github.io/tags/추리소설/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"}],"author":"wangpigon"},{"title":"[소스 투고] Nitrous 태그를 색상으로 구분하기","slug":"/sct/@anpigon/5lmuhk-nitrous","date":"2019-07-05T01:48:54.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/5lmuhk-nitrous/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/5lmuhk-nitrous/","excerpt":"안녕하세요. 안피곤입니다.요즘 Nitrous SteemCoinpan 오픈소스에 기여하는 재미에 빠져있습니다. 내가 필요하는 기능을 구현하고 반영되는 것을 보니 무척이나 재미있습니다. 그리고 realmankwon님이나 ayogom처럼 저도 이제부터 [소스 투고] 라는 타이틀을 사용할께요.","text":"안녕하세요. 안피곤입니다.요즘 Nitrous SteemCoinpan 오픈소스에 기여하는 재미에 빠져있습니다. 내가 필요하는 기능을 구현하고 반영되는 것을 보니 무척이나 재미있습니다. 그리고 realmankwon님이나 ayogom처럼 저도 이제부터 [소스 투고] 라는 타이틀을 사용할께요. 이번에 추가한 기능은 Nitrous 태그를 색상으로 구분하고, 마우스 오버시 툴팁 정보를 보여주는 기능을 구현하였습니다. 하지만 아직 Nitrous에 반영 되지는 않았습니다. 반영될 거라고 믿습니다. ㅎㅎ 개발 내용 해당 nitrous의 SCOT 토큰 정보만 가져오는 부분을 수정했습니다. 모든 SCOT 토큰 정보를 가져와서 scotConfig에 저장합니다. 아래는 구현 코드의 일부입니다. 그리고 nitrous 태그의 경우에는 bg가 Accent Color가 표시됩니다. 그리고 툴팁 메세지를 작성하여 마우스 오버시 보여줍니다. 아래는 구현 코드의 일부입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[오픈소스] SCT 소스 수정 : SCT 앱 아이콘 표시 기능과 토큰(Token) 잔액 Style 변경","slug":"/sct/@anpigon/sct-sct-token-style","date":"2019-07-04T04:23:09.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/sct-sct-token-style/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/sct-sct-token-style/","excerpt":"안녕하세요. 안피곤입니다.@jacobyu님이 공지한 “스팀코인판, 니트로 관련 개발 아이디어” 글을 읽고, 제일 간단해 보이는 기능을 구현했습니다.그런데 작업하고 보니, 블록체인스튜디오님(@blockchainstudio)이 먼저 구현해서 PR 하셨더군요. 블록체인스튜디오님은 정말 빠르네요. ㅎㅎ 저도 구현한 코드가 아까워서 그냥 PR 했습니다. ㅋ","text":"안녕하세요. 안피곤입니다.@jacobyu님이 공지한 “스팀코인판, 니트로 관련 개발 아이디어” 글을 읽고, 제일 간단해 보이는 기능을 구현했습니다.그런데 작업하고 보니, 블록체인스튜디오님(@blockchainstudio)이 먼저 구현해서 PR 하셨더군요. 블록체인스튜디오님은 정말 빠르네요. ㅎㅎ 저도 구현한 코드가 아까워서 그냥 PR 했습니다. ㅋ SCT 앱 아이콘 표시 스팀코인판에서 작성한 글이라면 목록과 상세 화면에서 SCT 아이콘이 표시됩니다. 목록화면 상세화면 토큰(Token) 잔액 Style 변경 그리고 몇 일 전에 간단한 Style CSS 수정도 했습니다. SCT에는 이미 반영되었습니다. 이렇게 보이던 토큰 잔액이… 이렇게 바뀌었습니다. 이건 정말 간단한 작업입니다. 코드를 보면 css 속성을 하나 수정했습니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"@nhj12311님이 만든 steem.apps 댑에 토큰 보상을 추가했어요.","slug":"/sct/@anpigon/nhj12311-steem-apps","date":"2019-07-03T03:01:03.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/nhj12311-steem-apps/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/nhj12311-steem-apps/","excerpt":"안녕하세요. 안피곤입니다.제목 그대로 @nhj12311님이 만든 steem.apps 댑에 각 토큰 보상금액을 한 번에 볼수 있는 기능을 추가했습니다. 그리고 저자보상을 받을 수 있는 태그는 Curious Blue 컬러로 강조 표시했습니다. steem.apps https://anpigon.github.io/steem.apps/","text":"안녕하세요. 안피곤입니다.제목 그대로 @nhj12311님이 만든 steem.apps 댑에 각 토큰 보상금액을 한 번에 볼수 있는 기능을 추가했습니다. 그리고 저자보상을 받을 수 있는 태그는 Curious Blue 컬러로 강조 표시했습니다. steem.apps https://anpigon.github.io/steem.apps/ 그런데 steem.apps 댑에 기능을 추가하고 보니, 스팀픽에서 이미 구현이 되어 있는 기능이네요. 이제서야 발견했습니다. ㅠ 스팀픽에서도 보상금액에 마우스 오버하면 각 토큰에 대한 보상금액을 볼 수 있습니다. 저자/큐레 보상 비율도 볼수 있네요. 개발내용 보상 금액에 마우스 오버하면 아래와 같이 툴팁에 정보가 표시됩니다. 툴팁을 JQuery나 Bootstrap으로 구현하려다가 그냥 CSS로 구현했습니다. 그리고 툴팁에 뿌려주는 내용은 HTML의 title attribute를 사용했습니다. 니트로 기반의 커뮤니티가 점점 늘어나서 부계정도 만들었습니다. 그런데 관리하기가 힘들고 헷갈립니다. 저는 하나의 댑에서 글을 모아보는 것을 선호합니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"헤로쿠 서버에서 Nitrous(스코판) 사이트 서비스하기","slug":"/sct/@anpigon/nitrous","date":"2019-07-02T05:05:54.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/nitrous/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/nitrous/","excerpt":"안녕하세요. 안피곤입니다.최근에 스팀코인판에서 코드 바운티 프로그램 운영/보상 발표가 있었습니다. 관련글: &quot;[Notice] 코드 바운티 프로그램 운영, 보상 발표 (code bounty program)&quot; 이 발표를 계기로 스팀잇에 많은 개발자들의 유입이 있었으면 좋겠습니다. 그리고 #kr-dev 태그에 개발글이 넘쳤으면 좋겠어요. ㅋ","text":"안녕하세요. 안피곤입니다.최근에 스팀코인판에서 코드 바운티 프로그램 운영/보상 발표가 있었습니다. 관련글: &quot;[Notice] 코드 바운티 프로그램 운영, 보상 발표 (code bounty program)&quot; 이 발표를 계기로 스팀잇에 많은 개발자들의 유입이 있었으면 좋겠습니다. 그리고 #kr-dev 태그에 개발글이 넘쳤으면 좋겠어요. ㅋ 이번에 무료로 이용할 수 있는 헤로쿠 서버에 Nitrous를 올려보았습니다. Docker를 사용해서 앱을 배포하면 매우 간단합니다. 그래서 제가 사용한 방법을 간략하게 정리해서 공유합니다. Nitrous 오픈 소스 포크하고 내려 받기 Nitrous 오픈소스: https://github.com/eonwarped/nitrous/ Nitrous 깃헙 저장소(Repository)를 내 깃헙으로 포크(Fork)합니다. 포크한다라는 말은 오픈 소스 코드를 통째로 복사하여 독립적인 새로운 앱을 개발하는 것을 말합니다. 아래는 내 깃헙 저장소에 포크된 Nitrous 오픈소스입니다. 그다음 [Clone or download] 버튼을 눌러서 깃헙 저장소 URL을 확인합니다. 그리고 깃헙 저장소 URL에서 nitrous 오픈소스를 git clone 합니다. nitrous 디렉토리로 이동합니다. 그리고 체크아웃 받을 수 있는 브랜치(branch)를 확인합니다. 위 브랜치 중에서 가장 마음에 드는 브랜치를 선택하면 됩니다. 저는 스팀코인판(scotty_steemcoinpan) 브랜치를 체크아웃 받았습니다. 도커 설치 Nitrous를 빌드하고 구동하기 위해서 Docker를 설치합니다. Docker를 사용하지 않고 전통적인 방법으로 개발해도 됩니다. 하지만 개발환경 구축하는건 정말 귀찮은 일입니다. 저는 Mac OS를 사용하고 있습니다. 그래서 Homebrew를 사용하여 Docker를 설치했습니다. 1brew cask install docker 참고: How to install Docker in Mac, Windows, and Linux 윈도우즈에서 도커를 설치하는 방법은 realmankwon님의 “내 컴퓨터에서 나만의 sct를 실행해 보자” 글을 참고하세요. Heroku 가입하기 헤로쿠에 회원가입을 하고 Heroku-CLI를 설치합니다. Heroku-CLI 설치 방법은 공식 가이드 문서를 참고합니다. 헤로쿠에 로그인합니다. heroku login를 입력하면 브라우저가 실행되면서 로그인창이 나타납니다. 그리고 Heroku 앱을 생성합니다. 저는 anpigon으로 생성했습니다. 참고로 앱 이름은 도메인으로도 사용됩니다. 예) anpigon.herokuapp.com Heroku 에 배포하기 도커 이미지 배포 방법은 헤로쿠 공식 문서를 참고하였습니다. 참고: https://devcenter.heroku.com/articles/container-registry-and-runtime 컨테이너에 로그인합니다. 1$ heroku container:login 도커 이미지를 빌드하고 Container Registry에 푸시(push)합니다. 1$ heroku container:push web 그런 다음 도커 이미지를 앱으로 출시(release)합니다. 1$ heroku container:release web 이제 브라우저에서 앱을 실행합니다. 1$ heroku open 아래는 헤로쿠 서버에서 앱을 실행한 화면입니다. 참고로 이미지 URL은 https://steemitdevimages.com/ 도메인을 바라보고 있어서 이미지가 하나도 안보입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Heroku","slug":"heroku","permalink":"https://anpigon.github.io/tags/heroku/"},{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[React Native] Steem 모바일 지갑앱 만들기 #4","slug":"/sct/@anpigon/react-native-steem-4","date":"2019-07-01T04:02:36.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/sct/@anpigon/react-native-steem-4/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-steem-4/","excerpt":"안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 만들기 4번째 포스팅입니다. 이번에는 스팀 + 스팀엔진 토큰의 마켓 가격을 계산하여 총 자산 금액을 보여주는 기능을 추가하였습니다. Total Assets 에 표시된 금액이 제가 보유하고 있는 총 자산의 USD 금액입니다.","text":"안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 만들기 4번째 포스팅입니다. 이번에는 스팀 + 스팀엔진 토큰의 마켓 가격을 계산하여 총 자산 금액을 보여주는 기능을 추가하였습니다. Total Assets 에 표시된 금액이 제가 보유하고 있는 총 자산의 USD 금액입니다. 참고로 지갑앱은 Whan팀 내에서만 테스트하고 있습니다. 그리고 아직 송금 기능이 없어서, 저는 개인적으로 잔액 확인 용도로만 사용하고 있습니다. 시리즈글 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #1 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #2 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #3 ![](https://cdn.steemitimages.com/300x0/https://ipfs.busy.org/ipfs/QmUKxtLW5JEnqaaAnwiLc9kFK1BqpcMGoFKTF7JLKcvJqy) 스팀과 스팀달러 마켓 가격을 확인할 수 있는 무료 API 바로 전 포스팅에서 스팀과 스팀달러 마켓 가격을 코인마켓캡 API에서 가져오게 구현했습니다. 하지만 코인마켓캡의 API는 무료 사용량이 제한되어 있습니다. 그래서 개발하고 테스트하다 보면 하루 사용량을 금방 다 써버립니다. ㅠㅠ 검색해보니 무료 API가 있어서 갈아탔습니다. ㅋ https://postpromoter.net/api/prices를 요청하면 다음과 같은 결과를 받을 수 있습니다. 12345678910｛ \"sbd_price\":0.9654108693894001, \"steem_price\":0.3639348516, \"se_token_prices\":｛ \"PAL\":0.39, \"SCT\":1.51203, \"DEC\":0.00267, \"AAA\":0.00315 ｝｝ 그리고 다음은 구현된 코드 내용입니다. HTTP 통신에는 axios 라이브러리를 사용했습니다. 기본 모듈인 fetch를 사용하는게 성능이 더 좋지만, 저는 범용성을 위해서 axios를 많이 사용합니다. 스팀엔진 토큰 마켓 가격 가져오기 sscjs 라이브러리를 사용하여 스팀엔진 토큰 마켓 가격을 가져옵니다. 다음과 같은 결과를 받을 수 있습니다. 12345678910111213141516[ ｛ \"symbol\": \"SCT\", \"volume\": \"3974.81155503\", \"volumeExpiration\": 1562034918, \"lastPrice\": \"1.52099\", \"lowestAsk\": \"1.52100\", \"highestBid\": \"1.52099\", \"lastDayPrice\": \"1.51106\", \"lastDayPriceExpiration\": 1561993083, \"priceChangeSteem\": \"0.00993000\", \"priceChangePercent\": \"0.66％\", \"$loki\": 206 ｝, // ...] 그리고 다음은 구현된 코드 내용입니다. 잔액이 0 이상인 토큰 마켓 가격만 가져오기 위해서 $or 조건을 사용하였습니다. 몽고 DB 쿼리문을 그대로 사용할 수 있는 것 같습니다. 예를 들어 내가 가지고 있는 토큰만 조회하고 싶다면, &quot;query&quot;:｛$or:[｛symbol:&quot;SCT&quot;｝,｛symbol:&quot;AAA&quot;｝]｝ 형태로 조회합니다. 그리고 스팀엔진 마켓의 lastPrice 가격으로 USD 가격을 계산하였습니다. 1token.price = token.totalBalance * marketPrice.lastPrice * steemPrice; 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"Steem  지갑앱 만들기","slug":"개발-이야기/react-native/steem-지갑앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/steem-지갑앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Steem","slug":"steem","permalink":"https://anpigon.github.io/tags/steem/"}],"author":"anpigon"},{"title":"[React Native] Steem 모바일 지갑앱 만들기 #3","slug":"/sct/@anpigon/react-native-steem-3","date":"2019-06-29T02:15:15.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/sct/@anpigon/react-native-steem-3/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-steem-3/","excerpt":"안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 만들기 3번째 포스팅입니다. 이 시리즈의 2번째 포스팅 올린 게 벌써 2달 전이네요. ㅎㅎ 시간이 참 빨리 흘러간다고 느껴집니다.간만에 지갑에 기능을 업데이트 했습니다. 참고로 지갑앱은 Whan팀 내에서만 테스트하고 있습니다. 그리고 아직 송금 기능이 없어서, 저는 개인적으로 잔액 확인 용도로만 사용하고 있어요.","text":"안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 만들기 3번째 포스팅입니다. 이 시리즈의 2번째 포스팅 올린 게 벌써 2달 전이네요. ㅎㅎ 시간이 참 빨리 흘러간다고 느껴집니다.간만에 지갑에 기능을 업데이트 했습니다. 참고로 지갑앱은 Whan팀 내에서만 테스트하고 있습니다. 그리고 아직 송금 기능이 없어서, 저는 개인적으로 잔액 확인 용도로만 사용하고 있어요. 시리즈글 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #1 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #2 ![](https://cdn.steemitimages.com/300x0/https://ipfs.busy.org/ipfs/QmUKxtLW5JEnqaaAnwiLc9kFK1BqpcMGoFKTF7JLKcvJqy) 개발 내용 지갑 목록 화면에서 스팀, 스팀달러, 스팀파워, 그리고 스팀엔진 토큰 잔액을 보여줍니다. 그리고 부기님(gfriend96) 요청으로 보유 코인만 보기 옵션을 추가했습니다. STEEM과 SBD 가격은 코인마켓캡 API를 이용하였습니다. 새로고침(Refresh)은 끌어당김(Pull Down)으로 동작합니다. 스팀/스달 가격 보여주기 - 코인마켓 캡 https://coinmarketcap.com/api/ 코인마켓캡 API를 사용하기 위해서, 코인마켓캡 개발자 콘솔에서 API 키를 발급받았습니다. 그런데 예전에는 티커 API가 완전 무료였는데, 이번에는 호출 횟수 제한이 생겼습니다. ㅠ API는 하루에 최대 333번 호출할 수 있고, 한 달에 최대 10,000까지 호출 가능합니다. 테스트하면서 다 사용해버릴 것 같습니다. ㅜ 앱을 서비스해서 제대로 사용하려면 비용을 지불해야 할 것 같습니다. 아래는 코인마켓캡 API 사용 등급에 따른 가격표입니다. 하지만 코인마켓캡 API 가격표를 보면 저렴하지 않습니다. 한달에 $29를 지불하더라도 하루 호출 횟수가 1,300건입니다. 가난한 개발자는 티커 API 서버를 따로 만들어서 운영해야할 것 같습니다. 아니면 코인마켓캡 API를 캐시하고 캐시된 데이터를 제공하는 서비스를 만들어도 좋을 것 같습니다. 제 계획은 Stellarterm Ticker API 처럼 1분마다 깃헙 페이지에 ticker.json 파일을 생성해서 서비스할 생각입니다. 코인마켓캡 API 구현 코드 아래는 코인마켓캡 API를 이용하여 최근 마켓 가격을 가져오는 코드입니다. 인자값 id에서 1230가 STEEM이고 1312는 SBD입니다. 참고로 slug=steem,sbd나 symbol=STEEM,SBD 로 가격을 가져오는 방법도 있습니다. 완성 화면 지금까지 완성된 앱 동작 화면입니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"Steem  지갑앱 만들기","slug":"개발-이야기/react-native/steem-지갑앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/steem-지갑앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Steem","slug":"steem","permalink":"https://anpigon.github.io/tags/steem/"}],"author":"anpigon"},{"title":"스팀잇 글을 티스토리에 올리기","slug":"/sct/@anpigon/2zgchx","date":"2019-06-28T04:19:03.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/sct/@anpigon/2zgchx/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/2zgchx/","excerpt":"안녕하세요. 안피곤입니다.최근에 티스토리 블로그를 다시 시작했습니다. 그리고 다음 AdFit 광고를 신청해서 달았습니다. 티스토리 글은 모두 스팀잇에서 작성한 글로 채웠어요. 스팀잇에서 글을 복사한 다음 티스토리 에디터에 붙여넣기 하면 거의 그대로 붙여넣기 됩니다. ㅎㅎ","text":"안녕하세요. 안피곤입니다.최근에 티스토리 블로그를 다시 시작했습니다. 그리고 다음 AdFit 광고를 신청해서 달았습니다. 티스토리 글은 모두 스팀잇에서 작성한 글로 채웠어요. 스팀잇에서 글을 복사한 다음 티스토리 에디터에 붙여넣기 하면 거의 그대로 붙여넣기 됩니다. ㅎㅎ 기존에는 개츠비를 이용하여 깃헙 페이지에서 블로그를 운영 중이었습니다. 그리고 깃헙 페이지는 Travis-CI 서비스를 이용해서 자동 배포하고 있습니다. 하지만 스팀잇에 작성한 글 개수가 많아지니, 더 이상 자동 배포가 안되고 있습니다. 빌드 시간이 10m0s 이상 넘어가니 스케쥴러 Job이 중단되어 버립니다. ㅠㅠ Travis-CI 에서는 스팀잇에서 작성한 모든 글을 가져와서 파싱하고, 다시 깃헙 페이지에 업로드하고 있었습니다. 하지만 스팀잇에서 작성한 글이 많아지니 빌드 시간이 길어진 것 같습니다. Free Plan의 한계인 것 같습니다. 참고로 깃헙 블로그는 구글 광고로 운영 중입니다. 하지만 유저 유입은 거의 없고 구글 광고 수익도 거의 발생하지 않네요. 아래는 티스토리의 최근 일주일간 다음 광고 수익입니다. 일주일 동안 약 100원이 적립되었네요. 참고로 다음 AdFit 광고는 확정 적립금이 5만 원 이상 되어야 지급 요청이 가능합니다. ![](https://steemitimages.com/300x0/https://ipfs.busy.org/ipfs/QmUKxtLW5JEnqaaAnwiLc9kFK1BqpcMGoFKTF7JLKcvJqy) 스팀잇 글을 티스토리에 계속 복사&amp;붙여넣기로 운영하다가 불편해서 툴을 하나 만들었습니다. 원래는 혼자만 사용하려고 만들었는데 그냥 공개합니다. 간단하게 혼자 사용하려고 만든 거라서 기능이 많이 부족합니다. 페이지를 새로 만들까 하다가 기존에 asbear님이 만드신 steeme를 포크 하여 기능을 붙였습니다. 아래 링크에 접속하면 사용할 수 있습니다. https://anpigon.github.io/steeme/ 사용하려면 반드시 티스토리에 대표 블로그가 존재해야합니다. 다음은 사용방법입니다. 티스토리 로그인하기 [Tistory] 버튼을 누르면 티스토리 로그인 창이 팝업됩니다. 그리고 로그인에 성공하면 티스토리 API를 이용하여 액세스 토큰을 가져옵니다. 클라이언트에서 발급받을 수 있는 액세스 토큰은 유효시간이 약 1시간입니다. 그래서 사용할 때마다 매번 로그인해야합니다. 하지만 이미 티스토리 로그인 세션이 존재한다면, 로그인 창이 보이자마자 액세스 토큰을 자동으로 가져오고 팝업창이 바로 닫힐 것입니다. 티스토리에 스팀잇 글 업로드하기 티스토리 로그인이 완료되면, 목록에 [Tistory Publish] 버튼이 보입니다. [Tistory Publish] 버튼을 누르면 팝업 다이얼로그 창이 나타납니다. 팝업 다이얼로그 창에서는 markdown을 html으로 렌더링 해서 보여줍니다. 하지만 완벽하게 렌더링 하지 않았기 때문에 미흡한 부분이 있을 수 있습니다. 그다음 [Tistory Publish] 버튼을 누르면 글 제목과 내용이 티스토리에 업로드됩니다. 참고로 티스토리에 비공개 글로 등록됩니다. 티스토리에 업로드가 완료되면 [View Tistory] 녹색 버튼이 노출됩니다. 이 버튼 노출 여부로 내가 티스토리에 업로드한 글인지 아닌지를 판단할 수 있습니다. 참고로 스팀잇과 티스토리에서 동일 글 여부 판단을 제목으로 비교하기 때문에 제목을 수정하면 다른 글로 인식합니다. 티스토리에서 수정하기 내 티스토리 블로그에 접속하면 방금 업로드한 글이 보입니다. 수정을 눌러줍니다. 지금 티스토리 에디터는 2.0으로 리뉴얼되었습니다. 하지만 API는 아직 1.0을 사용하고 있어서 API를 사용하여 글을 등록하면 티스토리 예전 에디터가 보입니다. 이 에디터를 그대로 사용해도 됩니다. 하지만 새로운 에디터에서 글을 수정하는 게 더 편합니다. 맨 상단에 보이는 [에디터 전환] 링크를 눌러줍니다. 아래는 새로 리뉴얼된 티스토리 에디터 2.0 입니다. 위지윅, HTML, 마크다운 편집 방식을 제공합니다. 마지막으로 공개를 선택하고, 카테고리, 홈주제를 선택하고 [공개 발행] 버튼을 누르면 됩니다. 댓글, 팔로우, 업보팅해 주시는 모든 분들 감사합니다. 항상 행복한 하루 보내시길 바랍니다. vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"티스토리","slug":"티스토리","permalink":"https://anpigon.github.io/tags/티스토리/"}],"author":"anpigon"},{"title":"@nhj12311님이 만든 steem.apps 댑에 #aaa, #stc 태그를 추가했어요.","slug":"/sct/@anpigon/nhj12311-steem-apps-aaa-stc","date":"2019-06-25T00:57:36.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/nhj12311-steem-apps-aaa-stc/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/nhj12311-steem-apps-aaa-stc/","excerpt":"안녕하세요. 안피곤(@anpigon)입니다.steem.apps 댑은 제가 스팀잇 처음 시작했을 때 가장 많이 이용했던 최애 스팀댑입니다. 바로 @nhj12311님이 만드셨죠. 태그별로 피드(Feed)를 볼 수 있고, 댓글을 바로 확인 할 수 있습니다.그리고는 스팀잇에 익숙해지면서 시간이 지나 한 동안 잊고 지냈습니다. 그러다가 갑자기 #태그를 간편하게 조회해서 볼 수 있는 페이지가 필요하고 생각했습니다. steempeak에도 FAVORITE TOPICS 기능이 있습니다. 하지만 모바일에서 steempeak 메뉴 사용이 불편하네요.","text":"안녕하세요. 안피곤(@anpigon)입니다.steem.apps 댑은 제가 스팀잇 처음 시작했을 때 가장 많이 이용했던 최애 스팀댑입니다. 바로 @nhj12311님이 만드셨죠. 태그별로 피드(Feed)를 볼 수 있고, 댓글을 바로 확인 할 수 있습니다.그리고는 스팀잇에 익숙해지면서 시간이 지나 한 동안 잊고 지냈습니다. 그러다가 갑자기 #태그를 간편하게 조회해서 볼 수 있는 페이지가 필요하고 생각했습니다. steempeak에도 FAVORITE TOPICS 기능이 있습니다. 하지만 모바일에서 steempeak 메뉴 사용이 불편하네요. @nhj12311님의 허락없이 일단 깃허브 소스(https://github.com/nhj7/nhj7.github.io)를 포크(Fork) 하였습니다. 그리고 다음과 같이 #sct와 #aaa를 추가하였습니다. 아래는 제 깃헙 페이지에서 서비스되고 있는 페이지입니다. sct와 aaa가 보입니다. ㅋ https://anpigon.github.io/steem.apps/ 아래는 두 달전에 만들었던 페이지입니다. 관련 태그를 주제별로 묶어서 보여주는 페이지입니다. 예를 들면, 도서 탭을 누르면 #book, #kr-book, #booksteem 태그를 모아서 보여줍니다. https://anpigon.github.io/steemit-community/ 최근 니트로 기반의 사이트(SCT, AAA)가 등장하면서 스팀잇에서 활동하는 유저들의 패턴이 많이 바뀌었습니다. 그리고 이 페이지는 사용자가 많지 않을 것 같아서 지금은 개발 중단했습니다. 그리고 지금은 모바일 개발이 더 잼납니다. ㅋ steemit-community 라고 명명한 태그를 모아 볼수 있는 페이지의 작동 방식은 대략 이렇습니다. 봇(Bot) 데몬이 스팀잇 데이터를 실시간 수집하여 로그에 기록합니다. 그리고 스택에 쌓인 로그 데이터를 파싱하여 필요한 데이터만 정제합니다. 그리고 MonogoDB에 저장합니다. 외부에서 DB 조회할 수 있는 API 서버는 Google App Engine에 GraphQL를 디플로이(Deploy) 했습니다. 마지막으로 사용자가 브라우저에서 볼 수 있는 웹페이지는 Github Page에서 호스팅됩니다. 여기까지는 모두 무료로 제공되는 서비스(Free Price Plan)를 이용해서 개발했습니다. 하지만 트래픽이 올라가면 비용이 발생할 수도 있습니다. ㅋ 해피 코딩하세요~! vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"⟪토이 스토리4⟫ - 픽사 최고의 걸작","slug":"/aaa/@wangpigon/4","date":"2019-06-24T04:42:27.000Z","updated":"2019-11-11T13:41:49.851Z","comments":true,"path":"/aaa/@wangpigon/4/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/4/","excerpt":"이번 주말에 토이스토리4를 보고 왔습니다. 토이스토리3(2010)가 개봉한지도 벌써 9년이 흘렀네요. 저는 토이스토리 시리즈 1, 2, 3 모두 명작이라고 생각합니다. 그리고 토이스토리 4는 토이스토리 시리즈에서 최고의 걸작입니다. 웃음·감동·재미 모두 전작을 뛰어넘었습니다. 영화 후기는 최대한 스포일러를 자제하면서 적어볼게요.","text":"이번 주말에 토이스토리4를 보고 왔습니다. 토이스토리3(2010)가 개봉한지도 벌써 9년이 흘렀네요. 저는 토이스토리 시리즈 1, 2, 3 모두 명작이라고 생각합니다. 그리고 토이스토리 4는 토이스토리 시리즈에서 최고의 걸작입니다. 웃음·감동·재미 모두 전작을 뛰어넘었습니다. 영화 후기는 최대한 스포일러를 자제하면서 적어볼게요. 카우보이 인형 우디의 주인 앤디는 장난감을 가지고 노는 나이를 지나 어른이 됩니다. 그리고 우디는 어른이 된 앤디를 떠나게 됩니다. 우디는 새로운 주인 보니를 만나면서 더욱 성숙해집니다. 저는 여기서 장난감을 가지고 놀던 아이(우디)가 다 커서, 이제는 아이 아빠가 된듯한 느낌을 받았습니다. 영화의 전체적인 배경이 된 놀이동산은 저를 다시 어릴 적 추억에 빠지게 만들었습니다. 우디, 버즈가 놀이동산 언덕 위에 서서 해질녘 노을을 바라보는 장면은 정말 멋지네요. 선과 악인에 대한 구분이 모호한 설정이 제 마음에 더한 감동을 불어넣었습니다. 이전 토이스토리 시리즈에서는 항상 악역이 등장했었고, 그 악인을 처단하는 것이 중심 스토리였습니다. 하지만 토이스토리 4에서의 악인은 너무 성숙해진 것 같습니다. 저는 왜 악인이 되었는지에 대한 스토리를 듣고 나서는 불안하고 공포스러웠던 마음이 저절로 숙연해졌습니다. 우리가 그동안 봤던 토이스토리 1, 2, 3는 모두 토이스토리 4를 보기 위한 프롤로그였습니다. 마지막으로 영화 엔딩까지 보고 나니 기쁨과 감동이 밀려왔습니다. 그리고 저는 매우 행복해졌습니다. &quot;To Infinity, And Beyond!&quot; 영화 URL: https://www.themoviedb.org/movie/301528-toy-story-4?language=ko-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"[React Native] 영화 리뷰 모바일 앱 개발 이야기 #4","slug":"/sct/@anpigon/react-native-4","date":"2019-06-23T23:00:09.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/sct/@anpigon/react-native-4/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-4/","excerpt":"안녕하세요. 안피곤입니다.이 시리즈는 리액트 네이티브로 영화 리뷰 모바일 앱을 만드는 과정입니다.이번에는 포스팅 본문 내용을 보여주는 상세 화면을 구현합니다. body에 포함된 마크다운/HTML을 파싱하여 렌더링된 결과물을 네이티브 화면으로 출력합니다.웹 화면과 최대한 비슷하게 구현하려고 노력했습니다. 하지만 아직 미흡한 부분이 보여서 WEB으로 가는 링크를 우측상단에 넣었습니다. 클릭하면 웹페이지로 이동합니다.","text":"안녕하세요. 안피곤입니다.이 시리즈는 리액트 네이티브로 영화 리뷰 모바일 앱을 만드는 과정입니다.이번에는 포스팅 본문 내용을 보여주는 상세 화면을 구현합니다. body에 포함된 마크다운/HTML을 파싱하여 렌더링된 결과물을 네이티브 화면으로 출력합니다.웹 화면과 최대한 비슷하게 구현하려고 노력했습니다. 하지만 아직 미흡한 부분이 보여서 WEB으로 가는 링크를 우측상단에 넣었습니다. 클릭하면 웹페이지로 이동합니다. ![](https://cdn.steemitimages.com/200x0/https://cdn.pixabay.com/photo/2019/03/01/05/01/developer-4027334_1280.png) Remarkable : 마크다운(markdown) 파서 https://github.com/jonschlinkert/remarkable 마크다운(markdown) 파서는 remarkable를 사용했습니다. remarkable는 마크다운 문서를 HTML로 변환해주는 라이브러리입니다. common/extensions 마크다운 문법을 모두 지원하고, syntax 플러그인과 매우 빠른 속도를 자랑합니다. 그리고 MIT 라이센스입니다. 다음은 remarkable를 사용한 일부 코드입니다. React-Native Render HTML https://github.com/archriss/react-native-render-html HTML 렌더링에는 react-native-render-html를 사용했습니다. react-native-render-html는 리액트 네이티브 컴포넌트를 사용하여 HTML을 100％ 네이티브 뷰로 렌더링해줍니다. 그리고 BSD-2-Clause 라이센스입니다. 다음은 react-native-render-html를 사용한 일부 코드입니다. import HTMLView from 'react-native-render-html'; 완성 화면 해피 코딩하세요~! vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"영화 리뷰 앱 개발 이야기","slug":"개발-이야기/react-native/영화-리뷰-앱-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/영화-리뷰-앱-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/makeahabit/@wangpigon/makeahabit-1561275105","date":"2019-06-23T07:31:48.000Z","updated":"2019-11-11T13:41:49.859Z","comments":true,"path":"/makeahabit/@wangpigon/makeahabit-1561275105/","link":"","permalink":"https://anpigon.github.io/makeahabit/@wangpigon/makeahabit-1561275105/","excerpt":"","text":"Make a habit하루 한 번 하늘보기 | 매일오늘 한강 하늘 구름. 습하고 더워서 숨이 막히는 날씨다.from make a habit app","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"}],"author":"wangpigon"},{"title":"[React Native] 영화 리뷰 모바일 앱 개발 이야기 #3","slug":"/sct/@anpigon/react-native-3","date":"2019-06-22T23:51:21.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/sct/@anpigon/react-native-3/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-3/","excerpt":"안녕하세요. 안피곤입니다.이 시리즈는 리액트 네이티브로 영화 리뷰 모바일 앱을 만드는 과정입니다.코딩 마법사는 마법으로 앱을 금방 만들지만, 저는 한 땀 한 땀 노가다(삽질?)를 하면서 만들고 있습니다. 그리고 제가 속해 있는 Whan 개발팀에도 마법사가 여럿분 계십니다. 아직 Whan 개발팀의 존재를 모르시는 분은 뉴비존님이 작성한 “[출범식] WDT(WHAN DEV TEAM) 공식 활동 개시” 글을 읽어보세요.","text":"안녕하세요. 안피곤입니다.이 시리즈는 리액트 네이티브로 영화 리뷰 모바일 앱을 만드는 과정입니다.코딩 마법사는 마법으로 앱을 금방 만들지만, 저는 한 땀 한 땀 노가다(삽질?)를 하면서 만들고 있습니다. 그리고 제가 속해 있는 Whan 개발팀에도 마법사가 여럿분 계십니다. 아직 Whan 개발팀의 존재를 모르시는 분은 뉴비존님이 작성한 “[출범식] WDT(WHAN DEV TEAM) 공식 활동 개시” 글을 읽어보세요. 어제 @nhj12311님이 Whan 개발팀에 합류하였습니다. 축하해주세요. 그래서 기념으로 Whan 개발팀을 삼국지 인물에 매칭 시켜 보았습니다. 이것은 순전히 저의 개인적인 의견입니다. nhj12311님은 제갈공명, 뉴비존님은 유비, 원사마님은 관우, 햄뽀이님은 장비, 그리고 제이콥님은 조운. 마지막으로 부기님은 마초입니다. 죄송합니다. ㅠ_ㅜ ![](https://cdn.steemitimages.com/200x0/https://cdn.pixabay.com/photo/2019/03/01/05/01/developer-4027334_1280.png) 댓글로 많은 분들이 응원해주셨습니다. 그래서 다시 코딩 의욕이 살아나고 있습니다. 제이콥님, 토크잇님, 독거노인님 모두 감사합니다. 이번에는 스팀커넥트를 이용한 로그인을 구현했어요. &quot;[React Native] 스팀커넥트(Steemconnect) 로그인 만들기&quot;에서 작성했던 코드를 재활용했습니다. 덕분에 금방 구현했습니다. 로그인 화면 로그인 화면에는 스팀 커넥션 로그인 버튼과 회원가입 링크가 보입니다. 나중에 포스팅 키로 로그인할 수 있는 기능도 넣을 생각입니다. 그리고 앱 로고 텍스트는 Sweet Sensations Personal Use 폰트를 사용했습니다. 개인적인 용도로는 무료로 사용할 수 있다고 명시되어 있습니다. 회원가입 회원가입 링크를 누르면 스팀 피플 사이트로 연결됩니다. 한국 사용자는 이곳에서 스팀잇 계정을 생성하는 것이 매우 간편하다고 생각합니다. 하지만 스팀 피플에서 회원가입할 때는 개인 정보를 입력해야 하기 때문에 이용약관을 잘 읽어보셔야 합니다. 스팀커넥션 로그인 스팀 커넥션 로그인은 모달 컴포넌트와 웹뷰를 사용하였습니다. 아직 스팀 커넥션 계정을 생성하지 않아서 eSteem-app 계정을 무단으로 잠깐 빌렸습니다. 다음은 스팀 커넥션 로그인 모달 컴포넌트를 구현한 코드의 일부입니다. 웹뷰에서 제공하는 onNavigationStateChange 이벤트 옵션을 사용하여 URL 변화를 캐치하여 accessToken을 취득합니다. 완성 화면 로그인 기능이 잘 동작하네요. 해피 코딩하세요~! vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"영화 리뷰 앱 개발 이야기","slug":"개발-이야기/react-native/영화-리뷰-앱-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/영화-리뷰-앱-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/makeahabit/@wangpigon/makeahabit-1561184031","date":"2019-06-22T06:13:51.000Z","updated":"2019-11-11T13:41:49.858Z","comments":true,"path":"/makeahabit/@wangpigon/makeahabit-1561184031/","link":"","permalink":"https://anpigon.github.io/makeahabit/@wangpigon/makeahabit-1561184031/","excerpt":"","text":"Make a habit하루 한 번 하늘보기 | 매일서래마을 몽마르뜨 언덕에 왔어요. 하늘 구름이 이뻐요.from make a habit app","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"}],"author":"wangpigon"},{"title":"[React Native] 영화 리뷰 모바일 앱 개발 이야기 #2","slug":"/sct/@anpigon/react-native-2","date":"2019-06-22T01:29:03.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/sct/@anpigon/react-native-2/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-2/","excerpt":"안녕하세요. 안피곤입니다.매일매일 글을 써서 보상을 받기 위해 시작한 시리즈입니다. 하루라도 글을 써서 보상받지 않으면 내가 이미 받았어야 할 보상을 빼앗긴 기분이 듭니다. 스팀잇(Steemit)은 저에게 매일매일 글을 쓰게 만드는 장치입니다. 덕분에 글쓰기 스킬이 조금 좋아진 것 같습니다.","text":"안녕하세요. 안피곤입니다.매일매일 글을 써서 보상을 받기 위해 시작한 시리즈입니다. 하루라도 글을 써서 보상받지 않으면 내가 이미 받았어야 할 보상을 빼앗긴 기분이 듭니다. 스팀잇(Steemit)은 저에게 매일매일 글을 쓰게 만드는 장치입니다. 덕분에 글쓰기 스킬이 조금 좋아진 것 같습니다. 그리고 요즘은 예전처럼 코딩 의욕이 많이 줄어들었습니다. 오로지 보상을 받기 위해서 글을 씁니다. 이 글은 보상을 받기 위해서 쓰는 글이기 때문에 대충대충 작성해보겠습니다. ㅋ 이 시리즈는 리액트 네이티브로 모바일 앱을 만드는 과정을 그냥 일기처럼 기록합니다. #AAA 태그 글을 보여주는 영화 리뷰 앱을 만들려고 기획하고 개발을 시작했습니다. 사실은 기획 없이 시작하였습니다. 세세한 기능들은 생각나는 데로 또는 사용자의 피드백이 있으면 천천히 확장해 가겠습니다. 이번에는 AAA 태그에서 글을 가져와서 목록으로 출력하는 화면을 구현했습니다. 글 목록, 글 상세, 로그인, 글쓰기 기능 순으로 구현할 예정입니다. 참고로 피드 화면에는 글 보상이 보이지 않습니다. 내가 작성한 글만 글 보상을 보이게 할 계획입니다. 저는 다른 사람의 글 보상은 볼 필요가 없다고 생각합니다. 다른 글의 보상을 볼 때마다 의욕상실입니다. 회사에서 동기의 연봉이 나보다 더 많다는 것을 알게 된 기분??? ㅎㅎ React-Native-FAB 목록에 보이는 FAB(Floating Action Button) 버튼은 react-native-fab를 사용하였습니다. 나중에 글쓰기 버튼으로 활용할 예정입니다. 버튼을 누르면 아마도 글쓰기 화면으로 이동하게 되겠죠. 구글 검색해보면 알겠시만 FAB 또는 Speed Dial 라이브러가 다수 존재합니다. 저는 버튼이 나타났다 사라지게 하는 옵션이 마음에 들어서 선택하였습니다. FlatList 목록 컴포넌트는 &quot;[React Native] FlatList으로 Infinite Scroll와 Pull Down Refresh 구현하기&quot;에서 작성한 코드를 재활용하였습니다. FlatList 컴포넌트는 기본적으로 Pull-Down-Refresh(당겨서 새로고침) 옵션을 제공합니다. 그래서 스크롤을 아래로 당겼다가 놓았을 때 목록을 새로 고침하는 기능을 매우 쉽게 구현할 수 있습니다. 이런 것이 바로 리액트 네이티브의 장점이라고 생각합니다. 그리고 onScrollBeginDrag와 onScrollEndDrag 이벤트 속성을 사용하여 스크롤 중에는 FAB 버튼이 사라지게 합니다. FlatList는 ScrollView를 상속받았기 때문에 ScrollView 기능도 일부 사용 가능합니다. 작성한 코드 일부입니다. 팁: 코드 이미지는 VSC 확장프로그램 polacode를 사용해서 만들었습니다. 코드하이라이트 기능이 없는 에디터에는 텍스트보다 이게 가독성이 훨씬 좋아보입니다. VSC에서 코드를 드래그만 하면 이미지를 자동으로 만들어 줍니다. 완성 화면 #AAA 태그 글 목록에서 Pull-Down-Refresh와 Infinite Scroll 기능을 구현하였습니다. 이전에 학습하면서 작성했던 코드가 있어서 금방 구현하였네요. 앱 하단에 노란 텍스트 박스가 뜨는 것은 디버깅 모드라서 그렇습니다. 해피 코딩하세요~! vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"영화 리뷰 앱 개발 이야기","slug":"개발-이야기/react-native/영화-리뷰-앱-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/영화-리뷰-앱-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[오픈소스] 스팀코인판에 제가 수정한 코드가 반영되었습니다.","slug":"/sct/@anpigon/6vcmd","date":"2019-06-21T01:59:27.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/sct/@anpigon/6vcmd/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/6vcmd/","excerpt":"안녕하세요. 안피곤입니다.어제 제이콥(@jacobyu)님 도움을 받아, Nitros를 로컬에 셋팅하고 한번 돌려보았습니다. 그리고 제 눈에 거슬리는 부분이 있어서 바로 수정했습니다. 그리고 오픈 소스는 처음으로 기여를 해보게 되었네요. 저는 다른 사람의 코드를 이해하고 수정하는데 약간의 두려움이 있습니다. 그래서 제 코드가 반영된 사실이 매우 기쁩니다. ㅎㅎ","text":"안녕하세요. 안피곤입니다.어제 제이콥(@jacobyu)님 도움을 받아, Nitros를 로컬에 셋팅하고 한번 돌려보았습니다. 그리고 제 눈에 거슬리는 부분이 있어서 바로 수정했습니다. 그리고 오픈 소스는 처음으로 기여를 해보게 되었네요. 저는 다른 사람의 코드를 이해하고 수정하는데 약간의 두려움이 있습니다. 그래서 제 코드가 반영된 사실이 매우 기쁩니다. ㅎㅎ 이번에 제가 수정한 코드는 정말 정말 간단한 작업입니다. 하지만 반영되어서 기분이 매우 좋습니다.ㅋ 확인해보니 스팀 코인판뿐만 아니라 트리플 A에도 같이 반영되었네요. Project Information Repository: https://github.com/steem-engine-exchange/nitrous/tree/scotty_steemcoinpan PR: https://github.com/steem-engine-exchange/nitrous/pull/16 어느 부분이 수정되었는지는 스샷으로 설명하겠습니다. 수정 전 SCT POWER 금액 바로 아래에 (NaN SCT)가 보입니다. **NaN(Not a Number)**는 컴퓨터 연산에서 잘못된 입력을 받았음을 보여주는 기호입니다. 아마도 임대(delegations)를 한번도 하지 않은 사용자는 데이터가 없어서 NaN이 보이는 것 같습니다. 수정 후 임대(delegations) 정보가 없으면 보이지 않게 수정하였습니다. 어제 PR(Pull Requests)를 했는데 벌써 반영이 되었습니다. 그리고 eonwarped님이 친절하게 댓글도 달아주셨습니다. 그리고 수고하신 제이콥님에게도 감사드립니다. 아래 스샷에서 보이는 깃허브 아이디 passionbull가 제이콥님입니다. https://github.com/steem-engine-exchange/nitrous/blob/master/src/app/components/modules/UserWallet.jsx#L89 해피 코딩하세요~! vote, reblog, follow @anpigon","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"Nitrous","slug":"nitrous","permalink":"https://anpigon.github.io/tags/nitrous/"}],"author":"anpigon"},{"title":"[맛집] 뚝섬유원지 맛집 - 그남자의덮밥","slug":"/tasteem/@wangpigon/tasteem-891efc","date":"2019-06-20T00:50:33.000Z","updated":"2019-11-11T13:41:49.847Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-891efc/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-891efc/","excerpt":"그남자의덮밥뚝섬유원지의 맛있는 덮밥집뚝섬유원지역에서 우연히 발견한 조용한 맛집을 소개합니다. 저는 아무 생각없이 인테리어와 식당 이름만 보고 들어갔습니다. 혼밥하기에도 좋은 맛집입니다. 요기가 입구입니다. 그 남자의 덮밥입니다. 네이밍 센스가 돋보입니다. 들어가기 전부터 그 남자의 요리 솜씨가 기대됩니다.","text":"그남자의덮밥뚝섬유원지의 맛있는 덮밥집뚝섬유원지역에서 우연히 발견한 조용한 맛집을 소개합니다. 저는 아무 생각없이 인테리어와 식당 이름만 보고 들어갔습니다. 혼밥하기에도 좋은 맛집입니다. 요기가 입구입니다. 그 남자의 덮밥입니다. 네이밍 센스가 돋보입니다. 들어가기 전부터 그 남자의 요리 솜씨가 기대됩니다. 실내 분위기는 꼭 일본 식당 같습니다. 일본 드라마 고독한 미식가에 한 번쯤 나왔을 법한 분위기입니다. 요런 도시락 세트 메뉴도 있네요. 등갈비 세트를 가지고 한강에서 먹어도 맛있을 것 같습니다. 바로 근처가 한강 뚝섬 유원지라서 이런 메뉴가 있는 것 같아요. 메뉴판도 한번 찍어보았습니다. 저는 그 목살구이 덮밥과 그 연어구이 덮밥을 주문했습니다. 인터넷에서는 그 통삼구이 덮밥이 맛있다고 나와있는데, 메뉴가 변경된 것 같아요. 그 연어구이 덮밥 훈제 연어가 올라가 있습니다. 저는 연어를 참 좋아합니다. 그래서 덮밥집 가면 연어 덮밥을 자주 먹게 되네요. 맛은 나쁘지 않았습니다. 그 목살구이 덮밥 정말 맛있었습니다. 저는 연어를 더 좋아해서 연어 덮밥을 주문했습니다. 하지만 입에는 목살구이 덮밥이 자꾸만 들어옵니다. 가격은 연어구이 덮밥이 더 비쌉니다. 그렇지만 목살구이 덮밥이 더 맛있어요.ㅠ 요 따뜻한 국물도 맛있어요. 맛있어서 자꾸만 마시게 됩니다. 아래는 배고프신 분들을 위해 올리는 사진입니다. 밥 위에 연어구이 한점 올려서 한 숟가락 찍어봅니다. 밥 위에 목살구이 한점을 올리고 부추(?) 하나를 데코해서 한 숟가락 찍어봅니다. 마지막으로 평소 먹는 습관대로 한 숟가락 찍어보았습니다. 다음에는 진짜 등갈비 바베큐를 먹으러 한번 와야할 것 같습니다. 이상. 그 남자의 덮밥집 후기였습니다. 오늘도 행복한 하루가 되길 바랍니다. 맛집정보 그남자의덮밥 대한민국 서울특별시 광진구 자양동 855 [[맛집] 뚝섬유원지 맛집 - 그남자의덮밥](https://kr.tasteem.io/post/36577) 이 글은 Tasteem 컨테스트 [나에게만 집중해요, 조용한 맛집](https://kr.tasteem.io/event/475)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"},{"name":"맛집","slug":"맛집","permalink":"https://anpigon.github.io/tags/맛집/"}],"author":"wangpigon"},{"title":"[React Native] 영화 리뷰 모바일 앱 개발 이야기 #1","slug":"/sct/@anpigon/react-native-1","date":"2019-06-19T23:00:09.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/sct/@anpigon/react-native-1/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/react-native-1/","excerpt":"안녕하세요. 안피곤입니다.최근 회사 업무가 쌓여서 많이 바빠졌습니다. 그래서 저는 지금 안피곤과 왕피곤이 공존하고 있습니다. 의욕도 많이 줄어들고 코딩 글이 잘 안써지네요.그리고 최근 글 보상을 올리고 싶어 SCOT 토큰을 조금 매수했습니다. 스팀잇을 시작할 때는 글 보상에 연연해 하지 않겠다는 생각을 했었습니다. 하지만 최근에는 제 속에서 작은 악마(욕심)가 생겨났습니다. 욕심이 없는 마음을 선이라고 하고, 욕심을 악이라고 한다면, 저는 지금 선과 악이 공존하고 있는 상태입니다.","text":"안녕하세요. 안피곤입니다.최근 회사 업무가 쌓여서 많이 바빠졌습니다. 그래서 저는 지금 안피곤과 왕피곤이 공존하고 있습니다. 의욕도 많이 줄어들고 코딩 글이 잘 안써지네요.그리고 최근 글 보상을 올리고 싶어 SCOT 토큰을 조금 매수했습니다. 스팀잇을 시작할 때는 글 보상에 연연해 하지 않겠다는 생각을 했었습니다. 하지만 최근에는 제 속에서 작은 악마(욕심)가 생겨났습니다. 욕심이 없는 마음을 선이라고 하고, 욕심을 악이라고 한다면, 저는 지금 선과 악이 공존하고 있는 상태입니다. 최근 읽었던 데미안 소설 중에 이런 문장이 있습니다. 난 진정, 내 안에서 솟아 나오려는 것. 그것을 살아 보려 했다. 왜 그것이 그토록 어려웠을까? 그리고 다음은 데미안에서 가장 유명한 문장입니다. “새는 알에서 나오려고 투쟁한다. 알은 세계이다. 태어나려고 하자는 한 세계를 깨뜨리지 않으면 안 된다. 새는 신에게 날아간다. 신의 이름은 아브락사스다.” 이 문장에 나오는 신 아브락사스는 선과 악을 모두 지니고 있는 신입니다. 저는 개발 관련하여 학습 결과를 기록하고 정보를 공유하기 위해서 블로그(스팀잇)을 시작했습니다. 그런데 지금은 보상을 받기 위해 스팀잇을 하고 있다는 생각이 들었습니다. 그래서 본래 페이스를 다시 찾고자 합니다. 그리고 문득 생각이 나서 스팀잇에서 데미안 관련 포스팅을 모두 찾아보았습니다. 헤르만 헤세의 데미안과 아브락사스 by @isis-lee [책서평]데미안-새는 ‘나’, 알은 ‘세계’ by @siltie 투쟁, 살아가는 일에 대하여: 헤르만 헤세 &lt;데미안&gt; by @thewriting [독서] 데미안 줄거리 (스포 있어요) by @wangpigon [madamf’ author] 약간의 위트와 약간의 악의가 뒤섞인, 헤르만 헤세 ’ 데미안 ’ 북커버 by @madamf 주주부의 일상/ 북스팀📖 헤르만 헤세 ‘데미안’ by @joobooju 저도 데미안을 읽고 후기를 작성했습니다. @wangpigon을 팔로우 부탁드립니다. * 저는 소설책을 정말 좋아합니다. 그래서 스팀 블록체인 기반으로 도서 리뷰 모바일앱을 만들 계획을 하고 있었습니다. 하지만 지금은 영화 리뷰 앱이 더 끌립니다. 사실 전 영화도 매우 좋아합니다. 앱 이름은 아직 정하지 못했습니다. 사실은 코딩글 올릴게 없어서 시작한 시리즈입니다. ㅋ ![](https://steemitimages.com/300x0/https://files.steempeak.com/file/steempeak/anpigon/dMZwOS7L-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-06-2020E1848BE185A9E1848CE185A5E186AB201.03.36.png) Happy Coding~!","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"영화 리뷰 앱 개발 이야기","slug":"개발-이야기/react-native/영화-리뷰-앱-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/영화-리뷰-앱-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"⟪라빠르망(L'Appartement)⟫ - 미스터리 사랑 이야기","slug":"/aaa/@wangpigon/l-appartement","date":"2019-06-19T06:02:24.000Z","updated":"2019-11-11T13:41:49.851Z","comments":true,"path":"/aaa/@wangpigon/l-appartement/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/l-appartement/","excerpt":"“정말 특별한 여자를 만났어!” 모니카 벨루치, 뱅상 카셀 주연의 라빠르망을 소개합니다. 아름다운 이 두 배우를 실제 연인으로 연결해준 영화이기도 합니다.이 영화는 오래전 1997년에 개봉했던 작품입니다. 저는 2017년에 재개봉 하면서 알게된 작품입니다. 그리고 이해할 수 없는 마지막 결말에는 조금 충격을 받았습니다.","text":"“정말 특별한 여자를 만났어!” 모니카 벨루치, 뱅상 카셀 주연의 라빠르망을 소개합니다. 아름다운 이 두 배우를 실제 연인으로 연결해준 영화이기도 합니다.이 영화는 오래전 1997년에 개봉했던 작품입니다. 저는 2017년에 재개봉 하면서 알게된 작품입니다. 그리고 이해할 수 없는 마지막 결말에는 조금 충격을 받았습니다. 라빠르망은 시간적 흐름에 따라 진행되지 않고, 과거를 회상하는 장면이 섞여있습니다. 현재에 과거를 끼워 맞춰가면 플롯을 구축해가는 플래시백 형태를 하고 있습니다. 대충 쓰는 줄거리 주인공 막스(뱅상 카셀)가 우연히 카페에서 그녀의 흔적을 발견하면서 영화가 시작됩니다. 그녀는 바로 막스가 과거에 사랑했던 리자입니다. 2년 전 과거 구두 가게에서 일하는 막스(뱅상 카셀)는 리자(모니카 벨루치)를 보는 순간 첫눈에 반합니다. \"뚜둥~!\" 막스의 끈질긴 구애 끝에 라자는 막스의 마음을 받아들입니다. 이 후 둘은 연인이 되고 깊은 사랑에 빠집니다. 매우 행복한 시간을 보냅니다. 하지만, 어느날 갑가지 리자가 사라지고 둘은 갑작스러운 이별을 맞이하게 됩니다. \"눈물 없이 볼 수 없는 가슴 아픈 장면\" 이때 알리스(로만느 보링거)가 등장합니다. 그녀의 미션은 영화내에서 사랑의 삼각 관계를 만드는 것입니다. 그리고 가슴 아픈 멜로와 어긋난 사랑을 파국으로 만드는 것이 최종 목표입니다. 결국 알리스는 뛰어난 연기과 거짓말로 막스의 사랑을 얻어내는데 성공합니다. 이때쯤 스토리는 점점 막장으로 달려갑니다. 사실 영화에서 사랑의 관계를 엄밀하게 말하면 정확하게 삼각 관계는 아닙니다. 사각? 오각? 육각? 너무 막장이라서 사실 저도 잘 모르겠습니다. 저는 꼬일대로 꼬인 사랑의 관계라고 하겠습니다. ㅎㅎ 영화는 스토리의 개연성이나 흘러가는 방향에 대한 설명이 전혀 없기 때문에 추리하면서 봐야합니다. 영화 속 주인공들의 사랑 싸움도 그렇고, 관객들도 스토리를 이해하기 위해서는 머리를 많이 굴려야하기 때문에 일종의 두뇌(브레인) 영화입니다. 이번 영화의 감상평은 노래로 대신합니다. 비와 당신의 이야기 - 이승철 당신은 나를 기억해야 하네 항상 나를 슬프게 했지 나의 사랑스럽던 너의 눈가에 비들 그 날의 애절한 너를 차마 볼 수 없었던 거야 ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/12531-l-appartement?language=kr-KR 별점: AA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"[맛집] 세곡 양갈비 전문점 - 오세안양갈비","slug":"/tasteem/@wangpigon/tasteem-0f10ac","date":"2019-06-17T05:40:39.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-0f10ac/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-0f10ac/","excerpt":"오세안 양갈비세곡동 최고의 양갈비집제가 아끼는 맛집입니다. 하지만 너무 맛있어서 소개합니다. 세곡동 오세안 양갈비 집입니다.저는 원래 양꼬치 특유의 냄새때문에 좋아하는 음식이 아니었습니다. 하지만 이 집의 양고기는 냄새가 거의 안나고 정말 맛있습니다. 제가 반한 맛집입니다.","text":"오세안 양갈비세곡동 최고의 양갈비집제가 아끼는 맛집입니다. 하지만 너무 맛있어서 소개합니다. 세곡동 오세안 양갈비 집입니다.저는 원래 양꼬치 특유의 냄새때문에 좋아하는 음식이 아니었습니다. 하지만 이 집의 양고기는 냄새가 거의 안나고 정말 맛있습니다. 제가 반한 맛집입니다. 식당은 생긴지 얼마 안되었습니다. 저는 우연히 지나가다 발견했어요. 세곡동600번지에 위치하고 있어요. 구글 지도에서 검색하면 식당이 안나오네요. ㅋ 실내는 이렇게 생겼습니다. 남사장님과 여사장님 모두 매우 친절합니다. 양고기는 호주산이며 매일 아침 제일 좋은 고기로 받아오신다고 합니다. 그리고 어린양을 사용해서 냄새가 덜 난나고 하네요. 직원이 고기를 정말 맛있게 구워줍니다. 아마 제가 구웠으면 이렇게 맛있게 못먹을것 같아요. ㅋ 고기 한점을 근접샷으로 찍어보았습니다. 깨끗한 그릇에 옮겨서 사진을 찍을것 그랬네요. ㅋ 고기는 소스에 찍어 먹어도 맛있고, 그냥 먹어도 너무 맛있습니다. 잡내가 안나고 부드러워서 소고기 먹는 기분이었습니다. 잡내때문에 양고기 못드셨던 분은 이곳을 추천합니다. 맛집정보 오세안 양갈비 대한민국 서울특별시 서초구 헌릉로 [[맛집] 세곡 양갈비 전문점 - 오세안양갈비](https://kr.tasteem.io/post/36362) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/465)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"⟪맨 인 블랙: 인터내셔널⟫ - 저절로 하품 나오는 영화","slug":"/aaa/@wangpigon/32udcx","date":"2019-06-17T01:52:18.000Z","updated":"2019-11-11T13:41:49.851Z","comments":true,"path":"/aaa/@wangpigon/32udcx/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/32udcx/","excerpt":"주말에 맨 인 블랙을 보고 왔습니다. 최대한 스포는 피해서 리뷰하겠습니다. 이번에 개봉한 영화를 맨인블랙 4라는 생각에 무척 기대했습니다. 하지만 영화를 보고 나니 다른 영화라고 생각됩니다. 영화는 화려한 볼거리(CG) 와 B급 유머, 그리고 귀여움이 영화의 전부입니다. 스토리는 너무 진부하여 하품이 나올 정도입니다. 하지만 영화의 스케일은 확실히 커졌습니다.","text":"주말에 맨 인 블랙을 보고 왔습니다. 최대한 스포는 피해서 리뷰하겠습니다. 이번에 개봉한 영화를 맨인블랙 4라는 생각에 무척 기대했습니다. 하지만 영화를 보고 나니 다른 영화라고 생각됩니다. 영화는 화려한 볼거리(CG) 와 B급 유머, 그리고 귀여움이 영화의 전부입니다. 스토리는 너무 진부하여 하품이 나올 정도입니다. 하지만 영화의 스케일은 확실히 커졌습니다. 영화 “토르: 라그나로크(2017)” 와 “어벤져스: 엔드게임(2019)” 에서 합을 맞췄던, 크리스 헴스워스와 테사 톰슨이 개그 콤비가 되어 돌아왔습니다. 에이전트 H 역할의 크리스 햄스워스는 아직 어벤져스의 토르를 벗지 못했고, 에이전트 M 역할의 테사 톰슨은 맨인블랙 덕후가 코스프레하는 느낌이었습니다. 특히 크리스 햄스워스의 연기는 예전에 &quot;고스트버스터즈(2016)&quot;의 케빈이 연상될 정도 였습니다. 갑자기 윌 스미스가 보고 싶어졌습니다. 그나저나 맨인블랙3에도 출연했던 배우 엠마 톰슨은 정말 안 늙는것 같습니다. 얼굴이 예전 그대로네요. 부럽습니다. ㅋ 영화에는 귀여운 요소가 가끔 등장합니다. 다음은 못생겼지만 짱 귀엽습니다. 엄지외계인 피규어 나오면 갖고 싶어요. ㅋ 이전에 엑스맨 마지막 시리즈인 “다크 피닉스” 후기를 남겼습니다. 그런데 다크 피닉스 급의 영화가 이번에 또 개봉했네요. 이번에도 짧은 리뷰로 마무리합니다. 이번에 개봉한 맨 인 블랙: 인터내셔널은 흠이 너무 많아서 흠잡을 데 없는 영화입니다. 그리고 전작 시리즈를 모두 명작으로 만들어버렸습니다. 마지막으로 알라딘으로 갈아탄 윌 스미스의 탁월한 선택에 박수를 보냅니다. 자~! 이번에 개봉한 맨인블랙 영화 보신 분들은 여기 보세요~! ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/479455-men-in-black-international?language=ko-KR 별점: A 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"[여행] 광명동굴 (스크롤 압박 주의!!!)","slug":"/tripsteem/@wangpigon/tt20190616t154252952z","date":"2019-06-16T15:42:54.000Z","updated":"2019-11-11T13:41:49.848Z","comments":true,"path":"/tripsteem/@wangpigon/tt20190616t154252952z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@wangpigon/tt20190616t154252952z/","excerpt":"오늘 날씨가 너무 좋네요. 그래서 광명동굴에 다녀왔습니다. 광명동굴은 2017~2019 한국이 꼭 가봐야 할 한국 100대 대표관광지 입니다. 우리는 1호선 광명역에 내려서 투어를 시작했습니다.먼저, 광명동굴에 대해서 간단하게 설명하고 광명동굴 투어를 시작하겠습니다. 광명동굴에 대한 이야기는 가이드님께 들은 이야기입니다.","text":"오늘 날씨가 너무 좋네요. 그래서 광명동굴에 다녀왔습니다. 광명동굴은 2017~2019 한국이 꼭 가봐야 할 한국 100대 대표관광지 입니다. 우리는 1호선 광명역에 내려서 투어를 시작했습니다.먼저, 광명동굴에 대해서 간단하게 설명하고 광명동굴 투어를 시작하겠습니다. 광명동굴에 대한 이야기는 가이드님께 들은 이야기입니다. 광명동굴(구 시흥광산)은 일제강점기 자원수탁의 목적으로 개발되었습니다. 바로 일제강점기의 강제징용과 자원수탈의 현장이었습니다. 그리고 또한 해방 이후 근대 산업화의 흔적이 남아있는 곳입니다. 1972년 대홍수로 폐광 된 이후 40년간 새우젓 창고로 활용 되었습니다. 하지만 2011년 광명시에서 광명동굴을 매입하면서 이제는 문화예술 관광의 대표 명소가 되었습니다. 지금부터 광명동굴의 모든 것을 싹 다 보여 드리겠습니다. 그래서 사진을 좀 많이 찍었습니다. 사진이 많아서 스크롤이 매우 깁니다. 광명역 8번 출구로 나오면 버스 정류장이 있습니다. 이곳에서 17번 또는 77B번 버스를 타면 광명동굴에 내려줍니다. 광명동굴 매표소에 도착했습니다. 팁을 알려드리면, 광명시와 카카오톡 플러스친구면 20％ 할인을 받을 수 있습니다. 광명시와 카카오플러스 친구가 아니라면 친구하고 할인권 받으세요. ㅋ 2019년 4월 27일 부터 11월 24일까지 레인보우 팩토리 전시를 하고 있네요. 저는 보지 않았습니다. 하지만 관심있는 분들은 오셔서 관람하고 후기 남기세요. ㅋ 이것은 광명시자원회수시설 건물 굴뚝입니다. 쓰레기를 태우면 연기가 이 굴뚝으로 빠져나간다고 합니다. 많은 가족들이 광명동굴에 나들이 나왔어요. 오늘 날씨가 좋아서 그런지 사람이 무척 많았습니다. 사실 저는 VR체험관을 이용하지 않았어요. 그냥 VR체험관 건물 앞에서 사진만 찍었습니다. 광명동굴 입구 동굴 입구 내부에서 에어콘보다 차가운 바람이 불어옵니다. 가실 분은 겉옷 꼭 챙겨가세요. 생각보다 많이 추워요. 여긴 사실 자연 동굴이 아니고 폐광을 동굴로 만든 곳입니다. 웜홀 광장 웜홀 광장은 100년의 시공간을 넘어서 과거와 현재를 연결해줍니다. 이곳은 4개의 통로가 만나는 곳입니다. 그리고 동굴 세상으로 여행을 떠나는 출발지점입니다. 빛의 공간 어둠 속에서 가장 아름다운 존재는 바로 빛입니다. 이곳은 빛을 주제로 하나의 터널을 예술공간으로 만들었습니다. 음악에 맞춰 반짝이는 LED 빛 터널과 작가의 조명 작품을 만날 수 있습니다. 동굴예술의 전당 이곳은 대한민국에서 유일하게 동굴 내에 있는 예술의 전당입니다. 많은 예술가와 협업을 통한 공연과 미디어파사드쇼를 볼 수 있는 곳입니다. 동굴 벽을 스크린 삼아 빔프로젝트를 투영하여 보여주는 미디어파드쇼는 정말 환상적입니다. 여기 오시면 꼭 보아야 할 관광 포인트입니다. 입구에 들어오니 미디어파드쇼가 바로 시작되었습니다. 동굴아쿠아월드 동굴 지하 암반수를 이용하여 만든 아쿠아리움입니다. 국내의 토종물고기와 전세계 다양한 어종을 볼 수 있습니다. 지하수라서 물이 정말 맑습니다. 우리 피라냐는 이빨이 없어용. ㅠㅠ 황금길 황금길은 황금을 주제로 만든 예술공간입니다. 황금벽, 황금궁전, 황금방 등을 볼 수 있습니다. 벽을 황금색을 칠했는지 반짝 반짝 하네요. 소망의 초신성입니다. 방문객들의 소망을 적은 황금패를 보아서 만들었다고 합니다. 초신성 아래에서 소원을 기원하면 좋은 일이 있을 것이라고 합니다. 부를 가져다 주는 황금의 여신입니다. 뿔에 담겨있는 황금을 만지면 부자가 된다고 합니다. 그래서 만져보았습니다. 이곳에 와서 우리는 부자가 되는 행운을 받아갑니다. 방문객들의 소원이 적힌 황금패가 벽면 빼곡히 걸려있습니다. 눈에 띄는 황금패를 하나씩 읽어봅니다. 답십리 젠트리움 사업이 꼭 성공했으면 좋겠습니다. 그리고 김영운님과 김보람님의 사랑도 영원했으면 좋겠습니다. 조근남님은 로또 1등에 당첨되었으면 좋겠습니다. 그리고 우리 가족, 희정이 가족 모두 행복했으면 좋겠습니다. 황금패는 이곳에서 구입하여 소원을 적어서 벽에 걸면 됩니다. 황금패는 4 종류가 있습니다. 높이 9m, 너비 8.5m로 분당 1.4톤의 지하 암반수가 폭포가 되어 낙하합니다. 동굴 속이라서 폭포소리가 매우 웅장합니다. 조명 때문에 폭포가 매우 이쁩니다. 동굴지하세계 여기는 동굴 지하세계로 내려가는 입구입니다. 163계단이라고 합니다. 하지만 계단이 매우 가파릅니다. 이곳은 황금 궁전입니다. 황금 궁전에는 동굴요정 아이샤가 황금망치를 들고 황금의 방을 지키고 있습니다. 여기는 황금의 방입니다. 동굴요정 아이샤가 만들어낸 황금보물이 있는 곳입니다. 관람객들이 이 방에 던진 기부금은 모두 청소년 복지를 위해서 사용된다고 합니다. 조명에 비치는 동굴 지하 호수는 정말 이뻤습니다. 먹는 광부샘물은 동굴 지하 1레벨의 암반수를 활용한 약수터입니다. 지하 갱도에서 작업하던 광부들의 목마름을 해결해주던 곳이라고 합니다. 그냥 일반 아리수 식수대랑 똑같네요. 이곳은 근대역사관입니다. 그리고 광명동굴의 역사를 볼 수 있는 곳입니다. 디오라마 디테일이 깨알 같습니다. 귀엽네요. ㅋ 다음 디오라마는 동굴 예술의전당 건설 당시의 모습을 재연한 것 같습니다. 너무 멋졌습니다. 동굴식물원 동굴 속에도 식물원이 있습니다. 바로 동굴 식물원을 소개합니다. LED 빛으로 식물 광합성 작용을 돕는다고 합니다. 수족관에서 분해된 물고기의 배설물과 유기물을 영양분으로 활용하여 식물의 성장을 돕고 있습니다. 와인동굴 이제 마지막 코스인 와인동굴 입니다. 이곳은 연중 12도를 항상 유지하기 때문에 와인을 보관하기 가장 좋은 장소입니다. 그래서 와인 한방울 생산하지 않는 광명시가 와인동굴 덕분에 대한민국 국산화인의 메카가 되었습니다. 참고로 와인동굴은 드라마와 뉴스에도 나온 매우 유명한 곳입니다. ㅋ 관련 기사도 찾아봤습니다. “오마이뉴스 - 와인 한 방울 안 나는 광명 어떻게 국산 와인 메카 됐나” 이곳에서 와인을 공부하고 갑니다. 너무 잘만들어져 있어서 놀랐습니다. 와인시음대에 오시면 와인 시음을 할 수 있습니다. 시음대에서 와인 판매도 같이 하는 것 같습니다. 현재 시음하는 와인은 로제 와인입니다. 와인의 장밋빛 색이 정말 이쁩니다. 마시기 전에 찍었어야 하는데 다 먹어버렸네요. 장밋빛 색의 와인을 보여드려야하는데 ㅠㅠ 통로를 따라 가다 보니 와인판매대가 보입니다. 이곳에서 와인을 구입할 수 있을 것 같습니다. 와인동굴의 끝에는 마루드카브 레스토랑이 위치하고 있습니다. 레스토랑 손님만 입장이 가능합니다. 그래서 내부에 들어가지는 않았습니다. 동굴 탈출 와인동굴을 마지막으로 드디어 동굴 출구로 나왔습니다. 시계를 확인해보니 동굴 속에 약 2시간 정도 있었습니다. 꽤 오래 있었네요. 광명동굴에 볼거리가 많아서 시간 가는 줄 몰랐습니다. 기념품 숍은 모든 관광의 마지막 필수 코스입니다. 이제 이 기념품 숍을 들어가면 오늘 관광도 끝이네요. 아쉽습니다. 기념품 숖에는 광명동굴 캐릭터를 활용한 굿즈를 팔고 있습니다. 그리고 유리병으로 만든 접시가 매우 특이했습니다. 올 여름 광광지로 시원한 광명동굴을 추천합니다. 여행지 정보● 대한민국 경기도 광명시 학온동 가학로85번길 142[여행] 광명동굴 (스크롤 압박 주의!!!) 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"},{"name":"동굴","slug":"동굴","permalink":"https://anpigon.github.io/tags/동굴/"}],"author":"wangpigon"},{"title":"[카페] 뚝섬유원지역 분위기 좋은 카페 - 커피더쏠","slug":"/tasteem/@wangpigon/tasteem-75f30d","date":"2019-06-16T13:04:36.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-75f30d/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-75f30d/","excerpt":"커피 더 쏠네루토 융드립 커피오늘은 뚝섬 유원지 근처에 있는 카페에 다녀왔습니다. 지하철 7호선 내려서 뚝섬유원지역 1번 출구로 나오면 쉽게 찾을 수 있어요.저도 오늘 처음 방문한 카페입니다. 하지만 커피향과 커피맛이 너무 좋아서 소개합니다. 그리고 카페 분위기도 매우 좋습니다.","text":"커피 더 쏠네루토 융드립 커피오늘은 뚝섬 유원지 근처에 있는 카페에 다녀왔습니다. 지하철 7호선 내려서 뚝섬유원지역 1번 출구로 나오면 쉽게 찾을 수 있어요.저도 오늘 처음 방문한 카페입니다. 하지만 커피향과 커피맛이 너무 좋아서 소개합니다. 그리고 카페 분위기도 매우 좋습니다. 카페 분위기는 글로 설명하기 보다는 사진으로 보여드리겠습니다. 그래서 사진을 많이 찍어왔습니다. ㅋ 따뜻한 조명을 사용해서 카페가 전체적으로 아늑하고 따뜻한 분위기입니다. 케익과 수제 쿠키도 팔고 있어요. 아기자기한 소품과 인테리어가 완전 제 취향입니다. 소품 때문인지 카페가 왠지 고급스러웠습니다. 이곳에 앉아서 커피 한잔하고 싶었습니다. 하지만 우리는 커피 들고 뚝섬 유원지에 갈 거라서 테이크 아웃을 했습니다. 여기서 추천하는 탄자니아 원두로 아이스 아메리카노를 주문했습니다. 여기에 커피 원두에 대한 설명이 매우 자세하게 나와 있습니다. 이걸 읽어보시면 원두를 선택하는데 도움이 될 것 같습니다. 하지만 저는 선택 장애가 있기 때문에 카페에서 추천하는 원두를 마십니다. 오늘 날씨가 더워서 아이스 커피가 무척 마시고 싶었습니다. 마셔보니 커피 향이 진하고 목넘김이 매우 부드러웠습니다. 커피를 들고 뚝섬 유원지에 왔습니다. 인증 샷입니다~! 오늘은 하늘이 맑고 구름이 이뻤습니다. 그래서 많은 사람들이 유원지에 나들이 나왔어요. 오늘은 하늘과 구름이 참 이뻤습니다. 맛집정보 커피더쏠 대한민국 서울특별시 광진구 자양3동 능동로 18 [[카페] 뚝섬유원지역 분위기 좋은 카페 - 커피더쏠](https://kr.tasteem.io/post/36316) 이 글은 Tasteem 컨테스트 [내가 사랑한 카페](https://kr.tasteem.io/event/464)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/makeahabit/@wangpigon/makeahabit-1560651560","date":"2019-06-16T02:19:21.000Z","updated":"2019-11-11T13:41:49.858Z","comments":true,"path":"/makeahabit/@wangpigon/makeahabit-1560651560/","link":"","permalink":"https://anpigon.github.io/makeahabit/@wangpigon/makeahabit-1560651560/","excerpt":"","text":"Make a habit하루 한 번 하늘보기 | 매일오늘은 날씨가 대박이네용. from make a habit app","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"}],"author":"wangpigon"},{"title":"책 읽고 사진 찍기 | 주 3일","slug":"/makeahabit/@wangpigon/makeahabit-1560584112","date":"2019-06-15T07:35:12.000Z","updated":"2019-11-11T13:41:49.858Z","comments":true,"path":"/makeahabit/@wangpigon/makeahabit-1560584112/","link":"","permalink":"https://anpigon.github.io/makeahabit/@wangpigon/makeahabit-1560584112/","excerpt":"Make a habit책 읽고 사진 찍기 | 주 3일베르나르 베르베르 신간 죽음을 읽고 있습니다. 베르나르 베르베르는 제가 좋아하는 작가 중 한 명입니다.죽음을 소재로 어떤 스토리가 담겨있을지 무척 궁금합니다. 다 읽고 나서 후기 남겨볼께요- from make a habbit app","text":"Make a habit책 읽고 사진 찍기 | 주 3일베르나르 베르베르 신간 죽음을 읽고 있습니다. 베르나르 베르베르는 제가 좋아하는 작가 중 한 명입니다.죽음을 소재로 어떤 스토리가 담겨있을지 무척 궁금합니다. 다 읽고 나서 후기 남겨볼께요- from make a habbit app","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"},{"name":"베르나르 베르베르","slug":"베르나르-베르베르","permalink":"https://anpigon.github.io/tags/베르나르-베르베르/"}],"author":"wangpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/makeahabit/@wangpigon/makeahabit-1560578723","date":"2019-06-15T00:00:00.000Z","updated":"2019-11-11T13:41:49.858Z","comments":true,"path":"/makeahabit/@wangpigon/makeahabit-1560578723/","link":"","permalink":"https://anpigon.github.io/makeahabit/@wangpigon/makeahabit-1560578723/","excerpt":"","text":"Make a habit하루 한 번 하늘보기 | 매일하루에 한번 하늘보기 완료!오늘은 하늘 구름이 이뻐요.늘 하늘이 맑았으면 좋겠습니다.- from make a habit app","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"}],"author":"wangpigon"},{"title":"⟪마담 프루스트의 비밀정원⟫ - 잃어버린 행복한 기억을 다시 찾아준 영화","slug":"/aaa/@wangpigon/52fyug","date":"2019-06-14T06:54:18.000Z","updated":"2019-11-11T13:41:49.850Z","comments":true,"path":"/aaa/@wangpigon/52fyug/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/52fyug/","excerpt":"프랑스 영화는 저랑 잘 맞는 것 같습니다. 이번에 소개할 영화도 바로 프랑스 영화입니다. 한편의 동화같은 영화 마담 프루스트의 비밀정원을 소개합니다. “당신의 기억, 행복한가요?” 이하 내용부터는 스포일러가 있습니다.주인공 폴은 어린 시절 부모님을 모두 잃은 아픈 기억을 가지고 있습니다. 그래서 영화에서 그는 항상 눈에 동공이 풀려있고 생기가 없습니다. 게다가 실어증까지 걸려있습니다. 어릴때 부모님의 사랑을 받지 못한 사랑의 결핍 때문에 그런 것 같습니다.","text":"프랑스 영화는 저랑 잘 맞는 것 같습니다. 이번에 소개할 영화도 바로 프랑스 영화입니다. 한편의 동화같은 영화 마담 프루스트의 비밀정원을 소개합니다. “당신의 기억, 행복한가요?” 이하 내용부터는 스포일러가 있습니다.주인공 폴은 어린 시절 부모님을 모두 잃은 아픈 기억을 가지고 있습니다. 그래서 영화에서 그는 항상 눈에 동공이 풀려있고 생기가 없습니다. 게다가 실어증까지 걸려있습니다. 어릴때 부모님의 사랑을 받지 못한 사랑의 결핍 때문에 그런 것 같습니다. 그리고 그는 두 이모들의 손에 키워집니다. 그는 세계적인 피아니스트로 될 실력을 가지고 있지만, 댄스교습소에서 피아노를 연주하는 것이 일상의 전부입니다. 어느날 그는 우연히 이웃집의 프루스트 부인을 만나게 됩니다. 그녀는 실내에 작은 정원을 가지고 있습니다. 그리고 그는 부인이 만들어준 홍차와 마들렌을 먹고 꿈 속 무의식의 세계로 들어갑니다. 그는 그리워하던 부모님을 꿈속에서 다시 만나게 됩니다. 영화 속에서 1인칭 시점으로 보여지는 폴의 꿈 장면은 저도 같이 환각에 빠져 행복했던 시절을 떠올리게 했습니다. 프루스트 부인은 기억을 되살리기 위해서는 음악이 중요하다고 했습니다. 그리고 그는 부인의 기억 치료 덕분에 표정이 점점 밝아지고 결국에는 실어증을 극복합니다. “기억은 일종의 약국이나 실험실과 유사하다. 아무렇게나 내민 손에 어떤 때는 진정제가 때론 독약이 잡히기도 한다.” 마지막으로 배우 귀욤 고익스는 1인 2역으로 주인공 폴과 폴의 아빠를 연기했습니다. 이 사실을 알았을때 저는 정말 놀랐습니다. 영화를 보면서 전혀 알아차리지 못했거든요. ㅋ 이번에도 영화를 한 문장으로 표현해보겠습니다. 힐링이 필요하거나 우울할 때 보면 좋은 영화. 꿈과 희망의 노래를 불러 주는 영화라고 하겠습니다. 이상. 짧은 영화 리뷰였습니다. ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/186729-attila-marcel?language=ko-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"ECDSA 서명으로 JWT 토큰 생성 및 검증하기","slug":"/sct/@anpigon/dev-ecdsa-jwt","date":"2019-06-14T01:40:03.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/sct/@anpigon/dev-ecdsa-jwt/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/dev-ecdsa-jwt/","excerpt":"안녕하세요. 안피곤입니다.ECDSA는 암호화폐에 가장 많이 사용되는 암호화 알고리즘입니다. 그리고 RSA 보다 성능이 더 좋다고 알려져 있습니다. 그리고 JWT(JSON Web Token)은 보안 및 인증에 가장 많이 사용되고 있습니다. 이 2개를 가지고 토큰을 생성하고 인증 하는 방법을 구현합니다.","text":"안녕하세요. 안피곤입니다.ECDSA는 암호화폐에 가장 많이 사용되는 암호화 알고리즘입니다. 그리고 RSA 보다 성능이 더 좋다고 알려져 있습니다. 그리고 JWT(JSON Web Token)은 보안 및 인증에 가장 많이 사용되고 있습니다. 이 2개를 가지고 토큰을 생성하고 인증 하는 방법을 구현합니다. 보통은 JWT 생성에 SHA 해시 알고리즘을 사용하는 HMAC을 사용합니다. 이것은 단방향 암호화 방식입니다. 하지만 ECDSA를 사용하면 비대칭키를 사용하기 때문에 부인 방지 및 메세지 인증을 처리 할수 있습니다. 참고로 부인은 여러분이 생각하는 그 부인은 아닙니다. * * * 구현을 위해선는 아래 두 라이브러리가 필요합니다. 12const jwt = require(\"jsonwebtoken\");const ECDSA = require('ecdsa-secp256r1'); 참고: https://www.npmjs.com/package/jsonwebtoken https://www.npmjs.com/package/ecdsa-secp256r1 ECDSA 키 생성 12345678910111213141516171819202122232425262728293031323334353637383940const privateKey = ECDSA.generateKey() privateKey.toJWK()/*｛ kty: 'EC', crv: 'P-256', x: '4YdUIhIDncVu5tScgjxthiXOO_el11FWb56gR3qnhVQ', y: 'UyEvWOJbMZa9PtggGeRC9iQcAzOZZsyXpFE1qaF6jFk', d: 'TYVI2fW-nHSPGCx0MhWasg2Ggiyl1E_Kq4D1A5LmkxU' ｝*/ privateKey.asPublic().toJWK()/*｛ kty: 'EC', crv: 'P-256', x: '4YdUIhIDncVu5tScgjxthiXOO_el11FWb56gR3qnhVQ', y: 'UyEvWOJbMZa9PtggGeRC9iQcAzOZZsyXpFE1qaF6jFk' ｝*/ privateKey.toPEM()/*-----BEGIN PRIVATE KEY-----MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgTYVI2fW+nHSPGCx0MhWasg2Ggiyl1E/Kq4D1A5LmkxWhRANCAAThh1QiEgOdxW7m1JyCPG2GJc4796XXUVZvnqBHeqeFVFMhL1jiWzGWvT7YIBnkQvYkHAMzmWbMl6RRNamheoxZ-----END PRIVATE KEY-----*/ privateKey.asPublic().toPEM()/*-----BEGIN PUBLIC KEY-----MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4YdUIhIDncVu5tScgjxthiXOO/el11FWb56gR3qnhVRTIS9Y4lsxlr0+2CAZ5EL2JBwDM5lmzJekUTWpoXqMWQ==-----END PUBLIC KEY-----*/ privateKey.toCompressedPublicKey()/*A+GHVCISA53FbubUnII8bYYlzjv3pddRVm+eoEd6p4VU*/ ECDSA 서명 하기 12345const message = ｛ text: 'hello' ｝privateKey.sign(JSON.stringify(message))/*lY3Lf9xDtcsqom5IKu+ZyikxeYHlEuxnPfme4lMxp76NMkIm5BiLxVjbqBSo4itfT/LEuBCzMXl11cB0w/X8dA==*/ ECDSA 서명 검증 123456789const key = 'A+GHVCISA53FbubUnII8bYYlzjv3pddRVm+eoEd6p4VU'const publicKey = ECDSA.fromCompressedPublicKey(key) // or ECDSA.fromJWKconst message = ｛ text: 'hello' ｝const signature = 'lY3Lf9xDtcsqom5IKu+ZyikxeYHlEuxnPfme4lMxp76NMkIm5BiLxVjbqBSo4itfT/LEuBCzMXl11cB0w/X8dA==' publicKey.verify(JSON.stringify(message), signature)/*true*/ * * * JWT 토큰 생성하기 ES256는 P-256 곡선과 SHA-256 해시 알고리즘을 사용하는 ECDSA입니다. 다른 알고리즘은 여기 문서를 참고하세요. 123const privateKey = fs.readFileSync('private.key'); // or privateKey.toPEM();const payload = ｛ accessKey: 'hello' ｝;const jwtToken = jwt.sign(payload, privatekey, ｛ algorithm: 'ES256' ｝); JWT 토큰 검증하기 12const publicKey = publicKey.toPEM();const result = jwt.verify(jwtToken, publicKey, ｛ algorithm: 'ES256' ｝); # JWT 토큰 복호화하기 jwt 토큰 복호화 하여 내용을 확인합니다. 1const decodedToken = jwt.decode(jwtToken, ｛ algorithm: 'HS256' ｝); 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"ECDSA","slug":"ecdsa","permalink":"https://anpigon.github.io/tags/ecdsa/"},{"name":"JWT","slug":"jwt","permalink":"https://anpigon.github.io/tags/jwt/"}],"author":"anpigon"},{"title":"⟪일 포스티노⟫ -  한 폭의 아름다운 시를 읊어 주는 영화","slug":"/aaa/@wangpigon/4rrehn","date":"2019-06-13T06:20:45.000Z","updated":"2019-11-11T13:41:49.850Z","comments":true,"path":"/aaa/@wangpigon/4rrehn/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/4rrehn/","excerpt":"일포스티노우정과 사랑, 성장을 담은 한 폭의 시 “시가 내게로 왔다”첼레의 유명한 시인 네루다와 그의 친구이자 제자인 마리오가 읊어주던 시에 무척 감명받았던 영화입니다. 시네마 천국의 필립 느와레가 출연한 작품이라서 더 좋아했던 것 같습니다.저는 일 포스티노 영화를 사랑하는 사람이 무척 많을 것이라고 생각합니다. 이렇게 아름다운 시를 소재로한 영화는 매우 드뭅니다. 특히 마리오가 베아트리체의 사랑을 쟁취하기 위해 읇어주던 시는 정말 최고였습니다.","text":"일포스티노우정과 사랑, 성장을 담은 한 폭의 시 “시가 내게로 왔다”첼레의 유명한 시인 네루다와 그의 친구이자 제자인 마리오가 읊어주던 시에 무척 감명받았던 영화입니다. 시네마 천국의 필립 느와레가 출연한 작품이라서 더 좋아했던 것 같습니다.저는 일 포스티노 영화를 사랑하는 사람이 무척 많을 것이라고 생각합니다. 이렇게 아름다운 시를 소재로한 영화는 매우 드뭅니다. 특히 마리오가 베아트리체의 사랑을 쟁취하기 위해 읇어주던 시는 정말 최고였습니다. 하지만 영화의 주인공인 마리오 역할을 연기한 마시모 트로이시는 이 영화를 마지막으로 세상과 작별합니다. 그는 심장병 때문에 건강이 매우 악화된 상태였어요. 그런 악건강 상태에서 무리하게 촬영을 진행했습니다. 그리고는 마지막 장면 촬영을 무사히 마치고 숨을 거두고 말았습니다. ㅠㅠ 줄거리 칠레의 공산주의자인 시인 네루다는 정부의 탄압을 받게 됩니다. 그래서 이탈리아의 작은 섬으로 망명하게 됩니다. 이 섬에는 우편 배달부 마리오가 살고 있었습니다. 마리오는 아직 여자를 모르는 모쏠입니다. 그래서 그는 여자에게 인기가 많은 로맨티스트 시인 네루다를 매우 부러워합니다. 그리고 시를 통해 마리오는 네루다의 친구이자 제자가 됩니다. 마리오. 내가 쓴 시 구절은 다른 말로는 표현할 수가 없다네. 시란 설명하면 진부해지고 말아. 시를 이해하는 가장 좋은 방법은 감정을 직접 경험해 보는 것뿐이야. ___네루다 대사 중에서… 그 이후 마리오는 네루다로 부터 작업 멘트와 시를 배우게 됩니다. 그리고는 첫 눈에 반한 아름다운 베아트리체와 결국 사랑을 이룹니다. 그는 시를 배우면서 모쏠에서 탈출합니다. 그리고 시를 통해 마리오는 자기의 생각과 말도 명확하게 표현할 줄 알게 됩니다. 그리고 사회를 바라보는 시각도 달라집니다. 하지만 이탈리아 대규모 사회주의자 집회에 참석한 마리오는 어이없게 죽음을 맞이합니다. 시인 네루다는 마리오가 생전에 남겨놓은 섬의 아름다움을 녹음한 음성 편지를 몇 년이 지나서야 듣게 됩니다. 이 장면에서는 나도 모르게 눈에서 눈물이 주룩 흘렀습니다. 아름다운 시를 읊어주던 마리오가 죽어서 정말 가슴아프고 시렸습니다. 평범한 우편 배달부였던 마리오가 네루다를 만나면서 성장해가는 모습을 그린 영화. 그리고 시를 통해 영화의 분위기를 아름답게 표현한 영화라고 하겠습니다. 이상. 짦은 영화 리뷰였습니다. ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/11010-il-postino?language=kr-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"[블록체인] 하드웨어 웰렛으로 비트코인 서명 구현하기 #1","slug":"/sct/@anpigon/1","date":"2019-06-12T09:15:51.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"/sct/@anpigon/1/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/1/","excerpt":"안녕하세요. 안피곤입니다.개발자로서 블로그를 운영하며 매일 매일 글쓰기는 정말 어렵습니다. 그래서 개발 관련한 노하우나 기술라도 블로그에 자주 올리도록 노력해야겠습니다.다음은 비트코인 트랜잭션에서 계산된 시그해시를 외부에서 서명하여 트랜잭션에 다시 추가하는 방법입니다. SDK 라이브러리를 사용하면 지갑 생성과 서명을 한번에 다 처리해줍니다. 하지만 서명만 처리하는 서버가 별도로 있거나 지갑키(서명키)가 하드웨어 월렛 또는 모바일 디바이스에 있는 경우는 대부분의 SDK에서 지원하지 않는 것 같습니다. 이번에 하드웨어 웰렛을 개발하면서 삽질한(?) 노하우를 공유합니다.","text":"안녕하세요. 안피곤입니다.개발자로서 블로그를 운영하며 매일 매일 글쓰기는 정말 어렵습니다. 그래서 개발 관련한 노하우나 기술라도 블로그에 자주 올리도록 노력해야겠습니다.다음은 비트코인 트랜잭션에서 계산된 시그해시를 외부에서 서명하여 트랜잭션에 다시 추가하는 방법입니다. SDK 라이브러리를 사용하면 지갑 생성과 서명을 한번에 다 처리해줍니다. 하지만 서명만 처리하는 서버가 별도로 있거나 지갑키(서명키)가 하드웨어 월렛 또는 모바일 디바이스에 있는 경우는 대부분의 SDK에서 지원하지 않는 것 같습니다. 이번에 하드웨어 웰렛을 개발하면서 삽질한(?) 노하우를 공유합니다. UTXO 조회하기 서명에 필요한 utxo를 테스트넷에서 가져옵니다. 가져온 utxo에서 전송에 필요한 금액 만큼만 사용하면 됩니다. 12345678const Client = axios.create(｛ baseURL: 'https://test-insight.bitpay.com/api', headers: ｛ \"Content-Type\": \"application/json\" ｝, timeout: 10000｝);const fromAddress = \"1J5RoyfyjLBcdGc2PCnN8wkfEUJms13vv8\";const utxos = await Client.post(`/addrs/utxo`, ｛ addrs: fromAddress ｝).then(r =&gt; r.data); 실제 비트코인 주소입니다. 메인넷에서 테스트로 송금하셔도 됩니다. 트랜잭션 생성하기 트랜잭션 생성에는 비트코인(bitcore-lib) 라이브러리를 사용하였습니다. 그리고 일단은 P2PKH 주소 서명만 예제 코드로 사용하였습니다. 주소의 prefix로 스크립트 유형을 알아낼 수 있습니다. 비트코인 주소 유형은 이곳 위키 를 참고하세요. 12345678910111213const bitcore = require('bitcore-lib');const tx = new bitcore.Transaction();if ( [\"1\", \"m\", \"n\"].includes(fromAddress.slice(0, 1)) ) ｛ // P2PKH tx.from(utxos); ｝ else ｛ // P2PK, P2SH, P2WPKH, Etc ...｝tx.to(to, amount.toNumber());tx.feePerKb(20000); // TX KB별 필요한 수수료 입력tx.change(fromAddress); // 잔금 받을 주소 입력(HD지갑이라면 change 주소 사용)const transaction = tx.uncheckedSerialize(); 주소 prefix가 1이면(테스트넷은 m or n) P2PKH 입니다. 서명할 시그해시 계산하기 12345const hash = tx.inputs.map((input, index) =&gt; ｛ let sighash = bitcore.Transaction.Sighash.sighash(tx, 0x01, index, input.output.script); sighash = bitcore.encoding.BufferReader(sighash).readReverse(); return sighash.toString(\"hex\");｝); bitcore 라이브러리는 서명에 little-endian을 사용하고 있습니다. 그래서 계산된 hash를 다시 reverse 합니다. 트랜잭션에 서명값 추가하기 외부 서버나 디바이스에서 받아온 서명을 다시 트랜잭션에 추가합니다. 123456789101112131415161718192021222324252627282930313233343536// sign 서버에 서명 요청하기const signatures = await SignService.requestSignature(hash); signatures.forEach((signature, index) =&gt; ｛ // signature 객체 생성 let sig = bitcore.crypto.Signature.fromCompact( buffer.Buffer(signature, \"hex\") ); // 시그해시 계산 const input = tx.inputs[index]; let hashbuf = bitcore.Transaction.Sighash.sighash(tx, 0x01, index, input.output.script); hashbuf = bitcore.encoding.BufferReader(hashbuf).readReverse(); // 서명 검증 const ecdsa = bitcore.crypto.ECDSA(｛ hashbuf, sig ｝); ecdsa.set(｛ pubkey: ecdsa.toPublicKey() ｝); if (!ecdsa.verify().verified) ｛ return Errors.BAD_SIGNATURES; ｝ // tx에 서명 추가 const signatureObj = new bitcore.Transaction.Signature(｛ publicKey: ecdsa.pubkey, prevTxId: input.prevTxId, outputIndex: input.outputIndex, inputIndex: index, signature: sig, sigtype: 0x01 // SIGHASH_ALL. ｝); tx.applySignature(signatureObj);｝);// 서명된 tx를 serialize 하기const serializeTx = tx.serialize(); 이제 마지막으로 serialized된 tx를 비트코인 노드서버로 send 하면 됩니다. 비트코인이 동작은 단순하지만 구현하는 부분에 있어서는 매우 어렵고 복잡합니다. 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"비트코인","slug":"비트코인","permalink":"https://anpigon.github.io/tags/비트코인/"}],"author":"anpigon"},{"title":"⟪그랑블루⟫ - 내 마음속에 깊은 여운을 남긴 영화","slug":"/aaa/@wangpigon/3h4qd8","date":"2019-06-12T02:37:27.000Z","updated":"2019-11-11T13:41:49.850Z","comments":true,"path":"/aaa/@wangpigon/3h4qd8/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/3h4qd8/","excerpt":"내 인생 영화 중 하나를 소개합니다. 영화 레옹의 뤽 베송 감독의 첫 영화이자 전설이 된 영화 “그랑블루” 입니다. 원제는 “Le Grand Blue” 입니다. 그리고 미국판 제목은 “The Big Blue” 입니다. 제 생각에는 많은 분들이 그랑블루를 인생 영화라고 생각할 것 같습니다. 하지만 영화를 아직 보지 않으신 분도 있을 수 있기 때문에 스포와 관련된 내용을 적지 않겠습니다.","text":"내 인생 영화 중 하나를 소개합니다. 영화 레옹의 뤽 베송 감독의 첫 영화이자 전설이 된 영화 “그랑블루” 입니다. 원제는 “Le Grand Blue” 입니다. 그리고 미국판 제목은 “The Big Blue” 입니다. 제 생각에는 많은 분들이 그랑블루를 인생 영화라고 생각할 것 같습니다. 하지만 영화를 아직 보지 않으신 분도 있을 수 있기 때문에 스포와 관련된 내용을 적지 않겠습니다. 시작은 그리스 산토리니와 비슷하게 생긴 작은 마을에서 시작됩니다. 어린 자크와 그의 친구 엔조는 어릴때 부터 라이벌이자 친구입니다. 다른 아이들에 비해 둘다 잠수 실력이 월등히 뛰어납니다. 두 친구의 성장 영화이자 뜨거운 우정을 그린 영화이기도 합니다. 그리고 영화에 나오는 배경 음악은 아주 깊은 바다를 연상하게 만듭니다. 저는 아직도 이 장면을 잊을 수 없습니다. 정말 아름다운 장면입니다. 깊은 바다와 고독, 외로움 등 다양한 감정을 느끼게 만드는 장면입니다. 짦은 영화 리뷰였습니다. 아직 안보셨다면 이 영화를 보면서 딥블루 감성의 바다에 빠져 보시길 바랍니다. 명대사 “물 속 깊이 내려가면 바다는 더이상 푸른빛이 아니고, 하늘은 기억 속에만 존재하고, 남은 것은 오직 고요. 고요 속에 머물게 되지.” “가장 힘든 것은 바다 맨 밑에 있을 때야. 왜냐하면 다시 올라와야 할 이유를 찾아야 하거든. 항상 그걸 찾는 게 너무나 어려워.” ___자크 대사 중에서… “가서 뭘 본다는 거예요? 그곳에는 아무것도 없어요. 자크. 밑에는 차갑고 어두울 뿐이에요. 당신홀로 있을 뿐이에요. 그리고 나는 여기있어요. 나는 현실속에 이렇게 있잖아요!” ___조안나 대사 중에서… ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/175-le-grand-bleu?language=ko-KR 별점: AAA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"[맛집] 성수동 맛집 - 소문난성수감자탕","slug":"/tasteem/@wangpigon/tasteem-0db5e2","date":"2019-06-11T01:22:39.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-0db5e2/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-0db5e2/","excerpt":"소문난성수감자탕백종원3대천왕에 출연한 감자탕 맛집오늘은 성수동에서 가장 맛있는 감자탕 집을 소개합니다. 참고로 이 식당은 오픈한지 벌써 30년이 넘었습니다. 옛날식 감자탕을 맛을 느끼고 싶다면 적극 추천합니다. 간단한 식사메뉴인 감자국이 인기가 제일 많습니다. 국내산 돼지 등뼈와 잡뼈를 24시간 고와낸다고 합니다. 그래서 육수가 진하고 살코기는 입안에서 흐드러집니다. 먹어보면 흐드러진다는 표현이 어떤지 알 수 있을 거에요.","text":"소문난성수감자탕백종원3대천왕에 출연한 감자탕 맛집오늘은 성수동에서 가장 맛있는 감자탕 집을 소개합니다. 참고로 이 식당은 오픈한지 벌써 30년이 넘었습니다. 옛날식 감자탕을 맛을 느끼고 싶다면 적극 추천합니다. 간단한 식사메뉴인 감자국이 인기가 제일 많습니다. 국내산 돼지 등뼈와 잡뼈를 24시간 고와낸다고 합니다. 그래서 육수가 진하고 살코기는 입안에서 흐드러집니다. 먹어보면 흐드러진다는 표현이 어떤지 알 수 있을 거에요. 그리고 이곳은 백종원 3대 천왕에도 나온 매우 유명한 집입니다. 저는 백종원을 좋아하진 않지만, 백종원이 추천하는 식당이면 그냥 믿고 먹습니다. ㅋ 이 곳은 주말에 오면 항상 사람들이 줄서서 먹는 곳입니다. 그래서 저는 주로 평일 저녁에 먹으러 갑니다. 제가 주로 먹는 감자국입니다. 감자국에 밥 말아먹으면 매우 맛있습니다. 감자국이라고 해도 살코기가 매우 많습니다. 젓가락으로 발라 먹다보면 나중에는 손가락이 저릴 정도입니다. 근접 샷으로 한번 더 찍었습니다. 살코기를 양념장에 찍어서 먹으니 입에서 살살 녹네요. 성수동에서 제일 핫한 맛집. 소문난성수감자탕 이었습니다. 오늘도 행복한 하루 되세요~! 맛집정보 소문난성수감자탕 대한민국 서울특별시 성동구 성수2가3동 315-100 [[맛집] 성수동 맛집 - 소문난성수감자탕](https://kr.tasteem.io/post/35885) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/458)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #4 - 마지막 업데이트 이야기","slug":"/sct/@anpigon/steem-sct-vp-4","date":"2019-06-10T23:00:09.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/sct/@anpigon/steem-sct-vp-4/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/steem-sct-vp-4/","excerpt":"안녕하세요. 안피곤입니다.최근에 많이 바빠졌습니다. 그래서 스팀 위젯 앱 업데이트가 많이 늦어졌습니다. 그리고 안드로이드 스팀 위젯 앱은 아마도 이번이 마지막 업데이트가 될 것 같습니다. 왜냐하면 안드로이드 JAVA 개발은 제 적성에 안 맞습니다. OS 버전 마다 사용가능한 API 규격이나 Life Cycle이 다르고, 해상도에 따라 위젯이 다르게 보입니다. ㅠㅠ","text":"안녕하세요. 안피곤입니다.최근에 많이 바빠졌습니다. 그래서 스팀 위젯 앱 업데이트가 많이 늦어졌습니다. 그리고 안드로이드 스팀 위젯 앱은 아마도 이번이 마지막 업데이트가 될 것 같습니다. 왜냐하면 안드로이드 JAVA 개발은 제 적성에 안 맞습니다. OS 버전 마다 사용가능한 API 규격이나 Life Cycle이 다르고, 해상도에 따라 위젯이 다르게 보입니다. ㅠㅠ 몇 일 전에 kayap2님이 부탁하신 기능이 있었습니다. 위젯앱을 개발한 이후에 SCT 보팅파워회복속도 변경이 있었고, 마침 AAA도 출시되면서 앱 업데이트에 대한 계획은 있었습니다. kayap2님의 부탁때문에 업데이트를 조금 서둘렀어요. . 이번에 추가된 기능에 대한 설명입니다. 위젯을 추가할 때 Token을 선택할 수 있습니다. 서버에서 데이터를 가져오기 때문에 최초 실행할 때는 로딩 이미지가 잠깐 보일 수 있습니다. 최근에 SCOT API 서버가 느려서 조금 시간이 걸릴 수 도 있습니다. username를 입력하고 사용하고 있는 Token을 선택합니다. 저는 확인을 위해서 모두 체크했습니다. 다음은 모든 Token을 선택하여 바탕화면에 위젯을 추가한 화면입니다. 데이터가 없는 녀석들은 null로 보이네요. ㅋ 아래는 스팀 위젯 앱을 설치하고 사용하는 사용자 통계 자료입니다. play.google.com 콘솔에서 캡쳐했습니다. 안드로이드 스팀 위젯 앱을 총 13분이 설치해서 사용하고 계십니다. 특이하게 말레이시아에서 설치하신 분도 계시네요. 앱을 설치해서 사용하시는 분들에게는 행운이 있을 거에요. 피드백은 댓글로 남겨주세요. 구글 스토어 : https://play.google.com/store/apps/details?id=com.steem_widget Happy Coding~","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"스팀보팅파워 위젯 개발 이야기","slug":"개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] WHAN DAPP 개발 이야기 #1","slug":"/sct/@anpigon/snax-whan-app","date":"2019-06-10T06:20:45.000Z","updated":"2019-11-11T13:41:49.818Z","comments":true,"path":"/sct/@anpigon/snax-whan-app/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/snax-whan-app/","excerpt":"안녕하세요. 안피곤입니다.다음은 스팀댑 개발팀의 단톡방에서 나온 아이디어입니다. 예전에는 더 많은 아이디어가 나왔었는데, 요즘은 저도 바쁘고 다른 분들도 바빠서 개발에 대한 이야기가 예전보다 많이 줄었습니다.SCT나 AAA와 같이 Steem 블록체인 기반의 Dapp 서비스를 모바일앱에서 모두 서비스하면 어떨까 하는 생각에 시작되었습니다.","text":"안녕하세요. 안피곤입니다.다음은 스팀댑 개발팀의 단톡방에서 나온 아이디어입니다. 예전에는 더 많은 아이디어가 나왔었는데, 요즘은 저도 바쁘고 다른 분들도 바빠서 개발에 대한 이야기가 예전보다 많이 줄었습니다.SCT나 AAA와 같이 Steem 블록체인 기반의 Dapp 서비스를 모바일앱에서 모두 서비스하면 어떨까 하는 생각에 시작되었습니다. 아래는 뉴비존님(@newbijohn)이 그리신 큰그림 입니다. 모바일앱 이름은 Whan Dapp 입니다. 기획의 신 뉴비존님은 딱 한 장의 그림만 그려서 보여주셨습니다. 기능에 대한 별도의 설명도 없었습니다. 저는 이 그림 한 장이면 충분할 것 같습니다. 왜냐하면 그림을 보자마자 나머지 화면과 기능들은 머리속에 자동으로 주입되었습니다. 알라딘이 램프의 요정 지니를 처음만나 신기한 체험을 했을때 기분이 아마도 이런 느낌이었을 것 같습니다. https://steemitimages.com/640x0/https://cdn.steemitimages.com/DQmNpcHsY4vBGAxKez3HgK3B9k1MouVQ2YSqCHHVFi4QvPD/newLOGO_％EC％96％87％EC％9D％80.png 다음은 기획서를 보고 1차 작업한 앱 화면입니다. 뉴비존님의 그림과 최대한 비슷하게 구현하려고 노력했습니다. 여기서 ENG은 의도를 잘 모르겠습니다. 아마도 영어 공부하는 Dapp일 것이라고 생각됩니다. 그 다음은 생각나는 데로 오른쪽 사이드바를 만들었습니다. 사이드바는 화면을 오른쪽에서 왼쪽으로 슬라이드 하면 나타납니다. 사이드바 상단영역에는 프로필을 보여 줄 예정입니다. 그리고 사이드바 아래에는 제가 필요할 것 같은 기능을 리스트로 출력해보았습니다. 모두 해피 코딩하세요.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"WHAN DAPP 개발 이야기","slug":"개발-이야기/react-native/whan-dapp-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/whan-dapp-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"WHAN DAPP","slug":"whan-dapp","permalink":"https://anpigon.github.io/tags/whan-dapp/"}],"author":"anpigon"},{"title":"[맛집] 속초 순대 맛집 - 북청전통아바이순대","slug":"/tasteem/@wangpigon/tasteem-5d083b","date":"2019-06-09T07:29:42.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-5d083b/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-5d083b/","excerpt":"북청전통아바이순대속초 당일치기 여행 - 아바이마을 순대맛집당일치기로 속초 아바이마을에 다녀왔습니다. 아바이는 동북 방언으로 아버지를 의미한다고 합니다.아바이 마을은 6.25 전쟁 당시 함경도 지역의 피난민들이 집단촌을 만들면서 생겨난 마을입니다. 그리고 아바이마을은 드라마 가을동화와 1박2일 촬영지로도 유명합니다.","text":"북청전통아바이순대속초 당일치기 여행 - 아바이마을 순대맛집당일치기로 속초 아바이마을에 다녀왔습니다. 아바이는 동북 방언으로 아버지를 의미한다고 합니다.아바이 마을은 6.25 전쟁 당시 함경도 지역의 피난민들이 집단촌을 만들면서 생겨난 마을입니다. 그리고 아바이마을은 드라마 가을동화와 1박2일 촬영지로도 유명합니다. 거룻배를 이용하여 마을간의 이동이 가능합니다. 거주민은 거룻배가 무료이고 외지인은 탑승료 500원을 받습니다. 아바이마을에는 순대집이 정말 많습니다. 그리고 1박2일이 촬영했던 식당은 사람들이 줄서서 기다립니다. 그래서 저는 비교적 사람이 적고 한적해보이는 순대집을 찾았습니다. 다음 지도에서 검색하니 북청전통아바이순대집에 다녀온 사람들의 평이 좋았습니다. 그래서 지도를 보면서 찾아갔습니다. 식당 벽면에 붙어있는 메뉴판 사진에서 오징어순대가 맛있어 보였습니다. 그래서 오징어순대와 따뜻한 국물이 있는 순대국을 주문했습니다. 그런데 실제 오징어순대는 사진과 달랐습니다. 사진속 음식을 기대하고 시켰는데 약간 실망스러웠습니다. 하지만 한입 먹어보니 정말 맛있었습니다. 모듬순대를 주문했으면 오징어순대와 아바이순대를 같이 먹을수 있었을 텐데 조금 후회가 됩니다. 다음은 순대국입니다. 제가 회사 근처 식당에서 먹던 그 순대국 맛이었습니다. ㅋ 얼큰한 국물의 순대국이었으면 더 좋았을 뻔 했습니다. 순대가 많이 안들어있어서 이것도 약간 실망이네요. 사장님이 순대를 오징어젓갈에 찍어서 깻잎에 싸먹으면 맛있다고 알려주셨어요. 알려준대로 먹으니 정말 맛있습니다. 하지만 그냥 먹어도 맛있었어요. 그리고 북청전통아바이순대집은 사장님의 친절함에 약간 감동이었습니다. 식사를 마치고 식당에서 나갈때에는 오랜만에 찾아온 반가운 손님이 떠나는 것처럼 인사를 해주셨어요. 이상 아바이순대 맛집이었습니다. 오늘도 행복한 하루 보내시길 바랍니다. 맛집정보 북청전통아바이순대 대한민국 강원도 속초시 청호동 아바이마을길 27-33 [맛집] 속초 아바이순대 - 북청전통아바이순대 이 글은 Tasteem 컨테스트 내가 소개하는 이번 주 맛집에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"[소설] 헤르만 헤세 ⟪데미안⟫","slug":"/kr/@wangpigon/6ykwbs","date":"2019-06-08T01:00:51.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"/kr/@wangpigon/6ykwbs/","link":"","permalink":"https://anpigon.github.io/kr/@wangpigon/6ykwbs/","excerpt":"청소년 권장 도서인 데미안을 성인이 되어 다시 손에 잡았습니다. 하지만 상징과 비유, 그리고 철학적인 내용이 많아서 읽는데 무척이나 힘들었습니다. 한번 완독하고 나서 다시 한번 더 읽었습니다. 사실 포스팅 내용은 독서 후기라기 보다는 줄거리 요약에 더 가깝습니다.데미안은 독일의 소설가 헤르만 헤세가 1919년에 발표한 소설입니다. 부제로는 &quot;에밀 싱클레어의 청년 시절의 이야기&quot; 이라고 합니다. 데미안 소설을 집필할 당시는 제1차 세계대전이 발발 중이었습니다. 그래서 전쟁을 겪었던 작가의 일생이 아마도 작품에 많은 영향을 미쳤을 것입니다.","text":"청소년 권장 도서인 데미안을 성인이 되어 다시 손에 잡았습니다. 하지만 상징과 비유, 그리고 철학적인 내용이 많아서 읽는데 무척이나 힘들었습니다. 한번 완독하고 나서 다시 한번 더 읽었습니다. 사실 포스팅 내용은 독서 후기라기 보다는 줄거리 요약에 더 가깝습니다.데미안은 독일의 소설가 헤르만 헤세가 1919년에 발표한 소설입니다. 부제로는 &quot;에밀 싱클레어의 청년 시절의 이야기&quot; 이라고 합니다. 데미안 소설을 집필할 당시는 제1차 세계대전이 발발 중이었습니다. 그래서 전쟁을 겪었던 작가의 일생이 아마도 작품에 많은 영향을 미쳤을 것입니다. 난 진정, 내 안에서 솟아 나오려는 것. 그것을 살아 보려 했다. 왜 그것이 그토록 어려웠을까? * 1장 두 세계 주인공 에밀 싱클레어는 독실한 기독교 집안으로 부유한 환경에서 자라난 도련님이다. 싱클레어는 어린 시절 두 세계를 경험한다. 두 세계란 밝은 세계와 어둠의 세계를 의미한다. 밝은 세계에는 부모의 사랑과 보호가 존재한다. 그리고 평화와 질서와 안정, 의무와 책임, 용서와 사랑이 있다. 어둠의 세계는 하녀들과 직공들의 세계다. 이 세계에는 항상 유령 이야기와 추한 소문이 있었다. 그리고 미움과 싸움, 그리고 무질서가 존재했다. 싱클레어는 그의 가정이 밝고 세계로만 이루어져 있지 않다는 것을 알게 된다. 그리고 두 세계는 매우 가깝게 닿아 있었다. 밝은 세계에는 곧바로 미래로 통하는 곧은 길이 있었고, 의무와 책임, 양심의 가책과 고해, 용서와 좋은 목적들, 사랑 그리고 존경, 성경 말씀과 지혜가 있었다. 인생이 맑고 명확하고 아름답고 정돈되어 있으려면 이 세계를 향해야만 했다. (…중략…) 어둠의 세계에는 섬뜩하고 요사스럽고 끔찍한 수수께끼 같은 일이 넘쳤고, 도살장과 감옥, 주정뱅이들과 고함치는 여자들, 새끼 낳는 암소, 쓰러진 말들, 강도, 살인, 자살 같은 일들이 일어났다. ___본문 내용 중에서 10세 무렵의 싱클레어는 불량 집단의 우두머리인 프란츠 크로머에게 잘 보이기 위해서 도둑질을 했다고 거짓말을 한다. 크로머는 이를 밀비로 싱클레어를 계속 협박하고 돈을 갈취한다. 결국 이 일로 싱클레어는 매우 괴로워하고 하늘이 무너지는 듯한 좌절감을 느낀다. 이 시절에 싱클레어는 어린 나이로 견디기 매우 힘든 고충(苦衷)을 겪는다. 그 시절의 나는 일종의 정신 착란 상태였다. 우리 집의 정돈된 평화 가운데 나는 겁먹고 고통받으며 유령처럼 지내고 있었다. 다른 사람과 함께 생활 할 수도 없었으며, 잠깐이라도 내 자신을 잊어버리고 지내지도 못했다. ___본문 내용 중에서 2장 카인 이 장에서 싱클레어의 구세주인 데미안이 등장한다. 데미안은 평범한 학생들과 달랐다. 그는 특별하고 개성이 강해서 남의 이목을 끌었다. 데미안은 싱클레어를 크로머에게서 구해준다. 구원은 전혀 상상하지 못했던 방향에서 왔다. 그리고 동시에 무언가 새로운 것이 내 삶속으로 들어왔는데, 그것은 지금까지도 나에게 영향을 미치고 있다. ___본문 내용 중에서 데미안은 성경에 나오는 카인의 이야기를 완전히 다르게 해석한다. 원래 카인은 아벨을 죽인 패륜아로 취급된다. 하지만 데미안의 해석은 실상 그가 용기와 개성을 지니고 있을 뿐만 아니라 신(神)의 특별한 '표적’을 지니고 있다는 것이다. 평범한 사람들은 그런 카인을 두려워했고, 음모를 꾸며 그를 살인자로 몰았다는 것이다. 싱클레어는 데미안의 해석을 듣고 난 후 엄청난 혼란에 빠진다. 그 후 싱클레어는 선악의 기준에 대한 관념적 사상의 뿌리가 흔들린다. 그리고 싱클레어는 또 다른 나쁜 세계로 유혹하려는 데미안을 멀리한다. 사람은 누구 앞에서든지 다른 사람을 두려워할 필요가 없어. 그런데도 누군가가 두렵다는 건 나를 다스리는 힘을 타인에계 맡겨 버렸기 때문이야. ___본문 내용 중에서 카인과 아벨 카인과 아벨의 이야기는 구약성서 창세기 4장 1-16절에 나온다. 카인과 아벨은 아담과 이브의 두 아들이다. 형 카인은 농부이고 동생 아벨은 양치기다. 그리고 카인이 하느님의 사랑을 독차지하는 동생 아벨을 질투하여 살해했다고 나온다. 그리고 이 사건을 인류 최초의 사건이라고 기록하고 있다. 이미지 출처: https://ko.wikipedia.org/wiki/카인과_아벨 농부 카인은 땅에서 나온 수확물을 하느님에게 바쳤다. 그러나 하느님은 목동인 아벨의 수확물을 더 좋아했다. 이에 질투를 느낀 카인은 아벨를 몰래 꾀어내서 살해한다. 그러자 하느님은 그 벌로 카인을 추방하면서 표식을 주었다. 이 표식은 카인을 해칠 수 없게 하느님이 보호해준다는 보호자의 표식이다. ___위키피디아 내용 중에서 3장 예수 옆에 매달린 도둑 이제 싱클레어는 유년기를 지나 본능적인 충동을 아는 사춘기가 되었다. 그는 성적 충동을 억제하지 못하면서도 해소할 길을 찾지 못해 방황한다. 누구라도 그러하듯이 성에 관한 호기심이 나에게 적이자 파괴자로, 금기로, 유혹으로, 죄악으로 찾아들었다. ___본문 내용 중에서 이런 싱클레어에게 데미안은 두 명의 도둑에 관한 이야기를 한다. 골고다 언덕 위 십자가에 두 도둑이 묶여 있다. 한 도둑은 회개하면서 후회의 눈물을 흘린다. 그러나 다른 도둑은 자기 갈 길을 간다. 데미안은 자기 갈 길을 간 도둑이 강한 개성을 지녔으며 카인의 후예일 것이라고 한다. “만약 나에게 두 도둑 가운데 한 명을 친구로 택하라고 한다면, 적어도 난 신뢰가 있는 상대를 선택할 거야. 눈물을 짜며 징징거리는 개종자를 선택하진 않을 거야.” ___본문 내용 중에서 싱클레어는 데미안의 이 새로운 견해를 자신의 운명으로 받아들인다. 견진성사를 마치고 난 후 싱클레어는 집을 떠나 다른 학교로 간다. 그리고 데미안은 여행을 떠난다. 가을이 되면 나무 주위에 낙엽이 떨어지게 마련이지만 나무는 그것을 느끼지 못한다. 비와 햇빛이 나무를 적시고, 서리가 내리고, 나무의 내부에서는 생명이 서서히 위축되고 깊숙이 움츠러든다. 그러나 나무가 죽은 것은 아니다. 그것은 기다림이다. ___본문 내용 중에서 골고다 언덕의 세 십자가 십자가에 못 박힌 두 강도 이야기는 마태복음과 마가복음, 그리고 누가복음에 나온다. 예수님의 십자가 양 옆으로 두 강도도 함께 처형을 당했다. 한 강도는 회개를 하여 후회의 눈물을 흘린다. 하지만 또 다른 강도는 자신의 죄를 그대로 받는다. 4장 베아트리체 싱클레어는 처음으로 집을 떠나 독일의 고등학교 김나지움의 기숙사에서 생활한다. 싱클레어는 이곳에서 적응하지 못하고 비애와 절망감에 몸부림친다. 그리고 세상을 멸시하며 고독 속으로 파고든다. 나는 외부 세계에는 아주 냉정한 태도를 취하며 온종일 나의 내부에 귀를 기울였다. 결국에는 가장 내면적인 곳에 흐르고 있는 금기 같은 어두운 냇물소리를 듣는 데 온 정신을 빼앗겼다. ___본문 내용 중에서 싱클레어는 동급생 알 폰스 베크를 만나면서 술과 쾌락을 배운다. 그리고 학교, 부모, 교회로부터 벗어나 환락을 경험하며 일탈의 자유를 만끽한다. 이 시기에 싱클레어는 술집에 자주 드나들고 세상에 반항한다. 그리고 스스로를 쓸모없는 존재라고 받아들인다. 우리를 고독하게 만들어서 신이 우리 자신에게로 이끌어 줄 수 있는 길은 너무도 많다. 신은 그때 나와 함께 이런 타락의 길을 갔다. 마치 악몽 같았다. ___본문 내용 중에서 그러던 중 싱클레어는 베아트리체라고 이름 지은 소녀를 만나면서 심경의 변화가 일어난다. 마음속에 있는 어둠과 악을 몰아내고 다시 밝은 세계로 돌아오기 위해 노력한다. 나는 다시 무너져 버린 생활의 폐허 속에서 '밝은 세계’를 재건하려는 노력을 진지하게 시작했으며 마음속에서 어둠과 악을 몰아내고 완전히 밝은 세계 속에 머무르려는 열망으로 신들 앞에 무릎을 꿇었다. ___본문 내용 중에서 싱클레어는 그녀의 초상화를 그리게 되는데, 초상화의 모습이 점점 데미안을 닮아간다. 그리고 그 얼굴에서 자신의 내면 속 모습도 보인다. 그의 마음에는 데미안에 대한 그리움이 차오른다. 그리고 데미안에게 지구 위로 날아오르려 하는 새를 그려 편지로 보낸다. “우리들 마음속에는 모든 것을 알고 모든 것을 원하고 우리들 자신보다 모든 것을 더 잘 해내는 누군가가 들어 있어. 그 사실을 인식하는 것이 너에게 도움이 될 거야.” ___본문 내용 중에서 단테의 베아트리체 축복받은 베아트리체 (Beata Beatrix, Blessed Beatrice) (1864~1870) oil on canvas, 86,4 x 66 cm, 테이트 미술관, 런던 이탈리아 작가 단테의 문학에 가장 큰 영향력을 끼친 여자이다. 그리고 단테가 평생을 두고 사모한 여인이다. 단테는 베아트리체를 천사와 같이 순진한 처녀로서 숭고한 정신의 상징으로 보았다. 베아트리체가 실제 살았던 인물인지 아닌지는 확실하지 않으나 위대한 문학가 단테에 의하여 그녀는 순결하고 고상한 여자의 대표처럼 그려져 있다. ___네이버 지식백과 내용 중에서 5장 새는 알에서 나오려고 투쟁한다 싱클레어는 데미안에게 보낸 그림에 대한 답장을 받는다. 그리고 데미안의 답장에는 유명한 문장이 쓰여져 있다. “새는 알에서 나오려고 투쟁한다. 알은 세계이다. 태어나려고 하자는 한 세계를 깨뜨리지 않으면 안 된다. 새는 신에게 날아간다. 신의 이름은 아브락사스다.” 이제 싱클레어는 아브락사스를 찾아 헤맨다. 그러던 중 우연히 수업시간에 아브락사스를 듣게 된다. 아브락사스는 신적인 것과 악마적인 것을 결합하는 일종의 상징적인 신의 이름이다. 그때 우린 분명히 존경하는 하나의 신이 있었다. 그 신은 단지 인공적으로 구분된 세계의 절반만을 포용할 뿐이었다. 그것은 공적으로 허용된 ‘밝은 세계’였다. 하지만 사람은 세계에 존재하는 모든 것을 존경할 수 있어야 한다. 그러자면 악마까지도 포용한 새로운 신을 갖거나 아니면 신에게 예배하는 동시에 악마에게도 예배하지 않으면 안 된다. 데미안이 그때 이렇게 말했다. 그렇다면 지금 이 아브락사스가 신인 동시에 악마인, 바로 우리가 찾던 그 신이었다. ___본문 내용 중에서 싱클레어는 시내를 걷다가 우연히 교회의 오르간 연주자 피스토리우스를 만나게 된다. 싱클레어는 그가 연주하는 신비하고 독특한 음악에 끌림을 당하듯 그에게 영혼을 맡겨버린다. 그리고 피스토리우스를 통해 아브락사스에 대한 이야기를 듣게 된다. 피스토리우스는 싱클레어의 또 다른 지도자이자 스승이 되어 준다. 나는 그 당시 예상치 못한 피난처를 ‘우연히’ 발견했다. 하지만 우연이란 존재하지 않는다. 무엇인가를 간절히 필요로했던 사람이 그것을 발견한다면 그것은 우연히 이루어진 것이 아니라 자기 자신이, 혹은 자기 자신의 소원과 필연이 그곳으로 자신을 이끌었기 때문이다. ___본문 내용 중에서 6장 야곱의 싸움 피스토리우스는 싱클레어의 꿈을 해석하고 가치를 찾아주며 그에게 용기와 존경을 심어준다. 하지만 싱클레어는 한 순간의 말 실수로 피스토리우스의 상처를 건드리고 그와 헤어지게 된다. “우리가 어떤 사람을 미워하는 것은 그의 형상 속에서 우리들 자신의 내부에 숨어 있는 그 무엇인가를 미워하는 것이오. 우리들 자신의 내부에 존재하지 않는 것은 진정으로 우리를 흥분시키지 못하는 법이니까 말이오!” ___본문 내용 중에서 어느 날 동급생 크나우어가 싱클레어의 특별함을 알아보고 접근한다. 그리고 싱클레어는 자살 시도를 하는 크나우어를 구해주게 된다. 그 후 크나우어는 싱클레어를 신성시하며 추종한다. 싱클레어는 피스토리우스와 크나우어를 통해 자신의 내부에도 데미안과 같은 지도가 있음을 알게 된다. 누구에게나 '사명’은 있다. 그러나 누구에게도 스스로 선택하고 해석하고 임의로 관리 할 수 있는 사명은 없다는 깨달음이 날카로운 불꽃처럼 나를 불태웠다. 새로운 신을 원한다는 것은 틀렸다. 각성된 인간에게 부여된 의무는 단 한가지, 자신을 찾고 자신의 내부에서 견고해져서 그 길이 어디에 닿아 있건 간에 조심스럽게 자신의 길을 더듬어 나가는 일. 그 이외의 다른 의무는 존재하지 않는다. 이러한 생각이 깊이 나를 사로잡았고, 이 생각이야말로 내가 이변의 체험에서 얻은 열매였다. 때때로 나는 미래의 형상과 함께 놀았고, 혹은 시인으로서 혹은 예언자로서 혹은 화가로서 혹은 다른 어떤 것으로서 나에게 부여되었을 역할을 꿈꾸었다. ___본문 내용 중에서 야곱과 신의 천사 사이의 싸움 그것은 야곱과 신의 천사 사이의 싸움에 관한 말로서 “그대 나를 축복치 않는다면 내 그대를 놓아 주지 않으리다.” 7장 에바 부인 싱클레어는 방학 중에 데마안의 옛 집에 갔다가 데미안 어머니의 사진을 우연히 보게된다. 그녀의 얼굴은 바로 싱클레어가 꿈속에서 보았던 운명의 그녀였다. 그러던 어느날 싱클레어는 데이안을 우연히 다시 만나게 된다. 그리고 그의 집에서 데미안의 어머니 에바 부인을 처음으로 보게 된다. 나는 한마디도 할 수 없었다. 자신의 아들 처럼 시간과 나이를 초월한, 활기와 지혜에 넘치는 얼굴에 아름답고 품위 있는 자태의 부인이 나를 향해 정답게 미소를 보내고 있었다. 그 여자의 눈길은 충족이 었고 그 여자의 인사는 귀향을 뜻했다. 나는 아무말 없이 그녀에게 두 손을 뻗었다. 그녀는 굳건하고도 따스한 두 손으로 내 손을 잡아 주었다. ___본문 내용 중에서 에바 부인은 싱클레어에게 탄생의 괴로움과 인간의 운명에 대해 들려준다. 그리고 싱클레어는 이런 그녀에게 사랑을 느낀다. 그리고 사랑하는 에바 부인에게 좀 더 적극적이지 못한 자신을 책망한다. 그러나 그 사랑이 불가능하다는 것을 잘 알고 있다. 그녀는 바다이며 별이고, 자신은 그 속으로 끌려가는 하나의 강 또는 별이라고 생각한다. 그녀는 별에 반한 젊은이의 이야기를 해주었다. 그는 바닷가에서 손을 뻗치고 별에 예배했고 별의 꿈을 꾸고 자기의 생각을 별에 보냈다. (…중략…) 그는 어느 날 밤 다시 바닷가의 높은 벼랑 위에서 서서 별을 쳐다보고 별을 향한 사랑을 불태웠다. 그리하여 동경이 절정에 달한 순간 그는 별을 향해서 허공으로 뛰어들었다. (…중략…) 그는 바닷가에 떨어져서 산산조각이 났다. 그는 사랑하는 법을 이해하지 못했던 것이다.(…중략…) 그일이 이루어질 거라고 믿는 정신력이 있다면 그는 하늘로 날아 올라가서 별과 하나가 될 수 있었을 터였다. “사랑을 간청해서는 안 되는 거예요.” 그녀는 진지하게 말했다. “또 요구해서도 안 되지요. 사랑은 자신의 내부에서 확신에 이르는 힘을 가져야해요. 그러면 사랑은 끌려오는 것이 아니라 끌어당기게 되는 거지요. 싱클레어, 당신의 사랑은 나에게 끌리고 있어요. 당신이 나를 끌게 되면 나는 가겠어요. 나는 아무런 선물도 드리고 싶지 않아요. 나는 당신에게 획득당하고 싶은 거에요.” ___본문 내용 중에서 어느날 데미안은 싱클레어에게 갑자기 꿈의 예언에 대한 이야기를 한다. 그는 지금 이 세계가 부패했으며 붕괴가 다가오고 있다고 말한다. 곧 전쟁이 시작됨을 예고한다. 작별을 고하고 혼자 거실을 지날 때 풍겨 온 히아신스의 향기가 시들고 무의미한 죽음의 냄새처럼 느껴졌다. 한 자락의 그림자가 우리들을 덮쳐 온 것이다. ___본문 내용 중에서 8장 종말의 시작 1차 세계대전이 반발한다. 동원령이 떨어지고 싱클레어와 데미안은 전쟁에 참전한다. 그리고 싱클레어는 이제 앞으로 에바부인을 볼 수 없다는 생각에 매우 괴로워한다. 내 이야기의 끝이 가까워졌다. 사태는 급속히 진전되어 전쟁은 곧 시작되었고, 데미안은 은회색의 군복을 입고 이상스럽고 낯선 모습으로 떠나갔다. 나는 그의 어머니를 집으로 데려다 주었다. 얼마 지나지 않아 나도 그녀와 작별했다. 그녀는 내 입에다 입을 맞추고 잠시 나를 가슴에 끌어안아 주고는 불타는 큰 두 눈으로 나의 눈을 바싹 들여다보았다. ___본문 내용 중에서 전쟁 중 싱클레어는 부상을 당해 야전병원으로 옮겨진다. 그리고 그곳에서 데미안을 다시 만난다. 데미안은 싱클레어에게 이별을 고한다. 앞으로는 자신을 볼 수 없을 것이며, 도움이 필요하다면 자기 자신의 내부에 귀를 기울이라고 말한다. 그리고 데미안은 에바 부인을 대신하여 싱클레어에게 입맞춤을 한다. 데미안의 입술에서는 피가 흐른다. 다음날 아침 눈을 떴을 때, 싱클레어는 데미안이 없어진 걸 발견한다. 그리고 그는 친구이자 지도자인 데미안과 자신이 닮아있음을 발견한다. 나는 열쇠를 발견했고, 때때로 어두운 거울 속에 운명의 형상이 졸고 있는 그곳, 내 자신의 내부에 완전히 들어가기만 하면 되었다. 나는 단지 그 어두운 거울 위에 몸을 굽히기만 하면 되었다. 그러면 이젠 완전히 데미안과 같은, 내 친구이자 지도자인 데미안과 같은 내 자신의 모습을 거기서 발견할 수 있었다. ___본문 내용 중에서 나는 이 소설을 읽으면서 론다 번 작가의 시크릿 책이 머리속에 제일 먼저 떠올랐습니다. 긍정적인 생각과 간절한 믿음은 강력한 힘을 발휘한다는 것입니다. 바로 끌어당김 법칙의 힘이 발휘되는 것입니다. &quot;무엇이든 ‘우연히’ 발견되고, ‘우연히’ 시작되는 것은 없다. 사람이 무언가 간절히 원하는 것이 있다면 그것은 이루어진다. ___본문 내용 중에서 헤르만 헤세가 이 책에서 데미안을 통해 독자에게 하고 싶었던 말은 이것이라고 생각합니다. 새가 알을 깨고 태어나듯이 새로운 세상으로 나오려는 자는 다른 하나의 세계를 파괴해야만 합니다. 그리고 선과 악을 동시에 가지고 있는 신 아프락사스는 인간의 진정한 모습을 상징합니다. 인간은 선과 악. 이 두 가지 모습을 모두 가지고 있으며 그것을 모두 인정해야만 어리석음에서 벗어날 수 있습니다. 그리고 내면에 존재하는 진정한 자기 자신을 발견하는 것이 진정한 깨달음이라고 합니다. 마지막으로 모든 사람의 내면에는 데미안과 같은 지도자가 존재합니다. 자신의 내면을 들여다 보고 내면에서 강하게 요구하는 일을 실행에 옮겨라. 그러면 반드시 성공할 것이다. 내 속에도 데미안과 같은 지도자가 존재하는지는 모르겠습니다. 하지만 자기 자신의 내면을 들여다보고 명상을 하니 내 마음이 매우 차분해지고 판단력이 좋아짐을 느꼈습니다. 그리고 목표를 정하고 간절히 생각하니, 목표를 언제 가는 꼭 이룰 수 있다는 자신감이 생겼습니다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"},{"name":"헤르만 헤세","slug":"헤르만-헤세","permalink":"https://anpigon.github.io/tags/헤르만-헤세/"}],"author":"wangpigon"},{"title":"⟪엑스맨 - 다크 피닉스⟫ - 속이 까맣게 타들어가는 영화","slug":"/aaa/@wangpigon/3lyrpg","date":"2019-06-07T22:58:36.000Z","updated":"2019-11-11T13:41:49.850Z","comments":true,"path":"/aaa/@wangpigon/3lyrpg/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/3lyrpg/","excerpt":"엑스맨의 마지막 시리즈. 다크 피닉스가 개봉한다고 해서 피곤한 몸을 이끌고 보고 왔습니다. 이 영화감독은 캡틴 마블같은 여성 히어로가 엑스맨에도 있다는 것을 알려주고 싶었던 것 같습니다.원래 엑스맨 시리즈 영화는 잘 보지 않는 편인데 21세기 폭스가 디즈니에 인수되었기 때문에, 약간의 기대를 가지고 보게 되었습니다.","text":"엑스맨의 마지막 시리즈. 다크 피닉스가 개봉한다고 해서 피곤한 몸을 이끌고 보고 왔습니다. 이 영화감독은 캡틴 마블같은 여성 히어로가 엑스맨에도 있다는 것을 알려주고 싶었던 것 같습니다.원래 엑스맨 시리즈 영화는 잘 보지 않는 편인데 21세기 폭스가 디즈니에 인수되었기 때문에, 약간의 기대를 가지고 보게 되었습니다. 줄거리 분노 조절 장애가 있는 여주인공 진 그레이는 어릴때 자신의 분노를 참지 못하고 초능력을 각성하게 됩니다. 그리고 이 사건으로 인해 그녀는 부모님을 모두 잃게 됩니다. 초능력 영재학교의 원장 찰스 자비에는 그런 그녀를 가족으로 받아들이고 따뜻하게 품어줍니다. 그리고 그녀의 분노 조절 장애를 꼭 고쳐주고자 약속합니다. 하지만 성인이 된 진 그레이는 자신의 몸에 주체할 수 없을 만큼 큰 흑염룡이 힘이 날뛰는걸 느낍니다. 바로 사춘기에 대표적인 질병인 중2병이 생겨버렸습니다. 영재학교의 선생님들은 분노 조절 장애와 더불어 중2병까지 생겨버린 그녀를 감당하기가 점점 힘들어집니다. 이 영화의 스토리는 여주인공 진 그레이의 중심으로만 흘러갑니다. 그래서 다른 히어로들의 개성이 부각되지 않은 점이 정말 많이 아쉬웠습니다. 특히 퀵실버가 영화에서 차지하는 비중이 너무 많이 축소되었습니다. 그리고 울버린의 부재도 크게 느껴졌습니다. 영화를 보고나니 마음속에 매우 큰 공허함과 허탈함이 느껴졌습니다. 그리고 자꾸 헛웃음이 났습니다. 이를 악물고 영화 감독이 누군지 찾아보았습니다. 이번에 관객들에게 다크 피닉스라는 큰 선물을 선사한 사이먼 킨버스(Simon Kinberg) 감독의 필모 그래피에는 판타스틱4(2015) 와 엘리시움(2013) 영화도 있었습니다. 이 두 영화와 함께 다크 피닉스도 제 명작 목록에 같이 올라갈 것 같습니다. 엑스맨 시리즈의 대미를 장식할 마지막 영화. “다크 피닉스” 후회하지 말고 꼭 챙겨 보시기 바랍니다. 그리고 오늘도 행복한 하루 보내길 바랍니다. The Happy Day~ ※ 리뷰 하단에 다음 두가지 항목 포함 필수 (미포함 시 차후 자체사이트에 반영 안됨) 영화 URL: https://www.themoviedb.org/movie/320288-dark-phoenix?language=ko_KR 별점: A 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"}],"author":"wangpigon"},{"title":"베르나르 베르베르 작가의 《죽음》출간 기념, “코엑스 별마당 도서관 독자와의 만남”에 다녀왔습니다.","slug":"/partiko/@wangpigon/9dfvgbfq","date":"2019-06-06T23:53:39.000Z","updated":"2019-11-11T13:41:49.858Z","comments":true,"path":"/partiko/@wangpigon/9dfvgbfq/","link":"","permalink":"https://anpigon.github.io/partiko/@wangpigon/9dfvgbfq/","excerpt":"출처: 열린책들 트위터6월6일 현충일 어제. 코엑스 별마당 도서관에 베르나르 베르베르 작가님이 오신다고 해서 다녀왔습니다.작가님은 이번에 출간한 책 소개와 함께 많은 이야기를 해주셨어요. 머리 스타일과 옷차림은 스티븐 잡스가 생각났습니다.시각, 청각, 촉감 등 모든 감각에 집중하여 우주의 말을 들어보라고 하셨어요. 작가님은 우주의 지시를 받아서 작가가 되었다고 하네요. 간단히 말하면 명상을 많이 하라고 했어요. 한국 사람들은 명상을 많이 할 줄 알았는데 생각보다 많이 안한다고 하네요.","text":"출처: 열린책들 트위터6월6일 현충일 어제. 코엑스 별마당 도서관에 베르나르 베르베르 작가님이 오신다고 해서 다녀왔습니다.작가님은 이번에 출간한 책 소개와 함께 많은 이야기를 해주셨어요. 머리 스타일과 옷차림은 스티븐 잡스가 생각났습니다.시각, 청각, 촉감 등 모든 감각에 집중하여 우주의 말을 들어보라고 하셨어요. 작가님은 우주의 지시를 받아서 작가가 되었다고 하네요. 간단히 말하면 명상을 많이 하라고 했어요. 한국 사람들은 명상을 많이 할 줄 알았는데 생각보다 많이 안한다고 하네요. 그리고 본인을 가장 많이 사랑하라고 했습니다. 남을 위해 희생하기 보다는 자기 자신을 더 사랑하면 더 행복할 수 있다고 했습니다. 마지막으로 작가님은 독자들을 만나는게 가장 행복하다고 하셨습니다. 다양한 독자들과의 만남을 통해 영감을 얻으신다고 하셨어요. 그리고 아이폰으로 사진도 막 찍어 가셨어요. 내 초상권 어쩔…ㅠ 그리고 행사 계획에는 없었는데, 강연이 끝나고 독자들 한분한분 싸인하고 사진도 찍어주셨습니다. 덕분에 저도 작가님의 싸인을 받았습니다. Posted using Partiko Android","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"베르나르 베르베르","slug":"베르나르-베르베르","permalink":"https://anpigon.github.io/tags/베르나르-베르베르/"},{"name":"코엑스 별마당 도서관","slug":"코엑스-별마당-도서관","permalink":"https://anpigon.github.io/tags/코엑스-별마당-도서관/"}],"author":"wangpigon"},{"title":"디즈니 영화 ⟪알라딘⟫의 지극히 개인적인 감상평","slug":"/aaa/@wangpigon/4tqmyq","date":"2019-06-04T02:52:12.000Z","updated":"2019-11-11T13:41:49.850Z","comments":true,"path":"/aaa/@wangpigon/4tqmyq/","link":"","permalink":"https://anpigon.github.io/aaa/@wangpigon/4tqmyq/","excerpt":"영화를 보고 감상평을 적는 것은 정말 피곤한 일입니다. 저는 디즈니 실사 영화 중에서 알라딘을 최고로 뽑고 싶습니다.알라딘 영화는 제가 느끼기에 B급 뮤지컬 가족 영화입니다. 그리고 윌 스미스가 아니었다면 그냥 B급 영화에서 끝났을 것 같습니다. 판타지 세계를 보여주는 환상적인 그래픽 CG와 지니 역할의 윌 스미스, 그리고 공주님 자스민의 호소력 있는 노래가 영화의 모든 것이라고 말할 수 있습니다. 사실 제가 영화를 보고나서 기억하고 있는 전부입니다. ㅋ","text":"영화를 보고 감상평을 적는 것은 정말 피곤한 일입니다. 저는 디즈니 실사 영화 중에서 알라딘을 최고로 뽑고 싶습니다.알라딘 영화는 제가 느끼기에 B급 뮤지컬 가족 영화입니다. 그리고 윌 스미스가 아니었다면 그냥 B급 영화에서 끝났을 것 같습니다. 판타지 세계를 보여주는 환상적인 그래픽 CG와 지니 역할의 윌 스미스, 그리고 공주님 자스민의 호소력 있는 노래가 영화의 모든 것이라고 말할 수 있습니다. 사실 제가 영화를 보고나서 기억하고 있는 전부입니다. ㅋ 어릴때 디즈니 애니매이션이나 책으로 알라딘을 많이 보았기 때문에, 알라딘의 스토리를 모두 알고 있었습니다. 그래서 극적인 연출이나 반전이 나와도 나에게는 감흥이 그렇게 크지 않았네요. 다만 애니매이션을 실사 영화로 어떻게 표현하는 지에 대한 부분이 나의 최대 관심사였습니다. ㅋ 알라딘과 자스민 공주가 마법의 양탄자를 타고 “A whole new world” 노래를 부르는 장면은 애니매이션이나 영화 모두 명장면입니다. 이 장면을 보기 위해서 알라딘 영화를 보려고 결심했다고 할 수도 있습니다. * 사실 알라딘은 나의 어린 시절에 영향을 끼친 것 중 하나입니다. 저는 알라딘 게임을 무척이나 좋아했습니다. 알라딘 게임 스크린샷만 보아도 그때 감흥이 떠오롭니다. 제가 만약 램프의 요정 지니라면 모두가 부자가 되는 소원을 들어주고 싶습니다. 감사합니다. 영화 URL: https://www.themoviedb.org/movie/420817-aladdin?language=en-US 별점: AA 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"},{"name":"디즈니","slug":"디즈니","permalink":"https://anpigon.github.io/tags/디즈니/"},{"name":"알라딘","slug":"알라딘","permalink":"https://anpigon.github.io/tags/알라딘/"}],"author":"wangpigon"},{"title":"[여행] 제주도 서귀포 카페 - 퍼시픽랜드더클리프","slug":"/tripsteem/@wangpigon/tt20190604t014628330z","date":"2019-06-04T01:46:30.000Z","updated":"2019-11-11T13:41:49.848Z","comments":true,"path":"/tripsteem/@wangpigon/tt20190604t014628330z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@wangpigon/tt20190604t014628330z/","excerpt":"퍼시픽랜드더클리프중문 젊음의 열정이 느껴지는 더클리프 카페제주도 서귀포시에 멋진 카페가 있어서 소개합니다. 중문색달 해수욕장이 보이는 곳에 위치하고 있습니다.여기는 카페 입구입니다.카페는 인터넷으로 미리 찾아봤습니다. 그래서 입구 들어가기 전에 조금 기대가 되었습니다.","text":"퍼시픽랜드더클리프중문 젊음의 열정이 느껴지는 더클리프 카페제주도 서귀포시에 멋진 카페가 있어서 소개합니다. 중문색달 해수욕장이 보이는 곳에 위치하고 있습니다.여기는 카페 입구입니다.카페는 인터넷으로 미리 찾아봤습니다. 그래서 입구 들어가기 전에 조금 기대가 되었습니다. 내부에 들어오니 분위기가 카페는 아닌 것 같고, 완전 클럽입니다. 음악 소리에 어깨가 저절로 들썩입니다. 그리고 카페 내부는 생각보다 매우 컸습니다. 100명 정도는 거뜬히 수용할 수 있을 것 같습니다. 실내 바를 뒤로하고 야외 테이블 석으로 나갔습니다. 그런데 야외에 나오니, 마치 외쿡에 여행 온 듯한 느낌을 받았습니다. 이전에 여행했던 오키나와의 아메리칸 빌리지가 생각났습니다. 제주 바다의 저녁노을은 매우 아름다웠습니다. 그리고 이국적인 분위기 때문인지 잠시 현실 세계를 벗어난 것 같았습니다. \\* * * 그리고 제가 갔을 때는 마침 1주년 페스티벌 파티를 하고 있었습니다. 운이 매우 좋았네요. 지금 공연하고 있는 팀은 아마도 감성 4인조 엄브렐라인 것 같습니다. 네이버 검색해보니 맞습니다. 보컬 4명 모두 노래를 정말 잘 부릅니다. 보컬 중에 한 분은 히든싱어 바비킴 편에서 우승했다고 하셨습니다. 네이버에 검색해보니 폴 송이라는 가수입니다. 그리고 초대 가수 목록에는 없었지만, 골드 가수가 무대에 나와서 Shinny Day라는 노래를 불렀었습니다. 그리고 노래 가사가 매우 인상적이었습니다. 그래 나는 괜찮아 더는 못난 생각 하지마 울고 웃던 시간들 그것 마저도 소중한걸 매일 감사해 나의 곁에 있는 모든것 꿈을 이룰 때까지 나를 지켜줘요 우리는 무대 뒤쪽 테이블에 앉았습니다. 그리고 제주 바다를 보면서 조용히 저녁을 먹었습니다. 테이블 바로 앞에는 제주 바다가 보이고, 뒤쪽으로는 공연 가수의 노랫소리가 들립니다. 이곳은 저를 현실에서 완전히 벗어나게 만들었습니다. 이곳에서 사랑하는 연인과 저녁을 먹으니 천국이 따로 없었습니다. 행복은 바로 가까이 있습니다. ㅋ 오늘도 행복한 하루를 보내시길 바랍니다. 여행지 정보● 대한민국 제주 서귀포시 색달동 중문관광로 154-17[여행] 제주도 서귀포 카페 - 퍼시픽랜드더클리프 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"제주도","slug":"제주도","permalink":"https://anpigon.github.io/tags/제주도/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"}],"author":"wangpigon"},{"title":"[Steem Tools] 크롬 익스텐션 개발 : 스팀 엔진 토큰 목록 업데이트 (20190604)","slug":"/sct/@anpigon/steem-tools-20190604","date":"2019-06-03T15:39:51.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/sct/@anpigon/steem-tools-20190604/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/steem-tools-20190604/","excerpt":"안녕하세요. 안피곤입니다.저는 천재 개발자 해피베리보이님(@happyberrysboy)과 함께 스팀잇 크롬 익스텐션을 개발하고 있습니다. 참고로 WS_TOOL은 오픈소스입니다. 라이센스는 MIT &amp; WHAN 입니다. 누구든지 참여 가능합니다. - 출처: 해피베리보이님의 블로그 내용 중…","text":"안녕하세요. 안피곤입니다.저는 천재 개발자 해피베리보이님(@happyberrysboy)과 함께 스팀잇 크롬 익스텐션을 개발하고 있습니다. 참고로 WS_TOOL은 오픈소스입니다. 라이센스는 MIT &amp; WHAN 입니다. 누구든지 참여 가능합니다. - 출처: 해피베리보이님의 블로그 내용 중… 햄뽀님은 잠도 안 자고 개발하십니다. 그리고 크롬 익스텐션에 정말 많은 기능을 추가하셨습니다. 크롬 익스텐션의 대부분의 기능은 햄뽀님 작품입니다. 저는 잠을 충분히 자기 때문에 햄뽀님을 쫓아갈 수가 없네요. 저는 아직 2가지 기능 밖에 구현못했습니다. WS_TOOL 크롬 익스텐션은 Steemit과 Nitrous에 유용한 기능을 지속적으로 업데이트 할 계획입니다. 그리고 의견은 댓글로 남겨주시면 적극 반영하겠습니다. * 제가 이번에 크롬 익스텐션에 소소한 기능을 하나 추가하게 되어 소개합니다. 하지만 배포 전이라서 업데이트는 아직 기다려야 합니다. 햄뽀님이 비슷한 기능을 이미 추가했지만, 향후 출시될 AAA SCOT의 보팅 파워를 팝업 화면에서도 보여줍니다. 그리고 바로 아래에 스팀 계정 정보와 스팀 엔진 토큰 정보를 추가하였습니다. 블록체인스튜디오님(@blockchainstudio)이 만드신 &quot;STEEM SCOT Voting Power Viewer / SCOT 보팅파워 뷰어&quot;를 많이 참고 하였습니다. 블록체인스튜디오님 감사합니다. 토큰 목록에서 아코디언을 펼치면 아래와 같이 토큰에 대한 정보를 볼 수 있습니다. 잔액, 스테이킹, 토큰 정보를 볼 수 있습니다. 다음은 실제 사용 화면입니다. * 마지막으로 @tanky님이 만든 스팀 계정 정보 페이지를 소개합니다. 제가 이렇게 함부로 스크린샷을 올려서 소개해도 되는지 모르겠습니다. 하지만 많은 사람들에게 소개하고 싶습니다. 일단 UI가 매우 이쁩니다. tanky님은 디자인 감각이 매우 뛰어나시네요. 쉽고 예쁘게 보고 싶어 만들어 본 “스팀 계정 정보” 페이지 🥰 오늘도 해피 코딩~! 관련글 [kr-dev] Steem Tools 전면 개편!!(크롬 확장프로그램) [kr-dev] Steem Tools 디자인 변경 [kr-dev] Steemit Tools 유저 바로가기 기능 구현 [kr-dev] Steemit Tools, Tag Filter 기능 [kr-dev] Steemit Tools Tag 바로가기 / Markdown 가져오기 [kr-dev] sct payout claim의 또다른 방법 및 Steemit Tools 소개 Steem Tools 설치 및 기본 기능들 소개 [Steem Tools] 스팀잇! 스팀코인판! 사이트에서 바로 보팅파워확인 [Steem Tools] 폰트변경 및 색변경 기능 소개 [Steem Tools] AAA 보팅파워 추가! 각종 보팅파워 On/Off 설정추가 [kr-dev] Firebase 데이터베이스 프로젝트 설정 해피보이님과 스팀잇 확장 프로그램 개발하는 이야기 (스팀코인판 출범 축하 기념) 크롬 확장 프로그램 기능 추가 이야기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[맛집] 제주 통갈치조림 맛집 - 제주어멍","slug":"/tasteem/@wangpigon/tasteem-72ab71","date":"2019-06-02T02:02:03.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-72ab71/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-72ab71/","excerpt":"제주어멍통갈치전복문어조림이번에는 제주갈치조림이 가장 맛있다는 제주어멍에 다녀왔습니다. 제주어멍은 제주공항 뒷편 해안가에 위치하고 있어요. 네이버 예약하고 가면 5％ 할인을 해줍니다.저는 통갈치전복문어조림과 통갈치구이 세트를 고민했습니다. 이왕 제주도에 온김에 다 먹어보자고 생각하고 통갈치전복문어조림을 주문했습니다. ㅋ","text":"제주어멍통갈치전복문어조림이번에는 제주갈치조림이 가장 맛있다는 제주어멍에 다녀왔습니다. 제주어멍은 제주공항 뒷편 해안가에 위치하고 있어요. 네이버 예약하고 가면 5％ 할인을 해줍니다.저는 통갈치전복문어조림과 통갈치구이 세트를 고민했습니다. 이왕 제주도에 온김에 다 먹어보자고 생각하고 통갈치전복문어조림을 주문했습니다. ㅋ 음식은 가짓수가 매우 많고 깔끔합니다. 나오는 모든 음식이 다 맛있습니다. 반찬으로 나온 음식들도 맛있었어요. 여기 중에서는 간장 게장이 정말 맛있었습니다. 저는 이곳 식당에서 맛있다는 말을 백번도 넘게 했던것 같습니다. 아래 사진에서 왼쪽에 보이는 음식은 갈치회와 고등어회입니다. 전 갈치회와 고등어회를 처음 먹어봤습니다. 입에서 살살 녹습니다. 너무 맛있습니다. 다음 고등어 구이 정말 맛있습니다. 저는 고등어 구이를 정말 좋아합니다. 하지만 여기 식당이 제일 맛있는것 같습니다. 고등어 살이 매우 도톰하고 쫄깃합니다. 그리고 적당히 짭짜롬하니 제 입맛에 너무 딱 맞습니다. 전 이 고등어 구이 하나만 있어도 밥 2공기는 거뜬히 먹을 수 있을 것 같습니다. 다음은 전복으로 만든 요리입니다. 아마도 튀긴 것 같습니다. 데코가 정말 이뻤습니다. 하지만 사진을 찍기 전에 요렇게 되어버렸습니다. 바삭바삭하니 소스에 찍어먹으면 맛있습니다. 마지막 끝판왕 요리입니다. 바로 갈치조림입니다. 버너 2개를 사용합니다. 요리 양이 생각보다 매우 많았습니다. 갈치조림이 메인 요리입니다. 하지만 앞서 나온 맛있는 음식들을 너무 많이 먹어서 배가 불러오기 시작합니다. 이때 큰일이라고 생각했습니다. 통갈치전복문어조림이 2 ~ 3 분이라고 해서 주문했는데 양이 생각보다 너무 많았습니다. 제 생각에는 3 ~ 4인분이라고 표기해야 옳을 것 같습니다. 갈치도 생각보다 매우 큽니다. 제주도에서 직접 잡은 갈치라고 합니다. 갈치 하나를 들어보니 갈치 살코기에 양념이 잘 배어 있습니다. 갈치 살에서 가시를 발라내고 입에 넣으면 고기를 씹을 것도 없습니다. 그냥 입에서 녹아 없어집니다. ㅋ 문어다리도 사진으로 찍었습니다. 갈치에 밀려서 찬밥 신세지만 그래도 맛있습니다. 제주도에 와서 문어는 질리도록 먹었습니다. 맛집정보 제주어멍 대한민국 제주특별자치도 제주시 용담삼동 2576-3 [[맛집] 제주 통갈치조림 맛집 - 제주어멍](https://kr.tasteem.io/post/35305) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/450)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #3 - Doze와 앱 대기(App Standby) 이야기","slug":"/sct/@anpigon/steem-sct-vp-3-doze-app-standby","date":"2019-06-01T07:22:18.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/sct/@anpigon/steem-sct-vp-3-doze-app-standby/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/steem-sct-vp-3-doze-app-standby/","excerpt":"안녕하세요. 안피곤입니다.사실 스팀 위젯에 기능을 업데이트를 할 계획은 없었습니다. 그런데 막상 구현하고 보니 욕심이 계속 생깁니다. 앱에 버그도 있고 기능도 거의 없는게 계속 마음에 걸리네요.그리고 위젯 UI 디자인은 포기했습니다. 해상도, OS 버전, 시스템 폰트 크기와 글꼴에 영향을 많이 받습니다. 안드로이드 UI 개발은 경험이 없어서 매우 어렵습니다. ㅠㅠ","text":"안녕하세요. 안피곤입니다.사실 스팀 위젯에 기능을 업데이트를 할 계획은 없었습니다. 그런데 막상 구현하고 보니 욕심이 계속 생깁니다. 앱에 버그도 있고 기능도 거의 없는게 계속 마음에 걸리네요.그리고 위젯 UI 디자인은 포기했습니다. 해상도, OS 버전, 시스템 폰트 크기와 글꼴에 영향을 많이 받습니다. 안드로이드 UI 개발은 경험이 없어서 매우 어렵습니다. ㅠㅠ 이번에 @griend96님이 제안하신 기능을 넣었습니다. 바탕화면에 위젯을 여러개 설치할 수 있습니다. 부 계정을 여러개 가지고 있는 스팀잇 사용자에게는 유용할 것 같습니다. 사용 예시 저는 완(WHAN)팀 멤버들을 바탕화면 위젯에 추가하여 모니터링(?) 하고 있습니다. 이제 완팀에 @griend96도 합류하셔서 이제 6명이 되었습니다. 축하해주세요. ㅋ 사용방법 사용 방법은 매우 간단합니다. 아래 순서만 지키면 누구나 쉽게 바탕화면에 위젯을 추가할 수 있습니다. 저는 매우 직관적이고 간단한 사용방법을 구현하기 위해서 항상 노력합니다. 1. 바탕화면에 위젯을 추가한다. 2. 스팀잇 아이디를 입력하고 확인을 누른다. Doze 모드와 앱 대기(App Standby) 모드 이야기 Android 6.0 마시멜로(API 레벨 23)부터 Doze 모드라는 게 존재합니다. 앱이 Doze 모드나 앱 대기 모드(App Standby)에 들어가게 되면 네트워크 엑세스, Wake Lock, SyncAdapter, JobScheduler, AlarmManager이 작동하지 않게됩니다. &quot;이 이유 때문에 위젯앱 설치하고 하루가 지나면 업데이트가 되지 않았던 것입니다.&quot; 하지만 충전 중일때는 두 모드에서 빠져나옵니다. 해당 모드는 배터리를 아낄수 있어서 사용자에게는 매우 좋습니다. 하지만 개발자에겐 헬입니다. ㅠㅠ 그리고 삼성 갤럭시폰에는 스마트매니저(Smart Manager) 라는 녀석도 있습니다. 스마트 매니저는 장기간 사용하지 않는 앱을 강제로 잠재워 버립니다. 자장~ 자장~ ㅋ 결국 저는 Doze, App Standby, Smart Manager에 항복했습니다. 해당 모드에서 빠져나가는 것은 코드 레벨에서 처리할 수 없다고 판단내렸습니다. Background Service를 버리고 Foreground Service로 개발하였습니다. Foreground Service는 해당 모드 영향을 안받는다고 합니다. 대신 서비스 동작시 상태바에 노티 알람 발생합니다. 위 화면에서 보는 거와 같이 서비스가 동작 중일때는 상태바에 아이콘이 표시됩니다. 만약 노티에 아이콘이 오랫동안 보인다면 사용자가 강제로 종료시킬 수 있습니다. * 노티 알람 발생시 진동과 소리를 없애기 노티 알람 발생시 진동과 소리를 없애려면 아래와 같이 설정하세요. 1234567NotificationChannel channel = new NotificationChannel(CHANNEL_ID, \"SteemWidget Service Channel\", NotificationManager.IMPORTANCE_LOW);((NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE)).createNotificationChannel(channel);NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);builder.setSmallIcon(R.mipmap.ic_launcher);builder.setVibrate(null);builder.setSound(null);startForeground(1, builder.build()); Stack Overflow에서는 builder.setVibrate(null) 와 builder.setSound(null) 적용하면 된다고 했습니다. 그런데 적용해도 진동과 소리가 발생합니다. 저는 채널에 NotificationManager.IMPORTANCE_LOW를 설정하니 진동과 소리가 나지 않습니다. 보팅 파워 계산 로직 안드로이드 Java 코드에서 보팅 파워는 다음과 같이 계산합니다. ISO 날짜 파싱을 위해서 SimpleDateFormat를 사용하였습니다. 123456789101112131415private static final long VP_REGENERATION_SECS_STEEM = 432000; public static String calculateVotingPower(String lastVoteTime, int votingPower) ｛ try ｛ SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\"); Date d = df.parse(lastVoteTime+\"+00:00\"); double elapsed = (new Date().getTime() - d.getTime()) / 1000; double vp = votingPower + (10000.0 * elapsed) / VP_REGENERATION_SECS_STEEM; vp = Math.min(Math.floor(vp) / 100, 100); return String.valueOf(vp); ｝ catch(Exception ex) ｛ Log.e(TAG,\"\", ex); ｝ return \"0\"; ｝ 날짜 계산에 Joda Time 라이브러리를 사용하고 싶었습니다. 하지만 React Native에서 릴리즈 빌드시 오류가 발생합니다. ㅠㅠ Low Level에서 오류가 발생하는 것 같아서 원인을 찾다가 포기했습니다. 구글 스토어 다운로드 링크: https://play.google.com/store/apps/details?id=com.steem_widget 리액트 네이티브 기반으로 스팀 위젯 앱 개발을 시작했습니다. 그런데 구현하다보니 여러가지 문제(?)로 위젯 기능을 안드로이드 Java로 다시 구현했습니다. 요 몇일동안 구글 문서보면서 Android 공부하느라 기능 업데이트가 늦어졌습니다. 그리고 피드백은 댓글로 남겨주세요. 위젯 기능을 제외하고는 다른 기능은 리액트 네이티브로 구현하면서 조금씩 업데이트 해보려고 합니다. ㅋ 참고로 저는 본업은 백엔드 개발자입니다. 프론트엔드와 모바일 개발은 취미로 하고 있습니다. 취미로 하는 개발이 더 재미있습니다. 마지막으로 안드로이드 위젯 개발하면서 참고했던 블로그 자료를 모두 공유합니다. 오늘도 해피 코딩하세요~! 관련 자료 Doze 및 앱 대기 모드 최적화 | Android Developers: https://developer.android.com/training/monitoring-device-state/doze-standby?hl=ko 백그라운드 실행 제한 | Android Developers: https://developer.android.com/training/monitoring-device-state/doze-standby?hl=ko Android 8.0 동작 변경 사항 | Android Developers: https://developer.android.com/about/versions/oreo/android-8.0-changes?hl=ko Android O에서의 백그라운드 처리를 위한 JobIntentService: https://medium.com/til-kotlin-ko/android-o％EC％97％90％EC％84％9C％EC％9D％98-％EB％B0％B1％EA％B7％B8％EB％9D％BC％EC％9A％B4％EB％93％9C-％EC％B2％98％EB％A6％AC％EB％A5％BC-％EC％9C％84％ED％95％9C-jobintentservice-250af2f7783c Doze 모드에서 서비스 실행 방법: https://hashedin.com/blog/save-your-android-service-from-doze-mode/ Android 오레오(API 26)에서 백그라운드 서비스 유지하는 방법: https://android.jlelse.eu/keep-those-background-services-working-when-targeting-android-oreo-sdk-26-cbf6cc2bdb7f [Android] 배터리 최적화 대응하기: 도즈(Doze)와 어플 대기모드(App Standby): https://m.blog.naver.com/PostView.nhn?blogId=nife0719&amp;logNo=221029613969&amp;categoryNo=26&amp;proxyReferer=http％3A％2F％2Fwebs.co.kr％2Findex.php％3Fdocument_srl％3D3312655 Google Developers Korea Blog: 안드로이드 6.0 마시멜로 무엇을 테스트 할까요? https://developers-kr.googleblog.com/2015/08/testyourapponandroid60.html adb로 안드로이드 배터리 상태 모킹(Mocking) 하기: https://www.intellectsoft.net/blog/android-shell-part-1-mocking-battery-status/","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"스팀보팅파워 위젯 개발 이야기","slug":"개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[맛집] 제주도 이중섭거리 맛있는 덮밥 - 중섭이네식당","slug":"/tasteem/@wangpigon/tasteem-1a6ef2","date":"2019-06-01T00:53:36.000Z","updated":"2019-11-11T13:41:49.846Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-1a6ef2/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-1a6ef2/","excerpt":"중섭이네식당이중섭거리 제주도 문어요리 전문식당두번째 제주도 맛집을 소개합니다. 소개다하보니 또 덮밥집이네요. ㅋ 제주도에는 해물라면과 덮밥집이 많은 것 같습니다.중섭이네 식당은 이중섭 거리 내에 있습니다. 이중섭 거리 입구로 들어가서 주욱 올라가면 됩니다. 이중섭거리는 천재 화가 이중섭을 기리기 위해 조성된 거리라고 합니다. 이중섭이 피난당시 거주했던 초가도 볼 수 있습니다.","text":"중섭이네식당이중섭거리 제주도 문어요리 전문식당두번째 제주도 맛집을 소개합니다. 소개다하보니 또 덮밥집이네요. ㅋ 제주도에는 해물라면과 덮밥집이 많은 것 같습니다.중섭이네 식당은 이중섭 거리 내에 있습니다. 이중섭 거리 입구로 들어가서 주욱 올라가면 됩니다. 이중섭거리는 천재 화가 이중섭을 기리기 위해 조성된 거리라고 합니다. 이중섭이 피난당시 거주했던 초가도 볼 수 있습니다. 저는 이중섭 거리를 천천히 구경하면서 오르막 길을 올라갔습니다. 이중섭 미술관 입구를 지나고 서귀포 관광극장을 지나면 식당이 바로 보입니다. 식당 앞에 있는 벤치에 앉아서 식당을 배경으로 사진을 찍으면 이쁘게 나와요. ㅋ 내부에 들어오면 매우 아늑합니다. 창문으로 들어오는 잔잔한 햇살과 따뜻한 조명이 분위기를 매우 아늑하게 만들어 주고 있어요. 중섭이네식당 사장님이 매우 친절했어요. 덕분에 더 맛있게 잘먹었습니다. 저는 아보카도 명란덮밥과 돌문어 덮밥을 주문했습니다. 돌문어 덮밥은 한정 판매라고 해서 기대하고 시켜봤어요. ㅎ 돌문어 덮밥입니다. 보기만 해도 군침이 돕니다. 돌문어를 가위로 작게 잘라서 먹으면 먹기 편합니다. 그런데 저는 문어가 잘 안씹히네요. ㅠ 아보카도 명란덮밥입니다. 명란과 아보카도를 숟가락으로 밥에 싹싹 비벼서 먹으면 정말 맛있습니다. 명란의 짭조름한 맛과 아보카도의 부드럽고 고소한 맛에 완전 반했습니다. 아보카도는 처음 먹어봤어요. 저는 돌문어 덮밥보다 아보카도 명란덮밥이 더 맛있었습니다. ㅋ 맛있게 잘 먹고 갑니다. 오늘도 행복한 하루 되세요~! 맛집정보 중섭이네식당 대한민국 제주특별자치도 서귀포시 서귀동 528-5 [맛집] 제주도 이중섭거리 맛있는 덮밥 - 중섭이네식당 이 글은 Tasteem 컨테스트 내가 소개하는 이번 주 맛집에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"[여행] 제주소 쇠소깍","slug":"/tripsteem/@wangpigon/tt20190531t050734317z","date":"2019-05-31T05:07:36.000Z","updated":"2019-11-11T13:41:49.848Z","comments":true,"path":"/tripsteem/@wangpigon/tt20190531t050734317z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@wangpigon/tt20190531t050734317z/","excerpt":"제주도를 대표하는 관광지 중 하나인 쇠소깍에 다녀왔습니다. 쇠소깍은 제주도 방언입니다. 쇠는 효돈마을을 뜻하고 소는 연못, 그리고 깍은 끝을 의미한다고 합니다. 풍경이 아름다운 곳으로 유명한 곳입니다.쇠소깍 입장료는 무료입니다. 그리고 전통나룻배(카약) 체험을 할 수 있는데 이용료가 1인에 만원입니다.","text":"제주도를 대표하는 관광지 중 하나인 쇠소깍에 다녀왔습니다. 쇠소깍은 제주도 방언입니다. 쇠는 효돈마을을 뜻하고 소는 연못, 그리고 깍은 끝을 의미한다고 합니다. 풍경이 아름다운 곳으로 유명한 곳입니다.쇠소깍 입장료는 무료입니다. 그리고 전통나룻배(카약) 체험을 할 수 있는데 이용료가 1인에 만원입니다. 쇠소깍에는 숨겨진 전설이 있다고 합니다. 스포가 될 것 같아서 여기서 이야기 하지는 않겠습니다. ㅋ 쇠소깍 방향으로 바라본 풍경입니다. 오늘은 날씨가 좋아서 경치가 매우 좋았습니다. 나룻배를 이용하는 관광객도 무척 많았어요. 쇠소깍에서 바닷가 방향으로 바라본 풍경입니다. 선착장이 보이네요. 보고 있으면 매우 여유롭고 한가롭습니다. 사람들의 나룻배를 유유자적 타는 모습을 위에서 감상하니 시간 가는 줄 몰랐습니다. 사실 저는 햇빛이 넘 더울 것 같아서 나룻배는 타지 않았어요. 노 젓기 싫으신 분은 단체배를 타시면 됩니다. 이 배는 아저씨가 줄을 당기면서 이동합니다. 쇠소깍 바로 뒤쪽에는 검은모래해변이 있습니다. 멀리 등대 2개가 보입니다. 해변을 따라 걷다가 등대 근처까지 왔습니다. 여기 바다는 또 다른 느낌입니다. 그리고 사람이 별로 없어서 매우 조용합니다. ㅋ 풍경을 사진에 모두 담고 싶어서 파노라마 사진도 한번 찍어 보았습니다. 오늘도 행복한 하루를 보내시길 바랍니다. 여행지 정보● 대한민국 제주특별자치도 서귀포시 하효동 쇠소깍로 128● 대한민국 제주특별자치도 서귀포시 하효동 하효쇠소깍해변[여행] 제주소 쇠소깍 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"제주도","slug":"제주도","permalink":"https://anpigon.github.io/tags/제주도/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"}],"author":"wangpigon"},{"title":"[맛집] 제주도 쇠소깍 덮밥 맛집 - 바람에머물다","slug":"/tasteem/@wangpigon/tasteem-240326","date":"2019-05-30T04:21:51.000Z","updated":"2019-11-11T13:41:49.845Z","comments":true,"path":"/tasteem/@wangpigon/tasteem-240326/","link":"","permalink":"https://anpigon.github.io/tasteem/@wangpigon/tasteem-240326/","excerpt":"바람에머물다해물라면과 덮밥이 맛있는 집여행하면서 갔던 맛있는 곳을 하나씩 소개하겠습니다. 제주도에는 맛집이 정말 많습니다.제주도의 시원한 바다전망이 보이는 쇠소깍에 있는 맛집을 소개합니다. 식당이름도 정말 멋집니다. 바로 **“바람에머물다”**입니다.쇠소깍 해변에서 서귀포 테라로사 길을 따라 올라가다 보면 이렇게 작은 식당이 보입니다.","text":"바람에머물다해물라면과 덮밥이 맛있는 집여행하면서 갔던 맛있는 곳을 하나씩 소개하겠습니다. 제주도에는 맛집이 정말 많습니다.제주도의 시원한 바다전망이 보이는 쇠소깍에 있는 맛집을 소개합니다. 식당이름도 정말 멋집니다. 바로 **“바람에머물다”**입니다.쇠소깍 해변에서 서귀포 테라로사 길을 따라 올라가다 보면 이렇게 작은 식당이 보입니다. 바람 부는 언덕위에 위치하고 있어서 **“바람에머물다”**가 아닐까 추측해봅니다. 그리고 식당 바로 뒤에는 게스트 하우스가 있습니다. 아마도 게스트 하우스에서 운영하는 식당이 아닐까요? ㅋ 식당 내부는 아담한 시골(?) 식당 분위기입니다. 메뉴판은 카운터에 붙어있는 타일에 적혀있습니다. 가격이 착한편은 아닙니다. 가격이 착했으면 더 좋았을 뻔 했습니다. ㅋ 그리고 야외 테이블에서 먹는다면 바다 풍경을 보면서 식사할 수 있어요. 저는 멋진 바다뷰 관람료 포함이라고 생각하고 식사했습니다. ㅋ 한쪽 벽면에는 손님들이 남기고간 메모가 빼곡하게 붙어 있습니다. 많은 분들이 추억을 만들고가셨네요.ㅋ 저는 문어해물라면과 불고기전복덮밥을 먹었습니다. 문어해물라면은 정확하진 않지만 아마도 신라면 일것 같습니다. 신라면은 좋아하시는 분이라면 확실히 좋아하실 것같습니다. 그리고 불고기전복덮밥도 맛이 깔끔하고 담백하니 너무 맛있었습니다. 바람이 머무는곳에서 맛있는 해물 라면과 덮밥을 드셔보세요. 오늘도 행복한 하루를 보내시길 바랍니다. 맛집정보 바람에머물다 대한민국 제주특별자치도 서귀포시 효돈동 1052-3 [[맛집] 제주도 쇠소깍 덮밥 맛집 - 바람에머물다](https://kr.tasteem.io/post/35120) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/450)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"wangpigon"},{"title":"하루 한 번 하늘보기 | 매일","slug":"/makeahabit/@anpigon/makeahabit-1559177632","date":"2019-05-30T00:53:54.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/makeahabit/@anpigon/makeahabit-1559177632/","link":"","permalink":"https://anpigon.github.io/makeahabit/@anpigon/makeahabit-1559177632/","excerpt":"","text":"Make a habit하루 한 번 하늘보기 | 매일하늘이 뿌옇타 ㅠ","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"},{"name":"Make a habit","slug":"make-a-habit","permalink":"https://anpigon.github.io/tags/make-a-habit/"}],"author":"anpigon"},{"title":"STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #2 - 앱 업데이트 이야기","slug":"/kr/@anpigon/steem-sct-vp-2","date":"2019-05-28T08:00:21.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/kr/@anpigon/steem-sct-vp-2/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steem-sct-vp-2/","excerpt":"안녕하세요. 안피곤입니다.이전 글 &quot;STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #1&quot;에서 안드로이드용 STEEM&amp;SCOT 보팅파워 위젯앱을 소개를 하였습니다. 반나절만에 급하게 개발한거라 앱디자인 퀄리티는 그렇다 치더라도 위젯 새로고침 버그가 있었습니다. ㅠ","text":"안녕하세요. 안피곤입니다.이전 글 &quot;STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #1&quot;에서 안드로이드용 STEEM&amp;SCOT 보팅파워 위젯앱을 소개를 하였습니다. 반나절만에 급하게 개발한거라 앱디자인 퀄리티는 그렇다 치더라도 위젯 새로고침 버그가 있었습니다. ㅠ * 나는 왜 리액트 네이티브로 위젯을 개발할 수 있다고 생각했을까? 위젯앱은 리액트 네이티브에서 제공하는 Headless JS를 사용하여 개발했습니다. Headless JS는 백그라운드에서 JavaScript를 실행할 수 있게 해줍니다. 리액트 네이티브는 역시 짱입니다.ㅋ 위젯 작동 방식은 대략 이렇습니다. 위젯의 새로고침 버튼을 터치하면, 위젯 프로바이더(AppWidgetProvider)가 헤드리스JS서비스(HeadlessJsTaskService)를 호출합니다. 그리고 HeadlessJsTaskService에서는 React Native에 있는 JavaScript를 실행합니다. 그리고 그 JavaScript는 비동기 통신 후 다시 ReactContextBaseJavaModule 모듈을 호출하여 Java 코드에 값을 전달합니다. 이렇게 설명하고 보니 굉장히 비효율적인 구조네요. 그리고 Android O 버전(API 26)에는 한가지 문제점이 있습니다. AppWidgetProvider에서 HeadlessJsTaskService 서비스 호출이 안 됩니다. Context.startService(serviceIntent)로 서비스를 호출하면 오류가 발생합니다. 해결 방법은 targetSdkVersion의 버전을 낮추면 된다고 하네요. 하지만 개발자의 알량한 자존심이 허락하지 않습니다. 안드로이드 O에서는 앱이 백그라운드에 진입하게 되면 몇분 뒤 동작 중인 백그라운드 서비스는 자동으로 중지되며 onDestroy()가 호출됩니다. 더하여 백그라운드 상태에서 서비스를 구동하기 위한 startService()의 호출은 IllegalStateException이 발생하며 허용되지 않습니다. - 출처: https://medium.com/til-kotlin-ko/android-o％EC％97％90％EC％84％9C％EC％9D％98-％EB％B0％B1％EA％B7％B8％EB％9D％BC％EC％9A％B4％EB％93％9C-％EC％B2％98％EB％A6％AC％EB％A5％BC-％EC％9C％84％ED％95％9C-jobintentservice-250af2f7783c 그래서 Context.startForegroundService(serviceIntent)를 사용해서 서비스를 호출했습니다. 하지만 startForegroundService를 사용하여 서비스를 호출하면, Android O에서는 상태바에 Notification 알람이 발생합니다. 위젯을 새로 고칠 때마다 알람이 발생하니 보기에 좋지 않네요. 게다가 백그라운드에서 실행되는 Javascript는 가끔 네트워크 통신 응답이 없을 때가 있습니다. Javascript에서는 connection timeout 컨트롤하기가 매우 까다롭습니다. 결국 안드로이드 Java 코드로 위젯을 다시 구현하였습니다. 앱 실행 화면은 리액트 네이티브로 그대로 사용하고, 위젯만 안드로이드 Java로 구현하였습니다. 위젯 화면 갱신을 위해 안드로이드 버전 26.1.0에 추가된 JobIntentService를 사용하여 구현하였습니다. * 개발 과정 JobIntentService를 사용하여 백그라운드 작업을 처리하는 방법은 다음과 같습니다. AndroidManifest.xml 에 서비스를 추가합니다. 1234&lt;service android:name=\".UpdateService\" android:permission=\"android.permission.BIND_JOB_SERVICE\" android:enabled=\"true\" android:exported=\"true\" /&gt; `UpdateService`은 다음과 같이 구현합니다. 1234567891011121314public class UpdateService extends JobIntentService ｛ static final int JOB_ID = 1000; static void enqueueWork(Context context, Intent work) ｛ enqueueWork(context, UpdateService.class, JOB_ID, work); ｝ @Override protected void onHandleWork(Intent intent) ｛ String username = intent.getStringExtra(\"username\"); int[] appWidgetIds = intent.getIntArrayExtra(\"appWidgetIds\"); new SteemAsyncTask(this, appWidgetIds).execute(username); ｝｝ `WidgetProvider`에서는 새로고침 브로드캐스트가 발생하면 `UpdateService`를 실행합니다. 1234567891011121314151617181920212223242526public class WidgetProvider extends AppWidgetProvider ｛ // (...) @Override public void onReceive(final Context context, final Intent intent) ｛ // (...) if (Constant.ACTION_REFRESH.equals(intent.getAction())) ｛ // AsyncLocalStorage 에서 username 가져오기 ReactDatabaseSupplier rdbs = ReactDatabaseSupplier.getInstance(context); SQLiteDatabase db = rdbs.get(); String username = AsyncLocalStorageUtil.getItemImpl(db, \"username\"); rdbs.closeDatabase(); if(username!=null &amp;&amp; !username.isEmpty()) ｛ Intent intent = new Intent(); intent.putExtra(\"username\", username); intent.putExtra(\"appWidgetIds\", appWidgetIds); UpdateService.enqueueWork(context, intent); // 서비스 실행 ｝ ｝ ｝ 참고로 리액트 네이티브의 AsyncLocalStorage에 저장한 데이터를 자바 코드에서 사용하려면, 다음과 같이 가져올 수 있습니다. 1234ReactDatabaseSupplier rdbs = ReactDatabaseSupplier.getInstance(context);SQLiteDatabase db = rdbs.get();String username = AsyncLocalStorageUtil.getItemImpl(db, \"username\");rdbs.closeDatabase(); * 앱을 수정하여 다시 배포하였습니다. 변경 사항은 아래와 같습니다. 구글 스토어 바로가기: https://play.google.com/store/apps/details?id=com.steem_widget 현재까지 10분이 앱을 설치해주셨습니다. 앱을 설치하신 모든 분들에게 항상 행운이 깃들길 빕니다. 부적이라고 생각하고 앱을 사용했으면 좋겠습니다. 감사합니다. 앱 관련 피드백은 댓글로 부탁드립니다. 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"스팀보팅파워 위젯 개발 이야기","slug":"개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"STEEM/SCT 보팅파워(VP) 안드로이드 위젯 #1","slug":"/sct/@anpigon/steem-sct-vp-1","date":"2019-05-26T15:04:27.000Z","updated":"2019-11-11T13:41:49.820Z","comments":true,"path":"/sct/@anpigon/steem-sct-vp-1/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/steem-sct-vp-1/","excerpt":"안녕하세요. 안피곤입니다.스팀코인판에 올리는 2번째 글입니다. 요즘 #sct와 더불어 #kr-dev에도 많은 글이 올라오니 기분이 좋습니다. 예전의 스팀잇 전성기로 돌아가는 것 같습니다. ㅎㅎblockchainstudio님이 최초로 SCOT 보팅파워 뷰어를 만들었습니다. 그리고 트윈짱님이 데스크탑 위젯을 만드셨습니다.","text":"안녕하세요. 안피곤입니다.스팀코인판에 올리는 2번째 글입니다. 요즘 #sct와 더불어 #kr-dev에도 많은 글이 올라오니 기분이 좋습니다. 예전의 스팀잇 전성기로 돌아가는 것 같습니다. ㅎㅎblockchainstudio님이 최초로 SCOT 보팅파워 뷰어를 만들었습니다. 그리고 트윈짱님이 데스크탑 위젯을 만드셨습니다. 관련글: blockchainstudio님의 글: “STEEM SCOT Voting Power Viewer / SCOT 보팅파워 뷰어” twinbraid님의 글: “SCT 보팅파워 바탕화면 위젯” 그다음 개발되어야 할 앱은 크롬 익스텐션 또는 안드로이드/iOS 위젯일 것 같습니다. 크롬 익스텐션은 happyberrysboy님이 곧 개발하실 것 같아서, 저는 먼저 안드로이드 위젯을 개발했습니다. 사실 안드로이드 위젯은 @nps0132님과 @talkit님의 댓글에서 아이디어를 얻었습니다. 두분께 감사합니다. ㅋ * 앱개발 이 앱은 리액트 네이티브(React Native)로 개발하였습니다. 그리고 react-native-android-widget-poc 오픈 소스를 사용하였습니다. 리액트 네이티브에서는 위젯 기능을 제공하지 않습니다. 그래서 안드로이드 Java 코드를 구현해야합니다. 그래서 이번에는 expo를 사용할 수가 없네요.ㅠㅠ expo 툴을 사용하여 리액트 네이티브를 개발할때는 정말 편리합니다. 하지만 요즘은 리액트 네이비브 앱을 expo로 개발하면서 expo의 한계를 정말 많이 느낍니다. 안드로이드 위젯을 개발하기 위해서, 안드로이드 공식 문서도 참고 하였습니다. 그런데 한글 문서는 없네요. ㅠ 안드로이드 개발 경험이 부족하여 버그가 있을 수 있습니다.(사실 있습니다.ㅠ) 안드로이드 위젯은 화면 View 컨트롤하기가 까다롭네요. 앱소개 사용 방법은 매우 간단합니다. 앱을 실행하고 USERNAME를 입력합니다. 그 다음 바탕화면에 위젯을 추가합니다. 위젯이 추가된 화면입니다. 구글 스토어에서 지금 바로 설치 가능합니다. https://play.google.com/store/apps/details?id=com.steem_widget&amp;rdid=com.steem_widget&amp;pli=1 참고로 위젯에서 새로 고침 버튼 눌러도 새로 고침이 안되는 버그가 있습니다. 그때는 앱을 실행해서 SAVE 버튼을 눌러주세요. 안드로이드 위젯 라이프 사이클에 대한 이해가 부족하여 버그를 수정 못 하고 있습니다. ㅠㅠ 하지만, 금방 수정해서 재배포 할 계획입니다. ㅋ 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"스팀보팅파워 위젯 개발 이야기","slug":"개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/스팀보팅파워-위젯-개발-이야기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"크롬 확장 프로그램 기능 추가 이야기","slug":"/sct/@anpigon/4gusrb","date":"2019-05-21T12:14:42.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/sct/@anpigon/4gusrb/","link":"","permalink":"https://anpigon.github.io/sct/@anpigon/4gusrb/","excerpt":"안녕하세요. 안피곤입니다.늦었지만 스팀코인판 출범을 축하합니다. 그리고 코인판(coinpan.com)을 뛰어넘는 커뮤니티가 되길 바랍니다. ㅋ그동안 스팀엔진 토큰에 관해서 관심을 두지 않고 있었습니다. 그러나 코인판으로 인해 스팀엔진 토큰에 관심이 많이 생겼습니다. 그리고 스팀코인판에 첫 글을 남겨봅니다.","text":"안녕하세요. 안피곤입니다.늦었지만 스팀코인판 출범을 축하합니다. 그리고 코인판(coinpan.com)을 뛰어넘는 커뮤니티가 되길 바랍니다. ㅋ그동안 스팀엔진 토큰에 관해서 관심을 두지 않고 있었습니다. 그러나 코인판으로 인해 스팀엔진 토큰에 관심이 많이 생겼습니다. 그리고 스팀코인판에 첫 글을 남겨봅니다. 저는 해피베리보이님(@happyberrysboy)과 크롬 익스텐션을 개발하고 있습니다. 크롬 익스텐션의 대부분 기능은 능력자이신 해피베리보이님께서 개발하고 계십니다. 그리고 저는 개인적으로 제가 필요한 작은 기능 하나를 추가하였습니다. 폰트 글꼴, 크기, 줄간격을 변경할 수 있습니다. 사용방법은 다음과 같습니다. 크롬 익스텐션의 다른 기능이나 자세한 내용은 해피베리보이님이 쓰신 “[kr-dev] sct payout claim의 또다른 방법 및 Steemit Tools 소개” 글을 읽어보세요. 해피베리보이님이 소스를 오픈해주신 덕분에 제가 넣고 싶은 기능을 추가할 수 있게 되었습니다. 사이트에 필요한 기능을 하나씩 추가할 계획입니다. 관심 있으신 분 많은 참여 바랍니다. ㅋ 해피 코인하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[],"author":"anpigon"},{"title":"5/17 김창옥 토크 콘서트 - 잘 살아보세 후기","slug":"/kr/@anpigon/5-17","date":"2019-05-17T23:56:30.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/kr/@anpigon/5-17/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/5-17/","excerpt":"안녕하세요. 안피곤입니다.김창옥 교수님은 세바시에서 처음 알게 되었고, 유튜브 포프리쇼 강연을 즐겨보았습니다. 이번에 김창옥 교수님의 첫 유료인 강연 토크 콘서트에 다녀왔습니다. 항상 무료 강연만 하셨는데, 이번에는 유료 강연이라서 부담된다고 하셨습니다. 총 강연시간은 2시간입니다. 그런데 콘서트 시간이 정말 금방 지나갔습니다. 사실 세바시나 유튜브 강연에서 들었던 이야기도 조금 있었습니다. 하지만 이야기에 공감하고 웃고 즐기다 보니 지루하지 않게 시간이 흘러갔습니다.","text":"안녕하세요. 안피곤입니다.김창옥 교수님은 세바시에서 처음 알게 되었고, 유튜브 포프리쇼 강연을 즐겨보았습니다. 이번에 김창옥 교수님의 첫 유료인 강연 토크 콘서트에 다녀왔습니다. 항상 무료 강연만 하셨는데, 이번에는 유료 강연이라서 부담된다고 하셨습니다. 총 강연시간은 2시간입니다. 그런데 콘서트 시간이 정말 금방 지나갔습니다. 사실 세바시나 유튜브 강연에서 들었던 이야기도 조금 있었습니다. 하지만 이야기에 공감하고 웃고 즐기다 보니 지루하지 않게 시간이 흘러갔습니다. * 강연의 핵심 주제는 “예쁜 말을 사용하자” 입니다. 자신에게도 타인에게도 항상 예쁜 말을 사용하는 게 중요합니다. 반대로 이야기하면 서로에게 상처 주는 말은 사용하지 말아야합니다. 그리고 배우자를 선택할 때 제일 중요한 것은 그 사람의 모국어를 들어야 합니다. 즉, 그 사람의 부모님이 서로에게 어떻게 말하는지를 들어야 합니다. 일부의 사람을 제외하고는 대부분 모국어를 그대로 물려받는다고 합니다. 예쁜 말을 하는 부모에게서 예쁜 말을 하는 자식이 나옵니다. 평소에 칭찬이나 상대방을 배려하는 말을 쓰지 않는 사람은 예쁜 말을 많이 들어보지 못했기 때문에 사용하지 못하는 것입니다. 칭찬에 인색하고 평소에 감정없이 무뚝뚝하게 말하는 사람은 그렇게 대화하도록 길들여진 것입니다. 저는 강연을 들으면서 이기주 작가님의 책 **“언어의 온도”**와 신카이 마코토 감독님의 애니매이션 **“언어의 정원”**이 생각났습니다. * 콘서트가 끝나고 사인회가 있었습니다. 원래는 교수님과 셀카를 찍을 수 있는 시간인데 줄이 너무 길어 시간 관계상 셀카는 안된다고 하네요. ㅠ 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"김창옥","slug":"김창옥","permalink":"https://anpigon.github.io/tags/김창옥/"}],"author":"anpigon"},{"title":"🚀 리액트에서 ESlint + Prettier + Airbnb Style 한방에 셋팅하기","slug":"/whan/@anpigon/eslint-prettier-airbnb-style","date":"2019-05-15T02:16:45.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/whan/@anpigon/eslint-prettier-airbnb-style/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/eslint-prettier-airbnb-style/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.협업으로 개발할때는 코딩 스타일과 코드 가독성이 매우 중요합니다. 이걸 좀더 편하게 할 수 있는 도구가 있어서 소개합니다. ESLint는 자바스크립트 문법을 검사해줍니다. 그리고 Prettier는 작성된 코드를 규칙에 따라 이쁘게 정리해줍니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.협업으로 개발할때는 코딩 스타일과 코드 가독성이 매우 중요합니다. 이걸 좀더 편하게 할 수 있는 도구가 있어서 소개합니다. ESLint는 자바스크립트 문법을 검사해줍니다. 그리고 Prettier는 작성된 코드를 규칙에 따라 이쁘게 정리해줍니다. 제가 주로 사용하는 VSCode 에디터를 기준으로 설명합니다. 비슷한 다른 에디터도 설정 방식이 비슷할 것이라고 생각합니다. VSCode를 실행하고 ESLint와 Prettier 익스텐션을 설치합니다. ESLint 설치하기 설치링크: https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint Prettier 설치하기 설치링크: https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode 프로젝트에 적용하기 복잡한 설정은 가라~! 이게 바로 리액트의 매력입니다. ㅋ ESLint와 Prettier의 복잡한 설정을 한방에 할 수 있는 멋진 쉘 스크립트가 있습니다. 개발자는 Paulo Ramos입니다. 출처: https://github.com/paulolramos/eslint-prettier-airbnb-react 프로젝트 루트 디렉토리에서 다음 명령을 수행합니다. 1exec 3&lt;&amp;1;bash &lt;&amp;3 &lt;(curl https://raw.githubusercontent.com/paulolramos/eslint-prettier-airbnb-react/master/eslint-prettier-config.sh 2&gt; /dev/null) 스크립트가 bash 쉘입니다. 그래서 윈도우에서 설정하기 위해서는 Ubuntu App가 필요할 것이라고 생각됩니다. 위 명령어를 실행하면 아래와 같은 화면이 출력됩니다. 저는 패키지 매니저를 yarn을 선택하였습니다. 그리고 설정 파일 타입은 .json. 한 라인의 길이는 80. 후행 콤마 스타일은 all를 선택하였습니다. 본인의 코딩 스타일에 맞게 선택하시면 됩니다. Trailing Comma는 이해를 돕기 위해 잘 설명되어 있는 블로그를 소개합니다: https://heygyun.tistory.com/49 설치가 완료되면 .eslintrc.json 와 .prettierrc.json 파일이 생성됩니다. 그리고 .prettierrc.json 파일을 열어보면 다음 내용이 입력되어 있습니다. 12345｛ \"printWidth\": 80, \"singleQuote\": true, \"trailingComma\": \"all\"｝ 입력되어 있는 내용은 쉘 스크립트에서 우리가 선택한 옵션입니다. printWidth는 한 라인의 길이를 설정합니다. 가독성을 위한 권장 길이는 80자입니다. singleQuote는 문자열에 ' 를 사용합니다. trailingComma는 배열 후행에 쉼표가 추가됩니다. 저는 다음 옵션을 추가하였습니다. 123\"useTabs\": false,\"tabWidth\": 2,\"semi\": true, useTabs가 false이면 들여쓰기에 탭 대신에 스페이스를 사용합니다. tabWidth 는 들여쓰기 스페이스 공백 갯수입니다. semi는 코드 끝에 세미콜론;을 사용합니다. Prettier에는 더 많은 옵션이 있습니다. 더 자세한 내용은 Prettier 공식 문서 를 참고하세요. 이제 F1를 누르고 Format Documents를 선택하면 코드가 깔끔해집니다. 단축키는 Shift + Option/Alt + F 입니다. 파일 저장시 자동 적용되게 하기 코드 정리를 자동으로 해놓으면 매우 편리합니다. 아래 설정 과정을 통해 파일 저장할 때 코드가 자동으로 정리되게 해보세요. Settings에서 JavaScript Format를 검색합니다. 자바스크립트 기본 포맷터 기능을 비활성화합니다. 우리는 Prettier를 사용하기 때문에 필요가 없습니다. Settings에서 Format On Save을 검색합니다. Editor: Format On Save를 활성화합니다. 그럼 저장할때 코드를 자동 포멧팅 해줍니다. Settings에서 Auto Fix On Save을 검색합니다. Eslint: Auto Fix on Save를 활성화 합니다. settings.json에서 보면 다음 코드가 추가되어 있습니다. 12345｛ \"eslint.autoFixOnSave\": true, \"editor.formatOnSave\": true, \"javascript.format.enable\": false｝ 코드를 작성하고 파일을 저장해보세요. 그러면 아래와 같이 코드가 깔끔하게 자동으로 정리됩니다. 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"}],"tags":[{"name":"꿀팁","slug":"꿀팁","permalink":"https://anpigon.github.io/tags/꿀팁/"},{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"}],"author":"anpigon"},{"title":"[React] React Apollo Hooks 사용하기","slug":"/whan/@anpigon/react-react-apollo-hooks","date":"2019-05-13T15:05:30.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/whan/@anpigon/react-react-apollo-hooks/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/react-react-apollo-hooks/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.Hooks는 리액트 v16.8에 도입되었습니다. Hooks를 사용하면 함수형 컴포넌트에서도 상태관리와 다양한 작업들을 할 수 있습니다. 이번에는 React에서 Apollo Hooks 를 사용하는 방법을 안내합니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.Hooks는 리액트 v16.8에 도입되었습니다. Hooks를 사용하면 함수형 컴포넌트에서도 상태관리와 다양한 작업들을 할 수 있습니다. 이번에는 React에서 Apollo Hooks 를 사용하는 방법을 안내합니다. * 설치하기 12345npm install react-apollo-hooks# oryarn add react-apollo-hooks 참고: https://github.com/trojanowski/react-apollo-hooks react-apollo-hooks 사용하기 react-apollo-hooks를 사용하기 위해 다음과 같이 작성 합니다. 루트 컴포넌트를 &lt;ApolloProvider&gt; 로 감쌉니다. 그리고 ApolloProvider의 client에 ApolloClient를 전달합니다. 123456789101112131415161718import React from 'react';import ReactDOM from 'react-dom';import ApolloClient from 'apollo-boost';import ｛ ApolloProvider ｝ from 'react-apollo-hooks';// Create Apollo clientconst client = = new ApolloClient(｛ uri: process.env.REACT_APP_GRAPHQL_URL,｝);const App = () =&gt; ( &lt;ApolloProvider client=｛client｝&gt; &lt;MyRootComponent /&gt; &lt;/ApolloProvider&gt;);ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 참고로 리액트에서는 .env 파일을 사용할때, 반드시 Key에 REACT_APP_ 를 붙여야 합니다. 이걸 몰라서 고생했습니다. 그리고 ApolloClient에 대해 자세한 내용은 apollo-client를 참고하세요. 그다음 apollo-boost를 사용하여 GraphQL을 작성합니다. 12345678910111213import ｛ gql ｝ from \"apollo-boost\";const GET_POSTS = gql` query GetPosts( $tags: [String!]! ) ｛ getPosts( tags: $tags ) ｛ post_id title ｝｝`; useQuery useQuery를 사용하면 아래와 같이 작성합니다. 12345678910111213141516171819202122232425const MainPage = (props) =&gt; ｛ const ｛ data, error, loading ｝ = useQuery(GET_POSTS, ｛ variables: ｛ tags: ['kr-dev'], ｝ ｝); if (loading) ｛ return &lt;div&gt;Loading...&lt;/div&gt;; ｝; if (error) ｛ return &lt;div&gt;Error! ｛error.message｝&lt;/div&gt;; ｝; return ( &lt;ul&gt; ｛ data.getPosts.map(post =&gt; ( &lt;li key=｛post.post_id｝&gt;｛post.title｝&lt;/li&gt; )) ｝ &lt;/ul&gt; );｝ useApolloClient useApolloClient를 사용하면 아래와 같이 작성합니다. 123456789101112131415161718192021222324252627282930313233343536const MainPage = (props) =&gt; ｛ // ApolloClient const client = useApolloClient(); // posts Data const [posts, setPosts] = useState([]); // getPosts const _getPosts = async (｛ tags ｝) =&gt; ｛ const ｛ data ｝ = await client.query(｛ query: GET_POSTS, variables: ｛ tags, ｝ ｝); setPosts(data.getPosts); ｝ return ( &lt;&gt; &lt;button onClick=｛() =&gt; ｛ _getPosts(｛ tags: ['kr-dev'] ｝) ｝｝&gt;GetPosts&lt;/Button&gt; &lt;ul&gt; ｛ posts.map(post =&gt; ( &lt;li key=｛post.post_id｝&gt;｛post.title｝&lt;/li&gt; )) ｝ &lt;/ul&gt; &lt;/&gt; );｝;export default MainPage; * React + GraphQL + React Apollo Hooks를 사용하여 아래와 같은 사이트를 만들고 있습니다. 일단 컨셉만 잡아보았습니다. 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"}],"tags":[{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"},{"name":"Apollo Hooks","slug":"apollo-hooks","permalink":"https://anpigon.github.io/tags/apollo-hooks/"}],"author":"anpigon"},{"title":"크롬 앱(Chrome App) 만들기 #1","slug":"/whan/@anpigon/chrome-app-1","date":"2019-05-11T02:26:15.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/whan/@anpigon/chrome-app-1/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/chrome-app-1/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.이번에는 크롬 브라우저에서 동작하는 앱을 만드는 과정을 설명합니다. 다음과 같은 Chrome 앱을 만들 수 있습니다. 크롬 브라우저와 함께 동작하는 Chrome Extensions, 그리고 네이티브 앱처럼 독립적으로 실행할 수 있는 Chrome App이 있습니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.이번에는 크롬 브라우저에서 동작하는 앱을 만드는 과정을 설명합니다. 다음과 같은 Chrome 앱을 만들 수 있습니다. 크롬 브라우저와 함께 동작하는 Chrome Extensions, 그리고 네이티브 앱처럼 독립적으로 실행할 수 있는 Chrome App이 있습니다. 출처: https://developer.chrome.com/home Chrome App은 HTML, CSS, JS 만 알면 누구나 쉽게 개발할 수 있습니다. 그리고 크롬 브라우저가 설치되는 대부분의 OS에서 실행됩니다. 간단한 앱은 Chrome App으로 쉽게 만들 수 있습니다. Chrome App 만드는 방법은 매우 간단합니다. 다음 과정이면 누구나 쉽게 만들 수 있습니다. 지금 바로 스팀잇 앱을 만들어보세요. ㅋ * Chrome App에는 다음 구성 요소가 포함됩니다. manifest는 Chrome에서 실행하기 위한 앱에 대해 정보입니다. 앱 기본 정보와 실행하는 방법, 그리고 필요한 추가 권한을 설정합니다. background script는 프로그램 수명주기 관리하는 이벤트 페이지를 만드는 데 사용됩니다. 모든 코드(HTML, JS, CSS)는 Chrome 앱 패키지에 포함되어야 합니다. 모든 이미지와 기타 Assets도 패키지에 포함되어야합니다. manifest 만들기 manifest.json 파일을 생성합니다. manifest에 대한 자세한 설명은 Formats: Manifest Files를 참고하세요. 123456789101112｛ \"name\": \"Hello World!\", \"description\": \"My first Chrome App.\", \"version\": \"0.1\", \"manifest_version\": 2, \"app\": ｛ \"background\": ｛ \"scripts\": [\"background.js\"] ｝ ｝, \"icons\": ｛ \"16\": \"calculator-16.png\", \"128\": \"calculator-128.png\" ｝｝ 중요 : Chrome App은 반드시 manifest version 2를 사용해야합니다. background script 만들기 그다음 background.js 파일을 만듭니다. 12345678chrome.app.runtime.onLaunched.addListener(function() ｛ chrome.app.window.create('window.html', ｛ 'outerBounds': ｛ 'width': 400, 'height': 500 ｝ ｝);｝); 사용자가 앱을 실행하면 onLaunched 이벤트가 호출됩니다. 그리고 지정된 width와 height의 크기의 window을 열어 앱을 실행합니다. background script에는 listeners, windows, post messages, 그리고 launch data가 포함될 수 있습니다. 이 데이터는 이벤트 페이지에서 앱을 관리하는 데 사용됩니다. Step 3: window 페이지 만들기 window.html 파일을 만듭니다. 앱이 실행되면 보이는 화면입니다. 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Hello, world!&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Step 4: 아이콘 만들기 아래 아이콘을 다운로드 받아 앱 폴더에 넣어주세요. calculator-16.png calculator-128.png 앱 실행하기 앱로드 하기 크롬 브라우저에서 설정 아이콘을 클릭하고 도구 더보기(L) &gt; 확장 프로그램(E)을 선택합니다. 또는, 주소창에 chrome://extensions/를 입력하여 이동합니다. 그리고 상단죄측의 개발자 모드를 선택합니다. 그다음 압축해제된 확장 프로그램을 로드합니다 버튼을 클릭하고 앱의 폴더로 이동 한 다음 확인을 클릭 합니다. 그러고 나면 Chrome Apps 에 Hello World 아이콘이 생성된 것을 확인할 수 있습니다. 클릭하면 앱이 실행됩니다. 참고: https://developer.chrome.com/apps/first_app 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[],"author":"anpigon"},{"title":"크롬 확장 프로그램 개발하기","slug":"/whan/@anpigon/4wsyo2","date":"2019-05-08T01:39:00.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/whan/@anpigon/4wsyo2/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/4wsyo2/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.크롬 웹 스토어에는 해피베리보이(@happyberrysboy)님이 만드신 Steem Tools 앱이 있습니다. 제가 유용하게 잘 사용하고 있습니다. ㅋ제가 여기에 기능을 추가하고 싶다는 의사를 전달하였습니다. 감격스럽게도 해피보이님께서 저를 일명 WS_TOOLS 앱의 커미터(Committer)로 채택해주셨습니다. 그래서 해피보이님과 협업으로 크롬 확장프로그램을 개발하고 있습니다. ㅋ","text":"Design by @imrahelk안녕하세요. 안피곤입니다.크롬 웹 스토어에는 해피베리보이(@happyberrysboy)님이 만드신 Steem Tools 앱이 있습니다. 제가 유용하게 잘 사용하고 있습니다. ㅋ제가 여기에 기능을 추가하고 싶다는 의사를 전달하였습니다. 감격스럽게도 해피보이님께서 저를 일명 WS_TOOLS 앱의 커미터(Committer)로 채택해주셨습니다. 그래서 해피보이님과 협업으로 크롬 확장프로그램을 개발하고 있습니다. ㅋ 저는 크롬 확장 프로그램은 한번도 만들어 본적이 없습니다. 그래서 해피님의 도움과 구글 문서를 참고 하여 개발하였습니다. 참고: https://developer.chrome.com/extensions/content_scripts * manifest.json 파일에 content_scripts를 추가합니다. content_scripts를 사용하면 부모 페이지의 DOM에 접근할 수 있습니다. manifest.json 12345678910... \"content_scripts\": [ ｛ \"matches\": [\"https://steemit.com/*\"], \"run_at\": \"document_idle\", \"js\": [\"jquery3.3.1.min.js\", \"content_script.js\"], \"css\": [\"content_style.css\"] ｝ ],... 그리고 `content_script.js` 파일을 작성합니다. 이 파일에 카테고리 링크를 보여주는 HTML과 API 서버에서 글을 가져오는 로직을 구현합니다. content_script.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768(async () =&gt; ｛ const GetPostsQuery = `query GetPosts($tags: [String!]!) ｛ getPosts( tags: $tags ) ｛ author permlink title author_reputation summary tags image created total_payout_value curator_payout_value pending_payout_value vote_count comment_count ｝ ｝`; function getPosts(tags=[\"kr\"], start=0, limit=10) ｛ fetch(GRAPHQL_URL, ｛ method: 'POST', headers: ｛ 'Content-Type': 'application/json', 'Accept': 'application/json', ｝, body: JSON.stringify(｛ query: GetPostsQuery, variables: ｛ tags, start, limit ｝, ｝) ｝) .then(r =&gt; r.json()) .then((｛ data ｝) =&gt; ｛ const posts = data.getPosts; const postsDom = posts.map(post =&gt; ｛ return `&lt;li&gt; &lt;div class='articles__summary'&gt; &lt;!-- ... 코드가 너무 길어서 생략함 ... --&gt; &lt;/div&gt; &lt;/li&gt;` ｝); $(\"#posts_list &gt; ul\").html(postsDom); ｝); ｝ const cetegoryDom = $(` &lt;div&gt; &lt;hr&gt; &lt;center&gt; &lt;a href=\"#\" tags=\"\"&gt;전체&lt;/a&gt; | &lt;a href=\"#\" tags=\"kr-life, life\"&gt;일상&lt;/a&gt; | &lt;a href=\"#\" tags=\"kr-book, book, booksteem\"&gt;도서&lt;/a&gt; | &lt;a href=\"#\" tags=\"kr-game, game\"&gt;게임&lt;/a&gt; | &lt;a href=\"#\" tags=\"kr-dev, dev\"&gt;코딩&lt;/a&gt; | &lt;a href=\"#\" tags=\"kr-art, art\"&gt;예술&lt;/a&gt; | &lt;/center&gt; &lt;hr&gt; &lt;/div&gt; `); cetegoryDom.find('a').click(evt =&gt; ｛ const tags = evt.target.getAttribute('tags').split(',') getPosts(tags); ｝) $(\".App__content\").before(cetegoryDom);｝)(); API 서버를 만드는 과정은 “Google App Engine + GraphQL으로 스팀잇 API 서버 만들기” 에서 소개하였습니다. 이 API 서버에서 각 분류에 해당하는 글을 가져옵니다. 데이터 가져오는 속도가 제 예상보다 빨랐습니다. * 아래는 여기까지 작업한 화면입니다. 각 카테고리에 해당하는 링크를 클릭하면 관련 글을 몽땅 가져옵니다. 글의 분류는 글에 포함되어 있는 태그를 기준으로 분류하였습니다. 예를 들어 글의 태그에 #book, #kr-book, #booksteem 중 하나라도 포함되어 있으면 도서로 분류됩니다. 그리고 이걸 작업하고 나서 해피님께 최우수상을 받았습니다. 이 맛에 코딩하는 것 같습니다. ㅋ 참고로 상장은 원사마님이 디자인하였습니다. 모두 해피 코딩하세요~! ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg) Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"크롬 확장 프로그램an","slug":"크롬-확장-프로그램an","permalink":"https://anpigon.github.io/tags/크롬-확장-프로그램an/"}],"author":"anpigon"},{"title":"WHAN DEV TEAM 을 소개합니다.","slug":"/ntopaz/@anpigon/ntopaz--anpigon--125750869--ntopaz-kr-busy-whan-kr-art--2019-05-06-10-40-18--artwork--none","date":"2019-05-06T01:40:18.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/ntopaz/@anpigon/ntopaz--anpigon--125750869--ntopaz-kr-busy-whan-kr-art--2019-05-06-10-40-18--artwork--none/","link":"","permalink":"https://anpigon.github.io/ntopaz/@anpigon/ntopaz--anpigon--125750869--ntopaz-kr-busy-whan-kr-art--2019-05-06-10-40-18--artwork--none/","excerpt":"아이패드 Autodesk SketchBook 앱에서 그렸습니다. 애플 펜슬 구입한게 아까워서, 아이패드에서 가끔 마음에 드는 그림을 따라 그립니다. 저는 레트로 느낌의 그림체를 좋아합니다. ㅋ스팀잇에서 활동하는 @wonsama, @happyberrysboy, @anpigon, @newbijohn 님을 제가 생각했던 캐릭터로 표현해보았습니다.","text":"아이패드 Autodesk SketchBook 앱에서 그렸습니다. 애플 펜슬 구입한게 아까워서, 아이패드에서 가끔 마음에 드는 그림을 따라 그립니다. 저는 레트로 느낌의 그림체를 좋아합니다. ㅋ스팀잇에서 활동하는 @wonsama, @happyberrysboy, @anpigon, @newbijohn 님을 제가 생각했던 캐릭터로 표현해보았습니다. 못하는게 없는 개발자! 다재다능한 원사마님 천재적인 두뇌와 최첨단 장비로 날아다니는 원사마맨. 부산 상남자 스타일~! 코딩밖에 모르는 해피베리보이님 코딩하러 달려가는 해피보이헐크. 기획의 신! 갓뉴비존님 기존의 고정 관념을 모두 깨부수는 기획의 신~! 뉴비토르. 그리고 스펠링이 A로 시작하는 안피곤. ㅋ “I can do coding all day” 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[소설] 더글라스 케네디 ⟪스테이트 오브 더 유니언 (Kennedy, Douglas - State of the Union)⟫","slug":"책 이야기/2019-05-06---kennedy-douglas-state-of-the-union","date":"2019-05-05T23:12:42.000Z","updated":"2019-11-11T13:41:49.863Z","comments":true,"path":"책 이야기/2019-05-06---kennedy-douglas-state-of-the-union/","link":"","permalink":"https://anpigon.github.io/책 이야기/2019-05-06---kennedy-douglas-state-of-the-union/","excerpt":"볼륜 이야기 전문 작가 더글라스 케네디의 소설을 읽었다. 역시나 스테이트 오브 더 유니언에도 외도와 볼륜 이야기가 등장한다.여주인공 한나의 이야기이다. 이야기는 1부(1960~1970년대)와 2부(2000년대)로 나뉜다. 한나의 아버지는 언론에서 베트남 반전 운동으로 유명한 대학 교수이다. 그리고 어머니는 자기중심적이며 진보성향이 강한 예술가이다. 한나는 이런 부모 밑에서 자라면서 평범하고 싶어한다.","text":"볼륜 이야기 전문 작가 더글라스 케네디의 소설을 읽었다. 역시나 스테이트 오브 더 유니언에도 외도와 볼륜 이야기가 등장한다.여주인공 한나의 이야기이다. 이야기는 1부(1960~1970년대)와 2부(2000년대)로 나뉜다. 한나의 아버지는 언론에서 베트남 반전 운동으로 유명한 대학 교수이다. 그리고 어머니는 자기중심적이며 진보성향이 강한 예술가이다. 한나는 이런 부모 밑에서 자라면서 평범하고 싶어한다. 1부에서는 유부녀 한나의 외도, 그리고 2부에서는 한나 딸의 볼륜과 실종사건이 발생한다. 2부 중반 이후에는 이 사건들이 복합적으로 수면위로 떠오르면서 이야기가 흥미진진하게 흘러간다. 그리고 언론에서 이슈를 터트리기 위해 한나를 마녀 사냥 하는 모습은 현대 사회의 암울한 현실을 보여주는 것 같다. 작가는 왜 1부를 1960년대로 설정했을까? 1960년대의 미국은 급진주의의 시대였다. 인권운동과 반전운동, 프리섹스 주의가 활기를 띠던 때였다. 그리고 기성세대와 구시대적 질서에 대한 반감도 대단히 높았다. 젊은이들은 부모 세대의 보수적 가치에 반항해 싸우고자 했다. 관련기사: 미국 문화의 숨겨진 핵심 코드, 히피 책 속에서 생각나는 문장 인간은 살아남기 위해 무엇이든 붙잡는다. 아무리 힘겨운 삶을 살아가고 있다고 하더라도 바위 모서리를 붙잡은 나처럼 악착같이 삶에 매달린다. (272p) 부모란 자식이 잘못을 저지르면 혼자 남몰래 자책하는 존재이다. (313p) “내 인생을 돌아볼 때 가장 후회되는 게 뭔지 아니? 내 스스로 행복해질 수 있는 일을 만들지 않았다는 거야.” (355p) 오래된 부부의 가장 좋은 점은 안정감과 편안함이다. 보통 때는 그 장점들을 당연한 것으로 생각해 소중한지 모른다. 갑작스러운 위기가 밀어닥치고 모든 걸 빼앗기기 직전에야 그 장점들이 얼마나 소중한지 깨닫게 된다. (430p)","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"더글라스 케네디","slug":"더글라스-케네디","permalink":"https://anpigon.github.io/tags/더글라스-케네디/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"}],"author":"steemory"},{"title":"Google App Engine + GraphQL으로 스팀잇 API 서버 만들기","slug":"/whan/@anpigon/google-app-engine-graphql-api","date":"2019-05-03T06:11:06.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/whan/@anpigon/google-app-engine-graphql-api/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/google-app-engine-graphql-api/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.바로 이전글 ⌈🚀5분 안에 Google App Engine에 Apollo GraphQL 서버 구성하기!⌋에서 GAE에 GraphQL 서버를 구성했습니다.이제 이 API 서버를 이용하여 태그별 피드 검색, 저자 명성도 순, 댓글 순, 보상금액 순, 보팅 순 등의 데이터를 조회할 용도로 사용할 것입니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.바로 이전글 ⌈🚀5분 안에 Google App Engine에 Apollo GraphQL 서버 구성하기!⌋에서 GAE에 GraphQL 서버를 구성했습니다.이제 이 API 서버를 이용하여 태그별 피드 검색, 저자 명성도 순, 댓글 순, 보상금액 순, 보팅 순 등의 데이터를 조회할 용도로 사용할 것입니다. 사실 API 서버를 Prisma로 구성하고 싶었습니다. 그런데 Prisma는 기능이 아직 많이 부족하다고 생각합니다. 제가 원하는 서비스를 구현하기에 매우 힘들었습니다.😥 결국 MongoDB를 사용하였습니다. 혹시라도 Prisma에 관심있으면 ⌈프리즈마(Prisma) 사용하기⌋ 시리즈 글을 읽어주세요~! * MongoDB + GraphQL + Google App Engine 조합으로 API 서버를 구성하였습니다. 그리고 MongoDB는 mlab.com 서비스를 이용하고 있습니다. DB 무료 제공 용량이 500MB라서 아껴서 써야 할 것 같습니다. 10만 건의 데이터를 저장했더니, 벌써 50％를 사용해버렸습니다. ㅠㅠ 그리고 코드를 전부 공개하기는 좀 그렇고, 일부 핵심 코드만 공개합니다. 앞으로 댓글 순, 보팅 순, 보상금액 순, 저자 명성도 순으로 조회하는 기능을 추가할 예정입니다. index.js 1234567891011121314151617181920212223242526272829303132import Storage from './storage'const typeDefs = ` type Query ｛ getPosts( tags: [String] ): [Post!]! ｝`;const resolvers = ｛ Query: ｛ getPosts: async (_, args, ｛ storage ｝) =&gt; ｛ const ｛ tags ｝ = args; return await storage.getPosts(tags); ｝ ｝｝const storage = new Storage();const server = new GraphQLServer(｛ schema, context: (｛ request ｝) =&gt; (｛ request, storage ｝)｝);server.express.use(logger('dev'));server.start(｛ port: PORT ｝, () =&gt; ｛ console.log(`Server running on http://localhost:$｛PORT｝`)｝); storage.js 12345678910111213141516171819202122232425import ｛ MongoClient ｝ from 'mongodb';const collections = ｛ POSTS: 'posts',｝export default class Storage ｛ constructor() ｛ MongoClient.connect(process.env.MONGO_URI, ｛ useNewUrlParser: true ｝) .then(client =&gt; ｛ this.db = client.db(); ｝); ｝ getPosts(tags=[\"kr\"], limit=10) ｛ return this.db.collection(collections.POSTS) .find(｛ $or: tags.map(tags =&gt; (｛ tags ｝)) ｝, ｛ limit ｝) .sort(｛ post_id: -1 ｝) .toArray(); ｝｝ 태그(tag)를 or 조건으로 검색합니다. 만약, [&quot;kr-book&quot;, &quot;booksteem&quot;]으로 검색한다면, 두 태그 중 하나라도 포함된 피드를 모두 조회합니다. 아래는 구글 앱 엔진에서 실행한 화면입니다. 이제 #bootsteem과 #kr-boot 태그에 올라온 피드를 조회하여, 최신순으로 받아 볼 수 있습니다. 이제 GraphQL 서버와 크롤링 데몬, 그리고 Front-End 페이지까지 개발완료되면 완성된 앱을 볼 수 있을 것 같습니다. 해피 코딩하세요~! Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"GraphQL","slug":"graphql","permalink":"https://anpigon.github.io/tags/graphql/"},{"name":"Google App Engine","slug":"google-app-engine","permalink":"https://anpigon.github.io/tags/google-app-engine/"}],"author":"anpigon"},{"title":"🚀5분 안에 Google App Engine에 Apollo GraphQL 서버 구성하기!","slug":"/whan/@anpigon/5-google-app-engine-apollo-graphql","date":"2019-05-01T17:41:33.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/whan/@anpigon/5-google-app-engine-apollo-graphql/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/5-google-app-engine-apollo-graphql/","excerpt":"Design by @imrahelk구글 앱 엔진(Google App Engine)은 서버 없이 백엔드 API 서버를 구축하기 좋은 플랫폼입니다. 개발자가 오로지 앱 개발에만 집중할 수 있습니다. 웹서버, 로드밸런스, 네트워크 구성 등 몰라도 됩니다. ㅎㅎ 현재 GAE는 JAVA, PHP, Node.js, Python, C#, .Net, Ruby, Go 등의 언어를 지원합니다. 자세한 내용은 GAE 사이트를 참고하세요.","text":"Design by @imrahelk구글 앱 엔진(Google App Engine)은 서버 없이 백엔드 API 서버를 구축하기 좋은 플랫폼입니다. 개발자가 오로지 앱 개발에만 집중할 수 있습니다. 웹서버, 로드밸런스, 네트워크 구성 등 몰라도 됩니다. ㅎㅎ 현재 GAE는 JAVA, PHP, Node.js, Python, C#, .Net, Ruby, Go 등의 언어를 지원합니다. 자세한 내용은 GAE 사이트를 참고하세요. 저는 2014년도에 “왜 레진코믹스는 구글 앱엔진을 선택했나” 슬라이드를 보고나서, GAE를 정말 많이 이용했습니다. GAE는 PaaS(Platform as a service) 서비스입니다. 파스(PaaS)말고도 SaaS, IaaS, BaaS 등 다양한 형태의 클라우드 서비스가 존재합니다. BaaS가 예전에는 Backend as a service를 의미했습니다. 하지만 이제는 Blockchain as a service를 의미하는 것 같습니다. 이제는 블록체인도 클라우드 서비스 형태로 사용하는 시대입니다. 아마존은 작년(2018)부터 블록체인 클라우드 서비스를 시작했습니다. - AWS에서의 블록체인: https://aws.amazon.com/ko/blockchain/ 그리고 BaaS 하니깐 국내 KTH에서 서비스했던 baas.io가 생각납니다. baas.io도 정말 잘 사용했었습니다. 하지만 정식 오픈도 하기전에 역사의 뒤안길로 사라져서 너무 안타까웠습니다. 참고로 baas.io는 가격이 무척 저렴했습니다. baas.io를 모르시는 분을 위해 관련 기사를 링크합니다. - KTH, 모바일 앱 개발 도우미 서비스 출시: http://www.bloter.net/archives/132383 * 아래의 단계를 따르면 5분 안에 Apollo GraphQL Server를 **Google App Engine (GAE)**에서 실행할 수 있습니다. 내용은 “Apollo GraphQL Server on Google App Engine in under 5 minutes!” 블로그를 참고하였습니다. 프로젝트 생성하기 apollo-graphql-server 디렉토리를 만듭니다. 12$ mkdir apollo-graphql-server$ cd apollo-graphql-server 아래 명령을 실행하고 package.json 파일을 생성합니다. 1$ npm init 아래 명령을 실행하여 필요한 모듈을 설치합니다. 1$ npm install --save graphql-yoga graphql-yoga를 사용하면 GraphQL Server를 매우 쉽게 구현할 수 있습니다. 자세한 내용은 graphql-yoga 사이트에서 확인해주세요. index.js 만들기 ndex.js 파일을 만들고 아래 내용을 입력합니다. 1234567891011121314151617181920const ｛ GraphQLServer ｝ = require('graphql-yoga');const PORT = process.env.PORT || 8080;const typeDefs = ` type Query ｛ hello: String! ｝`;const resolvers = ｛ Query: ｛ hello: () =&gt; \"Hi\" ｝｝ const server = new GraphQLServer(｛ typeDefs, resolvers ｝);server.start(｛ port: PORT ｝, () =&gt; ｛ console.log(`Server running on http://localhost:$｛PORT｝`)｝); 서버는 process.env.PORT 변수에서 포트를 지정하도록 합니다. 이것은 GAE 런타임에 의해 설정된 환경 변수입니다. 그리고 PORT 값은 GAE 런타임에 의해 8080으로 설정됩니다. package.json package.json 파일에서 시작 스크립트와 node 및 npm 버전을 지정합니다. 1234567\"scripts\": ｛ \"start\": \"npx babel-node index\"｝\"engines\": ｛ \"node\": \"&gt; = 8.16\", \"npm\": \"5.x\" ｝ app.yaml GAE에 배포하기 위해서는 app.yaml 파일이 필요합니다. app.yaml 파일을 만들고 아래 내용을 입력합니다. 123456789101112runtime: nodejsenv: flexresources: cpu: 1 memory_gb: 0.5 disk_size_gb: 10 automatic_scaling: min_num_instances: 1 max_num_instances: 20 cool_down_period_sec: 60 cpu_utilization: target_utilization: 0.80 app.yaml 파일 정보는 공식 문서를 참고하세요. 앱 배포하기 아래 명령을 실행하면 앱을 배포하기 시작합니다. 배포가 완료되기까지 1~2분 정도 소요됩니다. 1gcloud app deploy 앱 실행하기 아래 명령을 실행하면 기본 브라우저에서 앱 URL로 이동합니다. 1gcloud app browse https://[your-project-id].appspot.com와 같은 URL로 이동하게 됩니다. 그럼 아래와 같이 GraphiQL 인터페이스를 볼 수 있습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"GraphQL","slug":"graphql","permalink":"https://anpigon.github.io/tags/graphql/"},{"name":"Google App Engine","slug":"google-app-engine","permalink":"https://anpigon.github.io/tags/google-app-engine/"}],"author":"anpigon"},{"title":"프리즈마(Prisma) 사용하기 #3 : 태그별  통계 계산하기","slug":"/whan/@anpigon/prisma-3","date":"2019-04-28T03:08:48.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/whan/@anpigon/prisma-3/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/prisma-3/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.크롤링한 스팀잇 데이터를 이용하여 본래 목적인 태그별 통계를 계산해보겠습니다. 사실 통계 시스템 구현에 prisma는 비효율적인 부분이 있는 것 같습니다. ㅋ개인적으로 prisma에 Insert All 기능이 없는 것이 가장 아쉽습니다. 그리고 Aggregations의 기능을 사용해보고 싶은데, 아직은 comming soon 입니다. ㅠ","text":"Design by @imrahelk안녕하세요. 안피곤입니다.크롤링한 스팀잇 데이터를 이용하여 본래 목적인 태그별 통계를 계산해보겠습니다. 사실 통계 시스템 구현에 prisma는 비효율적인 부분이 있는 것 같습니다. ㅋ개인적으로 prisma에 Insert All 기능이 없는 것이 가장 아쉽습니다. 그리고 Aggregations의 기능을 사용해보고 싶은데, 아직은 comming soon 입니다. ㅠ 아래에서는 수집한 데이터를 이용하여 보상금액순, 댓글순, 보팅순, 포스팅수를 집계할 것입니다. 하지만 아직 GraphQL이나 prisma에 익숙하지 않아 매우 단순하게 구현하였습니다. 시리즈글 ▪︎ 프리즈마(Prisma) 사용하기 #1 : 시작하기 ▪︎ 프리즈마(Prisma) 사용하기 #2 : Insert 하기 ▪︎ 프리즈마(Prisma) 사용하기 #3 : 태그별 통계 계산하기 시리즈 글을 자동으로 모아주는 툴이 있으면 정말 좋을 것 같습니다. @nhj12311님 어디 가셨나요? ㅠㅠ * datamodel 수정하기 필드를 추가하기 위해 datamodel.prisma 을 수정하였습니다. 보팅과 댓글 개수를 파악하기 위한 vote_count와 comment_count 필드가 추가되었습니다. 123456789101112131415161718type Post ｛ id: ID! @id post_id: Float! @unique author: String! author_reputation: Float! permlink: String! category: String! title: String! body: String! tags: [String!]! @scalarList(strategy: RELATION) image: String created: Float! total_payout_value: Float @default(value: 0) curator_payout_value: Float @default(value: 0) pending_payout_value: Float @default(value: 0) vote_count: Int @default(value: 0) comment_count: Int @default(value: 0)｝ 수정한 모델을 DB서버에 반영하고, prisma 클라이언트를 업데이트합니다. 1$ prisma deploy &amp;&amp; prisma generate 데이터 100건 등록하기 index.js의 main() 함수를 수정합니다. 데이터 100건을 loop 돌면서 등록합니다. 그리고 prisma.upsertPost() 함수를 사용하여 기존의 데이터가 있으면 수정 or 없으면 신규 등록하도록 하였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374async function main() ｛ const opts = ｛ tag: 'kr', limit: 100 ｝ const discussions = await client.database.getDiscussions('created', opts); for (let i = 0, l = discussions.length; i &lt; l; i++) ｛ const ｛ post_id, author, author_reputation, permlink, category, title, body, json_metadata, created, total_payout_value, curator_payout_value, pending_payout_value, active_votes, children ｝ = discussions[i]; const ｛ tags, image: images ｝ = JSON.parse(json_metadata); const image = images &amp;&amp; images.length &amp;&amp; images[0] || null; const vote_count = active_votes.filter(e =&gt; e.percent &gt; 0).length; try ｛ const result = await prisma.upsertPost(｛ where: ｛ post_id ｝, update: ｛ author_reputation, title, body, tags: ｛ set: tags ｝, image, total_payout_value: parseFloat(total_payout_value), curator_payout_value: parseFloat(curator_payout_value), pending_payout_value: parseFloat(pending_payout_value), vote_count, comment_count: children ｝, create: ｛ post_id, author, author_reputation, permlink, category, title, body, tags: ｛ set: tags ｝, image, created: parseFloat(dateFormat(new Date(`$｛created｝`), 'yyyymmddHHMMss')), total_payout_value: parseFloat(total_payout_value), curator_payout_value: parseFloat(curator_payout_value), pending_payout_value: parseFloat(pending_payout_value), vote_count, comment_count: children ｝ ｝); console.log(result.id); ｝ catch (error) ｛ console.error(error, JSON.stringify(error)); ｝ ｝｝ 이제 실행해보겠습니다. 1$ npx babel-node index Prisma Playground 에서 쿼리를 날려 전체 데이터수를 확인해봅니다. 1234567query ｛ postsConnection ｛ aggregate ｛ count ｝ ｝｝ 이전에 테스트하면서 등록한 데이터가 있어서 108건이 출력되었습니다. 태그별 보상금액, 댓글, 보팅, 포스팅 개수 계산하기 기간 일주일(2019/04/22 ~ 2019/04/28)의 데이터를 이용하여 보상금액, 댓글, 보팅, 포스팅 개수 계산합니다. 데이터가 100건 밖에 없어서 일주일분의 데이터가 아닐 수도 있습니다. statByTag.js 파일을 작성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import ｛ Client ｝ from 'dsteem';import ｛ prisma ｝ from './generated/prisma-client';import 'console.table';const client = new Client('https://api.steemit.com');async function main() ｛ try ｛ const result = await prisma.posts(｛ where: ｛ created_gte: 20190422000000, created_lte: 20190428595959 ｝ ｝).$fragment(` fragment TagsInPosts on Posts ｛ tags total_payout_value curator_payout_value pending_payout_value vote_count comment_count ｝ `); const stat = result.reduce((acc, val) =&gt; ｛ const ｛ vote_count, comment_count, tags ｝ = val; const payout_value = val.curator_payout_value + val.pending_payout_value + val.total_payout_value; tags.filter(tag =&gt; Boolean(tag)).forEach(tag =&gt; ｛ if (acc.hasOwnProperty(tag)) ｛ acc[tag].post_count += 1; acc[tag].vote_count += val.vote_count; acc[tag].payout_value += payout_value; acc[tag].comment_count += val.comment_count; ｝ else ｛ acc[tag] = ｛ post_count: 1, vote_count, payout_value, comment_count, ｝; ｝ ｝); return acc; ｝, ｛｝); console.table(Object.keys(stat).map(key =&gt; (｛ tag: key, ...stat[key] ｝))) ｝ catch (error) ｛ console.error(error); ｝｝main() .then(() =&gt; ｛ process.exit(0) ｝) .catch(e =&gt; console.error(e)) 그다음 실행합니다. 1$ npx babel-node statByTag 원사마님이 알려주신 console.table을 이용하여 출력해보았습니다. 태그 순위(2019/04/22 ~ 2019/04/28) 프로그램을 돌려놓고 포스팅을 작성하는 중에 일주일 정도의 데이터가 수집되었습니다. 일주일 분량의 데이터를 수집하는데 약 30분 정도 소요된 것 같습니다. 그리고 태그는 중복으로 사용가능하기 때문에 중복 데이터가 포함되어 있습니다. 정렬: 포스팅 수 No 태그 포스팅수 보팅수 보상금액 댓글수 1 kr 2028 75811 5678.558 12501 2 busy 720 36089 2766.685 6258 3 jjm 421 22915 1888.191 4513 4 mini 265 11850 1035.02 2382 5 tasteem 185 9501 909.401 2385 6 life 176 7626 677.482 1020 7 kr-newbie 173 2200 142.994 892 8 tasteem-kr 169 8242 838.433 2140 9 jjangjjangman 168 3891 225.33 734 10 thegivingtree 149 3362 168 1106 정렬: 보상 금액 No 태그 포스팅수 보팅수 보상금액 댓글수 1 kr 2028 75811 5678.558 12501 2 busy 720 36089 2766.685 6258 3 jjm 421 22915 1888.191 4513 4 mini 265 11850 1035.02 2382 5 tasteem 185 9501 909.401 2385 6 tasteem-kr 169 8242 838.433 2140 7 life 176 7626 677.482 1020 8 muksteem 130 6412 563.322 1606 9 steemmonsters 93 5240 353.713 625 10 steemit 92 2811 332.537 484 정렬: 댓글 수 No 태그 포스팅수 보팅수 보상금액 댓글수 1 kr 2028 75811 5678.558 12501 2 busy 720 36089 2766.685 6258 3 jjm 421 22915 1888.191 4513 4 tasteem 185 9501 909.401 2385 5 mini 265 11850 1035.02 2382 6 tasteem-kr 169 8242 838.433 2140 7 muksteem 130 6412 563.322 1606 8 kr-series 71 4911 306.743 1301 9 tripsteem 99 4783 318.564 1118 10 thegivingtree 149 3362 168 1106 전체 데이터는 여기에서 확인 가능합니다. * 그리고 #kr에 사용되는 하위 태그를 기반으로 카테고리 분류도 해보려고 합니다. 욕심없이 대략 이 정도의 카테고리만 분류할 예정입니다. 영화, 방송&amp;연예, 게임, 애니메이션, 만화, 도서, 음악, 공연&amp;전시, 음식, 애완반려동물, 여행, 사진, 패션&amp;뷰티, 연애, 개그, 일상, 육아, IT, 얼리어답터, 지름, 자동차, 스포츠, 뉴스비평, 인문사회, 역사, 세계, 과학, 토이 참고로 이전에 머신러닝을 이용하여 분류해보려고 시도했었습니다. “[머신러닝] 스팀잇 글 분류하기 (첫번째 시도)”. 결과적으로 저의 머신러닝의 이해도가 매우 낮아 구현하지 못하였습니다. 이번에는 좀더 단순하게 접근하기로 하였습니다. 이번에 한다면 스팀잇 글 분류하기 두 번째 시도가 되겠네요. 여기까지 읽어주셔서 감사합니다. ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"Prisma","slug":"prisma","permalink":"https://anpigon.github.io/tags/prisma/"}],"author":"anpigon"},{"title":"프리즈마(Prisma) 사용하기 #2 : Insert 하기","slug":"/whan/@anpigon/prisma-2-insert","date":"2019-04-27T01:06:42.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/whan/@anpigon/prisma-2-insert/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/prisma-2-insert/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.스팀잇 API로 #kr 태그의 글을 가져와서 크롤링하여 저장하는 App을 만들어 보려고 합니다. 사실 기존에 사용하던 방법으로 더 쉽고 빠르게 구현가능합니다. 하지만, 저는 새로운 기술을 학습할때 사이드 프로젝트를 하면서 배우는 것을 선호합니다. 새로운 기술을 배우면서 서비스를 만들어 보는 것은 매우 흥미있는 일입니다. 지금 만드는 앱은 아마도 날짜별/태그별 통계 데이터를 집계하는데 사용할 것입니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.스팀잇 API로 #kr 태그의 글을 가져와서 크롤링하여 저장하는 App을 만들어 보려고 합니다. 사실 기존에 사용하던 방법으로 더 쉽고 빠르게 구현가능합니다. 하지만, 저는 새로운 기술을 학습할때 사이드 프로젝트를 하면서 배우는 것을 선호합니다. 새로운 기술을 배우면서 서비스를 만들어 보는 것은 매우 흥미있는 일입니다. 지금 만드는 앱은 아마도 날짜별/태그별 통계 데이터를 집계하는데 사용할 것입니다. 그리고 주말에는 좀 쉬어야겠습니다. 의자에 너무 오래 앉아있으니 목/허리가 아프네요. ![](https://steemitimages.com/350x0/https://images.velog.io/images/anpigon/profile/a3deb770-1e06-11e9-a113-d1bf3b7c35c8/aef8762dbd50aa9d499f38d51fc1909f.png) * Post model 추가하기 datamodel.prisma 파일을 열어서 다음 type을 추가합니다. 최소한의 데이터만 저장하기 위해서 아래와 같이 model을 정의하였습니다. 12345678910111213141516type Post ｛ id: ID! @id post_id: Float! @unique author: String! author_reputation: Float! permlink: String! category: String! title: String! body: String! tags: [String!]! @scalarList(strategy: RELATION) image: String created: Float! total_payout_value: Float! curator_payout_value: Float! pending_payout_value: Float!｝ 그다음 수정한 데이터모델(datamodel)을 deploy하여 DB에 반영합니다. deploy를 실행하면 서버에 바로 반영됩니다. 매우 편리합니다.ㅋ 1$ prisma deploy 그리고 prisma 관리자 페이지에 접속하면, 방금 추가한 Post 테이블이 생성된 것을 확인할 수 있습니다. 데이터 Inset 테스트 하기 이제 Prisma Playground를 이용하여 데이터를 등록(insert) 해봅니다. 아래와 같이 테스트 데이터를 입력하고 반환되는 id를 확인합니다. 123456789101112131415161718mutation ｛ createPost(data: ｛ post_id: 3 author: \"anpigon\" author_reputation: 1 category: \"kr\" permlink: \"kr\" title: \"test\" body: \"test\" created: 0 tags: ｛set: [\"kr\", \"kr-dev\"]｝ total_payout_value: 0 curator_payout_value: 0 pending_payout_value: 0 ｝) ｛ id ｝｝ id가 출력된 것을 보니, 데이터가 잘 등록된 것 같습니다. Prisma 클라이언트 설치하기 이제 코드를 구현해서 데이터를 insert 해보겠습니다. prisma와 연동하기 위해서는 client 라이브러리가 필요합니다. prisma-client-lib를 설치합니다. prisma-client-lib에는 Prisma 클라이언트를 실행하는 데 필요한 graphql의 모든 종속 패키지가 포함되어 있습니다. 설치하기 1$ npm install --save prisma-client-lib 그리고 generate를 명령어로 클라이언트를 업데이트합니다. generate 명령어를 실행하면 prisma 서버와 동기화하여 연동에 필요한 js가 ./generated 폴더에 자동 생성됩니다. 1$ prisma generate ES6(ES2105) 이상의 최신 JS 사용하기 ES6(ES2105) 이상의 JS 문법을 사용하기 위해서 babel을 설치합니다. 설치 방법은 babel-node 사이트를 참고하였습니다. 1$ npm install --save-dev @babel/cli @babel/core @babel/preset-env 그리고 바벨(babel)을 구성하기 위한 `.babelrc` 파일을 생성합니다. 1$ touch .babelrc `.babelrc`에 아래 내용을 입력합니다. 123｛ \"presets\": [\"@babel/preset-env\"]｝ `test.js` 를 실행할때는 다음 명령어를 사용합니다. 1$ npx babel-node test index.js 파일을 아래와 같이 구현합니다. 스팀잇에서 최신글 1개를 가져와서 prisma에 저장하는 로직입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import ｛ Client ｝ from 'dsteem';import dateFormat from 'dateformat';import ｛ prisma ｝ from './generated/prisma-client';const client = new Client('https://api.steemit.com');async function main() ｛ const opts = ｛ tag: 'kr', limit: 1 ｝ const discussions = await client.database.getDiscussions('created', opts); for (let i = 0, l = discussions.length; i &lt; l; i++) ｛ const ｛ post_id, author, author_reputation, permlink, category, title, body, json_metadata, created, total_payout_value, curator_payout_value, pending_payout_value ｝ = discussions[i]; const ｛ tags, image: images ｝ = JSON.parse(json_metadata); const image = images &amp;&amp; images.length &amp;&amp; images[0] || null; try ｛ const result = await prisma.createPost(｛ post_id, author, author_reputation, permlink, category, title, body, tags: ｛ set: tags ｝, image, created: parseFloat(dateFormat(new Date(`$｛created｝`), 'yyyymmddHHMMss')), total_payout_value: parseFloat(total_payout_value), curator_payout_value: parseFloat(curator_payout_value), pending_payout_value: parseFloat(pending_payout_value) ｝); console.log(result.id); ｝ catch (error) ｛ console.error(error); ｝ ｝｝main() .then(() =&gt; ｛ process.exit(0) ｝) .catch(e =&gt; console.error(e)) index.js를 실행합니다. 1$ npx babel-node index 방금 등록한 post의 id가 출력되었습니다. prisma 데이터 조회하기 마지막으로 Prisma Playground를 이용하여 방금 저장한 데이터를 조회합니다. id를 입력하고 title를 조회해보겠습니다. 1234567query ｛ post(where: ｛ id: \"cjuyrqk7uzsh60b30vyvp7qsj\" ｝) ｛ title ｝｝ 우리가 등록된 post의 title이 조회가 되었습니다. 여기까지 읽어주셔서 감사합니다. ![](https://steemitimages.com/400x0/https://cdn.steemitimages.com/DQmQmWhMN6zNrLmKJRKhvSScEgWZmpb8zCeE2Gray1krbv6/BC054B6E-6F73-46D0-88E4-C88EB8167037.jpeg)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"Prisma","slug":"prisma","permalink":"https://anpigon.github.io/tags/prisma/"}],"author":"anpigon"},{"title":"프리즈마(Prisma) 사용하기 #1","slug":"/whan/@anpigon/prisma-1","date":"2019-04-26T04:52:12.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/whan/@anpigon/prisma-1/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/prisma-1/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.무료 DB 서버 관련 이야기를 시작하면서 프리즈마(Prisma) 사용 방법을 시작하겠습니다. 무료 DB 서버 이야기저는 가난한 개발자입니다. 비용이 거의 발생하지 않는 DB 서버가 필요합니다.예전에 사용하지 않는 안드로이드폰에 MariaDB Server 앱을 설치해서 DB서버처럼 사용하기도 했습니다. 안드로이드폰은 2~3년 정도 사용하면 정말 느려집니다. 게다가 재부팅이 자주 발생합니다. 왜그런걸까요? WHY?","text":"Design by @imrahelk안녕하세요. 안피곤입니다.무료 DB 서버 관련 이야기를 시작하면서 프리즈마(Prisma) 사용 방법을 시작하겠습니다. 무료 DB 서버 이야기저는 가난한 개발자입니다. 비용이 거의 발생하지 않는 DB 서버가 필요합니다.예전에 사용하지 않는 안드로이드폰에 MariaDB Server 앱을 설치해서 DB서버처럼 사용하기도 했습니다. 안드로이드폰은 2~3년 정도 사용하면 정말 느려집니다. 게다가 재부팅이 자주 발생합니다. 왜그런걸까요? WHY? 또는 호스팅거처럼 저렴한 호스팅 서버에서 제공하는 작은 용량의 mysql을 사용하기도 했습니다. 호스팅 서버는 제약 사항이 너무 많습니다. 트래픽, DB쿼리횟수, 용량 등등… 외국 호스팅 서비스의 경우에는 CPU 점유율도 제한합니다. 국내 호스팅 서비스 중에서 닷홈이 저의 최애 서비스입니다. 잠깐 동안이었지만 서비스를 닷홈에서 운영했었습니다. 닷홈 무료 플랜의 경우 트래픽이나 용량을 예전 만큼 넉넉하게 주지 않아서 현재는 서비스를 운영하기에 매우 부족합니다. ㅠㅠ 그리고 호스팅 서버는 DB 외부 접속을 제공하지 않습니다. 그래서 API 서비스를 개발해서 구동해야합니다. 혹시 무료 호스팅 서버에 관심 있으면 다음 글을 읽어보세요. 워드프레스 개인 블로그를 운영하기에 적당합니다. 무료 웹 호스팅 사이트 (2019) : $ 0 비용으로 웹 사이트를 호스팅하는 방법 쓰다보니 갑자기 호스팅 서버 이야기로 넘어갔네요. 최근에 알게된 무료 몽고 DB 서비스입니다. mlab.com 와 mongodb.com 입니다. 두 서비스 모두 512MB용량의 DB를 제공합니다. 그리고 aws, google cloud, azure 에서 호스팅되고 있습니다. 저는 현재는 개발 용도로만 사용하고 있어요. * Prisma 프리즈마는 데이터베이스 도구 포함 ORM, 마이그레이션 및 관리자 UI (Postgres, MySQL 및 MongoDB) 입니다. 그리고 DB 프록시 서버 역할을 합니다. 사용자는 GraphQL Schema만 정의하면 되고 DB는 설계할 필요가 없습니다. DB는 GraphQL 스키마를 기반으로 자동 생성됩니다. 그리고 DB의 모든 Schema와 Table을 GraphQL로 관리할 수 있습니다. 참고로 프리즈마는 GraphQL 개발자와 Heroku 창업자가 같이 진행 중인 프로젝트라고 합니다. 프리즈마를 사용하기 위해서는 회원가입이 필요합니다. 프리즈마 사이트에 접속합니다. https://www.prisma.io/ 로그인 하고 나면 다음 화면이 보입니다. 여기서 ADD A SEVICE 를 선택합니다. 다음 화면에 보이는 설명을 따라합니다. 콘솔창에서 prisma 를 설치하고 로그인합니다. 12$ npm install -g prisma$ prisma login -k eyJhbGciOiJIUz... 로그인에 성공하면 브라우저의 화면이 다음 화면으로 자동 전환됩니다. 여기서 CREATE A NEW SERVICE 를 선택합니다. 그리고 다음 화면에 보이는 설명을 따라합니다. 프로젝트를 생성합니다. 1$ prisma init steem-community Use existing database를 선택하면 아래와 같이 Database를 선택하는 화면이 나옵니다. 저는 MongoDB를 선택했습니다. 관계형 DB를 원하시면 MySQL이나 PostgreSQL을 선택하셔도 됩니다. 옵션으로 MariaDB를 제공하지 않는 것이 많이 아쉽네요. 하지만, 저는 Demo Server를 선택했습니다. ㅋ 프리즈마 프로젝트 생성이 완료되면 아래와 같이 출력됩니다. 생성된 프로젝트에 들어가서 deploy 합니다. 이제 prisma 프로젝트가 생성되었습니다. 12$ cd steem-community$ prisma deploy 그리고 datamodel.prisma 파일을 살펴봅니다. 데이터 모델 파일입니다. 자세한 내용은 공식 문서를 참고하세요. type User ｛ id: ID! @unique name: String! ｝ 샘플로 생성된 datamodel.prisma 파일을 다음과 같이 수정합니다. 버전 업되면서 스펙이 조금 변경된 것 같습니다. 모델에 @id를 정의하라고 에러가 나네요. type User ｛ id: ID! @id name: String! ｝ 데이터 모델을 작성한 다음 prisma deploy 하면 DB가 생성됩니다. 이후로도 datamodel.prisma 파일를 수정하고 디플로이하면 DB에 바로 반영됩니다. 1$ prisma deploy 마지막으로 prisma 어드민 페이지에 접속하면, 테이블이 생성된 것을 확인 할 수 있습니다. 그리고 GraphQL API도 자동 생성됩니다. 여기까지 읽어주셔서 감사합니다. ### WHAN DEV TEAM [\\[출범식\\] WDT(WHAN DEV TEAM) 공식 활동 개시](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) [![](https://steemitimages.com/320x0/https://cdn.steemitimages.com/DQmbo4bis7WgjdVYdXR9VbzWdzh2aCXw2JFVKfruYNCNV4G/wdt.png)](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"Prisma","slug":"prisma","permalink":"https://anpigon.github.io/tags/prisma/"}],"author":"anpigon"},{"title":"[React Native] Steem 모바일 지갑앱 만들기 #2","slug":"/whan/@anpigon/react-native-steem-2","date":"2019-04-25T15:46:57.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/whan/@anpigon/react-native-steem-2/","link":"","permalink":"https://anpigon.github.io/whan/@anpigon/react-native-steem-2/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 2번째 포스팅입니다. 지갑 개발에 필요한 기능을 하나씩 학습하면서 구현하고 있습니다. 그리고 그 개발 과정을 기록하고 있습니다. 시리즈글 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #1","text":"Design by @imrahelk안녕하세요. 안피곤입니다.Steem 모바일 지갑앱 2번째 포스팅입니다. 지갑 개발에 필요한 기능을 하나씩 학습하면서 구현하고 있습니다. 그리고 그 개발 과정을 기록하고 있습니다. 시리즈글 ▪︎ [React Native] Steem 모바일 지갑앱 만들기 #1 * 개발환경 기분 좋게 expo로 Steem 모바일 지갑 개발을 시작했었습니다. 그러나 expo에서는 키 생성 및 암복호화 라이브러리를 사용할 수가 없었습니다. react-native에서는 standard node module를 모두 지원하지 않습니다. 가장 필요한 crypto와 buffer 라이브러리가 포함되어 있지 않네요. 저는 개발하기 편한 expo 환경을 유지하고 싶었습니다. 그래서 expo-kit을 eject하여 해결해보려고 했습니다. 결국은 삽질만 하다가 포기하고 react-native-cli로 프로젝트 환경으로 다시 구성하였습니다. ㅠㅠ 참고로 리액트 네이티브에서는 프로젝트를 시작하는 2가지 방법(expo-cli와 react-native-cli)을 가이드하고 있습니다. https://facebook.github.io/react-native/docs/getting-started * 데이터 안전하게 저장하기 react-native-keychain를 사용하면 KeychainiOS/KeystoreAndroid에 Access 할 수 있습니다. 모바일앱에서 매우 중요한 데이터는 Keychain/Keystore에서 생성된 키를 사용하여 암호화하여 저장합니다. 지갑앱에서는 사용자 PIN 6자리와 지갑키를 secure storage에 저장하고 있습니다. Android KeyStore 시스템에서는 암호화 키를 컨테이너에 저장하므로 기기에서 키를 추출해내기가 매우 어렵습니다. 자세한 내용은 Android Developers 문서를 읽어보세요. secure-key-store.js 파일을 아래와 같이 구현하여 사용합니다. 123456789101112131415161718192021import * as Keychain from 'react-native-keychain';// 데이터 저장const setItem = async (key, value) =&gt; ｛ await Keychain.setInternetCredentials( key, key, value )｝// 데이터 조회const getItem = async (key) =&gt; ｛ const result = await Keychain.getInternetCredentials(key); return result.password;｝export default ｛ setItem, getItem｝ * 구현 내용 앱을 최초 실행하면 username과 active key(또는 마스터키)와 사용자 PIN 6자리를 등록합니다. 그리고 계정(account) 등록이 완료되면 메인화면으로 이동하여 내 지갑 정보를 가져옵니다. 회원가입은 steempeople 페이지로 링크를 연결하였습니다. 지금까지 구현한 화면입니다. 여기까지 읽어주셔서 감사합니다. ### WHAN DEV TEAM [\\[출범식\\] WDT(WHAN DEV TEAM) 공식 활동 개시](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) [![](https://steemitimages.com/320x0/https://cdn.steemitimages.com/DQmbo4bis7WgjdVYdXR9VbzWdzh2aCXw2JFVKfruYNCNV4G/wdt.png)](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"Steem  지갑앱 만들기","slug":"개발-이야기/react-native/steem-지갑앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/steem-지갑앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Steem","slug":"steem","permalink":"https://anpigon.github.io/tags/steem/"}],"author":"anpigon"},{"title":"[React Native] 데이터 저장하기 : AsyncStorage와 SQLite, 그리고 Realm","slug":"/kr/@anpigon/reactnative-asyncstorage-sqlite-realm","date":"2019-04-24T15:05:33.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/kr/@anpigon/reactnative-asyncstorage-sqlite-realm/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/reactnative-asyncstorage-sqlite-realm/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.리액트 네이티브에서 데이터를 저장하고 사용할 수 있는 방법이 필요합니다. 그래서 AsyncStorage와 SQLite, 그리고 Realm에 대해서 살펴보았습니다. 그리고 각각의 API를 방법을 학습하면서 성능도 비교하였습니다. AsyncStorage와 database를 비교할 수는 없지만, 리액트 네이티브에서 AsyncStorage도 많이 사용되기 때문에 포함하였습니다.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.리액트 네이티브에서 데이터를 저장하고 사용할 수 있는 방법이 필요합니다. 그래서 AsyncStorage와 SQLite, 그리고 Realm에 대해서 살펴보았습니다. 그리고 각각의 API를 방법을 학습하면서 성능도 비교하였습니다. AsyncStorage와 database를 비교할 수는 없지만, 리액트 네이티브에서 AsyncStorage도 많이 사용되기 때문에 포함하였습니다. * * * 우선 Insert와 Select를 각각 테스트를 하기 위해서, 스팀잇 글 100건을 가져오는 함수를 구현합니다. 이 함수를 공통적으로 사용하여 데이터를 저장하도록 하겠습니다. 123456789// 스팀잇 글 100건 가져오기_getDiscussionsByBlog() ｛ return fetch('https://api.steemit.com', ｛ method: 'post', body: JSON.stringify(｛jsonrpc:\"2.0\",method:\"condenser_api.get_discussions_by_blog\",params:｛tag:\"anpigon\",limit:100｝,id:1｝) ｝) .then(r =&gt; r.json()) .then((｛result｝) =&gt; result)｝ * * * AsyncStorage AsyncStorage는 리액트 네이티브를 위한 key-value 형식의 스토리지입니다. Window.localStorage 와 매우 유사합니다. ***v0.59***부터는 react-native에 포함된 async-storage가 Deprecated 되었습니다. 그래서 @react-native-community/async-storage 설치하여 사용하는 것을 권장합니다. 자세한 내용은 공식 문서를 참고하세요. 설치하기 1$ npm install --save @react-native-community/async-storage 데이터 100건 저장하기 AsyncStorage에는 String만 저장가능합니다. 따라서 Object를 저장할 수 없습니다. 그래서 JSON Object를 String으로 변환하여 저장합니다. 1234567891011121314151617181920_insertAll = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ // 데이터 100건 가져오기 const data = await this._getDiscussionsByBlog() .then(r =&gt; r.map((｛ post_id, permlink, author, title, body ｝) =&gt; (｛post_id, permlink, author, title, body｝))); const startTime = Date.now(); // 시작 시간 await AsyncStorage.setItem(\"DATA\", JSON.stringify(data)); // AsyncStorage에 저장 const elapsedTime = Date.now() - startTime; // 경과 시간 this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 100건을 저장하는데 평균 1.8996초가 소요되었습니다. 10번 테스트하여 평균한 값입니다. 그리고 가장 높은/낮은값은 제외하였습니다. 전체 데이터 가져오기 AsyncStorage에서 전체 데이터를 가져옵니다. 그리고 다시 JSON parse하여 JSON Object로 변환하였습니다. 1234567891011_selectAll = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const startTime = Date.now(); // 시작 시간 const data = JSON.parse(await AsyncStorage.getItem(\"DATA\")); const elapsedTime = Date.now() - startTime; // 경과 시간 console.log(data); this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 전체를 조회는데 평균 0.0982가 소요되었습니다. 하나의 데이터 가져오기 AsyncStorage는 한 건을 조회하기 위해서도 모든 데이터를 가져와야 합니다. 그래서 전체 Select와 차이가 없었습니다. 성능을 높이기 위해서는 Array와 각 Item을 따로 저장해서 관리하면 될 것 같습니다. 1234567891011_selectOne = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const startTime = Date.now(); // 시작 시간 const data = JSON.parse(await AsyncStorage.getItem(\"DATA\")).filter(r =&gt; r.post_id === 67714463); const elapsedTime = Date.now() - startTime; // 경과 시간 console.log(data); this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터를 전체를 가져와서 한 건을 조회하는데 평균 0.0974가 소요되었습니다. * * * SQLite SQLite를 사용하기 위해서 react-native-sqlite-storage를 설치합니다. 자세한 내용은 공식 문서를 참고하세요. 설치하기 12$ npm install --save react-native-sqlite-storage$ react-native link SQLite 이슈나 SQL 사용 방법은 다음 사이트를 참고하세요. - https://github.com/xpbrew/cordova-sqlite-storage 데이터베이스 및 테이블 생성하기 componentDidMount() 함수에서는 데이터베이스를 오픈합니다. _createDatabase() 함수에서 테이블을 생성합니다. 그리고 테스트를 위해서 테이블이 생성되어 있으면 드롭(drop)하고 다시 생성하도록 하였습니다. 12345678910111213141516171819202122// 테이블 생성_createDatabase = async () =&gt; ｛ const result = await this.state.db.sqlBatch([ `DROP TABLE IF EXISTS TB_DISCUSSIONS`, `CREATE TABLE IF NOT EXISTS TB_DISCUSSIONS ( post_id INTEGER PRIMARY KEY, permlink TEXT, author TEXT, title TEXT, body TEXT )` ]);｝// 데이터베이스 오픈componentDidMount = async () =&gt; ｛ const db = await SQLite.openDatabase(｛ name: 'testDB' ｝); this.setState(｛ loading: false, db, ｝, () =&gt; this._createDatabase());｝ 데이터 100건 Insert 하기 SQLite.sqlBatch를 사용하여 데이터 100건을 한번에 insert 합니다. 123456789101112131415161718192021_insertAll = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const insertSQLs = await this._getDiscussionsByBlog() .then(r =&gt; r.map((｛ post_id, permlink, author, title, body ｝) =&gt; [ 'INSERT INTO TB_DISCUSSIONS VALUES (?1,?2,?3,?4,?5)', [post_id, permlink, author, title, body] ])); const startTime = Date.now(); // 시작 시간 const result = await this.state.db.sqlBatch(insertSQLs); const elapsedTime = Date.now() - startTime; // 경과 시간 this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 100건을 저장하는데 평균 3.9656초가 소요되었습니다. 데이터 전체 Select 하기 데이터를 모두 select 합니다. 1234567891011121314_selectAll() ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const startTime = Date.now(); // 시작 시간 this.state.db.executeSql('SELECT * FROM TB_DISCUSSIONS', [], (rs) =&gt; ｛ const elapsedTime = Date.now() - startTime; // 경과 시간 console.log(rs.rows) this.setState(｛ loading: false, elapsedTime ｝); ｝, (err) =&gt; console.log(err) ); ｝)｝ 데이터 전체를 조회하는데 평균 0.1086가 소요되었습니다. 데이터 한 건 Select 하기 데이터 한 건을 select 합니다. 123456789101112131415_selectOne() ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const startTime = Date.now(); // 시작 시간 this.state.db.executeSql('SELECT * FROM TB_DISCUSSIONS WHERE post_id = (?1)', [67714463], (rs) =&gt; ｛ const elapsedTime = Date.now() - startTime; // 경과 시간 console.log(rs.rows.item(0)); this.setState(｛ loading: false, elapsedTime ｝); ｝, (err) =&gt; console.log(err) ); ｝)｝ 데이터 전체를 조회하는데 평균 0.0072가 소요되었습니다. * * * Realm https://realm.io/ Realm 모바일 사용에 최적화된 내장 데이터베이스 라이브러리입니다. 한글 문서화가 굉장히 잘 되어 있는 오픈 소스입니다. 그리고 Realm 홈페이지에 가보면 속도가 엄청 빠르다고 자랑하고 있습니다. 다음 차트는 초당 쿼리수 입니다. 출처: realm.io 설치하기 12npm install --save realmreact-native link realm 스키마 생성하기 Realm 데이터 모델을 초기화하기 위해서는 스키마를 정의해야 합니다. SQLite에서 생성한 테이블 구조와 유사한 형태로 스키마를 정의하고 생성하였습니다. 스키마 모델과 관련하여 자세한 내용은 공식 문서를 참고하세요. 1234567891011121314151617181920componentWillMount() ｛ Realm.open(｛ schema: [｛ name: 'discussions', primaryKey: 'post_id', properties: ｛ post_id: 'int', permlink: 'string', author: 'string', title: 'string', body: 'string' ｝, ｝] ｝).then(realm =&gt; ｛ this.setState(｛ loading: false, realm ｝); ｝);｝ 데이터 100건 Insert 하기 데이터 100건을 insert 합니다. 1234567891011121314151617181920212223242526_insertAll = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ const dataArray = await this._getDiscussionsByBlog() .then(r =&gt; r.map((｛ post_id, permlink, author, title, body ｝) =&gt; (｛post_id, permlink, author, title, body｝))); const ｛ realm ｝ = this.state; const startTime = Date.now(); // 시작 시간 try ｛ realm.write(() =&gt; ｛ dataArray.forEach(data =&gt; realm.create('discussions', data)) ｝); ｝ catch (err) ｛ console.log(err); ｝ const elapsedTime = Date.now() - this.state.startTime; // 경과 시간 this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 100건을 저장하는데 평균 2.9978초가 소요되었습니다. 데이터 전체 Select 하기 데이터를 모두 select 합니다. 1234567891011121314151617_selectAll = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ let data; const startTime = Date.now(); // 시작 시간 try ｛ data = this.state.realm.objects('discussions'); ｝ catch (error) ｛ console.log(error); ｝ const elapsedTime = Date.now() - this.state.startTime; // 경과 시간 console.log(Array.from(data)); this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 전체를 조회하는데 평균 0.79가 소요되었습니다. 데이터 한 건 Select 하기 데이터 한 건을 select 합니다. 123456789101112131415161718_selectOne = () =&gt; ｛ this.setState(｛ loading: true ｝, async () =&gt; ｛ let data; const startTime = Date.now(); // 시작 시간 try ｛ data = this.state.realm.objects('discussions').filtered('post_id = 67714463'); ｝ catch (error) ｛ console.log(error); ｝ const elapsedTime = Date.now() - this.state.startTime; // 경과 시간 console.log(Array.from(data)); this.setState(｛ loading: false, elapsedTime ｝); ｝)｝ 데이터 한 건을 조회하는데 평균 0.0314가 소요되었습니다. 비교하기 쉽게 테스트 결과를 차트로 그려보았습니다. 세로축은 경과시간(ms)입니다. 100건의 데이터로 테스트한 결과라서 큰 차이는 없습니다. 데이터 저장의 경우 AsyncStorage가 가장 성능이 좋습니다. 그다음은 Realm입니다. 그리고 전체 데이터를 가져오는 경우에는 SQLite, AsyncStorage 순으로 성능이 좋습니다. 하지만 한 건의 데이터를 조회하는 경우에는 SQLite이 가장 성능이 좋습니다. * * * realm에서는 rawSQL을 사용할 수 없습니다. realm에서 제공하는 함수형 API로만 쿼리할 수 있습니다. 그래서 realm를 사용하려면 학습 비용이 발생하네요.ㅠㅠ 간단한 데이터를 저장하고 가져오는 기능을 구현하기 위해서는, AsyncStorage를 사용하는 것이 가장 좋은 선택일 것 같습니다. 그리고 Realm와 SQLite를 더 자세하게 비교한 블로그가 있어 링크를 공유합니다. https://medium.com/@maryangmin/realm-데이터베이스-제대로-알고-안드로이드에서-사용하기-bac02b8faef7 여기까지 읽어주셔서 감사합니다. ### WHAN DEV TEAM [\\[출범식\\] WDT(WHAN DEV TEAM) 공식 활동 개시](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) [![](https://steemitimages.com/320x0/https://cdn.steemitimages.com/DQmbo4bis7WgjdVYdXR9VbzWdzh2aCXw2JFVKfruYNCNV4G/wdt.png)](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"AsyncStorage","slug":"asyncstorage","permalink":"https://anpigon.github.io/tags/asyncstorage/"},{"name":"SQLite","slug":"sqlite","permalink":"https://anpigon.github.io/tags/sqlite/"},{"name":"Realm","slug":"realm","permalink":"https://anpigon.github.io/tags/realm/"}],"author":"anpigon"},{"title":"asbear님의 steeme 소스를 포크하여 수정","slug":"/kr/@anpigon/asbear-steeme","date":"2019-04-19T09:10:45.000Z","updated":"2019-11-11T13:41:49.833Z","comments":true,"path":"/kr/@anpigon/asbear-steeme/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/asbear-steeme/","excerpt":"Design by @imrahelk안녕하세요. 안피곤입니다.@wonsama님이 예전에 작성했던 글을 다시 찾아보려고, @asbear님의 steeme에 오랜만에 접속했습니다. 저는 작성했던 스팀잇 글을 전체적으로 파악하거나 검색 할 때, steeme의 Posting history 기능을 매우 유용하게 사용하고 있습니다. 그런데 조회도 안되고 오류가 발생하네요.","text":"Design by @imrahelk안녕하세요. 안피곤입니다.@wonsama님이 예전에 작성했던 글을 다시 찾아보려고, @asbear님의 steeme에 오랜만에 접속했습니다. 저는 작성했던 스팀잇 글을 전체적으로 파악하거나 검색 할 때, steeme의 Posting history 기능을 매우 유용하게 사용하고 있습니다. 그런데 조회도 안되고 오류가 발생하네요. 확인해보니 리스팀을 가져오는 함수에서 오류가 발생하고 있었습니다. 그래서 getRebloggedByAsync 함수를 오버라이딩(Overriding) 했습니다. 123456steem.api.getRebloggedByAsync = (author, permlink) =&gt; ｛ return fetch('https://api.steemit.com', ｛ method: 'post', body: JSON.stringify(｛jsonrpc:\"2.0\",method:\"follow_api.get_reblogged_by\",params:｛author,permlink｝,id:1｝) ｝).then(r =&gt; r.json()).then((｛result｝) =&gt; result)｝ 이것 외에도 API 규격이 조금 바뀐게 있네요. 결국 steeme를 수정하기위해 Github를 포크(Fork)했습니다. https://anpigon.github.io/steeme/ 예전에 활동 하셨던 능력자 분들이 스팀잇에 다시 돌아왔으면 좋겠습니다. 여기까지 읽어주셔서 감사합니다. ### WHAN DEV TEAM [\\[출범식\\] WDT(WHAN DEV TEAM) 공식 활동 개시](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) [![](https://steemitimages.com/320x0/https://cdn.steemitimages.com/DQmbo4bis7WgjdVYdXR9VbzWdzh2aCXw2JFVKfruYNCNV4G/wdt.png)](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team)","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] 인터렉티브한 애니메이션(Animations) 만들기","slug":"/kr/@anpigon/react-narive-animations","date":"2019-04-18T13:39:36.000Z","updated":"2019-11-11T13:41:49.815Z","comments":true,"path":"/kr/@anpigon/react-narive-animations/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-narive-animations/","excerpt":"Design by imrahelk 이쁜 대문 이미지를 만들어주신 **레이첼(imrahelk)**님 감사합니다. 아직 대문 이미지가 없으신 분은 &quot;☆축환갑☆ 환갑기념 대문장이 리턴즈&quot;에 이벤트 응모해보세요. * * * LottieLottie는 Airbnb에서 출시한 애니메이션 라이브러리입니다. 아래 화면과 같은 아름다운 애니메이션 효과를 만들 수 있습니다.","text":"Design by imrahelk 이쁜 대문 이미지를 만들어주신 **레이첼(imrahelk)**님 감사합니다. 아직 대문 이미지가 없으신 분은 &quot;☆축환갑☆ 환갑기념 대문장이 리턴즈&quot;에 이벤트 응모해보세요. * * * LottieLottie는 Airbnb에서 출시한 애니메이션 라이브러리입니다. 아래 화면과 같은 아름다운 애니메이션 효과를 만들 수 있습니다. 하지만 애니메이션을 만들기 위해서는 Adobe After Effect로 애니메이션을 만들고, Bodymovin로 다시 JSON 파일을 만들어야 합니다. 맥OS 사용자라면, lottie Bodymovin 플러그인을 brew로 설치할 수 있습니다. 12brew tap danielbayley/adobebrew cask install lottie 하지만 저는 설치하다가 오류가 발생하네요. ㅠㅠ 그리고 Adobe After Effect 로 애니메이션 만드는 방법도 잘 모르겠습니다. Lottie Files https://lottiefiles.com 그러나 Adobe After Effect를 할 줄 몰라도 괜찮습니다. LottieFiles 사이트에는 많은 디자이너들이 만든 애니메이션이 업로드되어 있습니다. 원하는 애니메이션을 검색하고 다운로드하세요. 그리고 모바일앱에 적용하면 됩니다. 저는 첫번째의 지갑에 동전 넣은 애니메이션이 마음에 드네요. ㅋ Lottie로 애니메이션을 구현하고 싶었습니다. 하지만 Adobe After Effect 다루는게 익숙하지가 않네요. * * * React Native Animated API React Native에서 제공하는 Animated API으로 애니메이션을 구현해보겠습니다. Animated API 사용 방법은 매우 간단합니다. React-Native API 문서를 참고하였습니다. 참고: https://facebook.github.io/react-native/docs/animations 아래와 같이 이미지가 뱅글뱅글 돌아가는 애니메이션을 만들어 봅니다. 이미지는 뉴비존님(newbijohn)께서 디자인해주셨습니다. 코드를 작성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, ｛ Component ｝ from 'react';import ｛ Animated, Easing, StyleSheet, View ｝ from 'react-native';export default class AuthLoadingScreen extends Component ｛ constructor(props) ｛ super(props); this.state = ｛ spinValue: new Animated.Value(0), ｝ ｝ componentDidMount() ｛ // 애니메이션을 설정한다. Animated.timing( this.state.spinValue, ｛ toValue: 1, duration: 3000, easing: Easing.linear, useNativeDriver: true, ｝ ).start() ｝ render() ｛ // 회전 애니매이션을 수행한다. const spin = this.state.spinValue.interpolate(｛ inputRange: [0, 360], outputRange: ['0deg', '360deg'], ｝); return ( &lt;View style=｛styles.container｝&gt; &lt;Animated.Image style=｛｛transform: [｛rotate: spin｝] ｝｝ source=｛require('../../assets/images/icon.png')｝ /&gt; &lt;/View&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: '#fff', ｝｝); 회전값 Value 는 state의 spinValue에 맵핑됩니다. 그리고 Animated.timing 의 easing 함수를 사용하여 시간에 따른 애니메이션 효과를 보여줍니다. 위 코드를 적용하면 아래와 같이 보여집니다. 여기까지 읽어주셔서 감사합니다. ### WHAN DEV TEAM [\\[출범식\\] WDT(WHAN DEV TEAM) 공식 활동 개시](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) [![](https://steemitimages.com/320x0/https://cdn.steemitimages.com/DQmbo4bis7WgjdVYdXR9VbzWdzh2aCXw2JFVKfruYNCNV4G/wdt.png)](https://steemit.com/steemengine/@newbijohn/wdt-whan-dev-team) Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"갤럭시S8 흑백화면으로 전자책 읽기","slug":"/kr/@anpigon/s8","date":"2019-04-16T00:59:33.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/kr/@anpigon/s8/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/s8/","excerpt":"안녕하세요. 안피곤입니다.스마트폰 화면을 흑백으로 전환하는 방법입니다. 화면을 흑백으로 보니 확실히 눈의 피로가 줄고 집중이 잘되는 것 같습니다.참고로 제 스마트폰은 갤럭시S8 입니다. 다른 최신 스마트폰도 비슷한 기능이 있을 거라고 생각합니다. 흑백화면으로 전환하기설정 &gt; 접근성 &gt; 시인성 향상 &gt; 색상조정 메뉴에서 흑백음영 옵션을 선택합니다. 그럼 바로 화면이 흑백으로 바뀝니다.","text":"안녕하세요. 안피곤입니다.스마트폰 화면을 흑백으로 전환하는 방법입니다. 화면을 흑백으로 보니 확실히 눈의 피로가 줄고 집중이 잘되는 것 같습니다.참고로 제 스마트폰은 갤럭시S8 입니다. 다른 최신 스마트폰도 비슷한 기능이 있을 거라고 생각합니다. 흑백화면으로 전환하기설정 &gt; 접근성 &gt; 시인성 향상 &gt; 색상조정 메뉴에서 흑백음영 옵션을 선택합니다. 그럼 바로 화면이 흑백으로 바뀝니다. 단축키 만들기 전자책 볼 때마다 설정 메뉴에서 옵션을 키는 것은 매우 불편합니다. 그래서 다음 방법으로 단축키를 설정합니다. 설정 &gt; 접근성 &gt; 고급 설정 &gt; 전원 버튼과 음량 올리기 버튼 메뉴에서 색상조정 옵션을 선택합니다. 이제 단축키(전원 버튼 + 음량 올리기 버튼)를 동시에 누르면, 흑백/컬러 화면을 쉽게 전환할 수 있습니다. 아래 비교 화면을 확인해보세요. 그리고 눈이 덜 피로하다고 생각되면 한번 사용해보세요. ㅎㅎ 흑백 적용 전 흑백 적용 후 단축키 외에 다른 방법은 삼성 루틴앱을 이용하는 방법입니다. 색상조정과 블루라이트 기능은 동시에 켜질 수 없습니다. 그래서 블루라이트가 켜지면 색상조정은 자동으로 꺼집니다. 아쉽게도 루틴앱에 색상조정 옵션은 없습니다. 하지만, 이런 습성(?)을 응용하면 루틴에서 자동화 할 수 있습니다. 기본 화면을 흑백화면으로 설정합니다. 그리고 전자책 외에 앱이 실행되면, 블루라이트 기능이 켜지게 합니다. 이렇게 하면 전자책 앱이 실행되면 흑백화면으로 보이고, 그 외에 앱이 실행되면 블루라이트(컬러) 화면으로 전환됩니다. 하지만 앱을 실행할때마다 화면 깜빡임이 너무 심합니다. 그래서 지금은 이 방법을 사용하지 않고 있어요. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] 인증(로그인) 상태에 따라 화면 분기하기","slug":"/kr/@anpigon/2x9aze-react-native","date":"2019-04-15T01:57:57.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/2x9aze-react-native/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/2x9aze-react-native/","excerpt":"React Navigation의 Authentication flows 문서를 참고하여 작성하였습니다. 참고: https://reactnavigation.org/docs/en/auth-flow.html Authentication flows일반적인 인증 Flow은 다음과 같습니다.","text":"React Navigation의 Authentication flows 문서를 참고하여 작성하였습니다. 참고: https://reactnavigation.org/docs/en/auth-flow.html Authentication flows일반적인 인증 Flow은 다음과 같습니다. 사용자가 앱을 실행합니다. 앱의 인증(로그인) 상태를 체크합니다. 유효한 인증 상태에 따라 인증(로그인) 화면 또는 기본 화면이 보입니다. 사용자가 로그아웃하면 인증 상태를 지우고 인증 화면으로 보냅니다. Navigators 설정하기 navigation/AppNavigator.js import React from 'react'; import ｛ createSwitchNavigator, createStackNavigator, createAppContainer ｝ from 'react-navigation'; import MainScreen from './screens/MainScreen'; import SignInScreen from './screens/SignInScreen'; import AuthLoadingScreen from './screens/AuthLoadingScreen'; const AppStack = createStackNavigator(｛ Main: MainScreen ｝); // 앱 메인 화면 const AuthStack = createStackNavigator(｛ SignIn: SignInScreen ｝); // 인증 화면 export default createAppContainer(createSwitchNavigator( ｛ AuthLoading: AuthLoadingScreen, App: AppStack, Auth: AuthStack, ｝, ｛ initialRouteName: 'AuthLoading', ｝ )); 화면은 기본 앱 화면MainScreen, 인증 화면SignInScreen, 로딩 화면AuthLoadingScreen으로 나누어집니다. 그리고 SwitchNavigator에 의해 관리됩니다. SwitchNavigator는 한번에 하나의 화면만 표시합니다. SwitchNavigator에 의해 화면이 전환되면 라우터와 상태 값이 초기화 됩니다. SwitchNavigator에 대한 자세한 내용은 API 문서를 참고하세요. 앱 실행 초기 화면으로 initialRouteName에 AuthLoading를 설정합니다. AuthLoading 화면에서는 인증 상태를 체크하여 화면을 전환할 것입니다. 인증 로딩 화면 만들기 screens/AuthLoadingScreen.js import React from 'react'; import ｛ AsyncStorage ｝ from 'react-native'; class AuthLoadingScreen extends React.Component ｛ constructor(props) ｛ super(props); this._bootstrapAsync(); ｝ // Fetch the token from storage then navigate to our appropriate place _bootstrapAsync = async () =&gt; ｛ const userToken = await AsyncStorage.getItem('userToken'); // This will switch to the App screen or Auth screen and this loading // screen will be unmounted and thrown away. this.props.navigation.navigate(userToken ? 'App' : 'Auth'); ｝; // Render any loading content that you like here render() ｛ return ( &lt;View&gt; &lt;ActivityIndicator /&gt; &lt;StatusBar barStyle=&quot;default&quot; /&gt; &lt;/View&gt; ); ｝ ｝ localStorage에 저장되어 있는 사용자 토큰(userToken)를 이용하여 인증 여부를 판단합니다. 인증 상태이면 App 화면, 아니면 Auth 화면으로 이동합니다. 참고로, jwt의 경우에는 토큰 만료일(expiry date)이 있기때문에, expired 여부도 체크해줘야합니다. 로그인(인증) 화면 screens/SignInScreen.js 123456789101112131415161718192021export default class SignInScreen extends Component ｛ // (...) // 스팀커넥트 성공 _onSteemconnectSuccess = (tokens) =&gt; ｛ this.setState(｛ modalVisible: false ｝, () =&gt; ｛ this._signInAsync(tokens.access_token); ｝); ｝ // 인증 정보 저장 _signInAsync = async (userToken) =&gt; ｛ await AsyncStorage.setItem('userToken', userToken); this.props.navigation.navigate('App'); ｝; render() ｛ // (...) ｝｝ 로그인 화면은 &quot;스팀커넥트(Steemconnect) 로그인 만들기&quot;에서 사용했던 코드를 가져왔습니다. 스팀 커넥트 로그인이 성공하면 _signInAsync() 함수에서 사용자 토큰을 localStorage에 저장합니다. 그리고 앱 기본 화면으로 이동합니다. 아래는 샘플로 구현한 화면입니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 장애인의 주홍글씨 BeMinor를 여러분의 가치로 만들어 주십시오. 1,000인의 마이너는 비마이너의 경제적 자립을 지원합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"전자책 정기 구독 서비스 비교","slug":"/kr/@anpigon/fsip1","date":"2019-04-14T01:59:39.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/kr/@anpigon/fsip1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/fsip1/","excerpt":"안녕하세요. 안피곤입니다.이제 교보문고도 전자책 무제한 구독 서비스를 시작했습니다. 교보문고는 e북 보유 권수가 가장 많기 때문에 정말 많은 기대가 됩니다. 어서 빨리 아마존 킨들 언리미티드처럼 백만권의 책을 무제한 대여 서비스 했으면 좋겠습니다. 관련기사: [한겨례] 교보문고도 ‘전자책 무제한 구독’ 서비스…출판업계선 우려","text":"안녕하세요. 안피곤입니다.이제 교보문고도 전자책 무제한 구독 서비스를 시작했습니다. 교보문고는 e북 보유 권수가 가장 많기 때문에 정말 많은 기대가 됩니다. 어서 빨리 아마존 킨들 언리미티드처럼 백만권의 책을 무제한 대여 서비스 했으면 좋겠습니다. 관련기사: [한겨례] 교보문고도 ‘전자책 무제한 구독’ 서비스…출판업계선 우려 그리고 문화체육관광부는 ‘2017 국민독서실태조사’에서 한국 성인의 한해 평균 종이책 독서량이 8.3권, 도서 구매량은 4.1권이라고 발표했습니다. 그리고 연간 종이책 독서량이 2015년에 비해서 2017년에는 5.4％ 감소했다고 발표했습니다. 저는 책을 많이 안 읽는 편이라고 생각합니다. 쉽진 않겠지만, 지금부터라도 일주일에 한 권씩은 읽어야겠습니다. 전자책 무제한 서비스를 이용하면 원하는 책을 얼마든지 읽을 수 있으니, 아마도 가능할 것으로 생각합니다. 그래서 전자책 구독 서비스를 비교하여 가격, 보유 권수 등을 정리하였습니다. * * * 교보문고 sam 일반 무제한 구독 서비스는 아니지만, 일단 포함하였습니다. http://m.kyobobook.co.kr/digital/sam/samMain.ink?listCateGubun=24 구분 내용 가격 월 7,000원 ~ 32,000원 / sam2 첫달 1,000원 이용권수 월 2권 ~ 12권 보유권수 약 12만 권 특이점 다양한 장르의 보유 권수가 가장 많다. 월 비용이 가장 비싸다. 교보문고 sam 무제한 무제한 서비스를 가장 늦게 시작해서 그런지, 실속 없이 보유 권수만 늘렸다는 느낌이 강합니다. 하지만 기존의 sam 서비스로 많은 전자책을 보유하고 있기 때문에 앞으로 가장 기대되는 서비스입니다. http://m.kyobobook.co.kr/digital/sam/samMain.ink?listCateGubun=25 구분 내용 가격 월 9,900원 / 첫달 무료(이후 3개월간 6,500원) 이용권수 무제한 보유권수 약 3만7천 권 특이점 재미 위주의 장르소설 분야의 책이 많다. 내가 읽고 싶은 책이 매우 적다. 예스24 북클럽 예스24는 특이하게 컴퓨터/IT 분야의 책이 가장 많았습니다. http://www.yes24.com/campaign/06_eBook/bookclub/intro.aspx 구분 내용 가격 월 5,500원/7,700원/첫달 무료 이용권수 무제한 보유권수 약 5,800 권 특이점 컴퓨터/IT분야 책이 많다. 소설/인문 분야의 책이 적다. 밀러의 서재 밀리의 서재는 모바일앱보다 PC에서 결제하는게 더 저렴합니다. https://www.millie.co.kr/viewfinder/viewfinder.html 구분 내용 가격 월 9,900원 / 11,900원(Android) / 12,000원(iOS) / 첫달 무료 이용권수 무제한 보유권수 약 3만 권 특이사항 음성으로 읽어주는 책을 요약 서비스. ‘리딩북’ 김난도 작가의 트렌드 코리아 2012 ~ 2019를 보유. 유시민 작가의 대부분의 책을 보유. 베르나르 베르베르, 히가시노 게이고 최신 소설 보유. 아서 코난 도일 작가의 셜록홈즈 전권 보유. 김용 작가의 무협지(사조영웅전, 신조협려, 의천도룡기 등) 보유. 리디셀렉트(리디북스) https://select.ridibooks.com/books 구분 내용 가격 월 6,500원 / 첫달 무료 이용권수 무제한 보유권수 약 3,200 권 특이사항 책 요약 만화 서비스. ‘책 끝을 접다’ 베스트셀러 비중이 높다.(리디북스 기준, 상위 5％ 도서로 리디셀렉트를 구성) 최신 베스트셀러를 선독점 서비스하는 경우가 많다.(이국종의 골든아워, 미셸 오바마의 비커밍, 밥 우드워드의 공포 독점 출간이 대표적) ___ 모두 첫달 무료 서비스를 하고 있기 때문에, 무료 기간 동안에 체험하면서 선택할 수 있을 것 같습니다. 저는 소설책을 좋아해서 소설책을 가장 많이 보유하고 있는 밀리의 서재를 선택했습니다. 그리고 알라딘이 전자책 무제한 구독 시장에 진출하지 않아서 조금 아쉽네요. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 장애인의 주홍글씨 BeMinor를 여러분의 가치로 만들어 주십시오. 1,000인의 마이너는 비마이너의 경제적 자립을 지원합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] Steem 모바일 지갑앱 만들기 #1","slug":"/kr/@anpigon/react-native-steem-1","date":"2019-04-13T14:16:36.000Z","updated":"2019-11-11T13:41:49.816Z","comments":true,"path":"/kr/@anpigon/react-native-steem-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-steem-1/","excerpt":"옛날에 이런 책이 있었습니다. 스팀잇에는 이 책을 기억하는 분들이 많을 것 같습니다. 저는 리액트를 공부한지 일주일이 훨씬 넘었는데 잘 할 수 있을까요? ㅋ 안녕하세요. 안피곤입니다.**WDT(WHAN DEV TEAM)**에 합류해서 올리는 첫 글이네요. WDT가 뭔지 잘 모르는 분들은, 뉴비존님이 작성한 “[출범식] WDT(WHAN DEV TEAM) 공식 활동 개시” 글을 읽어보세요.","text":"옛날에 이런 책이 있었습니다. 스팀잇에는 이 책을 기억하는 분들이 많을 것 같습니다. 저는 리액트를 공부한지 일주일이 훨씬 넘었는데 잘 할 수 있을까요? ㅋ 안녕하세요. 안피곤입니다.**WDT(WHAN DEV TEAM)**에 합류해서 올리는 첫 글이네요. WDT가 뭔지 잘 모르는 분들은, 뉴비존님이 작성한 “[출범식] WDT(WHAN DEV TEAM) 공식 활동 개시” 글을 읽어보세요. 이제 저는 WDT 팀원의 조언과 피드백을 거의 실시간으로 받을 수 있기 때문에, 코딩 실력 향상에 정말 많은 도움이 될 것 같습니다. 그리고 WDT 도움을 받아 스팀(Steem) 모바일 지갑앱 개발을 하려고 합니다. 저는 리액트 네이티브(React Native)를 공부하고 있었으므로, 모바일앱을 리액트 네이티브로 개발할 것 같습니다. 그리고 개발 과정을 스팀잇에 기록하려고 합니다. 스팀잇분들과 의견을 나누면서 개발하고 싶습니다. 많은 관심과 조언 부탁드립니다. * * * Expo 사용하기 저는 Expo를 사용해서 리액트 네이티브를 개발하고 있습니다. Expo 장점은 “리액트 네이티브로 무비앱을 만들어서 스토어에 올렸어요!” 글에서 한번 설명했습니다. 추가로 좋은점을 하나 더 알려드리면 앱 서명 키를 내가 관리할 필요가 없습니다. Expo에서 관리하도록 선택할 수 있습니다. 저는 앱 서명 키를 잃어버린 적이 많아서 큰 장점이라고 생각합니다. 그리고 Expo는 이렇게 개인 페이지도 제공 해줍니다. 개인 페이지에는 공개한 앱이 노출됩니다. 아래 보이는 앱들은 제가 동영상 강좌를 학습하면서 만든 샘플앱입니다. 그런데 어느 천사분께서 하트를 하나 눌러 주고 가셨네요. https://expo.io/@markan Expo CLI 설치하기 expo를 사용하기 위해서는 expo-cli가 설치되어 있어야 합니다. 1npm install expo-cli --global .gitignore 파일 생성하기 저는 .gitignore 파일을 생성할 때 아래 사이트를 사용합니다. https://www.gitignore.io/ 키워드를 입력하고 생성 버튼을 눌러서 파일을 다운받으면 됩니다. 아니면 아래 명령어로 다운로드하면 간편합니다. 1curl -o .gitignore https://www.gitignore.io/api/node,reactnative * * * 프로젝트 생성하기 expo 명령어로 프로젝트를 생성합니다. 1expo init whan-wallet 프로젝트 실행하기 생성한 프로젝트를 실행하면, 기본적으로 포함되어 있는 코드가 빌드되어 앱이 실행됩니다. 그리고 터미널 창에 QR 코드가 출력됩니다. QR 코드를 촬영하면 스마트폰으로 앱을 확인할 수 있습니다. 12cd whan-walletnpm start 스마트폰으로 앱을 확인하기 위해서는 expo client 앱이 설치되어 있어야 합니다. expo client 앱은 구글 스토어와 애플 스토어에서 설치 가능합니다. https://expo.io/tools#client expo client 앱에서 확인하기 위해서는 USB 연결 또는 PC와 같은 네트워크의 Wi-Fi에 연결되어 있어야합니다. expo client 앱에서 QR코드를 촬영하면, 아래 화면과 같이 샘플앱이 보입니다. 그리고 폰을 좌우로 흔들면 아래 화면처럼 개발 메뉴가 짠~!하고 나타납니다. 저는Remote Debugging와 Hot Reloading 기능을 자주 사용합니다. Fin. 저는 많은 분이 코딩에 흥미를 느꼈으면 좋겠습니다. 그리고 #kr-dev에 더 많은 글이 올라왔으면 좋겠습니다. #kr-dev에 올라오는 대부분의 개발글에는 보팅하고 있습니다. 참고로 제 스팀파워가 작아서 보상금액이 많지는 않습니다. 대신 정성을 다해서 보팅하고 있어요. ㅋ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 장애인의 주홍글씨 BeMinor를 여러분의 가치로 만들어 주십시오. 1,000인의 마이너는 비마이너의 경제적 자립을 지원합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"Steem  지갑앱 만들기","slug":"개발-이야기/react-native/steem-지갑앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/steem-지갑앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Steem","slug":"steem","permalink":"https://anpigon.github.io/tags/steem/"}],"author":"anpigon"},{"title":"[React Native] 카카오 책 검색 API 사용하기","slug":"/kr/@anpigon/react-native-api","date":"2019-04-09T17:48:18.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/react-native-api/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-api/","excerpt":"안녕하세요. 안피곤입니다.이전 글 &quot;국내 도서 검색 OPEN API 비교&quot;에서 책 검색 OPEN API를 조사했습니다. 그러나 제가 원하는 데이터를 모두 제공하는 API는 찾지 못했습니다. 그나마 Daum 책 검색 API가 가장 괜찮은 것 같습니다. 아니 이제는 Kakao 책 검색 API라고 해야하죠.","text":"안녕하세요. 안피곤입니다.이전 글 &quot;국내 도서 검색 OPEN API 비교&quot;에서 책 검색 OPEN API를 조사했습니다. 그러나 제가 원하는 데이터를 모두 제공하는 API는 찾지 못했습니다. 그나마 Daum 책 검색 API가 가장 괜찮은 것 같습니다. 아니 이제는 Kakao 책 검색 API라고 해야하죠. 저는 당연히 온라인 서점에서 책 검색 OPEN API 서비스를 제공할 것이라고 생각했습니다. 그런데 교보문서, 영풍문고에서 OPEN API 서비스는 찾아 볼 수가 없네요. 알라딘과 인터파크에서 OPEN API 서비스를 하고 있지만, 지금은 관리하지 않는 것 같아요. 국내 온라인 서점에서 운영하는 OPEN API 서비스 관리가 안 되는 점이 매우 안타깝습니다. 사실 국가기관인 한국정보화진흥원에서 운영하는 https://www.data.go.kr 운영도 부실하긴 마찬가지입니다. 국내 OPEN API 외에 Google Books APIs와 ISBNdb 사이트의 API 문서도 살펴보긴 했었습니다. 하지만 한글을 지원하면서 The Movie DB 만큼의 데이터를 제공하는 책 검색 OPEN API는 없는 것 같습니다. ㅠㅠ 다음은 Kakao에서 제공하는 책 검색 API를 이용하여 구현한 코드입니다. 전체 코드를 공개하기에는 코드량이 너무 많아서 핵심 코드만 공개하였습니다. * * * &nbsp; 책 검색 OPEN API 조회하기 카카오에서 제공하는 책 검색 API를 이용하여 아래와 같이 구현하였습니다. 그리고 네트워크 통신 라이브러리는 axios를 사용했습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import axios from 'axios';import ｛ parseDateString ｝ from '../utils/formatter';import ｛ DAUM_API_URL, DAUM_API_KEY ｝ from '../config.js';const client = axios.create(｛ baseURL: `$｛DAUM_API_URL｝`, method: 'post', headers: ｛ 'Content-Type': 'application/json; charset=utf-8', 'Host': 'dapi.kakao.com', 'Authorization': `KakaoAK $｛DAUM_API_KEY｝`, ｝, timeout: 10000 // 타임아웃 10초｝);/** * * @param ｛*｝ query 검색을 원하는 질의어 * @param ｛*｝ size 한 페이지에 보여질 문서의 개수(1-50 사이) * @param ｛*｝ page 결과 페이지 번호(1-100 사이) * @param ｛*｝ sort 결과 문서 정렬 방식(accuracy:정확도순, latest:최신순) * @param ｛*｝ target 검색 필드 제한(title:제목, isbn:ISBN, publisher:출판사, person:인명) */export const searchBook = (query = '', page = '1', size = 10, sort = 'sim', target = '') =&gt; ｛ const params = ｛ query, size, page, sort, target ｝; return client.get('/v3/search/book', ｛ params ｝) .then((｛ status, statusText, data ｝) =&gt; ｛ if (status === 200) ｛ const ｛ meta: ｛ is_end, // 현재 페이지가 마지막 페이지인지 여부(false이면 다음 페이지를 요청할 수 있음) pageable_count, // 검색 결과로 제공 가능한 문서수 total_count, // 전체 검색된 문서수 ｝, documents ｝ = data; const result = ｛ isEnd: is_end, pageableCount: pageable_count, totalCount: total_count, items: (documents &amp;&amp; documents.length) ? documents .filter((｛ thumbnail ｝) =&gt; !!thumbnail) // 표지 이미지 없는 책은 제외 .map((｛ title, // 도서 제목 contents, // 도서 소개 url, // 도서 상세 URL isbn, // 국제 표준 도서번호(ISBN10 ISBN13) datetime, // 도서 출판날짜(ISO 8601) authors, // 도서 저자 리스트 publisher, // 도서 출판사 translators, // 도서 번역자 리스트 price, // 도서 정가 sale_price, // 도서 판매가 thumbnail, // 도서 표지 썸네일 URL(120x174) status // 도서 판매 상태 정보(정상, 품절, 절판) ｝, index) =&gt; ｛ return ｛ id: String(((page - 1) * size) + index), title: title, contents, url, isbn: isbn ? isbn.split(' ') : [], authors: typeof(authors) === 'string' ? [authors] : authors, translators: typeof(translators) === 'string' ? [translators] : translators, pubdate: parseDateString(datetime), publisher, thumbnail, ｝ ｝) : [] ｝ return result; ｝ else ｛ throw new Error(`$｛status｝:$｛statusText｝`); ｝ ｝)｝ 결과 화면 구현된 모바일앱 화면입니다. 유시민 작가님의 책을 검색해보겠습니다. 목록은 FlatList를 사용했는데 스크롤 항목이 많아지니깐, VirtualizedList Scroll performance 문제가 조금 있네요. 좀 더 공부하면서 해결해봐야겠습니다. 참고: https://github.com/facebook/react-native/issues/13413 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"국내 도서 검색 OPEN API","slug":"국내-도서-검색-open-api","permalink":"https://anpigon.github.io/tags/국내-도서-검색-open-api/"}],"author":"anpigon"},{"title":"국내 도서 검색 OPEN API 비교","slug":"/kr/@anpigon/open-api","date":"2019-04-09T03:30:18.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/kr/@anpigon/open-api/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/open-api/","excerpt":"국내 도서 검색 OPEN API를 제공하는 서비스를 찾아서 정리해 보았습니다. 제가 원하는 데이터를 모두 제공하는 API는 없었습니다. ㅠㅠ 저는 아마도 다음이나 KOLIS-NET API를 사용할 것 같습니다.* * * 네이버 책 검색 OPEN APIhttps://developers.naver.com/docs/search/book/","text":"국내 도서 검색 OPEN API를 제공하는 서비스를 찾아서 정리해 보았습니다. 제가 원하는 데이터를 모두 제공하는 API는 없었습니다. ㅠㅠ 저는 아마도 다음이나 KOLIS-NET API를 사용할 것 같습니다.* * * 네이버 책 검색 OPEN APIhttps://developers.naver.com/docs/search/book/ 구분 내용 호출 건수 하루 2만5천 건 검색 조건 전체, 제목, 저자, 목차, ISBN, 출판사, 출간시작일, 출간종료일, 카테고리 정렬 순서 유사도순, 출간일순, 판매량순 출력 형식 XLM, JSON 출력 데이터 제목, 도서 상세 URL, 표지 이미지, 저자, 가격, 출판사, ISBN, 요약, 출간일 네이버는 너무 작은 크기의 도서 표지 이미지(82x116)를 제공하고 있습니다. 이 이유 하나 때문에 사용하기가 꺼려지네요. 다음 책 검색 OPEN API https://developers.kakao.com/docs/restapi/search#％EC％B1％85-％EA％B2％80％EC％83％89 구분 내용 호출 건수 ? 검색 조건 전체, 제목, ISBN, 출판사, 저자 정렬 순서 정확도순, 최신순 출력 형식 JSON 출력 데이터 제목, 소개, 도서 상세 URL, ISBN, 출간일, 출판사, 저자, 역자, 가격, 표지 이미지(120x174), 판매 상태 국가자료종합목록(KOLIS-NET) https://www.nl.go.kr/kolisnet/contents/openAPI.do 구분 내용 호출 건수 ? 검색 조건 전체, 제목, 저자, 출판사 (AND/OR 조건으로 검색어 5개 까지 연결 가능) 검색 조건2 표준 부호(ISBN, ISSN, CODEN, STRN, RNSTRN, CBN, CAN) 검색 조건3 분류 기호(KDC, KDCP, DDC, CEC, CWC, COC) 검색 조건4 발행년도 시작, 발행년도 끝 정렬 조건 제목, 저자, 발행년도 (DESC/ASC 가능) 출력 형식 XLM 출력 데이터 제목, 저자, 출판사, 발행년도, 자료유형, 표지이미지 다양한 검색 조건으로 조회할 수 있어서 매력적입니다. 하지만, JSON 출력 형식을 제공하지 않아서 불편합니다. 그리고 국립중앙도서관에서 보유하고 있는 서적만 검색 가능합니다. 인터파크 OPEN API http://book.interpark.com/blog/api/openApiMain.rdo http://book.interpark.com/bookPark/html/bookpinion/api_booksearch.html http://book.interpark.com/bookPark/html/bookpinion/openup_3.html 구분 내용 호출 건수 하루 1만 건 검색 조건 제목, 저자, 출판사, ISBN, 전체(제목, 저자, 출판사, ISBN) 정렬 순서 정확도, 출간일, 제목, 판매량, 고객평점, 리뷰갯수, 가격(오름차순/내림차순) 출력 형식 XLM, JSON 출력 데이터 제목, 도서 상세 URL, 표지이미지, ISBN, 저자, 역자, 설명, 가격, 카테고리, 출판사, 출간일 인터파크 OPEN API 서비스는 더는 관리하고 않고 있는 것 같습니다. API 문서 페이지 링크 찾기도 어렵습니다. 하지만 베스트셀러, 추천도서, 신간도서 API를 제공하고 있어서 조금 매력적입니다. 하지만 잘 동작할지는 모르겠습니다. 알라딘 OPEN API http://blog.aladin.co.kr/openapi/5353304 구분 내용 호출 건수 하루 5천 건 검색 조건 제목, 저자, 출판사, 전체(제목+저자) 정렬 조건 정확도, 출간일, 제목, 판매량, 고객평점, 마이리뷰갯수 출력 형식 XLM, JSON 출력 데이터 제목, 도서 상세 URL, ISBN, 상품설명, 도서출간일, 상품가격, 표지이미지, 카테고리, 출판사, 고객평점 하루에 쿼리를 5천 건만 할 수 있습니다. 쿼리 건수가 매우 적네요. 그리고 ISBN 검색을 제공하지 않습니다. Sponsored ( Powered by dclick ) 띠예(유튜버) 근황(2019년 4월 초 기준…) 이라고 붙은 제목에 '?'가 떠오르시면 클릭 권장 ㅋ","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[],"author":"anpigon"},{"title":"구글 스프레드시트 스팀잇 RSS 만들기","slug":"/kr/@anpigon/rss","date":"2019-04-05T08:30:27.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/kr/@anpigon/rss/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/rss/","excerpt":"안녕하세요. 안피곤입니다.어제 BNW 토큰의 창시자 @naha님에게 보여줄 구글 스프레드시트를 만들었어요. 스팀잇 포스팅 URL을 입력하면, 저자, 보팅, 댓글, 리스팀 여부를 가져와서 보여줍니다. [![](https://cdn.steemitimages.com/600x0/https://files.steempeak.com/file/steempeak/anpigon/48HtRVzu-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-04-0520E1848BE185A9E18492E185AE204.38.02.png) ](https://steemit.com/bnw/@anpigon/re-naha-re-anpigon-re-naha-re-anpigon-re-naha-re-anpigon-re-naha-7fsasx-bnw-20190404t144335053z)","text":"안녕하세요. 안피곤입니다.어제 BNW 토큰의 창시자 @naha님에게 보여줄 구글 스프레드시트를 만들었어요. 스팀잇 포스팅 URL을 입력하면, 저자, 보팅, 댓글, 리스팀 여부를 가져와서 보여줍니다. [![](https://cdn.steemitimages.com/600x0/https://files.steempeak.com/file/steempeak/anpigon/48HtRVzu-E18489E185B3E1848FE185B3E18485E185B5E186ABE18489E185A3E186BA202019-04-0520E1848BE185A9E18492E185AE204.38.02.png) ](https://steemit.com/bnw/@anpigon/re-naha-re-anpigon-re-naha-re-anpigon-re-naha-re-anpigon-re-naha-7fsasx-bnw-20190404t144335053z) 그리고 구글 스프레드시트 API 문서를 살펴보다가, 스팀잇 RSS 피드도 구현 가능할 것 같아서 한번 만들어 보았습니다. 만족할 만한 수준은 아닙니다. 이런 것도 가능하구나 하고 그냥 재미로 읽어보세요. ㅎㅎ * * * 스팀잇에서 글 가져오는 스크립트 입력하기 구글 스프레드시트를 열고 도구 &gt; 스크립트 편집기를 선택합니다. 다음과 같이 스크립트를 입력합니다. 아래 코드를 복사&amp;붙여넣기 하세요. 12345678910111213141516171819202122232425262728293031323334353637383940// 스팀잇 글 가져오기function getPosts(username) ｛ var params = [｛ tag: username, // 사용자 이름 limit: 100 // 100건 ｝]; var data = ｛ jsonrpc: \"2.0\", method: 'condenser_api.get_discussions_by_blog', params: params, id: 1 ｝; var options = ｛ 'method' : 'post', 'contentType': 'application/json', 'payload' : JSON.stringify(data) ｝; var response = UrlFetchApp.fetch('https://api.steemit.com', options); if (response.getResponseCode() == 200) ｛ var data = JSON.parse(response.getContentText()) .result .filter(function(post) ｛ return post.author === username; // 리스팀 글 제외(저자 글만) ｝) .map(function(post) ｛ return [ post.title, // 제목 post.body // 본문 ] ｝); if(data.length) ｛ var sheet = SpreadsheetApp.getActiveSheet(); sheet.getRange(1, 1, data.length, 2).setValues(data); // 시트에 입력 ｝ ｝｝function main() ｛ getPosts(\"anpigon\") // 실행｝ 그리고 코드를 저장합니다. 코드를 실행하면 다음과 같이 인증 권한을 요구합니다. 확인을 눌러서 계속 진행합니다. 스케쥴러 설정하기 실행 바로 아래에 있는 시계 아이콘을 선택합니다. 트리거를 추가합니다. 실행할 함수, 이벤트 소스, 트리거 기반 시간 유형을 선택합니다. 공유하기 다음과 같은 작업을 해야지 외부에서 API 조회가 가능합니다. 메뉴에서 파일 &gt; 웹에 게시를 선택합니다. 모든 사용자가 볼 수 있게 게시합니다. RSS 피드 만들기 이제 마지막입니다. 현재 보고 있는 구글 스프레드 시트의 주소의 형태는 다음과 같습니다. 1https://docs.google.com/spreadsheets/d/1Ky1tJvioEAzqD4suXqOD52XUiRzXshyU7sPo8gN80cY/edit#gid=0 주소를 다음과 같은 형태로 변경하여 브라우저에서 확인합니다. 1https://spreadsheets.google.com/feeds/worksheets/1Ky1tJvioEAzqD4suXqOD52XUiRzXshyU7sPo8gN80cY/public/basic XML Viewer 서비스를 이용하면 XML 데이터 보기가 편할 거에요. XLM 에서 아래와 같은 형태의 데이터를 찾으세요. 여기서 href 속성에 있는 값이 우리가 찾는 RSS Feed URL 입니다. 1234567&lt;feed&gt; &lt;entry&gt; &lt;...&gt; &lt;link rel=\"http://schemas.google.com/spreadsheets/2006#listfeed\" type=\"application/atom+xml\" href=\"https://spreadsheets.google.com/feeds/list/1Ky1tJvioEAzqD4suXqOD52XUiRzXshyU7sPo8gN80cY/od6/public/basic\" /&gt; &lt;...&gt; &lt;/entry&gt;&lt;/feed&gt; 다음과 같이 제 스팀잇 RSS URL이 생성되었습니다. 1https://spreadsheets.google.com/feeds/list/1Ky1tJvioEAzqD4suXqOD52XUiRzXshyU7sPo8gN80cY/od6/public/basic 브라우저에서 확인하면 다음과 같이 보입니다. RSS 프로그램에서 확인하면 이렇게 보이네요. *** 이걸 응용하면 특정 태그(kr, kr-dev)나 다른 사용자의 블로그도 RSS로 만들 수 있을 것 같습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[],"author":"anpigon"},{"title":"⟪초의식 독서법⟫ 김병완","slug":"책 이야기/2019-04-02---6gevae","date":"2019-04-02T01:56:57.000Z","updated":"2019-11-11T13:41:49.862Z","comments":true,"path":"책 이야기/2019-04-02---6gevae/","link":"","permalink":"https://anpigon.github.io/책 이야기/2019-04-02---6gevae/","excerpt":"독서 고수가 되고 싶어서, 김병완의 초의식 독서법을 읽고 있습니다. 그리고 내용 중에 나오는 초서 독서법이 궁금하여 인터넷을 찾아보았습니다. 다산 정약용의 초서 독서법 “수천 권의 책을 읽어도 그 뜻을 정확히 모르면 읽지 않은 것과 같으니라. 읽다가 모르는 문장이 나오면 관련된 다른 책들을 뒤적여 반드시 뜻을 알고 넘어가야 하느니라. 또한 그 뜻을 알게 되면 여러 차례 반복하여 읽어 너의 머릿속에서 떠나지 않게 하거라.” - 아들 정학유에게 보낸 편지 중에서","text":"독서 고수가 되고 싶어서, 김병완의 초의식 독서법을 읽고 있습니다. 그리고 내용 중에 나오는 초서 독서법이 궁금하여 인터넷을 찾아보았습니다. 다산 정약용의 초서 독서법 “수천 권의 책을 읽어도 그 뜻을 정확히 모르면 읽지 않은 것과 같으니라. 읽다가 모르는 문장이 나오면 관련된 다른 책들을 뒤적여 반드시 뜻을 알고 넘어가야 하느니라. 또한 그 뜻을 알게 되면 여러 차례 반복하여 읽어 너의 머릿속에서 떠나지 않게 하거라.” - 아들 정학유에게 보낸 편지 중에서 초서란? 책을 읽다가 정말 중요한 구절을 똑같이 필사(베껴 쓰는 것)을 말합니다. 독서할 때는 어떻게 해야 하느냐? 한번 쭉 읽고 버려둔다면 나중에 다시 필요한 부분을 찾을 때 곤란하지 않겠느냐? 그러니 모름지기 책을 읽을 때는 중요한 일이 있거든 가려서 뽑아서 따로 정리해 두는 습관을 길러야 할 것이다. 이것을 초서(抄書)라고 하는 것이다. 허나 책에서 나한테 필요한 내용을 뽑아내는 일이 처음부터 쉬운 일은 아닐 것이다. 먼저 마음속에 무엇이 중요하고 무엇이 필요한 내용인지 일정한 기준이 있어야 하지 않겠느냐? 곧 나의 학문에 뚜렷한 주관이 있어야 하는 것 이란다. 그래야 마음속의 기준에 따라 책에서 얻을 것과 버릴 것을 정하는 데 곤란을 겪지 않을 것이야. 이런 학문의 중요한 방법에 대해서는 앞서 누누이 말했는데 너희가 필시 잊어버린 게로구나. 책 한 권을 얻었다면 네 학문에 보탬이 되는 것만을 뽑아서 모아 둘 것이며 그렇지 않는 것은 하나 같이 눈에 두지 말아야 한 단다. 이렇게 하면 100권의 책도 열흘간의 공부에 지나지 않을 뿐이다. - 아들 정학유에게 보낸 편지 중에서 초서 독서법 다산 정약용의 초서 독서법은 5가지로 정리할 수 있습니다. 입지(立志) : 먼저 독서를 하기 전에 자신의 주관을 뚜렷하게 가져야 한다. 해독(解讀) : 독서를 하다가 모르는 내용이 나오면, 관련 자료를 찾아보고 완벽하게 이해해야 한다. 판단(判斷) : 무엇이 중요하고 안 중요한 것인지를 판단한다. 초서(抄書) : 중요한 내용이나 문장을 자신의 독서 노트에 옮겨 적는다. 입지(立志) : 책을 통해서 얻은 새로운 견해를 토대로 자신의 뜻을 새롭게 정리한다. 초의식 독서법을 간단하게 정리하면, 의식적으로 독서해라. 그리고 중요한 문장을 노트에 베껴써라. 그 문장에 내 의견이나 생각을 메모해라.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서법","slug":"독서법","permalink":"https://anpigon.github.io/tags/독서법/"},{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"김병완","slug":"김병완","permalink":"https://anpigon.github.io/tags/김병완/"}],"author":"steemory"},{"title":"[팁] 모바일 크롬 브라우저 성능 및 네트워크 데이터 절약 방법","slug":"/kr/@steemory/2d5ory","date":"2019-03-29T06:49:00.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/kr/@steemory/2d5ory/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/2d5ory/","excerpt":"출처: https://www.clien.net/service/board/lecture/13298653크롬 브라우저 주소창에 chrome://flags 를 입력합니다.#enable-lazy-image-loading를 검색합니다. 그리고 그 항목을 활성화(Enabled) 합니다.","text":"출처: https://www.clien.net/service/board/lecture/13298653크롬 브라우저 주소창에 chrome://flags 를 입력합니다.#enable-lazy-image-loading를 검색합니다. 그리고 그 항목을 활성화(Enabled) 합니다. 이렇게 설정하면 화면에 보이지 않는 이미지를 미리 로드하지 않는다고 합니다. 페이지 로딩 속도가 빨라지고 네트워크 데이터를 절약할 수 있습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[React Native] FlatList으로 Infinite Scroll와 Pull Down Refresh 구현하기","slug":"/kr/@anpigon/react-native-flatlist-infinite-scroll-pull-down-refresh","date":"2019-03-29T06:11:12.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/react-native-flatlist-infinite-scroll-pull-down-refresh/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-flatlist-infinite-scroll-pull-down-refresh/","excerpt":"https://youtu.be/Jc2MX0Ew3PE microcode님의 리액트 네이티브 강의입니다. 이분은 말 한마디 없이 코딩만 하네요.React Native에서 제공하는 FlatList를 사용하여 무한 스크롤(Infinite Scroll)과 Pull Down Refresh 기능을 구현합니다. FlatList에 대한 자세한 내용은 공식 문서에서 확인하세요.","text":"https://youtu.be/Jc2MX0Ew3PE microcode님의 리액트 네이티브 강의입니다. 이분은 말 한마디 없이 코딩만 하네요.React Native에서 제공하는 FlatList를 사용하여 무한 스크롤(Infinite Scroll)과 Pull Down Refresh 기능을 구현합니다. FlatList에 대한 자세한 내용은 공식 문서에서 확인하세요. 이번 예제를 위해서 snack를 이용하였습니다. 아래 화면처럼 브라우저에서 코딩하고 결과를 바로 확인 할 수 있습니다. 간단한 코딩 연습을 하기에 좋은 플랫폼입니다. 샘플 컴포넌트 생성하기 App.js 파일을 수정합니다. FlatList의 data 속성에는 배열 데이터를 입력합니다. 그리고 renderItem 속성에는 렌더링 함수를 입력합니다. 123456789101112131415161718192021222324252627import React from 'react';import ｛ View, Image, Text, FlatList, // here｝ from 'react-native'; export default class App extends React.Component ｛ state = ｛ data: [1, 2, 3] ｝ _renderItem = (｛item｝) =&gt; ( &lt;Text&gt;｛item｝&lt;/Text&gt; ); render() ｛ return ( &lt;FlatList data=｛this.state.data｝ renderItem=｛this._renderItem｝ /&gt; ); ｝｝ 아래는 결과화면입니다. Fake Online REST API 우리는 이번 예제를 위해서 JSONPlaceholder에서 제공하는 Fake Online REST API를 사용할 것입니다. JSONPlaceholder에서는 아래와 같이 다양한 샘플 API를 제공하고 있습니다. 이중에서 /photos API를 사용해 보겠습니다. JSON 데이터 형태는 아래와 같습니다. 서버에서 데이터 가져와서 출력하기 REST API에서 데이터를 가져오는 함수를 입력합니다. 한번에 10개씩 가져옵니다. 12345678910_getData = async () =&gt; ｛ const url = 'https://jsonplaceholder.typicode.com/photos?_limit=10'; fetch(url) .then(res =&gt; res.json()) .then(json =&gt; ｛ this.setState(｛ data: json ｝); ｝);｝ 그리고 컴포넌트가 마운트되고 나서 호출되도록 합니다. 123componentDidMount() ｛ this._getData();｝ 마지막으로 _renderItem 함수를 수정합니다. 123456_renderItem = (｛item｝) =&gt; ( &lt;View style=｛｛borderBottomWidth:1, marginTop: 20｝｝&gt; &lt;Image source=｛｛ uri: item.url ｝｝ style=｛｛ height: 200｝｝ /&gt; &lt;Text&gt;｛item.title｝&lt;/Text&gt; &lt;/View&gt;); > 여기까지 작업한 전체 코드입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from 'react';import ｛ View, Image, Text, FlatList, // here｝ from 'react-native';export default class App extends React.Component ｛ state = ｛ data: [1, 2, 3] ｝ _getData = async () =&gt; ｛ const url = 'https://jsonplaceholder.typicode.com/photos?_limit=10'; fetch(url) .then(res =&gt; res.json()) .then(json =&gt; ｛ this.setState(｛ data: json ｝); ｝); ｝ componentDidMount() ｛ this._getData(); ｝ _renderItem = (｛item｝) =&gt; ( &lt;View style=｛｛borderBottomWidth:1, marginTop: 20｝｝&gt; &lt;Image source=｛｛ uri: item.url ｝｝ style=｛｛ height: 200｝｝ /&gt; &lt;Text&gt;｛item.title｝&lt;/Text&gt; &lt;/View&gt; ); render() ｛ return ( &lt;FlatList data=｛this.state.data｝ renderItem=｛this._renderItem｝ keyExtractor=｛(item, index) =&gt; item.id｝ /&gt; ); ｝｝ 그리고 결과 화면입니다. 무한 스크롤 구현하기 맨 아래 항목까지 스크롤되면, 다음 데이터를 자동으로 가져와서 목록에 추가하는 기능을 구현할 것입니다… 이 기능을 Infinite Scroll 또는 무한 스크롤이라고 합니다. state에 page 변수를 추가합니다. 1234state = ｛ data: [], page: 1 // here｝ 그리고 _getData 함수를 수정합니다. 데이터를 가져올때마다 _page 번호를 증가합니다. 이렇게 하면 다음 요청에서는 다음 페이지의 데이터를 가져올 것입니다. 그리고 가져온 데이터를 기존 data에 추가(concat)합니다. 1234567891011_getData = () =&gt; ｛ const url = 'https://jsonplaceholder.typicode.com/photos?_limit=10&amp;_page=' + this.state.page; fetch(url) .then(r =&gt; r.json()) .then(data =&gt; ｛ this.setState(｛ data: this.state.data.concat(data), // 기존 data에 추가. page: this.state.page + 1 ｝) ｝);｝ 그리고 _handleLoadMore 함수를 입력합니다. 이 함수는 스크롤이 끝까지 도달했을때 호출됩니다. 123_handleLoadMore = () =&gt; ｛ this._getData();｝ 마지막으로 render 함수를 수정합니다. 1234567891011render() ｛ return ( &lt;FlatList data=｛this.state.data｝ renderItem=｛this._renderItem｝ keyExtractor=｛(item, index) =&gt; item.id｝ onEndReached=｛this._handleLoadMore｝ onEndReachedThreshold=｛1｝ /&gt; );｝ > 다음은 전체 코드입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React from 'react';import ｛ View, Image, Text, FlatList, // here｝ from 'react-native';export default class App extends React.Component ｛ state = ｛ data: [], page: 1 // here ｝ _renderItem = (｛item｝) =&gt; ( &lt;View style=｛｛borderBottomWidth:1, marginTop: 20｝｝&gt; &lt;Image source=｛｛ uri: item.url ｝｝ style=｛｛ height: 200｝｝ /&gt; &lt;Text&gt;｛item.title｝&lt;/Text&gt; &lt;Text&gt;｛item.id｝&lt;/Text&gt; &lt;/View&gt; ); // _getData 함수 수정 _getData = () =&gt; ｛ const url = 'https://jsonplaceholder.typicode.com/photos?_limit=10&amp;_page=' + this.state.page; fetch(url) .then(r =&gt; r.json()) .then(data =&gt; ｛ this.setState(｛ data: this.state.data.concat(data), page: this.state.page + 1 ｝) ｝); ｝ componentDidMount() ｛ this._getData(); ｝ // here _handleLoadMore = () =&gt; ｛ this._getData(); ｝ render() ｛ return ( &lt;FlatList data=｛this.state.data｝ renderItem=｛this._renderItem｝ keyExtractor=｛(item, index) =&gt; item.id｝ onEndReached=｛this._handleLoadMore｝ onEndReachedThreshold=｛1｝ /&gt; ); ｝｝ 다음은 결과 화면입니다. 스크롤이 끊임없이 됩니다. Pull Down Refresh 구현하기 이제 마지막입니다. state에 refreshing 변수를 추가합니다. refreshing 는 데이터를 가져오는 중인지를 판단합니다. 12345state = ｛ data: [], page: 1, refreshing: false // here｝ _handleRefresh 함수를 입력합니다. 이 함수는 화면을 Pull Down하면 호출될 것입니다. 데이터를 새로 가져올 것이기 때문에, page 번호를 1로 초기화해 줍니다. 123456_handleRefresh = () =&gt; ｛ this.setState(｛ refreshing: true, page: 1, ｝, this._getData);｝ render 함수를 수정합니다. refreshing 속성과 onRefresh 속성을 추가하였습니다. 12345678910111213render() ｛ return ( &lt;FlatList data=｛this.state.data｝ renderItem=｛this._renderItem｝ keyExtractor=｛(item, index) =&gt; item.id｝ onEndReached=｛this._handleLoadMore｝ onEndReachedThreshold=｛1｝ refreshing=｛this.state.refreshing｝ onRefresh=｛this._handleRefresh｝ /&gt; );｝ 마지막으로 _getData 함수를 수정합니다. refreshing가 true 일때는 가져온 데이터를 기존 데이터에 추가(concat)하지 않습니다. 123456789101112_getData = () =&gt; ｛ const url = 'https://jsonplaceholder.typicode.com/photos?_limit=10&amp;_page=' + this.state.page; fetch(url) .then(r =&gt; r.json()) .then(data =&gt; ｛ this.setState(｛ data: this.state.refreshing?data:this.state.data.concat(data), page: this.state.page + 1, refreshing: false ｝) ｝);｝ 다음은 결과 화면입니다. 화면을 아래로 당기면 onRefresh 이벤트가 발생합니다. 새로고침 해도 같은 데이터를 가져오기 때문에 화면의 변화는 없네요. 예제에 사용한 코드는 여기에서 확인할 수 있습니다. 감사합니다. Sponsored ( Powered by dclick ) DCLICK: 광고 기능을 소개 합니다 지난주에 dclick 에서 Advertise 기능이 오픈 되었습니다. Advertise 메뉴 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Infinite Scroll","slug":"infinite-scroll","permalink":"https://anpigon.github.io/tags/infinite-scroll/"},{"name":"Pull Down Refresh","slug":"pull-down-refresh","permalink":"https://anpigon.github.io/tags/pull-down-refresh/"},{"name":"FlatList","slug":"flatlist","permalink":"https://anpigon.github.io/tags/flatlist/"}],"author":"anpigon"},{"title":"리액트 네이티브로 무비앱을 만들어서 스토어에 올렸어요!","slug":"/kr/@anpigon/3radqh","date":"2019-03-28T03:16:57.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/3radqh/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/3radqh/","excerpt":"https://youtu.be/aMjAJRGATdU 리액트 네티이브 무비앱 소개 영상이번에는 리액트 네이티브 유료 강의를 듣고 무비앱을 만들었습니다. 완강하는데 약 18시간 정도가 소요되었습니다. 그리고 강의에 사용된 소스코드는 깃허브에 공개되어 있습니다. https://github.com/nomadcoders/nomad-movies","text":"https://youtu.be/aMjAJRGATdU 리액트 네티이브 무비앱 소개 영상이번에는 리액트 네이티브 유료 강의를 듣고 무비앱을 만들었습니다. 완강하는데 약 18시간 정도가 소요되었습니다. 그리고 강의에 사용된 소스코드는 깃허브에 공개되어 있습니다. https://github.com/nomadcoders/nomad-movies 이번 무비앱은 expo 툴을 사용하여 개발하였습니다. 모바일앱을 expo로 개발하면 정말 편합니다. 장점을 3가지만 나열해보겠습니다. 첫번째, 디바이스 USB 연결이 필요없습니다. WIFI 연결만으로 앱 디버깅이 가능합니다. 두번째, 수정할때마다 apk빌드할 필요가 없습니다. Publish만 하면 수정한 코드가 이미 설치되어 있는 앱에 자동 반영됩니다. 세번째, 필요한 모듈이나 라이브러리가 expo 툴에 대부분 포함되어 있습니다. 그리고 구글 플레이 스토어에도 올렸습니다. 감사합니다. Sponsored ( Powered by dclick ) DCLICK: 광고 기능을 소개 합니다 지난주에 dclick 에서 Advertise 기능이 오픈 되었습니다. Advertise 메뉴 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"맥(Mac)에서 터미널을 개발자스럽게 사용하는 방법","slug":"/kr/@anpigon/mac","date":"2019-03-15T17:02:27.000Z","updated":"2019-11-11T13:41:49.810Z","comments":true,"path":"/kr/@anpigon/mac/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/mac/","excerpt":"이 포스팅은 https://gist.github.com/kevin-smets/8568070를 참고하여 작성하였습니다. iTerm2https://www.iterm2.com저는 iTerm2 터미널 프로그램을 사용합니다. 지금부터 iTerm2를 개발자스럽게 셋팅하는 방법을 소개합니다. 먼저 iTerm2를 다운로드해 인스톨 합니다.","text":"이 포스팅은 https://gist.github.com/kevin-smets/8568070를 참고하여 작성하였습니다. iTerm2https://www.iterm2.com저는 iTerm2 터미널 프로그램을 사용합니다. 지금부터 iTerm2를 개발자스럽게 셋팅하는 방법을 소개합니다. 먼저 iTerm2를 다운로드해 인스톨 합니다. 맥 사용자라면 brew로도 인스톨 가능합니다. brew cask install iterm2 iTerm2은 많은 기능을 제공합니다. 한 가지 기능을 소개하면, 창 분할(Split Panes)입니다. 제가 가장 많이 사용하는 기능 중 하나입니다. 창 세로 분할: Command + D 창 가로 분할: Command + Shift + D 그리고 위 스크린 샷의 멋진 터미널 화면이 보이나요? 이제부터 우리는 터미널 화면을 멋지게 만들어 볼 것입니다. 아래 링크 중 하나를 선택하여 iTerm color settings을 다운로드합니다. 참고로 저는 Solarized Dark theme를 사용하고 있습니다. Solarized Dark theme Solarized Light theme More themes @ iterm2colorschemes 그리고 iTerm → Preferences → Profiles → Colors → Color Presets… 를 선택합니다. 다운로드한 color settings을 Import 합니다. Oh My Zsh 이제 Oh My Zsh를 이용하여 zsh를 구성합니다. Oh My Zsh는 zsh 구성을 관리하기 위한 오픈 소스 프레임 워크입니다. 자세한 정보는 아래 사이트를 참고하세요. https://github.com/robbyrussell/oh-my-zsh 터미널 창을 열고 다음 명령어를 입력하여 설치합니다. sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 설치가 완료되면 $HOME 디렉토리에 .zshrc 파일이 생성됩니다. .zshrc 파일에는 환경설정, 플러그인, 테마 등등 이 포함되어 있습니다. 그리고 기본 테마는 ZSH_THEME=&quot;robbyrussell&quot; 로 설정되어 있습니다. 이런 모양입니다. 안 이쁩니다. ㅠㅠ 다른 테마도 구경하고 싶으면 여기를 참고하세요. 약 100개의 테마를 제공하고 있습니다. 기존 bash 설정을 zshrc에서도 사용하고 싶으면 다음을 입력합니다. echo &quot;source $HOME/.bash_profile&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc prompt를 깔끔하게 만들고 싶으면 다음을 입력합니다. echo &quot;prompt_context () ｛ ｝&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc 프롬프트가 아래처럼 바뀝니다. 참고: https://stackoverflow.com/questions/28491458/zsh-agnoster-theme-showing-machine-name Powerlevel9k Theme for ZSH 저는 Powerlevel9k 테마를 사용하고 있습니다. 다음을 복사 붙여넣기 해서 실행합니다. git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 그리고 ~/.zshrc 파일을 열어서 테마를 수정합니다. ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; Powerlevel9k를 설정하는 방법은 매우 다양합니다. 다른 설정 방법도 여기에서 확인해 보세요. Font 설치하기 아래 링크에서 폰트를 다운로드합니다. Meslo (view raw를 클릭하고 파일을 다운로드 하세요) Source Code Pro Others @ powerline fonts 다운로드한 폰트를 열고 &quot;서체 설치&quot;를 선택합니다. 저는 Meslo 폰트를 설치하였습니다. iTems2 &gt; Preferences &gt; Profiles &gt; Text &gt; Change Font 에서 &quot;Meslo LG M for Powerline&quot; 폰트를 선택합니다. Visual Studio Code 설정하기 VS Code에서 zsh을 사용하려면 다음과 같이 설정합니다. VS Code에서 Settings(CMD + ,) 로 이동합니다. terminal.integrated.shell.osx 검색합니다. Terminal › Integrated › Shell: Osx 에서 /bin/bash 를 /bin/zsh 로 수정합니다. 그다음 terminal.integrated.fontFamily 검색합니다. Terminal › Integrated: Font Family 에 'Meslo LG M for Powerline' 를 입력합니다. 기타 다른 tweak 방법은 여기를 참고하세요. auto suggestions word jumping with arrow keys / natural text editing shorter prompt style syntax highlighting 기본 터미널 zshrc를 설정하고 나면, 기본 터미널이 이 모양이 됩니다. 폰트가 깨져서 모양이 이쁘지가 않습니다. 폰트를 변경하는 방법도 있지만, 저는 기본 터미널은 bash를 사용하도록 변경하였습니다. 터미널 메뉴에서 환경설정 &gt; 일반를 선택합니다. 그리고 셀 열기에서 명령어(절대 경로)를 선택하고 /bin/bash를 입력합니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 혹시 이 문자 받으셨나요?(부제 : 스팸 의심 문자) 저한테서 [Web발신]상품명:ㅎㅌㅋH9?안마의 자주문일자 :19/03/25 이하락 문자가 와버…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"꿀팁","slug":"꿀팁","permalink":"https://anpigon.github.io/tags/꿀팁/"}],"author":"anpigon"},{"title":"인사이드아웃 캐릭터 그림","slug":"/kr/@steemory/tpdjrulk","date":"2019-03-14T12:49:21.000Z","updated":"2019-11-11T13:41:49.857Z","comments":true,"path":"/kr/@steemory/tpdjrulk/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/tpdjrulk/","excerpt":"","text":"펜슬을 이용하여 아이패드에서 그려보았습니다. 생각보다 그리기 어렵습니다.버럭이가 첫번째 작품이고, 소심이가 두 번째 작품입니다. 두 번째로 그린 소심이 그림이 더 마음에 듭니다.Posted using Partiko Android","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[React Native] 레트로 게임 UI 만들기","slug":"/kr/@anpigon/react-native-ui","date":"2019-03-12T04:36:06.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/react-native-ui/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui/","excerpt":"Illustration © Codeman38어렸을 때 Final Fantasy와 같은 RPG 게임을 좋아했습니다. 옛날 레트로 느낌을 살려서, Final Fantasy UI 처럼 보이는 컨테이너를 만들어 봅니다.* * * 프로젝트 생성하기expo-cli를 사용하여 프로젝트를 생성합니다. 프로젝트 명은 ffcontainer라고 하였습니다.","text":"Illustration © Codeman38어렸을 때 Final Fantasy와 같은 RPG 게임을 좋아했습니다. 옛날 레트로 느낌을 살려서, Final Fantasy UI 처럼 보이는 컨테이너를 만들어 봅니다.* * * 프로젝트 생성하기expo-cli를 사용하여 프로젝트를 생성합니다. 프로젝트 명은 ffcontainer라고 하였습니다. $ expo init ffcontainer 라이브러리 설치 이번에는 styled-components 모듈을 설치하여 사용해 봅니다. $ yarn add styled-components FFContainer 만들기 App.js 파일의 내용을 지우고 아래와 같이 작성합니다. 먼저 필요한 모듈을 import 합니다. import React from 'react'; import ｛ View, Text, StyleSheet ｝ from 'react-native'; import ｛ Constants, LinearGradient ｝ from 'expo'; import styled from 'styled-components'; 그리고 styled-components를 사용하여, 앱 컨테이너를 담당할 &lt;Container&gt; 를 작성합니다. styled-components를 사용하면 다음과 같이 CSS 비슷하게 사용할 수 있습니다. const Container = styled.View` flex: 1; background-color: black; paddingTop: $｛Constants.statusBarHeight｝; `; styled-components로 만든 &lt;Container&gt;가 어떻게 렌더링되는지 확인해봅니다. export default class App extends React.Component ｛ render() ｛ return ( &lt;Container&gt; &lt;/Container&gt; ); ｝ ｝; 이제 본격적으로 FFContainer를 만들어 봅니다. 아래와 같이 작성합니다. const FFContainer = styled.View` border-radius: 8; border-width: 4; border-color: #e7dfe7; border-style: solid; background-color: #e7dfe7; margin-horizontal: 10; margin-vertical: 10; `; const styles = StyleSheet.create(｛ FFContents: ｛ padding: 10, borderRadius: 5, ｝ ｝); const GRADIENT_COLOR = ['#6c6eb2', '#181870', '#000028']; export default class App extends React.Component ｛ render() ｛ return ( &lt;Container&gt; &lt;FFContainer&gt; &lt;LinearGradient style=｛styles.FFContents｝ colors=｛GRADIENT_COLOR｝&gt; &lt;Text style=｛｛color:'white'｝｝&gt;Hello World!&lt;/Text&gt; &lt;/LinearGradient&gt; &lt;/FFContainer&gt; &lt;/Container&gt; ); ｝ ｝; 아래와 같이 보여집니다. Fonts 적용하기 이번에는 레트로 감성의 폰트를 적용해봅시다. 구글에서 제공하는 폰트 중에 Press+Start+2P가 있습니다. Press Start 2P Font를 다운로드 합니다. [여기]에서 다운로드 가능합니다. App.js 를 수정합니다. expo에서 Font 모듈을 추가로 import 합니다. import ｛ Constants, LinearGradient, Font, // here ｝ from 'expo'; 그리고 Font.loadAsync를 사용하여 assets 폴더에 있는 Font 파일을 가져옵니다. Font 파일 로딩이 완료되기 전에 Font 를 사용하면 에러가 발생합니다. 그래서state.fontLoaded로 Font 파일 로딩 완료 여부를 판단할 것 입니다. export default class App extends React.Component ｛ state = ｛ fontLoaded: false // here ｝ async componentWillMount() ｛ await Font.loadAsync(｛ 'PressStart2P': require('./assets/PressStart2P.ttf'), ｝); this.setState(｛ fontLoaded: true ｝); ｝ // (...) expo에서 커스텀 폰트 사용방법은 Using Custom Fonts 문서를 참고하였습니다. &lt;Text&gt; 에 'Hello World!’ 를 출력하여 Font를 확인해봅니다. export default class App extends React.Component ｛ // (...) render() ｛ if(this.state.fontLoaded) ｛ return ( &lt;Container&gt; &lt;FFContainer&gt; &lt;LinearGradient style=｛ styles.FFContents ｝ colors=｛ GRADIENT_COLOR ｝&gt; &lt;Text style=｛｛color:'white', fontFamily:'PressStart2P'｝｝&gt;Hello World!&lt;/Text&gt; &lt;/LinearGradient&gt; &lt;/FFContainer&gt; &lt;/Container&gt; ); ｝ return null; ｝ ｝; 스팀잇 프로필 화면 만들기 스팀잇 프로필을 아래와 같은 UI로 만들어 보았습니다. 화면에서 명성(Reputation)을 LV라고 표현해보았습니다. 게임 화면처럼 보이나요? ㅎㅎ 위 코드 내용은 snack.expo.io에서 확인할 수 있습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"도서관에서 책 3권을 빌렸습니다. 효율적인 독서와 영어 공부, 그리고 글쓰기를 잘하고 싶은 욕심이 생겼습니다.","slug":"/kr/@steemory/3-uzxnopv1","date":"2019-03-11T07:17:42.000Z","updated":"2019-11-11T13:41:49.862Z","comments":true,"path":"/kr/@steemory/3-uzxnopv1/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/3-uzxnopv1/","excerpt":"책 소개 내용은 온라인 서점에서 가져왔습니다. 세상을 바꾼 10권의 책 이 책의 저자는 일본의 유명한 저널리스트이다. 그리고 인류의 역사에 큰 영향을 끼쳤다고 판단한 10권의 책을 선정하였다. 주요 내용을 인용하고 나름의 감상을 풀어쓴 독서에세이다. 저자가 선정한 책은 『안네의 일기』 『성경』 『코란』 『프로테스탄티즘의 윤리와 자본주의 정신』 『자본론』 『진리를 향한 이정표』 『침묵의 봄』 『종의 기원』 『고용, 이자 및 화폐에 관한 일반 이론』 『자본주의와 자유』 등 이다. 우리에게 대체로 익숙한 고전들로 이해하기 쉽고 차분하게 대화하듯 책의 주요 내용들을 알려준다.","text":"책 소개 내용은 온라인 서점에서 가져왔습니다. 세상을 바꾼 10권의 책 이 책의 저자는 일본의 유명한 저널리스트이다. 그리고 인류의 역사에 큰 영향을 끼쳤다고 판단한 10권의 책을 선정하였다. 주요 내용을 인용하고 나름의 감상을 풀어쓴 독서에세이다. 저자가 선정한 책은 『안네의 일기』 『성경』 『코란』 『프로테스탄티즘의 윤리와 자본주의 정신』 『자본론』 『진리를 향한 이정표』 『침묵의 봄』 『종의 기원』 『고용, 이자 및 화폐에 관한 일반 이론』 『자본주의와 자유』 등 이다. 우리에게 대체로 익숙한 고전들로 이해하기 쉽고 차분하게 대화하듯 책의 주요 내용들을 알려준다. 몰입 영어 몰입 영어를 하면 활성화된 시냅스(뇌세포) 수가 최대가 된다. 활성화의 시냅스의 수가 최대가 되면 암묵기억 회로가 발달해 학습효과는 무한상승한다. 그리고 뇌는 흥분상태가 되어 저절로 재미를 느끼게 된다고 한다. 또한 모든 잡념이 사라져 효율적인 영어 공부에 가장 강력한 방법이라고 강조한다. 책쓰기가 이렇게 쉬울줄이야 책쓰기의 콘셉트 잡기 · 집필의 실전 9단계 · 베스트셀러의 5가지 조건 · 출판사 투고 시 편집자의 마음을 사로잡는 법 등 20년 차 출판기획사 대표가 알려주는 책쓰기의 모든 것이 이 책 한 권에 담겨 있다. 단순히 ‘글쓰기’라는 활동을 넘어 자신이 누구이며, 무엇을 좋아하며, 어떤 것에 관심이 많은지를 들여다보고 되새기고 끄집어내는 시간을 가질 수 있게 한다. 차분하게 생각하고 그것을 글로 담아내는 과정은 자기계발의 시간이요, 자기 성장의 순간이다. Posted using Partiko Android","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"}],"author":"steemory"},{"title":"[소설] 베르나르 베르베르 ⟪잠(Le sixième sommeil)⟫","slug":"/kr/@steemory/7u8z6z","date":"2019-02-25T06:31:42.000Z","updated":"2019-11-11T13:41:49.862Z","comments":true,"path":"/kr/@steemory/7u8z6z/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/7u8z6z/","excerpt":"이 책은 잠에 관한 소설입니다.하지만 읽다보면 전문 서적을 읽는 듯한 느낌을 받았습니다.주인공 자크의 어머니는 수면을 연구하는 유명한 신경 생리학 박사입니다.어머니 카롤린은 아들 자크가 어릴때 부터 꿈을 통제하는 방법을 가르쳐 줍니다.그래서 아들은 꿈을 통제하는 방법을 통해 항상 어려움을 극복합니다.","text":"이 책은 잠에 관한 소설입니다.하지만 읽다보면 전문 서적을 읽는 듯한 느낌을 받았습니다.주인공 자크의 어머니는 수면을 연구하는 유명한 신경 생리학 박사입니다.어머니 카롤린은 아들 자크가 어릴때 부터 꿈을 통제하는 방법을 가르쳐 줍니다.그래서 아들은 꿈을 통제하는 방법을 통해 항상 어려움을 극복합니다. 책 속에는 흥미로운 이야기들이 정말 많이 나옵니다. 역설수면, 자각몽, 세노이족, 노스피어, 클라인 블루, 클라인 병, … 등등 역설수면 「몸이 극도로 이완되고, 바깥 소리는 전혀 못 듣고, 심장 박동은 느리고, 체온은 떨어지는데, 특이하게도 되는 가장 빠르고 활발하게 움직이거든. 멋지고 환상적인 꿈도 이때 꾸지. 그래서 이 다섯 번째 단계를 &lt;역설수면&gt;이라고 불러.」 「1959년에 프랑스 과학자인 미셸 주베 교수가 이걸 발견했어. 그전에는 이 신기한 수면 단계에서 어떤 일이 벌어지는지 몰랐지」 - 엄마가 아들 자크에게 &lt;역설수면&gt;에 대해서 설명하는 내용 (1권, p. 53) 관련 기사: 관련 기사: 생의 3분의 1을 왜 잠으로 소비하나? 인류를 ‘오랜 꿈’에서 깨운 의학자 멋진 꿈을 꾸는 방법. 「소설과 시, 그림, 그리고 음악은 너 자신만의 꿈을 요리하기 위해 필요한 최상의 재료들이야. &lt;신선한&gt; 식재료들이지.」 - 멋진 꿈을 꿀수 있는 방법 (1권, p. 60) 멋진 꿈을 꿀수 있게 하는 신선한 재료들 소설: 루이스 캐럴의 『스나크 사냥』, 『재버워키』, 『겨울 나라의 앨리스』, 조너선 스위프트의 『걸리버 여행기』, 라블레의 세계의 『가르강튀아와 팡타그뤼엘』, 에드거 앨런 포의 『이이한 이야기들』, 쥘베른의 『신비의 섬』, 『지구 속 여행』, 『해저 2만 리』, 아이작 아시모프의 『파운데이션』, 『아이, 로봇』, 필립 K. 딕의 『유빅』, 『높은 성의 사내』 ... 시: 빅토르위고, 샤를 보들레르, 아르튀르 랭보, 보리스 비앙, 자크 프레베르, 조르주 페렉, ..... 그림: 히에로니무스 보스, 프란시스코 고야, 렘브란트, 루벤스, 페르메이르, 윌리엄 터너, 존 마틴, 살바도르 달리, 르네마그리트, ... 음악:비발디, 모차르트, 베토벤, 그리고, 포레, 드뷔시, ... 꿈 속에서 발명을 하다. 「1869년, 화학자 드리트리 멘델레예프는 옆방에서 들리는 클래식 음악을 듣다 잠이 들었어요. 그리고 기초화학 원소들이 음악의 주제처럼 연결되어 있는 꿈을 꾸죠. 잠이 깨고 나서 그는 자연에 존재하는 모든 화학 원소를 최초로 분류하고 정리한 &lt;주기율표&gt;를 만들어요.」 「1844년, 일라이어스 하우는 정글에서 식인 원주민들에게 쫓기는 꿈을 꿔요. 식인종들이 그를 에워싸고 무시무시한 창을 앞뒤로 흔들어 대며 위협하죠. 이 순간, 그는 꿈속에서 원주민들이 들고 있는 창의 끄트머리에 동그란 구멍이 하나 뚫린 것을 발견해요. 여기에서 줄을 넣어 구멍들을 하나로 잇는 아이디어를 얻은 다름날… 재봉틀을 발명하죠. 1984년, 알베르트 아인슈타인이라는 이름의 소년은 스키를 타고 산을 내려오는 꿈을 꿔요. 갈수록 경사가 가팔라져 썰매에 가속이 붙자 소년은 빛의 속도에 근접하는 느낌을 받아요. 하늘의 별들이 빛의 꼬리를 달고 휙휙 지나가는 것처럼 보이죠. 이 꿈에서 영감을 얻어 아인슈타인은 훗날 상대성 이론을 정립하게 돼요.」 (1권 p.111) 관련 글: 꿈을 현실로 만들었던 천재, 멘델레예프관련 글: 꿈에서 탄생한 재봉틀 수면 과정 수면 과정을 요약 하면, 0단계: 입면, 1단계: 아주 얕은 잠, 2단계: 얕은 잠, 3단계: 깊은 잠, 4단계: 아주 깊은 잠, 5단계: 역설수면. 이다음에 잠재기가 오는데, 이때 잠이 깨거나 수면 주기가 다시 시작되요.베타파. 15~30헤르츠. 평상시 우리 뇌의 주파수예요. 일상의 소소한 문제에 신경을 쓸 때 나타나는 주파수가 15헤르츠이고, 집중을 해서 두뇌 활동을 하거나 불안하고 초조한 상태일 떄가 30헤르츠죠. 여러분의 뇌파는 지금 베타파이겠네요.알파파. 8~10헤르츠. 수면 1단계에 해당하는 주파수예요. 눈을 감고 차분해진 상태의 뇌파죠. 휴식 상태말이에요. 내가 아까 여러분한테 30초 동안 눈을 감아보라고 했을 떄의 바로 그 상태예요.세타파. 4~7헤르츠. 수면 2단계인 얕은 잠에 해당하는 주파수예요. 최면 상태이거나 약물을 복용했을 때 이런 파동이 나타나요. 티베트 승려들이나 신비주의 대가들은 하루의 대부분을 세타파 상태에서 보낸다고 하더군요.델타파. 주파수가 0.5~0.7헤르츠로, 수면 3단계와 4단계에 해당해요. 느리고 깊은 수면 시에 나타나요. 이때 야경증과 몽유병 발작이 일어나죠. 이다음에 주파수 30헤르츠부터 40헤르츠까지에 해당하는 감마파가 있어요. 우리가 특정한 문제를 해결하려고 극도로 집중한 순간에 나타나죠. 체스 선수와 포커 선수, 십자말풀이 애호가, 양궁 선수, &lt;강박적 카사노바&gt; 등이 이런 감마파 상태예요. 5단계인 역설수면 상태에서 나타나는 주파수이기도 하죠.- 카롤린 클라인 박사가 강당에서 학생들에게 강의하는 내용 중 (1권 p.111 ~ 112) 자각몽 자각몽을 최초로 언급한 사람은 호메르스예요. 『오디세이아』에서 &lt;자고 있다는 것을 아는 상태에서 꿈을 꾸는&gt; 민족과 만난 경험을 들려줘요. 아리스토텔레스는 &lt;잠이 꺠지 않고 꿈을 꾸고 있다는 사실을 인식&gt;할 수 있다고 하죠. 1867년에 『꿈과 꿈을 운용하는 방법』을 집필한 프랑스 작가 레옹 데르베 드 생드니는 스스로를 &lt;꿈 학자&gt;라고 칭하죠. 그는 현대 꿈 연구의 초석을 놓은 사람이에요. 역설수면 단계에서 자각몽을 꿀 수 있다는 사실이 알려졌죠. (1권 p.113) 관련 기사: 무의식의 꿈을 통제하는 ‘자각몽’","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"베르나르 베르베","slug":"베르나르-베르베","permalink":"https://anpigon.github.io/tags/베르나르-베르베/"},{"name":"소설","slug":"소설","permalink":"https://anpigon.github.io/tags/소설/"}],"author":"steemory"},{"title":"[React Native] 커스텀 폰트 사용하기","slug":"/kr/@anpigon/29gyik-react-native","date":"2019-02-24T16:38:36.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/29gyik-react-native/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/29gyik-react-native/","excerpt":"리액트 네이티브(React Native)에서 사용자 글꼴(Custom Fonts)를 사용하는 방법입니다. 출처: https://medium.com/react-native-training/react-native-custom-fonts-ccc9aacf9e5e * * * Assets에 글꼴 파일 복사하기","text":"리액트 네이티브(React Native)에서 사용자 글꼴(Custom Fonts)를 사용하는 방법입니다. 출처: https://medium.com/react-native-training/react-native-custom-fonts-ccc9aacf9e5e * * * Assets에 글꼴 파일 복사하기 글꼴(Fonts) 파일을 루트에 있는 assets/fonts 폴더에 복사합니다. Package.json 수정하기 이제 React Native에게 글꼴 파일이 있는 위치를 알려줘야 합니다. package.json파일에 rnpm을 추가하고 글꼴 파일이 있는 경로를 입력합니다. 12345\"rnpm\": ｛ \"assets\": [ \"./assets/fonts/\" ] ｝ 그다음 React Native에게 글꼴 파일을 링크하도록 명령을 수행합니다 : $ react-native link 이렇게 하면 Android의 경우에는 Font 파일이 android/app/src/main/assets/fonts에 복사됩니다. 그리고 iOS는 Info.plist 파일에 글꼴 참조가 추가됩니다. iOS 폴더의 Info.plist 파일을 열어보면 아래와 같은 내용을 찾아 볼 수 있습니다. 1234&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt; &lt;string&gt;vincHand.ttf&lt;/string&gt;&lt;/array&gt; React Native Styles React Native 스타일에 글꼴을 추가하는 방법입니다. 아래와 같이 fontFamily 속성에 글꼴 이름을 입력하면 됩니다. 123456789101112131415161718192021const styles = StyleSheet.create(｛ container: ｛ flex: 1, justifyContent: \"center\", alignItems: \"center\", backgroundColor: \"#F5FCFF\" ｝, welcome: ｛ fontFamily: \"vincHand\", // here fontSize: 30, textAlign: \"center\", margin: 10 ｝, instructions: ｛ fontFamily: \"vincHand\", // here fontSize: 20, textAlign: \"center\", color: \"#333333\", marginBottom: 5 ｝｝); 스크린샷 Android iOS 소스 코드 이 튜토리얼의 소스 코드는 GitLab에서 찾을 수 있습니다. * * * 앱에 폰트를 추가하면 앱 용량이 매우 커지는 단점이 있습니다. 하지만 정말 원하는 폰트가 있다면, 폰트 용량을 줄여서 사용하는 방법이 있습니다. 폰트 용량 줄이는 방법은 아래 블로그에 잘 설명되어 있습니다. 한글 웹 폰트 경량화해 사용하기 웹폰트 경량화 - 폰트툴즈의 pyftsubset을 사용한 폰트 서브셋 만들기 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #8 - 배포하기","slug":"/kr/@anpigon/ethereum-mobile-wallet-8","date":"2019-02-22T01:56:00.000Z","updated":"2019-11-11T13:41:49.822Z","comments":true,"path":"/kr/@anpigon/ethereum-mobile-wallet-8/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/ethereum-mobile-wallet-8/","excerpt":"이제 정말 마지막 강좌입니다.이번 시간에는 구글 플레이 스토어에 우리가 만든 앱을 배포해봅니다. 우선은 안드로이드앱 배포 만 설명합니다.Google Play 스토어에 앱을 등록하기 위해서는 서명된 APK를 만들어야 합니다. 앱 서명에 대한 자세한 내용은 &lt;안드로이드 개발자 가이드 : 앱 서명&gt;를 참고하세요. 한글로 자세하게 설명되어 있습니다. 그리고 아래 내용은 &lt;리액트 네이티브 Generating Signed APK&gt; 문서를 참고하여 작성하였습니다.","text":"이제 정말 마지막 강좌입니다.이번 시간에는 구글 플레이 스토어에 우리가 만든 앱을 배포해봅니다. 우선은 안드로이드앱 배포 만 설명합니다.Google Play 스토어에 앱을 등록하기 위해서는 서명된 APK를 만들어야 합니다. 앱 서명에 대한 자세한 내용은 &lt;안드로이드 개발자 가이드 : 앱 서명&gt;를 참고하세요. 한글로 자세하게 설명되어 있습니다. 그리고 아래 내용은 &lt;리액트 네이티브 Generating Signed APK&gt; 문서를 참고하여 작성하였습니다. * * * 안드로이드 앱 아이콘 만들기 저는 앱 아이콘을 아래 사이트를 이용하여, 간단하게 만들었습니다. https://romannurik.github.io/AndroidAssetStudio/icons-launcher.html 생성된 아이콘을 다운로드 합니다. 그리고 android/app/src/main/res 폴더에 각 사이즈별 아이콘을 복사합니다. mipmap-hdpi mipmap-mdpi mipmap-xhdpi mipmap-xxhdpi mipmap-xxxhdpi 서명 키 생성하기 keytool를 사용하여 서명키를 생성합니다. 윈도우 사용자는 C:\\Program Files\\Java\\jdkx.x.x_x\\bin 경로에 keytool이 있습니다. 맥OS 사용자는 /usr/libexec/java_home 명령어를 실행하면, JDK가 설치된 경로를 알 수 있습니다. /Library/Java/JavaVirtualMachines/jdkx.x.x_x.jdk/Contents/Home 1$ keytool -genkey -v -keystore ethereum-wallet.keystore -alias ethereum-wallet -keyalg RSA -keysize 2048 -validity 10000 위 명령을 실행하면 콘솔창에 비밀번호와 이름, 지역 등을 입력하라는 메시지가 표시됩니다. 값을 모두 입력한 다음 “예”(or yes)를 입력합니다. 그러고 나면 ethereum-wallet.keystore 파일이 생성됩니다 . 방금 생성한 keystore에는 10000일 동안 유효한 키가 들어 있습니다. keystore password, key password, alias은 나중에 앱에 서명할 때 사용하므로 꼭 메모해 놓으시기 바랍니다. 그리고 keystore파일이 절대 git에 업로드되어 공개되지 않도록 조심하세요. gradle 설정하기 ethereum-wallet.keystore 파일을 android/app 폴더에 복사합니다. ~/.gradle/gradle.properties 또는 android/gradle.properties 파일을 열어서 다음과 같이 추가합니다. 1234MYAPP_RELEASE_STORE_FILE=ethereum-wallet.keystoreMYAPP_RELEASE_KEY_ALIAS=ethereum-walletMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** *******에는 keystore 암호화와 alias 암호를 정확하게 입력합니다. 앱의 gradle config에 서명 설정하기 프로젝트 폴더의 android/app/build.gradle파일에 signingConfig 설정을 추가합니다. 12345678910111213141516171819202122...android ｛ ... defaultConfig ｛ ... ｝ signingConfigs ｛ release ｛ if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) ｛ storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD ｝ ｝ ｝ buildTypes ｛ release ｛ ... signingConfig signingConfigs.release ｝ ｝｝... 안드로이드 APK 생성하기 터미널에서 아래 명령을 실행합니다. 12$ cd android$ ./gradlew assembleRelease 생성된 APK는 android/app/build/outputs/apk/release/app-release.apk에서 찾을 수 있습니다. 만약, 아래와 같은 메세지가 출력된다면… 123456&gt; FAILURE: Build failed with an exception.&gt; &gt; * What went wrong:&gt; A problem occurred configuring project ':app'.&gt; &gt; SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable.&gt; android/local.properties 파일을 생성하고, sdk.dir=/Users/｛YOUR_USER_NAME｝/Library/Android/sdk를 입력합니다. 또는, ~/.bash_profile 에 export ANDROID_HOME=｛YOUR_PATH｝를 설정할 수도 있습니다. 앱의 출시 빌드 테스트하기 release된 APK를 Play 스토어에 업로드하기 전에 테스트해야 합니다. 다음을 명령을 사용하면 장치에 release된 APK를 설치할 수 있습니다. 먼저 이미 설치된 앱을 제거해야 합니다. 1$ react-native run-android --variant=release ABI로 APK를 분할하여 파일 크기를 줄이기 기본적으로 생성된 APK에는 x86와 ARMv7a CPU 아키텍처 용 네이티브 코드가 모두 들어있습니다. 이렇게 하면 대부분의 Android 기기에서 실행되는 APK를 쉽게 배포할 수 있습니다. 그러나 이렇게 하면 어떤 장치에는 사용되지 않는 코드가 있으므로 불필요하게 큰 APK가 만들어질 수 있다는 단점이 있습니다. android/app/build.gradle에서 enableSeparateBuildPerCPUArchitecture를 true로 변경합니다. 그럼 각 CPU에 대한 APK를 만들 수 있습니다. 1def enableSeparateBuildPerCPUArchitecture = true 이 두 파일을 Google Play 및 Amazon AppStore 처럼 기기 타겟팅을 지원하는 마켓에 업로드 하면, 사용자는 자동으로 필요한 APK를 다운로드합니다. 단일 앱에 대해 여러 개의 APK를 지원하지 않는 APKFiles 과 같은 마켓에 업로드하려는 경우, 다음 줄도 변경하여 두 CPU의 바이너리가 모두 들어있는 범용 APK로 만들어야 합니다. 1universalApk true // If true, also generate a universal APK Proguard를 활성화하여 APK 크기 줄이기 (선택 사항) Proguard는 APK의 크기를 약간 줄일 수 있는 도구입니다. 앱에서 사용하지 않는 React Native Java 바이트 코드(및 종속성)의 일부를 제거합니다. Proguard를 활성화하려면 android/app/build.gradle 파일에서 다음을 수정합니다. 1234/** * Run Proguard to shrink the Java bytecode in release builds. */def enableProguardInReleaseBuilds = true 중요 : Proguard를 사용하도록 설정한 경우에는 앱을 철저히 테스트해야합니다. Proguard는 종종 각 네이티브 라이브러리에 특정한 설정을 필요로합니다. android/app/proguard-rules.pro 파일을 참조하세요. 구글 플레이 스토어에 앱 등록하기 구글 플레이 스토어에 등록하는 방법은 간략하게 설명하겠습니다. 자세하게 모두 설명하려니 내용이 너무 많아지네요. ㅠㅠ 아래 사이트에 접속하여 안드로이드 개발자 등록을 먼저 해야 합니다. https://play.google.com/apps/publish/?hl=ko 이미 개발자 등록이 되어있다는 가정하에 설명합니다. 애플리케이션 만들기 버튼을 선택합니다. 앱 제목을 입력하고 만들기 버튼을 선택합니다. 스토어 등록정보를 입력합니다. * 표시되어 있는 입력항목은 반드시 모두 입력해야 합니다. 그리고 스크린샷, 고해상도 아이콘, 그래픽 이미지를 모두 등록합니다. 스토어 등록정보, 콘텐츠 등록, 가격 및 배포 메뉴의 모든 정보를 입력합니다. 모든 정보를 입력해야 앱 출시가 가능합니다. 마지막으로 앱 버전 메뉴를 선택하고, 서명된 APK를 업로드합니다. 그리고 저장을 누르고 검토를 선택합니다. 배포가 완료되면 대시보드에서 내 앱을 확인할 수 있습니다. GOOGLE PLAY에서 보기 버튼을 누르면 구글 마켓으로 이동합니다. * * * 구글 마켓에 정상적으로 배포가 되었습니다. 구글마켓: https://play.google.com/store/apps/details?id=com.rn_ethereum_wallet 깃허브: https://github.com/anpigon/rn_ethereum_wallet 이더리움 지갑앱이 리액트 네이티브로 개발하여 마켓에 배포까지 한 첫 모바일 앱이 되었네요. 리액트 네이티브로 모바일앱을 개발하고 나서 느낀 점입니다. 앱 실행 속도, 화면 전환 속도, APK최적화(용량) 부분에서는 자바 언어로 개발한 안드로이드 앱보다는 만족감이 조금 떨어졌습니다. 하지만 리액트 네이티브가 개발(코딩) 속도, 앱 디버깅, 테스트 등에서는 정말 많은 이점이 있었습니다. 단순한 앱은 리액트 네이티브로 금방 개발할 수 있을 것 같습니다. 그리고 웬만한 필요한 기능들이 리액트 네이티브 모듈로 구현되어 깃허브에 공개되어 있네요. 참고로, 곧 출시될 삼성 갤럭시10에는 비트코인, 이더리움 암호화폐 지갑이 포함되었다고 합니다. 관련 기사: https://blockinpress.com/archives/13873 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"⟪1만 시간의 재발견⟫ 안데르스 에릭슨","slug":"/kr/@steemory/1","date":"2019-02-18T07:19:57.000Z","updated":"2019-11-11T13:41:49.862Z","comments":true,"path":"/kr/@steemory/1/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/1/","excerpt":"책의 원제는 Peak: Secrets from the New Science of Expertise 이다. 그리고 안데르스 에릭슨(Anders Ericsson) 박사는 미국 심리학자이며 ‘1만 시간의 법칙’ 이론의 창시자이다.이 책은 '올바른 연습’이란 무엇이며, 효과적인 실천방법에 대해서 설명한다. 어느 분야에서나 통하는 보편적인 방법을 '의식적인 연습(deliberate practice)'이라고 한다. '의식적인 연습’을 통하면 누구나 최고의 경지에 오를 수 있다.","text":"책의 원제는 Peak: Secrets from the New Science of Expertise 이다. 그리고 안데르스 에릭슨(Anders Ericsson) 박사는 미국 심리학자이며 ‘1만 시간의 법칙’ 이론의 창시자이다.이 책은 '올바른 연습’이란 무엇이며, 효과적인 실천방법에 대해서 설명한다. 어느 분야에서나 통하는 보편적인 방법을 '의식적인 연습(deliberate practice)'이라고 한다. '의식적인 연습’을 통하면 누구나 최고의 경지에 오를 수 있다. 전반부에서는 '의식적인 연습’이란 무엇인지, 왜 효과적인지, 전문가들이 이것을 활용하여 비범한 능력을 만들어내는지를 설명한다. 그리고 후반부에서는 그동안 전문가 연구를 통해 '의식적인 연습’에 대해 터득한 모든 사항을 다룬다. 문제는 시간이 아니라 방법이다. ‘목적의식 있는 연습’은 단순한 연습을 벗어날 것을 요구한다. 단순한 연습이란 자신의 컴포트 존comfort zone’(편안삼을 느끼는 일정한 범위)을 말한다. '목적의식 있는 연습’에 요구되는 집중력과 노력을 유지하기 위해서는 지속적인 동기부여가 필요하다. 그럼 이쯤에서 '목적의식 있는 연습’을 아주 간결하게 설명해보겠다. 자신의 컴포트 존을 벗어나되 분명한 목표, 목표에 도달할 계획, 진척 정도를 추적 관찰할 수단을 가지고, 집중하여 매진하라. 아, 그리고 자신의 동기부여를 유지할 방법도 파악하라. (p. 61) 뇌는 쓰면 쓸수록 발달한다. 우리 뇌의 구조와 기능은 고정되어 있지 않다. 누구든지 의식적인 훈련, 의식적인 연습을 통해 원하는 방향으로 뇌의 구조를 변화시킬 수 있다. 특이한 실험 사례: 미국과 이스라엘의 신경과학자와 시각 연구자들이 2012년에 발표한 것으로, 노화로 인한 원시로 고생하는 사람이라면 누구든 효과를 볼 수 있을 방법이 나타나 있다. 실험 참자가들은 세 달 동안 일주일에 세 번 정도 연구실에 와서 30분씩 시력 훈련을 했다. 이들은 화면에서 작은 이미지를 찾아내는 훈련을 했다. 다만 이미지의 색과 배경의 색이 매우 흡사했는데, 다시 말해 찾아야 하는 이미지와 배경 상이에 대비가 거의 없었던 것이다. 따라서 이미지를 찾아내기 위해서는 강도 높은 집중력과 노력이 필요했다. 세 달이 지난 후 실험 참가자들은 훈련을 시작하기 전에 가능했던 것보다 60퍼센트 더 작은 글씨를 읽을 수 있었다. 3개월의 훈련으로 시력이 개선되었지만, 눈 자체의 변화에 따른 것은 아니었다. 수정체는 여전히 탄력 없고 경직된 상태를 유지하고 있었고, 초점 조절 장애도 있었다. 대신 눈을 통해 들어오는 시각 신호를 해석하는 뇌 부위에서 변화가 일어났고, 그 결과 보는 능력이 개선된 것이다. 인간의 육체는 안정된 상태를 선호하는 경향이 있다. 이런 현상을 가르켜 항상성이라고 한다. 우리 몸을 충분히 강하게 그리고 오랫동안 압박을 하면 몸은 그런 압박 자체가 편해지는 방향으로 변화한다. 그런 과정에서 우리 몸은 이전보다 강해지고, 지구력과 근육의 협응력도 커진다. 하지만 압박의 강도를 계속 높이지 않으면, 우리 몸은 새로 얻은 항상성에 안주하게 된다. 최근 연구에 따르면 뇌의 구조 변화를 유발하는 데 새로운 기술을 익히는 것이 이미 아는 기술을 계속 연습하는 것보다 훨씬 효과적이라는 사실이 밝혀졌다. 그러나 한편으로 압박의 강도와 기간이 지나치면 극도의 피로와 함께 학습 효율이 오히려 떨어진다. 몸과 마찬가지로 뇌도 컴포트 존 밖으로 밀어내는, 그렇지만 너무 멀리 밀어내지는 않는 최적의 지검, 구기 종목에서 공이 가장 잘 맞는 지검을 가리키는 ‘스위트 스폿 sweet spot’에서 가장 빠르게 변화한다. -p.88 최고의 훈련 방법 첫째, 다른 사람들이 방법을 알고 있고, 그것을 위한 효과적인 훈련 기법이 수립되어 있는 기술을 연마한다. 그리고 이런 능력을 개발할 방법도 잘 알고 있는 교사나 코치가 프로그램을 설계하고 실행 과정을 감독한다. 둘째, 개인의 컴포트 존을 벗어난 지점에서 진행되며, 배우는 사람은 자신의 현재 능력을 살짝 넘어서는 작업을 지속적으로 시도해야 한다. 말하자면 개인의 최대치에 가까운 노력이 요구되는 것인데, 최대치에 가까운 노력을 하기란 일반적으로 즐겁지는 않은 일이다. 셋째, 명확하고 구체적인 목표를 가지고 진행된다. 다소 모호한, 전반적인 향상을 목표로 하지 않는다. 일단 전반적인 목표가 설정되면, 교사나 코치가 단계적인 작은 변화들을 달성할 훈련 계획을 세운다. 이렇게 작고 구체적인 부분을 목표로 하여 훈련하는 경우, 학생이 훈련의 성과를 쉽게 가시적으로 확인할 수 있다는 장점이 있다. 넷째, 신중하고 계획적이다. 즉, 개인이 온전히 집중하고 ‘의식적’으로 행동할 것을 요구한다. 단순히 교사나 코치의 지시를 따르는 것만으로는 충분하지 않다. 학생은 연습의 구체적인 목표에 집중해서 연습에 적응하고 연습을 통제할 수 있어야 한다. 다섯째, 피드백과 피드백에 따른 행동 변경을 수반한다. 훈련 초기에는 교사나 코치가 진행과정을 모니터하고, 문제점을 지적하고, 해결방법을 제시한다. 시간이 흐르고 경험이 쌓이면서 학생이 스스로를 모니터하고, 실수를 발견하고, 수정해 나간다. 이렇게 스스로를 모니터하고 개선점을 찾으려면 효과적인 심적 표상(물체, 문제, 일의 상태 등에 관한 지식이 마음에 저장되는 방식)이 있어야 한다. 여섯째, 효과적인 심적 표상을 만들어내는 한편으로 거기에 의존한다. 수행능력 향상은 심적 표상의 발전과 밀접히 관련되어 함께 이루어진다. 개인의 수행능력이 향상되면, 표상이 한층 상세해지고 효과적이 되며, 다시 이로 인해 수행능력이 향상된다. 심적 표상은 또한 개인이 연습과 실전 모두에서 스스로를 모니터할 수 있게 해 준다. 심적 표상 덕분에 개인은 올바른 수행 방법을 알 수 있고, 거기서 벗어나는 순간 이를 파악하고 바로잡을 수 있다. 일곱째, 기존에 습득한 기술의 특정 부분을 집중적으로 개선함으로써 이를 한층 발전시키거나 수정하는 과정이 수반된다. 시간이 흐르면서 이런 단계적인 발전이 결국에는 전문가 수준의 수행능력으로 이어진다. 기존의 기술을 토대로 새로운 기술을 학습하는 이런 방식 때문에 교사나 코치가 초보자에게 정확한 기본 기술을 가르쳐주는 것이 중요하다. 상급 수준에 올라가서 기본 기술을 다시 배워야하는 불상사가 일어나지 않게 하기 위해서다. 1만 시간을 연습하면 누구나 천재가 될 수 있습니다. 단순 반복 연습보다는 목표를 계속 높여가며 의식적인 연습을 한다. 연습 결과에 대한 피드백이 필요하다. 감독 코치가 있으면 좋다. 지속적인 동기부여가 필요하다. 책을 한 번 더 읽어볼 계획입니다. 한번만 읽었더니 후반부는 아직 기억하지 못한 내용이 많네요.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"안데르스 에릭슨","slug":"안데르스-에릭슨","permalink":"https://anpigon.github.io/tags/안데르스-에릭슨/"},{"name":"1만 시간의 법칙","slug":"1만-시간의-법칙","permalink":"https://anpigon.github.io/tags/1만-시간의-법칙/"}],"author":"steemory"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #7","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-7","date":"2019-02-15T01:52:18.000Z","updated":"2019-11-11T13:41:49.822Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-7/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-7/","excerpt":"이더리움 지갑 만들기 마지막 강좌입니다.이번에는 지갑키로 전자서명을 수행합니다. 그리고 테스트넷에서 이더를 출금(송금)합니다.아래는 완성된 앱 동작 화면입니다. 지갑에 필요한 기본적인 기능(지갑 생성, 입금, 출금)이 모두 구현되어 있습니다.* * * 전자서명 화면 만들기","text":"이더리움 지갑 만들기 마지막 강좌입니다.이번에는 지갑키로 전자서명을 수행합니다. 그리고 테스트넷에서 이더를 출금(송금)합니다.아래는 완성된 앱 동작 화면입니다. 지갑에 필요한 기본적인 기능(지갑 생성, 입금, 출금)이 모두 구현되어 있습니다.* * * 전자서명 화면 만들기 아래와 같이 전자서명을 수행하는 화면을 만듭니다. ConfimTxScreen.js 파일을 생성합니다. 코드가 내용이 너무 많아서, 핵심 코드만 가져와서 설명합니다. 전체 코드 내용은 ConfimTxScreen.js를 확인하시기 바랍니다. ./src/components/ConfimTxScreen.js 123456789101112131415161718192021222324252627282930313233343536export default class ConfimTxScreen extends Component ｛ constructor(props) ｛ super(props); const ｛ fromAddress, toAddress, gasPrice, gasLimit, value ｝ = props.navigation.state.params; // 수수료(가스비) 계산(가스가격 * 가스사용량) let estimateFee = ethers.utils.bigNumberify(gasPrice).mul(gasLimit); // 가스가격(gwei)를 ether 단위로 변환 let fee = ethers.utils.formatUnits(estimateFee, 'gwei').toString(); // 필요한 총 금액 계산(출금금액 + 수수료) let totalAmount = ethers.utils.parseEther(value).add(ethers.utils.parseEther(fee)); totalAmount = ethers.utils.formatEther(totalAmount).toString(); this.state = ｛ loading: false, // 로딩 화면 출력 여부 fromAddress, // 보내는 주소 toAddress, // 받는 주소 gasPrice, // 가스 가격 gasLimit, // 가스 최대 사용량 value, // 출금 금액 fee, // 수수료 totalAmount, // 총 금액 ｝ ｝｝ ConfimTxScreen 클래스의 생성자 함수 constructor()부터 살펴봅니다. 이전 화면에서 전달 받은 props.navigation.state.params 에서 데이터를 가져옵니다. 그리고 출금하는데 필요한 네트워크 비용(가스비) estimateFee를 계산합니다. 마지막으로 내 지갑에서 빠져나가는 총 금액(출금 금액 + 수수료) totalAmount을 계산합니다. 그다음은 실제 서명을 수행하는 함수 sign()를 살펴봅니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export default class ConfimTxScreen extends Component ｛ sign = async () =&gt; ｛ // 로딩 이미지 출력 this.setState(｛ loading: true ｝); let ｛ fromAddress, toAddress, gasPrice, gasLimit, value ｝ = this.state; // #1. ropsten 테스트넷 provider 생성 let provider = ethers.getDefaultProvider('ropsten'); // #2. nonce 값 조회(거래 시퀀스 번호, 0부터 시작하여 거래할때 마다 증가) let nonce = await provider.getTransactionCount(fromAddress); console.log(｛ nonce ｝); // #3. Transaction 데이터 생성 let transaction = ｛ to: toAddress, value: ethers.utils.parseEther(value), // ehter =&gt; wei gasPrice: ethers.utils.parseUnits(gasPrice, 'gwei'), // gwei =&gt; wei gasLimit: ethers.utils.bigNumberify(gasLimit), nonce: nonce, data: '' ｝; // #4. 개인키(서명키) 조회 let privateKey = await RNSecureKeyStore.get(fromAddress); // #5. 서명을 수행할 지갑 생성 let wallet = new ethers.Wallet(privateKey); // #6. 이더리움 Transaction 서명하기 let sign = await wallet.sign(transaction); // #7. 서명된 이더리움 Transaction 배포하기 try ｛ const tx = await provider.sendTransaction(sign); // #8. 완료 화면으로 이동 this.props.navigation.navigate('CompleteScreen', tx.hash); ｝ catch(error) ｛ console.log(error); Alert.alert('ERROR', `$｛error.code｝\\n$｛error.message｝`); ｝ this.setState(｛ loading: false ｝); ｝｝ 승인 버튼을 누르면 sign() 함수가 실행될 것입니다. sign() 함수에서는 지갑키로 트랜잭션을 서명하고 배포합니다. 자세한 설명은 주석으로 대신하겠습니다. 전체 코드 내용은 ConfimTxScreen.js를 확인하세요. 추가로, ethers에는 서명과 배포를 좀 더 간단하게 하는 방법도 있습니다. 지갑(Wallet)을 생성할때 provider 와 함께 지갑을 생성하면, 아래와 같이 짧은 코드로도 서명 함수 구현이 가능합니다. 123456789101112// provider 연결과 함께 지갑 생성let provider = ethers.getDefaultProvider();let wallet = new ethers.Wallet(privateKey, provider);// transaction 생성let transaction = ｛ to: \"0x88a5c2d9919e46f883eb62f7b8dd9d0cc45bc290\", value: ethers.utils.parseEther('1.0')｝// 지갑으로 서명하고 서명값을 서버에 보내기let tx = await wallet.sendTransaction(transaction); 참고로 transaction에 필요한 나머지값들은 자동으로 채워집니다. 거래 완료 화면 만들기 다음은 거래 완료을 만듭니다. 아래와 같이 거래가 완료되면, 화면에 TX Hash가 출력됩니다. 그리고 TxHash를 눌렀을때, etherscan.io로 연결하면 더 좋을 것 같습니다. CompleteScreen.js 파일을 생성합니다. ./src/components/CompleteScreen.js 123456789101112131415161718192021222324252627282930313233343536import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View, Slider, TouchableOpacity, Alert, AsyncStorage, Image, BackHandler ｝ from 'react-native';import ｛ Container, Spinner, Content, Header, Card, CardItem, Body, Text, Icon, Button, Left, Right, Thumbnail, Title, Toast, Form, Item, Input, Label ｝ from 'native-base'; export default function(props) ｛ const hash = props.navigation.state.params; return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛ flex: 1, marginTop: 50 ｝｝&gt; &lt;View style=｛｛ alignItems:'center', justifyContent:'space-evenly', marginHorizontal: 25, height: 300 ｝｝&gt; &lt;Icon name='checkcircle' type='AntDesign' style=｛｛color:'#2c952c', fontSize: 150｝｝ /&gt; &lt;Text&gt;거래가 완료되었습니다.&lt;/Text&gt; &lt;TouchableOpacity&gt; &lt;Text note style=｛｛ color:'#07C', textDecorationLine: 'underline' ｝｝&gt;｛hash｝&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛ marginHorizontal: 10, marginBottom: 30 ｝｝&gt; &lt;Button block onPress=｛() =&gt; ｛ props.navigation.popToTop(); ｝｝&gt; &lt;Text&gt;확인&lt;/Text&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/Container&gt; )｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, backgroundColor: 'white', justifyContent: 'space-between' ｝,｝); CompleteScreen는 함수형(function) 컴포넌트로 구현하였습니다. 함수형 컴포넌트가 클래스형 컴포넌트 보다 렌더링 속도가 조금 더 빠릅니다. 전달 받은 props.navigation.state.params 에서 tx hash 를 가져와서 화면에 출력합니다. 그리고 확인 버튼을 누르면 최상위 화면으로 이동합니다. props.navigation.popToTop() * * * 이더리움 지갑 만들기 강좌를 시작한지 벌써 2주가 지났습니다. 시간이 정말 금방 지나갑니다. 여기서 더 구현한다면 이더리움 토큰(ERC20) 지갑을 만들고, 백업과 인증(보안) 쪽을 좀 더 보완하고 싶습니다. 아, 그리고 거래 기록도 보여줘야겠네요. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[세바시] 괴로움을 즐거움으로 바꾸는 글쓰기 | 김민식 ‘매일 아침 써봤니?’ 저자, MBC 드라마 PD | 강의 강연 글쓰기 기초 강좌 | 세바시 899회","slug":"/kr/@steemory/or-mbc-pd-or-or-899","date":"2019-02-14T09:20:27.000Z","updated":"2019-11-11T13:41:49.856Z","comments":true,"path":"/kr/@steemory/or-mbc-pd-or-or-899/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/or-mbc-pd-or-or-899/","excerpt":"인생이 괴로울땐 인상을 쓰지 말고 글을 써야 한다. 글쓰기의 3단계첫번째, 오늘의 괴로움을 씁니다. 괴로울때 마다 글을 씁니다. 글에는 치유의 힘이 있습니다. 글을 쓰다보면 마음이 조금 풀립니다. 두번째, 내일을 위해 오늘의 계획과 꿈을 씁니다. 내일 내가 되고 싶은 나의 꿈에 대해서 글을 씁니다. 좋은 피드백과 조언을 받을 때 사람은 성장합니다. 나의 괴로움을 쓴 글을 2~3일 후에 다시 읽습니다. 그리고 내 자신 스스로에게 조언을 합니다.","text":"인생이 괴로울땐 인상을 쓰지 말고 글을 써야 한다. 글쓰기의 3단계첫번째, 오늘의 괴로움을 씁니다. 괴로울때 마다 글을 씁니다. 글에는 치유의 힘이 있습니다. 글을 쓰다보면 마음이 조금 풀립니다. 두번째, 내일을 위해 오늘의 계획과 꿈을 씁니다. 내일 내가 되고 싶은 나의 꿈에 대해서 글을 씁니다. 좋은 피드백과 조언을 받을 때 사람은 성장합니다. 나의 괴로움을 쓴 글을 2~3일 후에 다시 읽습니다. 그리고 내 자신 스스로에게 조언을 합니다. 세번째, 오늘 한 나의 노력에 대해 씁니다. 오늘 내가 한 노력에 대해서 글을 씁니다. 매일 매일 쌓인 노력에 대한 기록을 보았을 때, 내 스스로 멋있는 사람이라는 것을 확인 할 수 있습니다. 그리고 자신감이 생깁니다. 핵심은 이것인 것 같습니다. 괴로움을 글로 쓰자. 내가 쓴 글을 읽고 나 자신에게 조언과 충고를 합니다. 그러면 스스로 괴로움을 치유할 수 있습니다. 노력에 대한 기록을 글로 쓰자. 목표를 정하고 매일 매일 기록합니다. 그리고 스스로 뿌듯함을 느끼고 자신감이 생깁니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"세바시","slug":"세바시","permalink":"https://anpigon.github.io/tags/세바시/"}],"author":"steemory"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #6","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-6","date":"2019-02-13T02:01:45.000Z","updated":"2019-11-11T13:41:49.822Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-6/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-6/","excerpt":"이번에는 이더리움 출금 화면을 만들어 봅니다. 하지만 이더리움을 출금하기 위해서는 지갑에 이더(Ether)가 있어야 합니다. 구현하기 전에 Ropsten Testnet Faucet 사이트에 접속합니다. 그리고 이더(Ether) 요청을 하여 받아보겠습니다. 테스트넷 이더 받기","text":"이번에는 이더리움 출금 화면을 만들어 봅니다. 하지만 이더리움을 출금하기 위해서는 지갑에 이더(Ether)가 있어야 합니다. 구현하기 전에 Ropsten Testnet Faucet 사이트에 접속합니다. 그리고 이더(Ether) 요청을 하여 받아보겠습니다. 테스트넷 이더 받기 아래 사이트를 이용하면 테스트넷의 이더(Ether)을 받을 수 있습니다. 이더리움 주소를 입력하고 Send me test Ether 버튼을 클릭하면 수십 초 내에 이더(Ether)가 입금됩니다. 참고로, 우리는 Ropsten Testnet 에서 지갑앱을 구현합니다. https://faucet.ropsten.be 또는, 메타마스크에서 제공하는 https://faucet.metamask.io를 이용할 수도 있습니다. faucet.metamask.io를 이용하려면 크롬브라우저에 메타마스크(metamask)가 설치되어 있어야 합니다. 메타마스크 설치를 하려면 여기를 클릭하세요. 이더리움 잔액 조회하기 이제 지갑 목록에 이더리움 잔액을 보여줄 것입니다. components/WalletScreen.js 파일을 수정합니다. ./src/components/WalletScreen.js 1234567891011121314151617181920212223242526272829303132333435363738import // (...)import ｛ ethers ｝ from 'ethers'; // 추가된 코드export default class WalletsScreen extends Component ｛ static navigationOptions = ｛ // (…) ｝ constructor(props) ｛ // (…) ｝ _onWillFocus = payload =&gt; ｛ // (…) ｝ render() ｛ // (…) ｝ componentWillMount() ｛ // 1. provider 생성 let provider = ethers.getDefaultProvider('ropsten'); const pollingInterval = 20 * 1000; //20초 this.poller = setInterval(() =&gt; ｛ const wallets = [...this.state.wallets]; // 2. 지갑 잔액 조회 시작 wallets.forEach(wallet =&gt; ｛ provider.getBalance(wallet.address).then((balance) =&gt; ｛ // 이더리움 잔액 wei를 ehter로 변환 const etherString = ethers.utils.formatEther(balance); wallet.balance = etherString; ｝); ｝); // 3. 지갑 목록 화면 갱신 및 Storage 업데이트 this.setState(｛ wallets ｝, () =&gt; ｛ AsyncStorage.setItem('WALLETS', JSON.stringify(wallets)); ｝); ｝, pollingInterval); // 20초 마다 수행 ｝ // componentWillMount ｝ WalletsScreen 클래스에 componentWillMount() 함수가 추가되었습니다. ethers를 사용하여 Ropsten 테스트넷의 provider를 생성합니다. ethers의 사용 방법은 ether API 문서를 참고합니다. 지갑 잔액 조회는 setInterval() 함수를 사용하여 폴링하도록 구현하였습니다. 그리고 20초마다 폴링하도록 pollingInterval에 20000을 입력하였습니다. 참고로, Events 방식으로 구현하여 잔액을 표시할 수도 있습니다. 일단은 구현을 간단하게 하기위헤서 폴링으로 구현하였습니다. 그리고 잔액 조회가 완료되면, 화면을 갱신하고 Storage을 업데이트 합니다. 앱을 실행해보면, 이더리움 첫번째 지갑에 1.0 ETH가 보입니다. 출금 화면 만들기 아래 이미지는 이번에 만들 출금 화면입니다. 이체 금액, 받는 주소, 가스 수수료를 입력할 수 있습니다. components/SendScreen.js 파일을 생성합니다. 코드 내용이 너무 많아서 일부만 가져와서 설명합니다. SendScreen.js 파일의 전체 코드 내용은 여기에 업로드 되어 있습니다. ./src/components/SendScreen.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import // (...)export default class ReceiveScreen extends Component ｛ static navigationOptions = // (...) constructor(props) ｛ // (...) ｝ // 이더리움 주소 체크 함수 checkAddress = (address) =&gt; ｛ if (!/^(0x)?[0-9a-f]｛40｝$/i.test(address)) ｛ return false; ｝ return true; ｝; // 다음 버튼을 눌렀을때 next = () =&gt; ｛ let ehter = 0; try ｛ // 이더(Ehter) 단위 금액을 Wei로 변환 ehter = ethers.utils.parseEther(String(this.state.value || 0)); if(ehter.lte(0)) ｛ // 0보다 작으면 return Alert.alert('이체 금액을 확인해주세요.'); ｝ // 가스비(수수료) 계산 let estimateFee = ethers.utils.parseUnits(this.state.gasPrice, 'gwei').mul(String(this.state.gasLimit)); // 이체하는데 필요한 총 금액 계산(이체 금액 + 가스비) let totalRequiredAmount = ehter.add(estimateFee); // 잔액이 이체에 필요한 금액보다 작으면... let balance = ethers.utils.parseEther(wallet.balance); if(balance.lt(totalRequiredAmount)) ｛ let totalRequiredEther = ethers.utils.formatEther(totalRequiredAmount); return Alert.alert('잔액이 부족합니다.', `수수료 포함하여 필요한 금액\\n$｛totalRequiredEther｝ ETH`); ｝ ｝ catch(e) ｛ return Alert.alert('이체 금액을 확인해주세요.'); ｝ // 받는 주소 검증 try ｛ if(!this.checkAddress(this.state.toAddress)) ｛ return Alert.alert('받는 주소를 확인해주세요.'); ｝ ｝ catch(e) ｛ return Alert.alert('받는 주소를 확인해주세요.'); ｝ Alert.alert('ok'); ｝ render() ｛ // (...) ｝｝ 다음 버튼을 누르면 next() 함수가 호출 될 것입니다. render() 구현부가 위의 코드에는 생략되어 있습니다. 전체 코드를 참고하시기 바랍니다. next() 함수에서는 이더리움 주소 유효성 검사와 수수료 계산, 잔액 체크를 하고 있습니다. 모든 유효성 검사가 완료되면 알럿 메세지로 OK가 출력될 것입니다. 그리고 필요한 가스비와 이더리움 주소 유효성 검사는 아래에서 더 설명합니다. 마지막으로 App.js와 components/WalletInfoScreen.js 파일을 수정합니다. 다음은 수정한 부분의 일부 코드만 가져왔습니다. ./src/App.js 12345678const AppStackNavigator = createStackNavigator(｛ Wallets: ｛ screen: WalletsScreen ｝, // 지갑 목록 CreateWallet: ｛ screen: CreateWalletScreen ｝, // 지갑 생성 WalletInfo: ｛ screen: WalletInfoScreen ｝, // 지갑 정보 ReceiveScreen: ｛ screen: ReceiveScreen ｝, // 지갑 입금 SendScreen: ｛ screen: SendScreen ｝, // 지금 출금 (추가된 코드)// (...) App 네이게이터에 SendScreen: ｛ screen: SendScreen ｝ 가 추가되었습니다. ./components/WalletInfoScreen.js 12345678910111213141516171819202122232425262728export default class WalletInfoScreen extends Component ｛ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;Header&gt;(...)&lt;/Header&gt; &lt;Content padder&gt; &lt;Card transparent&gt; &lt;CardItem&gt;(...)&lt;/CardItem&gt; &lt;CardItem&gt;(...)&lt;/CardItem&gt; &lt;CardItem&gt;(...)&lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛｛ flexDirection: 'row', justifyContent: 'space-around'｝｝&gt; &lt;Button (...)&gt;&lt;Text&gt;입금&lt;/Text&gt;&lt;/Button&gt; &lt;Button bordered warning style=｛｛flex:1, justifyContent:'center', marginLeft: 10｝｝ onPress=｛() =&gt; this.props.navigation.navigate('SendScreen', wallet)｝&gt; &lt;Text&gt;출금&lt;/Text&gt; &lt;/Button&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝ 출금 버튼에 onPress=｛() =&gt; this.props.navigation.navigate('SendScreen', wallet)｝ 를 추가합니다. 이제 출금 버튼을 누르면 SendScreen 화면으로 이동할 것입니다. 여기까지 이더리움 지갑 잔액 조회와 입금 화면을 개발하였습니다. 아래에는 이더리움 주소 유효성 체크 방법과 이더리움 가스비에 대해서 더 설명합니다. * * * 이더리움 주소 유효성 검사 방법 이더리움 주소는 0x로 시작합니다. 그리고 40바이트의 영문자+숫자로 구성됩니다. 사실 **EIP-55 체크섬(checksum)**이 포함된 이더리움 주소도 검사해야 합니다. 하지만 이번 구현 코드에서는 포함하지 않았습니다. 이더리움 체크섬 주소의 유효성 검사를 포함한 코드는 아래를 참고하세요. 123456789101112131415161718192021222324252627282930313233const Hash = require('eth-lib/lib/hash');function checkAddressChecksum(address) ｛ // #1. 40바이트의 영문자+숫자로 구성되어 있는지 검사합니다. if (!/^(0x)?[0-9a-f]｛40｝$/i.test(address)) ｛ return false; ｝ // #2. EIP-55 체크섬이 포함되어 있지 않은 주소의 경우에는 true를 반환합니다. else if (/^(0x|0X)?[0-9a-f]｛40｝$/.test(address) || /^(0x|0X)?[0-9A-F]｛40｝$/.test(address)) ｛ return true; ｝ // #3. EIp-55 체크섬이 포함된 주소의 유효성을 검사합니다. else ｛ // 이더리움 주소를 keccak256 해시하여, // 주소와 매칭되는 해시의 16진수가 0x8 이상인 경우에 대문자인지 비교합니다. address = address.replace(/^0x/i, ''); const addressHash = Hash.keccak256(address.toLowerCase()).replace(/^0x/i, ''); for (let i = 0; i &lt; 40; i++) ｛ if ( (parseInt(addressHash[i], 16) &gt; 7 &amp;&amp; address[i].toUpperCase() !==address[i]) || (parseInt(addressHash[i], 16) &lt;= 7 &amp;&amp; address[i].toLowerCase() !==address[i]) )｛ return false; ｝ // if ｝ // for ｝ return true;｝ 이더리움 주소를 keccak256 해시하기 위해서, eth-lib 모듈의 keccak256() 함수를 사용하였습니다. 이더리움 가스비 알아내기 이더리움으로 거래(Transatcion)를 하기 위해서는 수수료(가스비)가 필요합니다. 그리고 가스 스테이션 서비스(https://ethgasstation.info)를 이용하면, 현재 메인넷의 가스비를 알 수 있습니다. 확인해보면, 현재 지출되고 있는 가스비가 1.1 ~ 7 사이 라는 것을 알 수 있습니다. 그리고 다음은 가스비를 조회할 수 있는 API 정보입니다. https://github.com/ethgasstation/ethgasstation-api https://www.etherchain.org/api/gasPriceOracle https://ethgasstation.info/json/ethgasAPI.json 지금 구현한 지갑앱에서는 가스비를 코드상에 값을 하드 코딩하였습니다. 나중에서는 API 서비스에서 조회하여 가스비를 유동적으로 보여줄 필요가 있을 것 같습니다. 추가로 ethers에서 제공하는 provider.getGasPrice() 함수를 사용하면, 평균 가스비를 가져올 수 있습니다. 여기까지 구현한 전체 코드는 모두 깃허브에 업로드 되어있습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[세바시] 글쓰기를 잘할 수 있는 3가지 비법 | 고영성 '일취월장', '완벽한 공부법' 저자 체인지그라운드 고문 | 세바시 900회 | 글쓰기 강연 듣기","slug":"/kr/@steemory/3-or-or-900-or","date":"2019-02-13T01:28:18.000Z","updated":"2019-11-11T13:41:49.856Z","comments":true,"path":"/kr/@steemory/3-or-or-900-or/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/3-or-or-900-or/","excerpt":"모순투성이이기 때문에 더욱 더 내 나라를 사랑하는 본 피고인은, 불의가 횡행하는 시대라면 언제 어디서나 타당한 격언인 네크라소프의 시구로 이 보잘것없는 독백을 마치고자 합니다. “슬픔도 노여움도 없이 살아가는 자는 조국을 사랑하고 있지 않다” - ‘1985년 5월 27일 성명 유시민’ [유시민의 항소이유서 전체보기]","text":"모순투성이이기 때문에 더욱 더 내 나라를 사랑하는 본 피고인은, 불의가 횡행하는 시대라면 언제 어디서나 타당한 격언인 네크라소프의 시구로 이 보잘것없는 독백을 마치고자 합니다. “슬픔도 노여움도 없이 살아가는 자는 조국을 사랑하고 있지 않다” - ‘1985년 5월 27일 성명 유시민’ [유시민의 항소이유서 전체보기] ![](https://steemitimages.com/p/2xVmzkbNCvpxFuJEEiPwkVxj4pHgMZAZywFAaoRemXS8uUYNtSrnPZAJJpaPDRQAZBAtYRYDsEoQRBUZFt6b1FBU1CCrVMZSqQk6bFBXrPqKqyJAooVD3RqyyfsMyWoUKrsAXN93vK97WnpdUPCjzDGtprWVYHXzSWtu5ESERrv4yS1tuTqy9fBnYJ47S7XQVQKDeH2w) 글쓰기를 두려워하지 마라 첫째, 재능없음을 두려워하지 마라. 누구든지 제대로된 방법으로 연습하면 글쓰기를 잘 할 수 있다. 의식적인 연습(올바른 노력 방법)으로 임계치가 넘는 노력을 하게 되면 전문가 반열에 오를 수 있다. - '1만 시간의 법칙’의 창시자 안데르스 에릭슨 박사 둘째, 맞춤법을 두려워하지 마라. 우리의 인지 자원은 한정되어 있다. 한정된 인지 자원은 모두 글 쓰는데 몰입 해야 한다. 맞춤법에 신경 쓰지 말자. 셋째, 수준 낮은 글을 쓸까 봐 두려워하지 마라. 못난 글도 계속 쓰다 보면, 그중에서 잘난 글이 나온다. 글쓰기의 시작은 독서이다. 글쓰기를 잘 하려면 독서를 많이 해야한다. 좋은 자료가 많을수록 좋은 글이 나올 확률이 높다. 글은 자신이 제기하고자 하는 주제의 근거를 제시하고 그 타당성을 입증해 보이는 싸움이다. 이 싸움은 좋은 자료를 얼마나 많이 모으느냐에 성패가 좌우된다. 자료가 충분하면 그 안에 반드시 길이 있다. 자료를 찾다보면 새로운 생각이 떠오른다. 때로는 애초에 의도했던 방향과 전혀 다른 쪽으로 글이 써지기도 한다. 글은 자료와 생각의 상호작용이 낳은 결과다. - ‘대통령의 글쓰기’ 저자 강원국 작가 3S 전법 첫 번째, Short 문장을 짧게 쓴다. 문장은 짧을수록 의미 전달력이 높다. 두 번째, Stroy 뇌는 스토리를 좋아한다. 어떤 주제나 교훈이 스토리에 담겨 전달될 때 기억에 잘 남는다. **최고의 스토리는 자신의 이야기이다.**자신의 이야기를 자신이 할 때 진정성이 있다. 진정성은 독자의 마음을 여는 힘이 있다. 리마커블한(이야기할 만한 가치가 있는) 스토리를 자신의 글에 접목해 써본다. 세 번쨰, Seat 그냥 무작정 글을 써본다. 나는 가능하면 글은 매일 쓰려고 노력한다. 영감이 오길 기다린다면 글을 한 줄도 쓰지 못할 것이다. - 알랭 드 보통(Alain de Botton) ![](https://steemitimages.com/p/2xVmzkbNCvpxFuJEEiPwkVxj4pHgMZAZywFAaoRemXS8uUYNtSrnPZAJJpaPDRQAZBAtYRYDsEoQRBUZFt6b1FBU1CCrVMZSqQk6bFBXrPqKqyJAooVD3RqyyfsMyWoUKrsAXN93vK97WnpdUPCjzDGtprWVYHXzSWtu5ESERrv4yS1tuTqy9fBnYJ47S7XQVQKDeH2w) 제 생각으로 중요 핵심은 이것인 것 같습니다. 독서를 많이 하자. 아무 글이나 많이 써보자. 자신의 이야기를 글로 표현해보자.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"세바시","slug":"세바시","permalink":"https://anpigon.github.io/tags/세바시/"}],"author":"steemory"},{"title":"[React Native] 쌩광부님의 이더리움 모바일 지갑 만들기 강좌 소개","slug":"/kr/@anpigon/34xdqb-react-native","date":"2019-02-11T04:49:54.000Z","updated":"2019-11-11T13:41:49.822Z","comments":true,"path":"/kr/@anpigon/34xdqb-react-native/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/34xdqb-react-native/","excerpt":"**“리액트 네이티브 이더리움 모바일 지갑 만들기”**가 잘 정리되어 있는 블로그가 있어서 소개합니다.관련 자료를 찾다 보니 저보다 먼저 이더리움 지갑 만들기 포스팅을 올리신 분이 있었네요. 초보자가 쉽게 따라 할 수 있도록 쉽게 잘 정리되어 있습니다. 쌩광부님의 모바일 지갑 만들기 강좌","text":"**“리액트 네이티브 이더리움 모바일 지갑 만들기”**가 잘 정리되어 있는 블로그가 있어서 소개합니다.관련 자료를 찾다 보니 저보다 먼저 이더리움 지갑 만들기 포스팅을 올리신 분이 있었네요. 초보자가 쉽게 따라 할 수 있도록 쉽게 잘 정리되어 있습니다. 쌩광부님의 모바일 지갑 만들기 강좌 [강좌] 쌩광부의 모바일 지갑 만들기 (프롤로그) [강좌] 쌩광부의 모바일 지갑 만들기 #1. React Native 설치하기 [강좌] 쌩광부의 모바일 지갑 만들기 #2. Navigation 만들기 [강좌] 쌩광부의 모바일 지갑 만들기 #3. Navigation 완성하기 [강좌] 쌩광부의 모바일 지갑 만들기 #4. 이더리움 계열 지갑 만드는 방법 [강좌] 쌩광부의 모바일 지갑 만들기 #5. React Native AsyncStorage [강좌] 쌩광부의 모바일 지갑 만들기 #6. 니모닉 지갑 생성 [강좌] 쌩광부의 모바일 지갑 만들기 #7. 지갑 불러오기 이미지 출처: https://www.ddengle.com/@TopMining","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[React Native] 동킹콩 모바일 게임 만들기","slug":"/kr/@anpigon/react-native","date":"2019-02-10T04:53:36.000Z","updated":"2019-11-11T13:41:49.814Z","comments":true,"path":"/kr/@anpigon/react-native/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native/","excerpt":"이번에는 리액트 네이티브로 모바일 게임을 만들어 보겠습니다. 이미 잘 만들어진 게임 샘플 코드를 가져와서 빌드하는 과정이라서 어렵지는 않습니다. 매우 간단합니다.최근에 출시되는 모바일 게임은 대부분 unity로 개발되어 있습니다. 하지만 리액트 네이티브로도 모바일 게임 개발이 가능합니다. react-native-game-engine를 설치하면 리액트 네이티브에서 모바일 게임을 만들수 있습니다.","text":"이번에는 리액트 네이티브로 모바일 게임을 만들어 보겠습니다. 이미 잘 만들어진 게임 샘플 코드를 가져와서 빌드하는 과정이라서 어렵지는 않습니다. 매우 간단합니다.최근에 출시되는 모바일 게임은 대부분 unity로 개발되어 있습니다. 하지만 리액트 네이티브로도 모바일 게임 개발이 가능합니다. react-native-game-engine를 설치하면 리액트 네이티브에서 모바일 게임을 만들수 있습니다. 이런 게임을 만들 수 있습니다. 추억 돋네요. ㅎㅎ 출처: https://github.com/bberak/react-native-donkey-kong * * * React Native 프로젝트 생성하기 먼저, my-donkey-kong-game이라는 프로젝트 폴더를 생성합니다. 1$ expo-cli init my-donkey-kong-game expo-cli는 expo 설치 가이드 문서를 참고하여 설치해주세요. Choose a template에서 blank를 선택합니다. Choose which workflow to use에서 **managed(default)**를 선택합니다. 마지막으로 expo.name에 앱 이름을 입력합니다. 저는 “My Donkey Kong Game” 이라고 입력하였습니다. 엔터를 입력하면 프로젝트 생성이 시작됩니다. 필요한 모듈을 다운로드하고 설치하는데 시간이 조금 소요됩니다. DonkeyKong 모듈 설치하기 프로젝트 폴더 생성이 완료되면, react-native-donkey-kong를 설치합니다. react-native-donkey-kong는 이미 완성되어 있는 게임 모듈입니다. 123$ cd my-donkey-kong-game$ npm install --save react-native-donkey-kong$ npm install 마지막으로 App.js를 수정합니다. 12345678import React, ｛ Component ｝ from \"react\";import DonkeyKong from \"react-native-donkey-kong\";export default class App extends Component ｛ render() ｛ return &lt;DonkeyKong /&gt;; ｝｝ react-native-donkey-kong에서 DonkeyKong를 import 합니다. 그리고 render()함수에서 &lt;DonkeyKong/&gt;를 return 해주면 끝입니다. 게임 실행하기 이제 게임 앱을 실행합니다. 1$ npm start 아래는 실제 빌드되어 실행한 게임 화면입니다. 터치를 슬라이드하면 케릭이 움직입니다. 키패드 방식이 아니라서 조작하기가 매우 어렵네요. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"⟪이공계의 뇌로 산다⟫ 완웨이강","slug":"/kr/@steemory/4pzkd5","date":"2019-02-09T17:32:27.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@steemory/4pzkd5/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/4pzkd5/","excerpt":"세상을 깊이 있고 유용하게 살아가기 위한 과학적 사고의 힘 너무 과학적인 내용이 담긴 전문적인 내용은 아닙니다. 다양한 이론을 이해하기 쉽게 재미있게 잘 풀어서 설명하고 있습니다. 책에 소개된 내용이 대부분 알고 있는 것과 상반되는 것이기 때문에 잘못된 고정관념을 바로 잡아 줍니다. 책에 소개된 새로운 것들은 모두 과학실험을 거쳐 얻은 결론이기 때문에 신뢰가 갑니다.","text":"세상을 깊이 있고 유용하게 살아가기 위한 과학적 사고의 힘 너무 과학적인 내용이 담긴 전문적인 내용은 아닙니다. 다양한 이론을 이해하기 쉽게 재미있게 잘 풀어서 설명하고 있습니다. 책에 소개된 내용이 대부분 알고 있는 것과 상반되는 것이기 때문에 잘못된 고정관념을 바로 잡아 줍니다. 책에 소개된 새로운 것들은 모두 과학실험을 거쳐 얻은 결론이기 때문에 신뢰가 갑니다. 책 요약 1. 빠지기 쉬운 사고의 함정 인지과학 실험을 통해 얻은 인간의 인식을 다루고 있다. 인간의 인식 능력은 완벽하지 않기에 종종 편견을 갖게 된다. 하지만, 쉽게 빠지는 사고의 오류가 무엇인지 안다면 그것을 피할 수 있고 이성적으로 직관할 수 있을 것이다. 2. 과학적인 자기계발과 자기계발적인 과학 자기계발을 이야기한다. 자기계발에도 과학적인 법칙이 있으며, 자산의 장점을 발휘하고 단점을 극복해야 한다. 특정 분야의 고수가 되기 위해서는 과학적인 훈련이 필수적이다. 어떻게 공부하고 훈련해야 하는지에 대해 실천 가능한 노하우을 알려준다. 3. 이공계 멍청이들이 세상을 바라보는 방식 과학을 이야기한다. 과학적인 사고 방식을 알면 최소한 사기당할 확률을 낮출 수 있다. 오늘날 처럼 정보가 쏟아지는 시대에는 과학적인 사고를 해야 한다. 많은 과학 지식을 갖추고 과학연구에 종사한다고 해서 과학적인 사고력이 높아지는 것은 아니다. 원로 학자라도 엉뚱한 말을 하는 경우가 종종있다. 과학적인 사고방식은 모두에게 유용하다. 이 책은 과학적인 사고를 키울수 있게 도와준다. 책 발췌 노벨 경제학상 수상자 로버트 아우만이 1976년에 발표한 논문 &lt;다름에 대한 동의&gt;는 역사에 남을 걸작이라고 평가받는다. 그는 이 논문에서 이성적이고 진실한 두 명의 ‘진리 추구자’가 어떤 문제를 두고 논쟁한다면 그 필연적인 결과는 두 사람이 합의를 이루는 것이라고 지적한 바 있다. 그렇다면 반대로, 논쟁이 합의를 이루지 못하고 불쾌하게 끝났다면 그중 한 사람은 필연적으로 위선자일 수 밖에 없다. (p. 42) 심리학자들은 사람의 지식과 기능을 세 개의 동심원 구역으로 나눈다. 가장 안쪽은 ‘편안한 구역’으로, 우리가 이미 익숙하게 할 수 있는 각종 기능이 여기에 속한다. 가장 바깥쪽은 ‘공황 구역’으로, 우리가 금방 배울 수 없는 기능이 속해 있으며, 중간에 위치한 구역은 ‘학습 구역’이다. 효과적인 훈련은 반드시 훈련하는 사람의 학습 구역내에서 이루어져야 하며 목표가 명확해야 한다. 또 훈련하는 사람은 반드시 자신이 개선해야 할 부분을 수시로 파악해야 하나. 어떤 것을 이미 익혔다면 더 이상 거기에 시간을 쏟지 말고 어려운 부분을 공략해야 한다. (p. 144) 지식을 얻고 싶다면 가장 좋은 방법은 책을 보는 것이다. 그중에서도 정규 교과서나 유명 전공 서적이 가장 좋다. 사람이 없는 조용한 곳에 앉아 여러 번 읽고 필기하면서 내용을 정리하고, 연습문제를 풀어보며 피드백을 받아야 한다. (p. 186)","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"완웨이강","slug":"완웨이강","permalink":"https://anpigon.github.io/tags/완웨이강/"},{"name":"뇌과학","slug":"뇌과학","permalink":"https://anpigon.github.io/tags/뇌과학/"}],"author":"steemory"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #5","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-5","date":"2019-02-09T03:27:24.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-5/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-5/","excerpt":"이번에는 이더리움 지갑 상세 화면과 입금 화면을 만들 것입니다. 지갑 상세 화면 만들기지갑 상세 정보를 보여줄 화면을 만듭니다. 지갑 상세 화면에는 이더리움 잔액과 입금/출금 버튼을 보여 줄 것입니다. components/WalletInfoScreen.js 파일을 생성합니다.","text":"이번에는 이더리움 지갑 상세 화면과 입금 화면을 만들 것입니다. 지갑 상세 화면 만들기지갑 상세 정보를 보여줄 화면을 만듭니다. 지갑 상세 화면에는 이더리움 잔액과 입금/출금 버튼을 보여 줄 것입니다. components/WalletInfoScreen.js 파일을 생성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View, AsyncStorage ｝ from 'react-native';import ｛ Container, Content, Header, Card, CardItem, Body, Text, Icon, Button, Left, Right, Thumbnail, Title ｝ from 'native-base'; export default class WalletInfoScreen extends Component ｛ static navigationOptions = ｛ header: null ｝ render() ｛ const wallet = this.props.navigation.state.params; return ( &lt;Content padder&gt; &lt;Card transparent&gt; &lt;CardItem&gt; &lt;Body style=｛ styles.center ｝&gt; &lt;Thumbnail source=｛｛uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/1027.png'｝｝ /&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛ styles.center ｝&gt; &lt;Text style=｛｛fontSize: 26, fontWeight:'600', marginTop: 10｝｝&gt; ｛ wallet.balance || '0.00' ｝ ｛ wallet.symbol ｝ &lt;/Text&gt; &lt;Text style=｛｛fontSize: 18, marginTop: 10, color:'gray'｝｝&gt; ≈ ￦ ｛wallet.convertPrice || '0.00'｝ &lt;/Text&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛ styles.center ｝&gt; &lt;Text note ellipsizeMode=\"middle\" numberOfLines=｛1｝&gt; ｛wallet.address｝ &lt;/Text&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛｛ flexDirection: 'row', justifyContent: 'space-around'｝｝&gt; &lt;Button bordered info style=｛｛flex:1, justifyContent:'center', marginRight: 10｝｝&gt;&lt;Text&gt;입금&lt;/Text&gt;&lt;/Button&gt; &lt;Button bordered warning style=｛｛flex:1, justifyContent:'center', marginLeft: 10｝｝&gt;&lt;Text&gt;출금&lt;/Text&gt;&lt;/Button&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, backgroundColor: 'white' ｝, center: ｛ alignItems: 'center', justifyContent: 'center', ｝｝); navigation.state.params로 전달받은 지갑 정보 wallet를 출력합니다. 아직 구체적인 기능을 구현하지는 않았습니다. 그다음 ./src/App.js 를 수정합니다. 네이게이터에 WalletInfoScreen을 추가합니다. 12345678910import WalletInfoScreen from './components/WalletInfoScreen';const AppStackNavigator = createStackNavigator(｛ Wallets: ｛ screen: WalletsScreen ｝, CreateWallet: ｛ screen: CreateWalletScreen ｝, WalletInfo: ｛ screen: WalletInfoScreen ｝, // 추가된 코드｝, ｛ // (…)｝); AppStackNavigator에 WalletInfo: ｛ screen: WalletInfoScreen ｝ 가 추가되었습니다. components/WalletsScreen.js 파일을 수정합니다. 123456789101112131415161718192021222324252627282930313233343536export default class WalletsScreen extends Component ｛ static navigationOptions = ｛/* (…) */｝ constructor(props) ｛/* (…) */｝ _onWillFocus = payload =&gt; ｛/* (…) */｝ render() ｛ return ( &lt;&gt; &lt;NavigationEvents onWillFocus=｛this._onWillFocus｝ /&gt; &lt;Container style=｛styles.container｝&gt; &lt;Content padder&gt; ｛ this.state.wallets.map((wallet) =&gt; ｛ return ( &lt;WalletComponent key=｛wallet.address｝ wallet=｛wallet｝ onPress=｛() =&gt; ｛ this.props.navigation.navigate('WalletInfo', wallet)｝ ｝/&gt; ) ｝) ｝ &lt;Card&gt; ｛/* (…) */｝ &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; &lt;/&gt; ); ｝｝const styles = StyleSheet.create(｛/* (…) */｝); WalletComponent 컴포넌트의 onPress 속성에 navigation.navigate('WalletInfo', wallet) 를 입력합니다. 이제 지갑 컴포넌트를 클릭하면, WalletInfo 화면으로 이동하면서 선택한 wallet를 전달합니다. 마지막으로 components/WalletComponent.js 파일을 수정합니다. 123456789101112import ｛ TouchableOpacity ｝ from 'react-native';export default function WalletComponent(props) ｛ const wallet = props.wallet; return ( &lt;TouchableOpacity onPress=｛props.onPress｝&gt; &lt;Card&gt; ｛/* (…) */｝ &lt;/Card&gt; &lt;/TouchableOpacity&gt; );｝ react-native 에서 TouchableOpacity를 import 합니다. &lt;Card&gt; 컴포넌트를 &lt;TouchableOpacity&gt; 로 감쌉니다. &lt;TouchableOpacity&gt;의 onPress 속성에 props.onPress를 입력합니다. props.onPress는 앞서 WalletsScreen에서 전달받은 ｛() =&gt; this.props.navigation.navigate('WalletInfo', wallet)｝입니다. 여기까지 작업하고 지갑 목록에서 지갑을 선택해 봅니다. 그럼 지갑 상세화면으로 이동하는 것을 볼 수 있습니다. 입금 화면 만들기 입금 화면에서는 QRCode 이미지와 이더리움 주소를 보여 줄 것입니다. 먼저 react-native-qrcode 모듈을 설치합니다. 1$ npm install react-native-qrcode --save 그리고 components/ReceiveScreen.js 파일을 생성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View, Clipboard, Share ｝ from 'react-native';import ｛ Container, Content, Header, Card, CardItem, Body, Text, Icon, Button, Left, Right, Thumbnail, Title, Toast ｝ from 'native-base'; import QRCode from 'react-native-qrcode';export default class ReceiveScreen extends Component ｛ static navigationOptions = ｛ header: null ｝ render() ｛ const wallet = this.props.navigation.state.params; return ( &lt;Container style=｛styles.container｝&gt; &lt;Header&gt; &lt;Left&gt; &lt;Button transparent onPress=｛() =&gt; this.props.navigation.goBack()｝&gt; &lt;Icon name=\"arrow-back\" /&gt; &lt;/Button&gt; &lt;/Left&gt; &lt;Body&gt; &lt;Title&gt;｛ wallet.symbol ｝ 입금&lt;/Title&gt; &lt;/Body&gt; &lt;Right /&gt; &lt;/Header&gt; &lt;Content padder&gt; &lt;Card transparent&gt; &lt;CardItem&gt; &lt;Body style=｛ styles.center ｝&gt; &lt;Thumbnail circle source=｛｛uri: 'https://s2.coinmarketcap.com/static/img/coins/64x64/1027.png'｝｝ /&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛[styles.center, ｛marginVertical: 20｝]｝&gt; &lt;QRCode value=｛wallet.address｝ bgColor='black' fgColor='white' size=｛200｝ /&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛[styles.center, ｛padding:10, backgroundColor:'#EFEFEF'｝]｝&gt; &lt;Text note onPress=｛() =&gt; ｛ Clipboard.setString(wallet.address); Toast.show(｛ text: \"주소 복사가 완료되었습니다.\", position: \"bottom\", duration: 1000 ｝); ｝｝&gt; ｛wallet.address｝ &amp;nbsp; &lt;Icon name='content-copy' type=\"MaterialCommunityIcons\" style=｛｛fontSize:15, color:'#777'｝｝/&gt; &lt;/Text&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body&gt; &lt;Button bordered info block style=｛｛marginHorizontal:100｝｝ onPress=｛() =&gt; ｛ Share.share(｛ message: wallet.address ｝); ｝ ｝&gt;&lt;Text&gt;주소 공유&lt;/Text&gt;&lt;/Button&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, backgroundColor: 'white' ｝, center: ｛ alignItems: 'center', justifyContent: 'center', ｝｝); &lt;QRCode&gt; 컴포넌트를 사용하여 주소를 QR코드로 보여줍니다. 주소를 선택하면 Clipboard을 사용하여 클립보드에 복사합니다. 그리고 Toast 메세지를 출력합니다. 주소 공유 버튼을 누르면 공유하기 기능을 수행합니다. 마지막으로 ./src/App.js를 수정합니다. 1234567891011121314151617181920212223import // (...)import ｛ Root ｝ from \"native-base\"; // 추가된 코드import ReceiveScreen from './components/ReceiveScreen'; // 추가된 코드const AppStackNavigator = createStackNavigator(｛ Wallets: ｛ screen: WalletsScreen ｝, CreateWallet: ｛ screen: CreateWalletScreen ｝, WalletInfo: ｛ screen: WalletInfoScreen ｝, ReceiveScreen: ｛ screen: ReceiveScreen ｝, // Screen 추가｝, ｛ defaultNavigationOptions: ｛ headerBackTitle: null, // 뒤로가기 버튼 타이틀 없음. ｝,｝);const AppContainer = createAppContainer(AppStackNavigator);export default () =&gt; ( &lt;Root&gt; &lt;AppContainer /&gt; &lt;/Root&gt;); 네이게이터에 ReceiveScreen: ｛ screen: ReceiveScreen ｝ 를 추가하였습니다. &lt;AppContainer /&gt;를 native-base의 &lt;Root&gt;로 감쌌습니다. 이것은 NativeBase Toast 컴포넌트를 사용하기 위함입니다. 지갑 상세화면의 입금 버튼에 ReceiveScreen 화면을 연결하고 앱을 실행해봅니다. * * * 이더리움 모바일 지갑을 구현하다 보니 구현 범위가 생각보다 크네요. 그리고 코드 량이 많아지다 보니 설명이 부족할 수 있다는 생각이 들었습니다. 읽다가 잘 이해가 안되는 부분을 댓글로 질문하면 최대한 답변 드리겠습니다. 여기까지 작업한 코드는 모두 깃허브에 업로드되어있습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[세바시] 책 잘 읽는 방법 | 김봉진 ‘책 잘 읽는 방법’ 저자 | 독서법 | 세바시 902회","slug":"/kr/@steemory/or-or-or-902","date":"2019-02-08T02:46:42.000Z","updated":"2019-11-11T13:41:49.856Z","comments":true,"path":"/kr/@steemory/or-or-or-902/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/or-or-or-902/","excerpt":"과시적 독서 방법이란? 자신감, 지적 이미지를 보완하고 과시하기 위해서 독서를 하는 것이다. 요약 노트 책에 대한 고정관념을 버린다. 다 읽겠다는 생각을 버린다. 반드시 책을 끝까지 다 읽을 필요는 없다. 과감히 모서리를 접고 밑줄 친다. 책이 더 소중해진다. 꼭 순서대로 읽지 않다도 된다. 흝어보듯이 읽다가 마음에 드는 문장부터 읽어도 된다.","text":"과시적 독서 방법이란? 자신감, 지적 이미지를 보완하고 과시하기 위해서 독서를 하는 것이다. 요약 노트 책에 대한 고정관념을 버린다. 다 읽겠다는 생각을 버린다. 반드시 책을 끝까지 다 읽을 필요는 없다. 과감히 모서리를 접고 밑줄 친다. 책이 더 소중해진다. 꼭 순서대로 읽지 않다도 된다. 흝어보듯이 읽다가 마음에 드는 문장부터 읽어도 된다. 책을 많이 사야 많이 본다. 읽고 싶은 책을 많이 구입한다. 읽지 않은 책에 죄책감 느끼지 않는다. 책 읽는 습관을 만든다. 책을 가까이 둔다. 책장보다는 책상 위, 침대 위에 둔다. 가방에 책 한두 권씩 갖고 다닌다. 책은 지루한 부분이 있어서 2권을 번갈아가며 읽는다. 한번에 3 ~ 5권을 동시에 읽는다. 집중력(10분?)이 떨어질때 다른 책으로 바꿔 읽는다. 그럼 다시 집중력이 생긴다. 두껍고 어려운 책에 도전한다. 몰라도 자꾸 읽다 보면 ‘지식의 거름망’이 촘촘해진다. 독서의 질을 높인다. 내 고정관념을 깨는 책을 읽는다. 책이 어려우면 해설서(만화책, 청소년용)를 이용한다. 베스트셀러 같은 흥미 위주의 책도 좋지만, 서울대 권장도서나 하버드 대학 교수 추천도서도 꼭 한 권씩 읽자. 운동도 힘든 운동을 해야지 근육이 크듯이 생각의 근육을 단련하기 위해서는 어려운 책을 읽어야 합니다. 결론은 책을 많이 읽고 생각의 근육을 키우는 것입니다","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"세바시","slug":"세바시","permalink":"https://anpigon.github.io/tags/세바시/"},{"name":"김봉진","slug":"김봉진","permalink":"https://anpigon.github.io/tags/김봉진/"},{"name":"독서법","slug":"독서법","permalink":"https://anpigon.github.io/tags/독서법/"}],"author":"steemory"},{"title":"VSC(Visual Studio Code) 개발을 도와주는 유용한 도구 #1","slug":"/kr/@anpigon/vsc-visual-studio-code-1","date":"2019-02-08T01:48:27.000Z","updated":"2019-11-11T13:41:49.810Z","comments":true,"path":"/kr/@anpigon/vsc-visual-studio-code-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/vsc-visual-studio-code-1/","excerpt":"제가 유용하게 사용하고 있는 개발 도구를 하나씩 소개할까 합니다.저는 코딩할 때 주로 VS Code를 사용합니다. 그래서 VS Code에 설치하여 사용하면 좋은 확장(Extensions) 프로그램을 두 가지를 소개합니다.저는 도구를 잘 사용하면 작업 효율이나 능률을 200％ 이상 올릴 수 있다고 생각합니다. 나만 알고 있는 유용한 프로그램을 스팀잇에 소개해보세요. 그리고 한국어 버전의 producthunt가 나왔으면 좋겠습니다.","text":"제가 유용하게 사용하고 있는 개발 도구를 하나씩 소개할까 합니다.저는 코딩할 때 주로 VS Code를 사용합니다. 그래서 VS Code에 설치하여 사용하면 좋은 확장(Extensions) 프로그램을 두 가지를 소개합니다.저는 도구를 잘 사용하면 작업 효율이나 능률을 200％ 이상 올릴 수 있다고 생각합니다. 나만 알고 있는 유용한 프로그램을 스팀잇에 소개해보세요. 그리고 한국어 버전의 producthunt가 나왔으면 좋겠습니다. * * * # Material Theme Material Design Icons for Visual Studio Code 머티리얼 UI 와 아이콘을 사용하여 아름다운 VS Code에서 작업해보세요. https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme 설치하기 VS Code Extensions MarketPlace에서 Material Theme를 찾아서 설치합니다. Color Theme 바꾸기 VS Code 메뉴에서 Code &gt; Preferences &gt; Color Theme 를 선택합니다. 그다음 원하는 테마를 선택합니다. 참고로 저는 Meterial Theme Darker High Contrast를 선택하였습니다. 적용전과 적용 후를 비교해보겠습니다. 적용 전 적용 후 Accent Color 바꾸기 User Settings &gt; Meterial Theme 에 들어가면 Accent Color를 변경할 수 있습니다. * * * # Indent Rainbow A simple extension to make indentation more readable 들여 쓰기 스타일을 적용하여 코드 가독성을 높여보세요. https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow 설치하기 VS Code Extensions MarketPlace에서 indent-rainbow 를 찾아서 설치합니다. 설치하고 나면 에디터 화면이 아래와 같이 보입니다. 커스터 마이징 하기 User Settings &gt; indentRainbow 에 들어가면 들여쓰기 스타일을 수정할 수 있습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"Visual Studio Code","slug":"visual-studio-code","permalink":"https://anpigon.github.io/tags/visual-studio-code/"}],"author":"anpigon"},{"title":"[종로] 백숙/삼계탕 맛집 - 토속촌","slug":"/tasteem/@steemory/tasteem-73bcdb","date":"2019-02-07T02:33:57.000Z","updated":"2019-11-11T13:41:49.845Z","comments":true,"path":"/tasteem/@steemory/tasteem-73bcdb/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-73bcdb/","excerpt":"토속촌 한약재와 견과류 들어간 영계삼계탕 맛집 매일 10:00 - 22:00 전화번호 02-737-7444 유료 주차 가능 4년생 인삼, 국내산 대추, 호박씨, 은행, 검은깨 등 각종 한약재와 견과류를 갈아넣어 국물이 고소하고 진한 것이 특징이라고 합니다. 식당은 한옥을 개조하여 만들었습니다. 그래서 외국인 관광객들도 많이 찾는다고 합니다. 내부에 들어가면 공간이 매우 넓습니다. 내부에 들어가면 조명때문인지 분위기가 매우 아늑합니다. 홀을 지나서 통로를 따라 들어가다 보면 또 넓은 공간이 나옵니다. 식당 규모가 어마어마 합니다. 추운 겨울날 뜨끈뜨끈한 온돌방에 앉아서 따뜻한 궁물이 먹고 싶을때, 여길 와야할 것 같습니다. 여기는 대통령의 단골집이라고 합니다. 노무현 전 대통령님이 즐겨 찾아서 유명해졌다고 하네요. 메뉴 입니다. 대표 메뉴는 토속촌삼계탕(16,000원)입니다. 삼계탕에서 김이 모락 모락 납니다. 그리고 제 몸의 추위도 같이 사라졌습니다. 따뜻한 뽀얀 국물과 하얀 속살을 자랑하는 삼계탕입니다.","text":"토속촌 한약재와 견과류 들어간 영계삼계탕 맛집 매일 10:00 - 22:00 전화번호 02-737-7444 유료 주차 가능 4년생 인삼, 국내산 대추, 호박씨, 은행, 검은깨 등 각종 한약재와 견과류를 갈아넣어 국물이 고소하고 진한 것이 특징이라고 합니다. 식당은 한옥을 개조하여 만들었습니다. 그래서 외국인 관광객들도 많이 찾는다고 합니다. 내부에 들어가면 공간이 매우 넓습니다. 내부에 들어가면 조명때문인지 분위기가 매우 아늑합니다. 홀을 지나서 통로를 따라 들어가다 보면 또 넓은 공간이 나옵니다. 식당 규모가 어마어마 합니다. 추운 겨울날 뜨끈뜨끈한 온돌방에 앉아서 따뜻한 궁물이 먹고 싶을때, 여길 와야할 것 같습니다. 여기는 대통령의 단골집이라고 합니다. 노무현 전 대통령님이 즐겨 찾아서 유명해졌다고 하네요. 메뉴 입니다. 대표 메뉴는 토속촌삼계탕(16,000원)입니다. 삼계탕에서 김이 모락 모락 납니다. 그리고 제 몸의 추위도 같이 사라졌습니다. 따뜻한 뽀얀 국물과 하얀 속살을 자랑하는 삼계탕입니다. ![](https://static.tasteem.io/uploads/image/image/134715/03d21151-0648-4713-833a-45fbe026097f.jpeg) 닭 다리는 2개가 들어있습니다. 확실하게 한 마리가 맞는 것 같습니다. 사진이 살짝 흔들였네요. 닭고기가 입에서 사르르 녹네요. 추운 겨울날 몸보신으로 삼계탕을 드셔보세요~ 맛집정보 토속촌 대한민국 서울특별시 종로구 체부동 자하문로5길 5 [[종로] 백숙/삼계탕 맛집 - 토속촌](https://kr.tasteem.io/post/27110) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/318)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet)  만들기 #4","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-4","date":"2019-02-07T01:37:21.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-4/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-4/","excerpt":"이번에는 생성한 지갑키를 Storage에 저장합니다. 우리는 React Native의 Secure Storage를 사용하여 지갑키를 저장 할 것입니다. Secure Storage는 iOS/Android의 Keychain/Keystore를 이용하여 데이터를 안전하게 저장합니다. Secure Storage를 사용하면, 지문인증과 같은 생체인증도 이용할 수 있습니다.","text":"이번에는 생성한 지갑키를 Storage에 저장합니다. 우리는 React Native의 Secure Storage를 사용하여 지갑키를 저장 할 것입니다. Secure Storage는 iOS/Android의 Keychain/Keystore를 이용하여 데이터를 안전하게 저장합니다. Secure Storage를 사용하면, 지문인증과 같은 생체인증도 이용할 수 있습니다. 지갑키를 Secure Storage에 저장하기 지갑키를 Secure Storage 저장하기 위해서 react-native-secure-key-store 라이브러리를 설치합니다. 12$ npm install react-native-secure-key-store --save$ react-native link react-native-secure-key-store 참고: https://github.com/pradeep1991singh/react-native-secure-key-store 그리고 지갑키 저장에 필요한 라이브러리를 import 합니다. 12import ｛ StyleSheet, View, AsyncStorage ｝ from 'react-native';import RNSecureKeyStore, ｛ACCESSIBLE｝ from \"react-native-secure-key-store\"; 생성된 지갑키와 지갑 정보를 Storage 에 저장합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export default class CreateWalletScreen extends Component ｛ static navigationOptions = ｛ /* (...) */ ｝ constructor(props) ｛ /* (...) */ ｝ componentWillMount = () =&gt; ｛ /* (...) */ ｝ _storeData = async (wallet, privateKey) =&gt; ｛ try ｛ // 기존 지갑 목록 정보 가져오기 const wallets = JSON.parse(await AsyncStorage.getItem('WALLETS')) || []; // 기존 지갑 목록에 추가하기 wallets.push(wallet); // 지갑 목록 정보 저장하기 await AsyncStorage.setItem('WALLETS', JSON.stringify(wallets)); // 개인키를 안전한 영역에 저장하기 await RNSecureKeyStore.set(wallet.address, privateKey, ｛accessible: ACCESSIBLE.ALWAYS_THIS_DEVICE_ONLY｝); ｝ catch (error) ｛ // Error saving data console.log(error); ｝ ｝; _createWallet = async () =&gt; ｛ // 1. 니모닉에서 시드 계산 const seed = bip39.mnemonicToSeed(this.state.mnemonic); // 2. 시드에서 마스터 키 생성 const root = bip32.fromSeed(seed); // 3. 이더리움 차일드 개인키 생성(derived) const xPrivKey = root.derivePath(\"m/44'/60'/0'/0/0\"); const privKey = xPrivKey.privateKey.toString('hex'); // 4. 공개키에서 이더리움 주소 계산 let address = ethUtil.pubToAddress(xPrivKey.publicKey, true).toString('hex'); address = ethUtil.toChecksumAddress(address).toString('hex'); // 저장할 지갑 정보 생성 const wallet = ｛ name: '이더리움', coinType: 'ETH', symbol: 'ETH', address ｝ // 저장하기 await this._storeData(wallet, privKey); // 지갑목록 화면으로 돌아가기 this.props.navigation.goBack(); ｝ render() ｛ /* (...) */ ｝｝ 지갑 정보를 저장하는 _storeData() 함수를 생성합니다. 지갑키는 SecureStorage에 저장합니다. 그리고 지갑키를 제외한 정보는 일반 Storage에 저장합니다. _createWallet() 함수에서는 생성된 지갑키와 지갑 정보를 _storeData() 함수를 사용하여 저장합니다. 마지막으로 지갑 정보와 지갑키 저장이 끝나면, 지갑 목록 화면으로 돌아갑니다. 지갑 목록 화면 만들기 components/WalletComponent.js 파일을 생성합니다. 지갑 목록에서 하나의 지갑을 나타내는 컴포넌트입니다. ./src/components/WalletComponent.js 1234567891011121314151617181920212223242526272829303132333435import React from 'react';import ｛ Card, CardItem, Body, Text, Icon, Button, Left, Right, Thumbnail ｝ from 'native-base'; export default function WalletComponent(props) ｛ const wallet = props.wallet; return ( &lt;Card&gt; &lt;CardItem&gt; &lt;Left&gt; &lt;Thumbnail small source=｛｛uri: 'https://s2.coinmarketcap.com/static/img/coins/32x32/1027.png'｝｝ /&gt; &lt;Body&gt; &lt;Text&gt;ETH&lt;/Text&gt; &lt;Text note&gt;｛wallet.name｝&lt;/Text&gt; &lt;/Body&gt; &lt;/Left&gt; &lt;Right&gt; &lt;Icon name='dots-vertical' type='MaterialCommunityIcons' /&gt; &lt;/Right&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Text note ellipsizeMode=\"middle\" numberOfLines=｛1｝ selectable=｛true｝&gt;｛wallet.address｝&lt;/Text&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Body style=｛｛ alignItems:'flex-end' ｝｝&gt; &lt;Text&gt; ｛wallet.balance || '0.00'｝ &lt;/Text&gt; &lt;Text note style=｛｛ marginRight:0 ｝｝&gt; ≈ ￦ ｛wallet.convertPrice || '0.00'｝ &lt;/Text&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; );｝ WalletsScreen.js 파일을 수정합니다. 우선 react-native에서 AsyncStorag를 import 합니다. 그리고 NavigationEvents도 import합니다. 12import ｛ StyleSheet, View, AsyncStorage ｝ from 'react-native';import ｛ NavigationEvents ｝ from 'react-navigation'; 그리고 WalletsScreen 를 수정합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445export default class WalletsScreen extends Component ｛ static navigationOptions = ｛/* (...) */｝ constructor(props) ｛ super(props); this.state = ｛ wallets: [] ｝ ｝ // 컴포넌트가 다시 활성화(foreground)되면 호출됩니다. _onWillFocus = payload =&gt; ｛ // Storage에서 지갑 목록을 가져온다. AsyncStorage.getItem('WALLETS').then(wallets =&gt; ｛ this.setState(｛ wallets: JSON.parse(wallets) || [], ｝) ｝); ｝ render() ｛ return ( &lt;View&gt; &lt;NavigationEvents onWillFocus=｛this._onWillFocus｝ /&gt; &lt;Container style=｛styles.container｝&gt; &lt;Content padder&gt; ｛ this.state.wallets.map((wallet) =&gt; ｛ return ( &lt;WalletComponent wallet=｛wallet｝ /&gt; ) ｝) ｝ &lt;Card&gt; ｛/* (...) */｝ &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; &lt;/View&gt; ); ｝｝ 지갑을 생성하고 지갑 목록화면으로 돌아오면, 생성된 지갑이 추가되어 보일 것입니다. Container 컴포넌트 바로 위에 NavigationEvents 컴포넌트가 사용되었습니다. Redux를 사용하지 않고, NavigationEvents를 사용하여 단순하게 처리하였습니다. 여기까지 작성하고 앱을 실행하고 확인하면 이렇게 보일 것입니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #3","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-3","date":"2019-02-04T02:00:21.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-3/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-3/","excerpt":"이번에는 니모닉으로 지갑키(PrivateKet)와 지갑주소를 생성합니다. 지갑주소는 공개키(PublicKey)에서 계산됩니다.* * * ethereumjs-util 라이브러리 설치이더리움 주소를 계산하기 위해 아래 라이브러리를 설치합니다.1$ npm install --save ethereumjs-util","text":"이번에는 니모닉으로 지갑키(PrivateKet)와 지갑주소를 생성합니다. 지갑주소는 공개키(PublicKey)에서 계산됩니다.* * * ethereumjs-util 라이브러리 설치이더리움 주소를 계산하기 위해 아래 라이브러리를 설치합니다.1$ npm install --save ethereumjs-util 이더리움 지갑키와 주소 계산에 필요한 라이브러리를 import 합니다. 12import bip32 from 'bip32';import ethUtil from 'ethereumjs-util'; 마지막으로 CreateWalletScreen.js를 수정합니다. 123456789101112131415161718192021222324252627282930313233343536export default class CreateWalletScreen extends Component ｛ // (...) _createWallet = async () =&gt; ｛ const seed = bip39.mnemonicToSeed(this.state.mnemonic); // 마스터 키 생성 const root = bip32.fromSeed(seed); // 이더리움 차일드 개인키 생성 const xPrivKey = root.derivePath(\"m/44'/60'/0'/0/0\"); const privKey = xPrivKey.privateKey.toString('hex'); // 이더리움 주소 생성 let address = ethUtil.pubToAddress(xPrivKey.publicKey, true).toString('hex'); // 이더리움 EIP-55 체크섬 주소로 변환 address = ethUtil.toChecksumAddress(address).toString('hex'); alert(address); ｝ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛ flex: 1, padding: 10 ｝｝&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; ｛/* (...) */｝ &lt;/View&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; &lt;Button block primary onPress=｛() =&gt; this._createWallet()｝&gt; &lt;Text&gt;생성하기&lt;/Text&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; &lt;/Container&gt; ); ｝｝ 지갑 생성하는 _createWallet() 함수를 생성합니다. 그리고 생성하기 버튼의 onPress 속성에 ｛() =&gt; this._createWallet()｝를 입력합니다. 이제 생성하기 버튼을 누르면 _createWallet() 함수를 호출할 것입니다. _createWallet() 함수는 니모닉에서 시드(SEED) 를 계산합니다. 그리고 BIP-32를 사용하여 시드에서 확장 개인키(HDPrivateKey)를 계산합니다. 그다음 HDPrivateKey에서 이더리움 PrivateKey를 계산합니다. 이더리움 PrivateKey는 BIP-44에 따라 생성(derivation) 됩니다. 그리고 derivePath는 이와 같은 형태입니다. m/purpose'/coin_type'/account'/change/address_index 우리는 HD지갑이 목적이 아니므로 단순하게 m/44'/60'/0'/0/0를 사용하여 지갑키를 생성합니다. 마지막으로 공개키(PublicKey)에서 주소를 계산합니다. 그리고 EIP-55 규칙에 따라 체크섬이 포함된 주소로 변환합니다. 이제 생성 버튼을 누르면 아래와 같이 지갑 주소가 생성됩니다. 확인하기 쉽게 Alert 으로 출력하였습니다. 이더리움 모바일 지갑앱 개발을 하면서, 개발 과정을 정리하여 포스팅까지 하려니 시간이 2~3배 정도 걸리네요. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #2","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet-2","date":"2019-02-03T03:08:24.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet-2/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet-2/","excerpt":"이번에는 이더리움 지갑 생성 및 복구에 필요한 **니모닉(Mnemonic)**을 생성합니다. 니모닉이란 지갑을 복구하기 위한 데이터입니다. 보통 12개의 영어 단어로 구성됩니다. 니모닉 생성 규칙은 BIP-39에 정의되어 있습니다. 니모닉은 아래와 같은 형태입니다.1kidney neglect bomb balcony leaf gun spy narrow total rib soldier depart speak bounce member","text":"이번에는 이더리움 지갑 생성 및 복구에 필요한 **니모닉(Mnemonic)**을 생성합니다. 니모닉이란 지갑을 복구하기 위한 데이터입니다. 보통 12개의 영어 단어로 구성됩니다. 니모닉 생성 규칙은 BIP-39에 정의되어 있습니다. 니모닉은 아래와 같은 형태입니다.1kidney neglect bomb balcony leaf gun spy narrow total rib soldier depart speak bounce member 아래 화면처럼 https://iancoleman.io/bip39/ 에 접속하면 니모닉을 생성해 볼 수 있습니다. 니모닉은 영어, 일본어, 스페인어, 중국어(간체/번체), 프랑스어, 이탈리아어, 한국어를 지원합니다. 이더리움의 이해가 필요한 분은 아랫글을 참고 바랍니다. 이전에 이더리움을 공부하면서 정리한 글입니다. 이더리움(Ethereum) 공부 #1 - 키와 주소 이더리움(Ethereum) 공부 #2 - HD 지갑과 니모닉 코드 이더리움(Ethereum) 공부 #3 - 트랜잭션과 서명 * * * 러이브러리 설치 아래 라이브러리를 모두 설치합니다. 123$ npm install --save react-native-bip39 bip32 ethers$ npm install --save-dev tradle/rn-nodeify$ ./node_modules/.bin/rn-nodeify --hack --install buffer,crypto,events,stream,vm,process 라이브러리가 모두 설치된 package.json 파일은 여기에 업로드 되어 있습니다. 참고하세요. rn-nodeify를 실행하고 나면, 루트에 shim.js 파일이 생성되어 있습니다. 루트에 있는 index.js 파일을 열어 shim.js를 import 합니다. 123456import ｛AppRegistry｝ from 'react-native';import App from './App';import ｛name as appName｝ from './app.json';import './shim.js' // 추가된 코드AppRegistry.registerComponent(appName, () =&gt; App); 만약 라이브러리 설치를 완료하고 나서, 앱 실행 시 아래와 비슷한 오류가 발생한다면 다음 방법을 시도해보세요. 12345678Module `stream` does not exist in the Haste module mapThis might be related to https://github.com/facebook/react-native/issues/4968To resolve try the following: 1. Clear watchman watches: `watchman watch-del-all`. 2. Delete the `node_modules` folder: `rm -rf node_modules &amp;&amp; npm install`. 3. Reset Metro Bundler cache: `rm -rf /tmp/metro-bundler-cache-*` or `npm start -- --reset-cache`. 4. Remove haste cache: `rm -rf /tmp/haste-map-react-native-packager-*`. CreateWalletScreen 수정하기 CreateWalletScreen.js 파일을 수정합니다. 화면에서 지갑 백업용 니모닉을 보여줄 것입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import bip39 from 'react-native-bip39';// (...)export default class CreateWalletScreen extends Component ｛ // (...) constructor(props) ｛ super(props); this.state = ｛ mnemonic: null ｝ ｝ componentWillMount = () =&gt; ｛ // 니모닉 생성 bip39.generateMnemonic().then(mnemonic =&gt; ｛ this.setState(｛ mnemonic ｝) ｝); ｝ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛ flex: 1, padding: 10 ｝｝&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; &lt;Text note&gt;아래 12개 니모닉을 복사하여 백업하세요. 지갑을 복구하는데 매우 중요한 데이터입니다.&lt;/Text&gt; &lt;Form&gt; &lt;Textarea rowSpan=｛5｝ bordered disabled value=｛this.state.mnemonic｝ /&gt; &lt;/Form&gt; &lt;/View&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; &lt;Button block primary&gt; &lt;Text&gt;생성하기&lt;/Text&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; &lt;/Container&gt; ); ｝｝ bip39.generateMnemonic() 함수를 사용하여 지갑 생성에 필요한 니모닉을 생성합니다. react-native-bip39 라이브러리의 더 자세한 사용 방법은 여기를 참고하세요. 니모닉은 보통 12 영단어로 구성됩니다. 24 영단어 니모닉을 생성하고 싶으면 bip39.generateMnemonic(256)를 사용하세요. 한글로 니모닉을 만들고 싶으면 여기를 참고하세요. 현재 react-native-bip39 라이브러리가 영어 외에는 지원하지 않아서 직접 추가해야 합니다. 이제 앱을 실행하여 확인해봅니다. 지갑 복구에 필요한 니모닉이 생성되었습니다. * * * 이더리움 지갑 개발에 필요한 라이브러리를 찾느라 시간이 많이 소요되었습니다. 그래서 진도를 많이 못 나갔네요. ㅎ 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[React Native] 이더리움 모바일 지갑(Ethereum Mobile Wallet) 만들기 #1","slug":"/kr/@anpigon/react-native-ethereum-mobile-wallet","date":"2019-02-01T02:27:27.000Z","updated":"2019-11-11T13:41:49.821Z","comments":true,"path":"/kr/@anpigon/react-native-ethereum-mobile-wallet/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ethereum-mobile-wallet/","excerpt":"오래 전 멀고 먼 블록체인 저편에… 암호화폐는 암흑의 시기이다. 하지만, 네드 베이더는 물리쳤고, 스티미디언 부대들은 스팀 얼라이언스 기지를 구축했다. 이번에는 리액트 네이티브로 이더리움 모바일 지갑을 만들어 봅니다. 리액트 네이티브로 암호화폐 지갑을 만드는 과정이 쉽지는 않을 것입니다.","text":"오래 전 멀고 먼 블록체인 저편에… 암호화폐는 암흑의 시기이다. 하지만, 네드 베이더는 물리쳤고, 스티미디언 부대들은 스팀 얼라이언스 기지를 구축했다. 이번에는 리액트 네이티브로 이더리움 모바일 지갑을 만들어 봅니다. 리액트 네이티브로 암호화폐 지갑을 만드는 과정이 쉽지는 않을 것입니다. 개발하기 앞서 자신의 시스템 환경을 꼭 체크하기 바랍니다. Node 8, Python2, JDK 8 이 필요합니다. 자세한 설치 방법은 「리액트 네이티브 설치 가이드 문서」의 Building Projects with Native Code 탭을 참고하세요. 개발환경이 윈도우OS이라면 윈도우 패키지 관리자인 Chocolatey를 통해 Node와 Python2를 설치하길 권장합니다. * * * 프로젝트 생성하기 이번에는 expo를 사용하지 않고 React Native CLI를 사용하여 프로젝트를 생성합니다. 12$ react-native init rn_ethereum_wallet$ cd rn_ethereum_wallet React Native CLI가 없으면 설치해주세요. npm i -g react-native-cli 라이브러리 설치 UI 라이브러리와 네비게이션 라이브러리를 설치합니다. 12$ npm install --save native-base react-navigation react-native-gesture-handler$ react-native link 프로젝트 폴더 구조 만들기 첫 번째로 src 폴더를 생성합니다. src 폴더 아래에 components 폴더를 생성합니다. 그리고 src 폴더에 App.js 파일을 생성합니다. ./src/App.js 12345678import ｛ createStackNavigator, createAppContainer ｝ from 'react-navigation';import WalletsScreen from './components/WalletsScreen';const AppStackNavigator = createStackNavigator(｛ Wallets: ｛ screen: WalletsScreen ｝,｝);export default createAppContainer(AppStackNavigator); 현재 네비게이터(Navigator)에는 지갑 목록을 보여주는 WalletsScreen가 하나 등록되어 있습니다. 그다음 루트에 있는 App.js 파일을 수정합니다. ./App.js 123import React from 'react';import App from './src/App';export default () =&gt; &lt;App/&gt;; 루트에 있는 App.js는 ./src/App.js 컴포넌트를 반환하는 역할만 합니다. WalletsScreen 화면 만들기 components 폴더에 WalletsScreen.js 파일을 생성합니다. ./src/components/WalletsScreen.js 1234567891011121314151617181920212223242526272829303132333435import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View ｝ from 'react-native';import ｛ Container, Content, Card, CardItem, Body, Text, Icon, Button ｝ from 'native-base'; export default class WalletsScreen extends Component ｛ static navigationOptions = ｛ title: \"Ethereum Wallet\", ｝ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;Content padder&gt; &lt;Card&gt; &lt;CardItem&gt; &lt;Body&gt; &lt;Button transparent iconLeft large block&gt; &lt;Icon name='ios-add-circle-outline' /&gt; &lt;Text&gt;지갑 생성&lt;/Text&gt; &lt;/Button&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, backgroundColor: 'white' ｝,｝); WalletsScreen 화면에는 앞으로 지갑 목록이 보여질 것입니다. 지금은 생성된 지갑이 없으므로, 지갑 생성 버튼만 존재합니다. 실행하기 여기까지 작업하고 어떻게 보이는지 앱을 실행해봅니다. 1$ react-native run-ios CreateWalletScreen 화면 만들기 components 폴더에 CreateWalletScreen.js 파일을 생성합니다. 1234567891011121314151617181920212223242526272829303132333435import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View ｝ from 'react-native';import ｛ Container, Content, Segment, Text, Icon, Button, Header, Left, Body, Title, Right, Form, Textarea, Input, Item ｝ from 'native-base'; export default class CreateWalletScreen extends Component ｛ static navigationOptions = ｛ title: '지갑 생성하기' ｝ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛ flex: 1, padding: 10 ｝｝&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; &lt;Text note&gt;아래 12개 니모닉을 복사하여 백업하세요. 지갑을 복구하는데 매우 중요한 데이터입니다.&lt;/Text&gt; &lt;Form&gt; &lt;Textarea rowSpan=｛5｝ bordered disabled /&gt; &lt;/Form&gt; &lt;/View&gt; &lt;View style=｛｛ flex: 1 ｝｝&gt; &lt;Button block primary&gt; &lt;Text&gt;생성하기&lt;/Text&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; &lt;/Container&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, ｝,｝); 지갑 생성 화면에는 백업 및 복구용 니모닉을 보여줄 것입니다. ./src/App.js를 수정합니다. 123456789101112131415import ｛ createStackNavigator, createAppContainer ｝ from 'react-navigation';import WalletsScreen from './components/WalletsScreen';import CreateWalletScreen from './components/CreateWalletScreen';const AppStackNavigator = createStackNavigator(｛ Wallets: ｛ screen: WalletsScreen ｝, CreateWallet: ｛ screen: CreateWalletScreen ｝,｝, ｛ defaultNavigationOptions: ｛ headerBackTitle: null, // 뒤로가기 버튼 타이틀 제거. ｝,｝);export default createAppContainer(AppStackNavigator); 네비게이터(Navigator)에 CreateWallet: ｛ screen: CreateWalletScreen ｝를 등록합니다. 네비게이터의 headerBackTitle: null 옵션을 설정하여, 헤더에 뒤로가기 버튼 아이콘만 보이도록 하였습니다. 마지막으로 WalletsScreen.js 파일을 수정합니다. 123456789101112131415161718192021222324export default class WalletsScreen extends Component ｛ // (...) render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;Content padder&gt; &lt;Card&gt; &lt;CardItem&gt; &lt;Body&gt; &lt;Button transparent iconLeft large block onPress=｛() =&gt; this.props.navigation.navigate('CreateWallet')｝&gt; &lt;Icon name='ios-add-circle-outline' /&gt; &lt;Text&gt;지갑 생성&lt;/Text&gt; &lt;/Button&gt; &lt;/Body&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝ Button의 onPress 속성에 navigate('CreateWallet')를 입력하였습니다. 이제 버튼을 누르면 CreateWallet 화면으로 이동합니다. 이제 지갑 생성하기 화면이 어떻게 보이는지 확인해봅니다. * * * 스팀잇 커뮤니티에 암호 화폐 모바일 지갑 앱 개발에 관심 있는 분이 얼마나 있을지 모르겠습니다. 이더리움 지갑 부터 시작해서 비트코인, 스팀, 리플, 이오스, 스텔라루멘 모바일 지갑을 다 만들고 싶네요. 하지만, 제 능력으로 다 개발할 수 있을지는 잘 모르겠습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"이더리움 지갑 앱 만들기","slug":"개발-이야기/react-native/이더리움-지갑-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/이더리움-지갑-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[세바시] 노트쓰기로 당신의 천재성을 끌어내세요 | 이재영 한동대학교 기계제어공학부 포스코 석좌교수 | 세바시 890회","slug":"/kr/@steemory/or-or-890","date":"2019-01-31T04:16:21.000Z","updated":"2019-11-11T13:41:49.856Z","comments":true,"path":"/kr/@steemory/or-or-890/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/or-or-890/","excerpt":"https://youtu.be/g-39OF50pUw천재들의 공통점은 모두 노트를 쓴다는 것이다. 누구나 천재가 될 수 있다. 노트쓰기는 블록현상을 넘어서 우리 안의 천재를 꺼냅니다. 블록현상(Block phenomenon) 이란? 지적 글을 쓸 수 있는데 써지지 않는 현상. 누구에게나 올 수 있으며 큰 고통이 따른다.","text":"https://youtu.be/g-39OF50pUw천재들의 공통점은 모두 노트를 쓴다는 것이다. 누구나 천재가 될 수 있다. 노트쓰기는 블록현상을 넘어서 우리 안의 천재를 꺼냅니다. 블록현상(Block phenomenon) 이란? 지적 글을 쓸 수 있는데 써지지 않는 현상. 누구에게나 올 수 있으며 큰 고통이 따른다. 요약 노트 노트는 정자체로 쓰세요. 생각이 폭주할 수록 천천히 또박또박 쓰세요. 생각의 폭풍이 글과 함께 동조가 일어난다. 노트는 다시 읽기 위해서 씁니다. 노트는 반드시 다시 보세요. 더 새로운 생각이 탄생합니다. 노트를 사는 순간 20％를 단숨에 쓰세요. 노트를 끝까지 쓸 확률이 높아집니다. 수첩을 사용합니다. - 큰 노트보다는 작은 수첩이 좋습니다. - 생각을 더 꼼꼼하게 담을 수 있습니다. 하루에 한번씩 세바시 동영상을 보면서 내용을 요약해보려고 합니다. 동영상 강의에서 말하는 내용을 내 것으로 만들고, 그것을 다시 요약하기 위해서 3번이나 봤습니다. 15분으로 짧은 동영상이지만, 2 ~ 3번째부터는 핵심 부분만 다시 보았습니다. 생각의 힘이나 글쓰기 실력은 모두 노트 쓰기에서 시작되는 것 같습니다. 전자 형태의 글쓰기(예를 들면 스팀잇에 글쓰기)도 좋지만, 저는 손글씨로 쓰는게 더 좋다고 생각됩니다. 운동으로 근육을 키우듯이, 노트 쓰기로 뇌근육을 키워봅시다~!","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"세바시","slug":"세바시","permalink":"https://anpigon.github.io/tags/세바시/"}],"author":"steemory"},{"title":"[React Native] 무한 스크롤(infinite scroll) 만들기","slug":"/kr/@anpigon/react-native-infinite-scroll--1548900759954","date":"2019-01-31T02:12:39.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-infinite-scroll--1548900759954/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-infinite-scroll--1548900759954/","excerpt":"이번에는 무한 스크롤(infinite scroll)를 구현합니다. “[React Native] 인스타그램 UI 만들기” 시리즈의 개발환경을 그대로 사용합니다. 그리고 아래 블로그 내용을 참고 하여 구현하였습니다. 참고: https://blog.nativebase.io/building-infinite-scroll-in-react-native-e717602553f8","text":"이번에는 무한 스크롤(infinite scroll)를 구현합니다. “[React Native] 인스타그램 UI 만들기” 시리즈의 개발환경을 그대로 사용합니다. 그리고 아래 블로그 내용을 참고 하여 구현하였습니다. 참고: https://blog.nativebase.io/building-infinite-scroll-in-react-native-e717602553f8 라이브러리 설치하기 무한 스크롤을 구현하기 위해서 impagination 라이브러리를 사용합니다. impagination는 페이징 가능한 레코드의 lazy 데이터 처리 레이어입니다. impagination는 종속성이 없기 때문에, JS 환경이면 어디서나 사용가능합니다. 1$ yarn add impagination util Impagination 데이터세트 만들기 ./src/components/HomeTab.js을 수정합니다. 먼저 impagination를 import 합니다. 1import Dataset from 'impagination'; 그리고 HomeTab 컴포넌트 내부에 setupImpagination 함수를 작성합니다. 1234567891011121314151617181920class HomeTab extends Component ｛ setupImpagination = () =&gt; ｛ let dataset = new Dataset(｛ pageSize: DEFAULT_LIMIT, // 한번에 가져올 레코드 갯수 observe: (datasetState) =&gt; ｛ // 새로운 `state`가 생성될때 마다 호출됩니다. this.setState(｛ datasetState ｝); ｝, fetch(pageOffset, pageSize, stats) ｛ // 서버에서 데이터를 가져옵니다. return _fetchFeeds(); ｝ ｝); dataset.setReadOffset(0); // Dataset 호출 this.setState(｛ dataset ｝); ｝ render() ｛ //... ｝｝ Dataset의 fetch() 함수에 전달되는 값은 세 가지입니다. pageOffset는 가져올 현재 페이지, pageSize는 한 페이지의 레코드 수, 그리고 stats입니다. API에서 지원한다면, stats에는 totalPages를 저장할 수 있습니다. 스팀잇 피드 가져오는 API에는 pageOffset이 없으므로 아래와 같은 방법으로 조회해야 합니다. 12345678910111213141516171819202122232425262728293031class HomeTab extends Component ｛ setupImpagination = () =&gt; ｛ _fetchFeeds = () =&gt; ｛ const ｛ startAuthor, startPermlink ｝ = this.state.next; // 가져올 레코드 시작 지점 return this.fetchFeeds(｛ tag: 'kr', limit: DEFAULT_LIMIT + 1, startAuthor, startPermlink ｝).then(feeds =&gt; ｛ let next = ｛ startAuthor: '', startPermlink: '', ｝ if(feeds.length &gt; DEFAULT_LIMIT) ｛ const ｛ author, permlink ｝ = feeds.pop(); next = ｛ startAuthor: author, startPermlink: permlink ｝ ｝ this.setState(｛ next ｝); return feeds; ｝); ｝ let dataset = new Dataset(｛ //... ｝); ｝ render() ｛ //... ｝｝ 마지막 레코드에서 다음 레코드의 시작 부분을 알아야 하기 때문에, 레코드를 하나 더 가져옵니다. 그리고 가져온 레코드가 DEFAULT_LIMIT 보다 크면 마지막 레코드를 pop하여 다음 레코드의 시작 지점을 알아냅니다. 이제 컴포넌트 constructor에 state를 선언합니다. 123456789101112131415class HomeTab extends Component ｛ constructor(props) ｛ super(props); this.state = ｛ dataset: null, datasetState: null, next: ｛ startAuthor: null, startPermlink: null, ｝ ｝; ｝ setupImpagination() ｛ //... ｝ render() ｛ //... ｝｝ 마지막으로 컴포넌트 마운트되기 시작할때, setupImpagination() 함수를 호출합니다. 123componentWillMount() ｛ this.setupImpagination();｝ 화면에 datasetState 출력하기 이제 Impagination의 datasetState을 루프돌면서 CardComponent 컴포넌트를 반환하도록 만듭니다. 123456789101112131415161718192021class HomeTab extends Component ｛ constructor(props) ｛ //... ｝ setupImpagination() ｛ //... ｝ componentWillMount() ｛ //... ｝ render () ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Header&gt;｛/* ... */｝&lt;/Header&gt; &lt;Content&gt; ｛/* ... */｝ ｛ this.state.datasetState.map(record =&gt; ｛ const ｛ content ｝ = record; return &lt;CardComponent data=｛ content ｝ key=｛ content.post_id ｝/&gt; ｝) ｝ &lt;/Content&gt; &lt;/Container&gt; ) ｝｝ 이렇게 하고 앱을 호출하면 Cannot read property 'title' of null 에러가 발생합니다. 이것은 Impagination 는 생성되자 마자 필요한 array 데이터를 생성합니다. array에 포함되어 있는 record 에는 다음과 같은 속성이 있습니다. isRequested, isSettled, isPending, isResolved, isRejected 레코드(record)가 완전한 상태가 아니면, 스피너가 보이도록 수정합니다. 1234567this.state.feeds.map(record =&gt; ｛ if (!record.isSettled) ｛ return &lt;Spinner key=｛ Math.random() ｝/&gt;; ｝ const ｛ content ｝ = record; return &lt;CardComponent data=｛ content ｝ key=｛ content.post_id ｝/&gt;｝) 무한 스크롤 만들기 이제 마지막 단계입니다. 스크롤하여 다음 레코드를 자동으로 불러올 차례입니다. 1234567891011121314151617181920212223242526272829class HomeTab extends Component ｛ constructor(props) ｛ //... ｝ setupImpagination() ｛ //... ｝ componentWillMount() ｛ //... ｝ setCurrentReadOffset = (event) =&gt; ｛ let itemHeight = 402; let currentOffset = Math.floor(event.nativeEvent.contentOffset.y); let currentItemIndex = Math.ceil(currentOffset / itemHeight); this.state.dataset.setReadOffset(currentItemIndex); ｝ render () ｛ return ( &lt;Container&gt; &lt;Header&gt;｛/* ... */｝&lt;/Header&gt; &lt;Content scrollEventThrottle=｛300｝ onScroll=｛this.setCurrentReadOffset｝&gt; ｛/* ... */｝ ｛ this.state.datasetState.map(record =&gt; ｛ const ｛ content ｝ = record; return &lt;CardComponent data=｛ content ｝ key=｛ content.post_id ｝/&gt; ｝) ｝ &lt;/Content&gt; &lt;/Container&gt; ) ｝｝ 스크롤 이벤트가 발생하면 setCurrentReadOffset() 함수가 호출됩니다. 이벤트 호출 시간은 scrollEventThrottle 속성을 사용하여 300(ms) 로 설정하였습니다. 다음은 완성한 앱입니다. 작업한 소스코드는 모두 깃허브에 업로드 되어있습니다. 그리고 샘플앱은 expo 클라이언트를 사용하면 확인해 볼 수 있습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: 광고 기능을 소개 합니다 지난주에 dclick 에서 Advertise 기능이 오픈 되었습니다. Advertise 메뉴 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Infinite Scroll","slug":"infinite-scroll","permalink":"https://anpigon.github.io/tags/infinite-scroll/"}],"author":"anpigon"},{"title":"[React Native] Redux와 Thunk Middleware 사용하기","slug":"/kr/@anpigon/react-native-redux-thunk-middleware--1548729080369","date":"2019-01-29T02:31:21.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-redux-thunk-middleware--1548729080369/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-redux-thunk-middleware--1548729080369/","excerpt":"이번에는 Redux와 Thunk Middleware를 사용해서 프로젝트의 전체적인 구조를 다시 잡아 보겠습니다. [React Native] 인스타그램 UI 만들기 시리즈의 개발환경을 그대로 사용합니다. 라이브러리 설치하기먼저 리덕스를 구현하는 필요한 라이브러리를 설치합니다. Redux 라이브러리는 이전 글 &quot;Redux로 Counter 앱 만들기&quot;에서도 한번 포스팅했었습니다.","text":"이번에는 Redux와 Thunk Middleware를 사용해서 프로젝트의 전체적인 구조를 다시 잡아 보겠습니다. [React Native] 인스타그램 UI 만들기 시리즈의 개발환경을 그대로 사용합니다. 라이브러리 설치하기먼저 리덕스를 구현하는 필요한 라이브러리를 설치합니다. Redux 라이브러리는 이전 글 &quot;Redux로 Counter 앱 만들기&quot;에서도 한번 포스팅했었습니다. redux 와 react-redux 설치 1$ yarn add redux react-redux 설치가 완료되고 나면 package.json 파일의 내용은 다음과 같습니다. 프로젝트 폴더 구조 만들기 이전 프로젝트에서 사용했던 폴더 구조를 조금 조정하겠습니다. 첫 번째로 src 폴더를 생성합니다. 그리고 App.js파일과 components 폴더를 src에 옮김니다. 그다음 Redux에 필요한 ./src/reducers 폴더를 생성합니다. reducers 폴더에는 리듀서 관련 파일을 넣을 것입니다. 마지막으로 루트에 App.js 파일을 생성합니다. 우리가 생성한 폴더 구조는 다음과 비슷해야합니다. Redux Store 설정하기 Redux 및 개념에 익숙하지 않은 경우에는 redux 문서를 참고하세요. 루트에 있는 ./App.js 파일에 Redux Store를 만듭니다 . Store에는 앱에 필요한 모든 데이터가 저장됩니다. 그리고 앱은 필요한 모든 데이터를 모두 Store에서 가져옵니다. 1234567import ｛ Provider ｝ from 'react-redux';import ｛ createStore, applyMiddleware ｝ from 'redux';import allReducers from './src/reducers';import App from './src/App';const store = createStore(allReducers); Reducers 는 단순히 일부 데이터를 반환하는 함수라고 볼 수 있습니다. 앱에는 여러 개의 reducers가 있을 수 있습니다. 우리는 이 reducers를 사용하여 가능한 많은 Store 을 구성 할 것 입니다. 위의 코드에서 우리는 모든 Reducers를 포함하는 allReducers 객체를 사용하고 있습니다. createStore 함수를 redux 모듈에서 import 합니다. 그리고 createStore() 함수를 사용하여 Store를 생성합니다. ./App.js 파일의 전체 코드는 다음과 같아야 합니다. 123456789101112131415161718import React, ｛ Component ｝ from 'react';import ｛ Provider ｝ from 'react-redux';import ｛ createStore, applyMiddleware ｝ from 'redux';import App from './src/App';import allReducers from './src/reducers';const store = createStore(allReducers);export default class Root extends Component ｛ render() ｛ return ( &lt;Provider store=｛ store ｝&gt; &lt;App/&gt; &lt;/Provider&gt; ) ｝｝ App.js 파일에서 제일 중요한 App 컴포넌트를 import하여 가져옵니다. Provider 컴포넌트를 react-redux 모듈에서 import 합니다. 이 컴포넌트는 App 컴포넌트를 하위 컴포넌트로 사용합니다. 그리고 Store 데이터를 App의 모든 부분에서 사용할 수 있도록 해줍니다. 마지막으로 store를 Provider 컴포넌트에 전달합니다. Store는 AllReducers 객체를 전달받아 생성되었습니다. Redux Reducers 만들기 우리는 하나의 리듀서(reducer)만 만들 것입니다. 그리고 만들어진 steemReducer 리듀서는 스팀잇 API 서버에서 데이터를 가져올 것입니다. ./src/reducers 폴더에 steemReducer.js 파일을 생성합니다. ./src/reducers/steemReducer.js 1234567891011121314151617181920212223242526import ｛ createAction, handleActions ｝ from 'redux-actions';// 액션 타입을 정의해줍니다.const GET_FEEDS = 'steem/getFeeds';// 액션 생성 함수를 만듭니다.export const getFeeds = createAction(GET_FEEDS);// 초기 State를 정의합니다.const initialState = ｛ feeds: []｝// 리듀서 함수를 정의합니다.export default handleActions(｛ [GET_FEEDS]: (state, action) =&gt; ｛ state = ｛ ...state, feeds: [ ...state.feeds, ...action.payload ] ｝ return state; ｝,｝, initialState); handleActions() 함수에 의해서 정의된 reducer 함수는 state와 action을 인자값으로 전달받습니다. 앱에서 Action이 전달되는 경우, action은 우리가 만든 모든 Reducers로 보내질 것입다. 마지막으로 모든 reducer를 하나의 개체로 결합할 파일이 필요합니다. reducer 폴더 아래에 index.js 파일을 만듭니다. 지금은 리듀서가 하나라서 불필요한 작업일 수 있습니다. 하지만 리듀서가 여러개일 경우에는 반드시 필요한 작업입니다. ./reducers/index.js 123456import ｛ combineReducers ｝ from 'redux';import steem from './steemReducer';export default combineReducers(｛ steem｝); Redux Thunk Middleware 사용하기 스팀잇 피드 목록을 가져 오는 작업은 Async operations 에 해당합니다. Async operations 은 오퍼레이션(operation)에 대한 응답이 바로 오지 않습니다. 따라서 Async operations에 대한 응답을 받을때까지 프로그램 실행을 잠시 중단하는 매커니즘이 필요합니다. 비동기로 가져오기 오퍼레이션(Async fetch operation)의 경우에 redux-thunk를 사용합니다. 라이브러리 설치하기 1$ yarn add redux-thunk 미들웨어 설정하기 App.js 파일로 돌아가서 store에 Thunk 미들웨어를 인식 시켜야 합니다. ./App.js 123import thunk from 'redux-thunk'import ｛ createStore, applyMiddleware ｝ from 'redux';const store = createStore(allReducers, applyMiddleware(thunk)); 이제 thunk action을 포함한 모든 actions을 생성할 수 있습니다. Redux Actions 만들기 리듀서에 fetchFeeds()함수를 생성합니다. fetchFeeds() 함수는 스팀잇 서버에서 피드를 가져오는 비동기 오퍼레이션을 수행할 것입니다. ./src/reducers/steemReducer.js 12345678910111213141516171819202122232425262728293031export const fetchFeeds = (tag) =&gt; ｛ const data = ｛ id: 1, jsonrpc: \"2.0\", method: \"call\", params: [ \"database_api\", \"get_discussions_by_created\", [ ｛ tag: tag, limit: 10, ｝ ] ] ｝; return (dispatch, state) =&gt; ｛ return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; ｛ dispatch(getFeeds(res.result)) ｝) .catch(error =&gt; ｛ console.error('ERROR', error); ｝); ｝;｝ Redux components에 적용하기 모든 Redux 설정이 끝나면, 우리는 이제 컴포넌트에서 리덕스를 사용할 수 있습니다. HomeTab.js 파일을 수정합니다. ./src/components/AppTabNavigator/HomeTab.js 1234567891011121314151617181920import ｛ connect ｝ from 'react-redux';import ｛ fetchFeeds ｝ from '../../reducers/steemReducer';// (...)// props에 전달할 state값 정의const mapStateToProps = (state) =&gt; ｛ return ｛ feeds: state.steem.feeds ｝｝;// props에 전달할 액션 함수 정의const mapDispatchToProps = ｛ fetchFeeds ｝;// 컴포넌트와 리덕스를 연결export default connect( mapStateToProps, mapDispatchToProps)(HomeTab); steemReducer 리듀서에서 fetchFeeds 액션을 import 하였습니다. mapStateToProps() 함수는 Props에 전달할 값을 정의합니다. steem 리듀서에서feeds 값을 Props에 전달하고 있습니다. mapDispatchToProps() 함수는 Props에 전달할 액션을 정의합니다. 마지막으로 connect() 함수를 사용하여 컴포넌트와 리덕스를 연결합니다. 이제 Reducers와 Actions를 Props로 전환하였습다. 그다음 componentWillMount() 함수를 수정합니다. 12345678910111213141516componentWillMount() ｛ // this.fetchFeeds().then(feeds =&gt; ｛ // this.setState(｛ // feeds // ｝) // ｝); this.props.fetchFeeds('kr'); // 리듀서 액션 호출 this.fetchFollowing().then(followings =&gt; ｛ this.setState(｛ followings ｝) ｝);｝ 원래 this.fetchFeeds() 함수를 호출하던 부분을 주석처리 하였습니다. 리듀서 액션 this.props.fetchFeeds()를 호출하도록 수정합니다. 마지막으로 render() 부분의 컴포넌트를 수정합니다. 1234567891011121314151617181920212223render() ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Header&gt; ｛/* (...) */｝ &lt;/Header&gt; &lt;Content&gt; ｛/* 여기부터 스토리 헤더 시작 */｝ ｛/* (...) */｝ ｛/* 여기까지 스토리 헤더 끝 */｝ ｛ !this.props.feeds || this.props.feeds.length === 0 ? &lt;Spinner color='blue'/&gt; : this.props.feeds.map(feed =&gt; ( &lt;CardComponent data=｛ feed ｝ key=｛ feed.url ｝/&gt; )) ｝ &lt;/Content&gt; &lt;/Container&gt; );｝ this.state.feeds를 this.props.feeds로 수정하였습니다. 이제 스팀잇 피드 가져오는 부분을 리듀서에서 처리하기 때문에, Props에서 가져와야 합니다. 그리고 &lt;Spinner color='blue'/&gt; 컴포넌트를 추가하여 피드를 가져오기 전에 로딩 이미지가 보이도록 하였습니다. 여기까지 작업한 구동 앱 화면입니다. UI는 달라진 부분이 없어서 변화가 크진 않네요. 작업한 소스코드는 모두 깃허브에 업로드 되어있습니다. * * * 인스타그램UI 형태의 스팀잇 모바일 앱을 원하는 분이 있다면, 개발을 더 진행하여 앱을 완성할 가치는 있을 것 같습니다. 하지만 partiko나 esteem와 같은 훌륭한 스팀잇 모바일 앱이 존재하므로, 저는 다른 형태의 모바일 앱을 개발하는 것이가치 있을 것으로 생각합니다. 그리고 이제 많은 분이 제 블로그 글을 보고 간단한 모바일 앱은 만들 수 있다고 생각합니다. 앞으로 다양한 아이디어를 가진 모바일 앱이 나오길 기대합니다. 개인적으로 스팀이 기반의 모바일 앱이 나오면 더 좋겠습니다. 예를 들어, 스팀잇 기반의 웹툰 서비스가 나오면 좋지 않을까요? 광고 수익과 스팀 저자 보상을 받을 수 있는 플랫폼이라면 괜찮을 거로 생각합니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"Thunk","slug":"thunk","permalink":"https://anpigon.github.io/tags/thunk/"}],"author":"anpigon"},{"title":"2019년 바람(Wish)","slug":"/kr/@anpigon/2019-wish","date":"2019-01-28T06:57:54.000Z","updated":"2019-11-11T13:41:49.856Z","comments":true,"path":"/kr/@anpigon/2019-wish/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/2019-wish/","excerpt":"2019년 새해 소원 릴레이 바톤을 넘겨주신 @codingart 님께 감사드립니다. 바톤을 받은 지 나흘이나 지났네요. 저는 개인적인 소망보다는 스팀잇에 바라는 점을 적어볼까 합니다. codingart님 말씀대로 저는 kr-dev 자리를 꾸준히 지켜보고 있습니다. 더 많은 분들이(비 개발자를 포함하여) 코딩에 관심을 가졌으면 좋겠어요. 그래서 스팀잇에 더 많은 코딩 글이 올라왔으면 좋겠습니다.","text":"2019년 새해 소원 릴레이 바톤을 넘겨주신 @codingart 님께 감사드립니다. 바톤을 받은 지 나흘이나 지났네요. 저는 개인적인 소망보다는 스팀잇에 바라는 점을 적어볼까 합니다. codingart님 말씀대로 저는 kr-dev 자리를 꾸준히 지켜보고 있습니다. 더 많은 분들이(비 개발자를 포함하여) 코딩에 관심을 가졌으면 좋겠어요. 그래서 스팀잇에 더 많은 코딩 글이 올라왔으면 좋겠습니다. 더 나아가 스팀잇에 다양한 분야의 글이 많아졌으면 좋겠습니다. 예를 들면 스팀잇에서 맛집, 요리, 여행, 코딩, 방송, 육아, 미용, IT, 영화, 독서, 상품, 만화 등 다양한 글을 읽을 수 있으면 좋겠어요. 불가능한 것은 아닙니다. 다양한 형태의 댑이 나와준다면 충분히 가능한 일입니다. 테이스팀 서비스 덕분에 스팀잇에는 맛집 글이 넘쳐납니다. ㅎㅎ * * * 저는 최근 공부하고 있는 리액트 네이티브나 블록체인, 머신러닝을 스팀잇에 정리해서 올리고 있습니다. 사실 제가 관심 있는 부분만 얇게 공부하고 있기 때문에, 관련 개발자가 읽기에 유용한 정보는 아닙니다. 대부분이 이미 인터넷에 공개되어 있는 정보입니다. 저는 비 개발자가 쉽게 따라 할 수 있도록 쉽게 정리해서 올리고 있습니다. 그리고 비 개발자가 관심 가질 만한 내용도 가끔 올리려고 노력합니다. 제 블로그를 보고 아이디어를 얻어가거나, 또는 저에게 아이디어를 줄 수 있지 않을까 하는 바람도 조금 있습니다. 지금은 스팀잇에 모바일 앱을 개발하는 과정을 정리해서 올리고 있습니다. 그리고 시간이 있을 때마다 다양한 형태의 모바일 앱을 만들어 볼 예정입니다. 하지만 완성도 높은 앱을 개발하려면 시간이 아직은 더 필요할 것 같습니다. 만들어 보고 싶은 앱은 많은데 시간이나 실력이 따라주진 못하네요. * * * 한 달만 더 있으면 제가 스팀잇을 시작한 지 만 1년이 됩니다. 스팀잇 서비스가 계속 유지되는 한 제가 먼저 스팀잇을 떠나는 일은 없을 것입니다. 그리고 올해 2019년에는 스팀잇에 큰 도약이 있었으면 좋겠습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[React Native] 스팀커넥트(Steemconnect) 로그인 만들기","slug":"/kr/@anpigon/react-native-steemconnect--1548595799187","date":"2019-01-27T13:30:18.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-steemconnect--1548595799187/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-steemconnect--1548595799187/","excerpt":"이번에는 리액트네이티브로 스팀커넥트 로그인을 구현합니다. 저는 스팀커넥트를 선호하는 편은 아닙니다. 하지만 편리함 때문에 사용하고 있습니다.“[React Native] 인스타그램 UI 만들기” 시리즈를 이어서 로그인까지 구현해보도록 하겠습니다. 이전에 작성했던 개발환경을 그대로 사용합니다.","text":"이번에는 리액트네이티브로 스팀커넥트 로그인을 구현합니다. 저는 스팀커넥트를 선호하는 편은 아닙니다. 하지만 편리함 때문에 사용하고 있습니다.“[React Native] 인스타그램 UI 만들기” 시리즈를 이어서 로그인까지 구현해보도록 하겠습니다. 이전에 작성했던 개발환경을 그대로 사용합니다. 로그인 화면 만들기 ./Components/LoginScreen.js 파일 생성합니다. LoginScreen 컴포넌트에는 로그인 버튼을 보여줄 것입니다. 123456789101112131415161718192021222324252627282930import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View, Modal ｝ from 'react-native';import ｛ Icon, Container, Button, Text ｝ from 'native-base'; export default class LoginScreen extends Component ｛ static navigationOptions = ｛ title: 'Login', ｝ render() ｛ return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛justifyContent:'center',alignItems: 'center'｝｝&gt; &lt;Button iconLeft primary&gt; &lt;Icon name=\"login\" type=\"AntDesign\" /&gt; &lt;Text&gt;Steemconnect Login&lt;/Text&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/Container&gt; ) ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', ｝,｝); 그다음 ./App.js 파일을 수정합니다. 123456789import MainScreen from './Components/MainScreen';import LoginScreen from './Components/LoginScreen';const AppStackNavigator = createStackNavigator(｛ Login: ｛ screen: LoginScreen ｝, Main: ｛ screen: MainScreen ｝｝);// ... 일부 코드 생략 ... LoginScreen 컴포넌트를 import 합니다. 그리고 AppStackNavigator 에 LoginScreen을 등록합니다. 로그인 체크 여부를 해서 LoginScreen 와 MainScreen를 분기해야 하지만, 나중에 고민해봅시다. 여기까지 작업하고 화면을 확인해봅니다. 심플하게 로그인 버튼 하나만 덩그러니 있습니다. Steemconnect 모달창 만들기 그다음에는 스팀커넥트 로그인 화면을 보여줄 모달창을 구현합니다. 스팀커넥트를 구현하기 위해서 steemconnect 라이브러리를 설치합니다. Steemconnect 라이브러리 설치 1$ yarn add steemconnect steemconnect 라이브러리 사용 방법은 공식 문서를 참고하세요. ./config.js 파일을 생성합니다. config.js에는 스팀커넥트를 생성하는데 필요한 설정값을 입력합니다. 12345module.exports = ｛ SC2_APP_ID=스팀커넥트 앱ID SC2_CALLBACK_URL=스팀커넥트 콜백URL｝ 그다음 ./steemConnect.js 파일을 생성합니다. steemConnect.js 파일에서는 steemconnect 객체를 초기화하여 생성합니다. 12345678910import sc2 from 'steemconnect';import Config from './config';const api = sc2.Initialize(｛ app: Config.SC2_APP_ID, callbackURL: Config.SC2_CALLBACK_URL, scope: ['vote','comment','delete_comment','comment_options','custom_json','claim_reward_balance','offline']｝);export default api; scope에는 사용가능한 모든 권한을 다 입력해보았습니다. 사실 offline 권한을 얻기 위해서는 response_type=code 옵션을 사용해야합니다. 하지만 별도의 요청 서버가 필요하기 때문에 이번에는 사용하지 않았습니다. ./Components/SteemConnectModal.js 파일을 생성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, ｛ Component ｝ from 'react';import ｛ WebView ｝ from 'react-native';import ｛ Icon, Container, Button, Header, Right ｝ from 'native-base'; import steemConnect from '../steemConnect';class SteemConnectModal extends Component ｛ // webview 상태 변경 체크 _onNavigationStateChange = (event) =&gt; ｛ if (event.url.indexOf('?access_token') &gt; -1) ｛ this.webview.stopLoading(); try ｛ const tokens = ｛｝; // 콜백 URL에서 accessToken 정보 추출하기 let params = event.url.split('?')[1]; params = params.split('&amp;'); params.forEach(e =&gt; ｛ const [key, val] = e.split('='); tokens[key] = val; ｝); // console.log('tokens:', tokens); // 스팀커넥트 인증 성공 this.props.onSteemconnectSuccess(tokens); ｝ catch (error) ｛ console.log(error); ｝ ｝ ｝; render() ｛ // 로그인 URL 생성 const link = steemConnect.getLoginURL(); // console.log(link); return ( &lt;Container style=｛｛ flex: 1 ｝｝&gt; &lt;Header&gt; &lt;Right&gt; &lt;Button icon transparent onPress=｛() =&gt; ｛ this.props.handleOnModalClose() ｝｝&gt;&lt;Icon name='ios-close'/&gt;&lt;/Button&gt; &lt;/Right&gt; &lt;/Header&gt; &lt;WebView source=｛｛ uri: link ｝｝ onNavigationStateChange=｛this._onNavigationStateChange｝ ref=｛ref =&gt; ｛ this.webview = ref ｝｝ /&gt; &lt;/Container&gt; ); ｝｝export default SteemConnectModal; _onNavigationStateChange() 함수는 WebView 컴포넌트의 URL 변화를 감지합니다. 그래서 스팀커넥트 콜백URL로 넘어온 토큰값을 가져옵니다. steemConnect.getLoginURL() 은 스팀로그인 URL을 생성합니다. https://steemconnect.com/oauth2/authorize?client_id=앱ID&amp;redirect_uri=콜백URL&amp;scope=vote,comment,delete_comment,comment_options,custom_json,claim_reward_balance,offline 형태의 URL이 생성됩니다. ./Components/LoginScreen.js 파일을 수정합니다. 이제 로그인 버튼을 누르면 SteemConnectModal 컴포넌트가 나타나게 합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import SteemConnectModal from './SteemConnectModal';import steemConnect from '../steemConnect';export default class LoginScreen extends Component ｛ static navigationOptions = ｛ title: 'Login', ｝ constructor(props) ｛ super(props); this.state = ｛ modalVisible: false, username: null, ｝ ｝ // 모달창 닫기 _handleOnModalClose = () =&gt; ｛ this.setState(｛ modalVisible: false ｝); ｝ // 스팀커넥트 성공 _onSteemconnectSuccess = (tokens) =&gt; ｛ this.setState(｛ modalVisible: false ｝); // console.log(tokens); // AccessToken 셋팅 steemConnect.setAccessToken(tokens.access_token); // 계정 정보 조회 steemConnect.me().then((｛ account ｝) =&gt; ｛ const ｛ profile ｝ = JSON.parse(account.json_metadata); console.log('profile', profile); this.setState(｛ username: profile.name ｝); ｝); ｝ render() ｛ const ｛ username ｝ = this.state; return ( &lt;Container style=｛styles.container｝&gt; &lt;View style=｛｛justifyContent:'center',alignItems: 'center'｝｝&gt; ｛ username ? &lt;Text&gt;｛ username ｝님 환영합니다.&lt;/Text&gt; : &lt;Button onPress=｛() =&gt; ｛ this.setState(｛ modalVisible: true ｝) ｝｝ iconLeft primary&gt; &lt;Icon name=\"login\" type=\"AntDesign\" /&gt; &lt;Text&gt;Steemconnect Login&lt;/Text&gt; &lt;/Button&gt; ｝ &lt;/View&gt; ｛/** 스팀커넥트 모달창 **/｝ &lt;Modal animationType=\"slide\" transparent=｛false｝ visible=｛this.state.modalVisible｝&gt; &lt;SteemConnectModal handleOnModalClose=｛this._handleOnModalClose｝ onSteemconnectSuccess=｛this._onSteemconnectSuccess｝ /&gt; &lt;/Modal&gt; &lt;/Container&gt; ) ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', ｝,｝);// ... 일부 코드 생략 ... 로그인이 되기전에는 로그인 버튼이 보이고, 로그인이 되고 나면 사용자 이름이 보입니다. _handleOnModalClose() 함수의 기능은 모달창을 닫습니다. _onSteemconnectSuccess() 함수는 스팀커넥트 로그인이 성공하면, access_token 을 전달받습니다. 그리고 로그인한 사용자 이름을 출력합니다. 아래는 완성된 앱 화면입니다. 구현된 소스는 깃허브 에 업로드 되어있습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] 인스타그램 UI 만들기 #5","slug":"/kr/@anpigon/react-native-ui-5-1548346515419","date":"2019-01-24T16:15:15.000Z","updated":"2019-11-11T13:41:49.823Z","comments":true,"path":"/kr/@anpigon/react-native-ui-5-1548346515419/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui-5-1548346515419/","excerpt":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 다섯번째 강의입니다. 이번에는 프로필 화면의 블로그 영역을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/JQuhEe9h9ok 동영상 강의는 이번이 마지막 입니다.","text":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 다섯번째 강의입니다. 이번에는 프로필 화면의 블로그 영역을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/JQuhEe9h9ok 동영상 강의는 이번이 마지막 입니다. ProfileTab에 세그먼트 버튼 만들기 ProfileTab.js 를 수정합니다. 프로필 화면에 버튼 4개를 만듭니다. 1234567891011121314&lt;View style=｛｛ flexDirection: 'row', justifyContent:'space-around', borderTopWidth:1,borderTopColor:'#eae5e5' ｝｝&gt; &lt;Button transparent&gt; &lt;Icon name='ios-apps' /&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-list' /&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-people' /&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-bookmark' /&gt; &lt;/Button&gt;&lt;/View&gt; 아래와 같이 프로필 화면에 아이콘 버튼 4개가 나타났습니다. 세그먼트 버튼에 이벤트 만들기 그다음은 각 버튼을 누르면 버튼이 활성화된 상태로 보이도록 구현합니다. 우선 state에 activeIndex를 선언합니다. 1234state = ｛ // ... 일부 코드 생략 ... activeIndex: 0,｝ 그리고 senmentClicked() 함수를 입력합니다. 12345senmentClicked = (activeIndex) =&gt; ｛ this.setState(｛ activeIndex ｝);｝ senmentClicked() 함수가 호출되면 전달된 값으로 state.activeIndex가 업데이트됩니다. 그다음은 버튼을 선택하면 senmentClicked() 함수가 호출되도록 합니다. 1234567891011121314151617181920212223242526&lt;View style=｛｛ flexDirection: 'row', justifyContent:'space-around', borderTopWidth:1,borderTopColor:'#eae5e5' ｝｝&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(0)｝ active=｛this.state.activeIndex === 0｝&gt; &lt;Icon name='ios-apps' style=｛[ this.state.activeIndex === 0 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(1)｝ active=｛this.state.activeIndex === 1｝&gt; &lt;Icon name='ios-list' style=｛[ this.state.activeIndex === 1 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(2)｝ active=｛this.state.activeIndex === 2｝&gt; &lt;Icon name='ios-people' style=｛[ this.state.activeIndex === 2 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(3)｝ active=｛this.state.activeIndex === 3｝&gt; &lt;Icon name='ios-bookmark' style=｛[ this.state.activeIndex === 3 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt;&lt;/View&gt; 각 Button의 onPress 속성에 ｛() =&gt; this.segmentClicked(0)｝를 입력합니다. segmentClicked()에는 각 버튼에 해당하는 인덱스 번호를 전달합니다. 그리고 선택된 버튼은 active 속성이 true가 됩니다. 그리고 선택되지 않은 버튼은 아이콘이 회색으로 표시되도록 하였습니다. 여기까지 작업하고 앱을 확인해봅니다. 선택한 버튼이 활성화되는 효과가 보이나요? 선택한 버튼에 따라 세그먼트 화면 전환하기 이제 선택한 버튼에 따라 화면에 다른 내용이 보여지게 합니다. renderSection() 함수를 입력합니다. 123456789export default class ProfileTab extends Component ｛ renderSection = () =&gt; ｛ if(this.state.activeIndex === 0) ｛ return &lt;View&gt;&lt;Text&gt;This is first section&lt;/Text&gt;&lt;/View&gt; ｝ ｝ // ... 일부 코드 생략 ... 우리는 버튼을 선택하면 해당 버튼의 인덱스를 state.activeIndex에 저장하였습니다. state.activeIndex 값에 따라서 다른 화면 내용이 보여지게 합니다. 버튼 영역 바로 아래에 ｛ this.renderSection() ｝ 코드를 입력합니다. 1234567891011121314151617181920212223242526272829&lt;View style=｛｛ flexDirection: 'row', justifyContent:'space-around', borderTopWidth:1,borderTopColor:'#eae5e5' ｝｝&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(0)｝ active=｛this.state.activeIndex === 0｝&gt; &lt;Icon name='ios-apps' style=｛[ this.state.activeIndex === 0 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(1)｝ active=｛this.state.activeIndex === 1｝&gt; &lt;Icon name='ios-list' style=｛[ this.state.activeIndex === 1 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(2)｝ active=｛this.state.activeIndex === 2｝&gt; &lt;Icon name='ios-people' style=｛[ this.state.activeIndex === 2 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt; &lt;Button transparent onPress=｛() =&gt; this.segmentClicked(3)｝ active=｛this.state.activeIndex === 3｝&gt; &lt;Icon name='ios-bookmark' style=｛[ this.state.activeIndex === 3 ? ｛｝ : ｛color: 'grey'｝ ]｝/&gt; &lt;/Button&gt;&lt;/View&gt;｛/* 아래 코드 추가 */｝｛ this.renderSection() ｝ 이제 첫번째 버튼을 선택하면 아래와 같은 화면이 표시됩니다. 첫번째 세그먼트 화면 구현하기 아래와 같이 이미지 더미 데이터를 입력합니다. 이미지 URL은 pixabay에서 임의로 가져왔습니다. 12345678910111213141516let images = [\"https://cdn.pixabay.com/photo/2018/11/29/21/19/hamburg-3846525__480.jpg\",\"https://cdn.pixabay.com/photo/2018/11/11/16/51/ibis-3809147__480.jpg\",\"https://cdn.pixabay.com/photo/2018/11/23/14/19/forest-3833973__480.jpg\",\"https://cdn.pixabay.com/photo/2019/01/05/17/05/man-3915438__480.jpg\",\"https://cdn.pixabay.com/photo/2018/12/04/22/38/road-3856796__480.jpg\",\"https://cdn.pixabay.com/photo/2018/11/04/20/21/harley-davidson-3794909__480.jpg\",\"https://cdn.pixabay.com/photo/2018/12/25/21/45/crystal-ball-photography-3894871__480.jpg\",\"https://cdn.pixabay.com/photo/2018/12/29/23/49/rays-3902368__480.jpg\",\"https://cdn.pixabay.com/photo/2017/05/05/16/57/buzzard-2287699__480.jpg\",\"https://cdn.pixabay.com/photo/2018/08/06/16/30/mushroom-3587888__480.jpg\",\"https://cdn.pixabay.com/photo/2018/12/15/02/53/flower-3876195__480.jpg\",\"https://cdn.pixabay.com/photo/2018/12/16/18/12/open-fire-3879031__480.jpg\",\"https://cdn.pixabay.com/photo/2018/11/24/02/05/lichterkette-3834926__480.jpg\",\"https://cdn.pixabay.com/photo/2018/11/29/19/29/autumn-3846345__480.jpg\"] 그다음 Dimensions를 import 합니다. 그리고 window 에서 width 와 height를 가져옵니다. 123import ｛ View, Text, StyleSheet, Image, Dimensions ｝ from 'react-native';const ｛ width, height ｝ = Dimensions.get('window'); renderSectionOne() 함수를 입력합니다. 1234567891011121314export default class ProfileTab extends Component ｛ renderSectionOne = () =&gt; ｛ return images.map((image, index) =&gt; ｛ return ( &lt;View key=｛index｝ style=｛｛ width: width/3, height: width/3 ｝｝ &gt; &lt;Image source=｛｛ url: image ｝｝ style=｛｛ flex:1 ｝｝/&gt; &lt;/View&gt; ) ｝) ｝ // ... 일부 코드 생략 ... renderSectionOne() 함수는 Image 를 화면 너비의 1/3 정사각형 크기로 출력합니다. 그리고 renderSection() 함수를 수정합니다. 123456789renderSection = () =&gt; ｛ if(this.state.activeIndex === 0) ｛ return ( &lt;View style=｛｛flexDirection:'row',flexWrap:'wrap'｝｝&gt; ｛ this.renderSectionOne() ｝ &lt;/View&gt; ) ｝｝ state.activeIndex가 0이면, renderSectionOne() 함수를 호출합니다. 앱 화면을 확인해보면 아래와 같이 표시됩니다. 내 스팀잇 블로그 글 표시하기 두 번째 버튼에 해당하는 세그먼트에는 내 스팀잇 블로그 글을 출력해보도록 합니다. 내 스팀잇 블로그 정보를 가져오는 fetchState() 함수를 구현합니다. fetchState() 함수를 이용하여 내 블로그 글을 표시해보도록 하겠습니다. 1234567891011121314151617181920212223export default class ProfileTab extends Component ｛ fetchState(username) ｛ const data = ｛ id: 3, jsonrpc: \"2.0\", method: \"call\", params: [ \"database_api\", \"get_state\", [`/@$｛username｝`] ] ｝; return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; res.result[0]) ｝ // ... 일부 코드 생략 ... 자세한 구현 내용은 ProfileTab.js 파일을 참고하세요. 아래는 완성된 화면입니다. 작업한 코드는 모두 깃허브에 업로드되어 있습니다. https://github.com/anpigon/rn_instagram_clone 여기까지 읽어주셔서 감사합니다. 시리즈 [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 Sponsored ( Powered by dclick ) 늦었지만 그럼에도 불구하고 진전있는 스팀의 행보를 기대봅니다. 이전까지의 행보로 많이 잰걸음했지만 지금의 행보를 보며 기대를 걸어봅니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"인스타그램 만들기","slug":"개발-이야기/react-native/인스타그램-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/인스타그램-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] 인스타그램 UI 만들기 #4","slug":"/kr/@anpigon/react-native-ui-4-1548207724086","date":"2019-01-23T01:42:06.000Z","updated":"2019-11-11T13:41:49.823Z","comments":true,"path":"/kr/@anpigon/react-native-ui-4-1548207724086/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui-4-1548207724086/","excerpt":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 네 번째 강의입니다. 이번에는 프로필 화면을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/9g_73wEbX8E 상단바 수정하기탭 화면마다 상단바가 다르기 때문에 수정해야합니다. 현재는 모든 탭 화면에서 같은 상단바가 보입니다.","text":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 네 번째 강의입니다. 이번에는 프로필 화면을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/9g_73wEbX8E 상단바 수정하기탭 화면마다 상단바가 다르기 때문에 수정해야합니다. 현재는 모든 탭 화면에서 같은 상단바가 보입니다. 먼저 MainScreen.js 파일을 수정합니다. 아래와 같이 header에 null 을 입력합니다. 1234567export default class MainScreen extends Component ｛ static navigationOptions = ｛ header: null ｝// ... 일부 코드 생략 ... 그다음 ./Components/AppTabNavigator/HomeTab.js 파일을 수정합니다. Header, Left, Right, Body를 추가로 import 합니다. 1import ｛ Container, Content, Icon, Thumbnail, Header, Left, Right, Body ｝ from 'native-base'; 그리고 render() 함수를 수정합니다. Container 아래에 Header를 추가합니다. 1234567891011export default class HomeTab extends Component ｛ render() ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Header&gt; &lt;Left&gt;&lt;Icon name='ios-camera' style=｛｛ paddingLeft:10 ｝｝/&gt;&lt;/Left&gt; &lt;Body&gt;&lt;Text&gt;Instagram&lt;/Text&gt;&lt;/Body&gt; &lt;Right&gt;&lt;Icon name='ios-send' style=｛｛ paddingRight:10 ｝｝/&gt;&lt;/Right&gt; &lt;/Header&gt; ｛/* ... 일부 코드 생략 ... */｝ 여기까지 작업하고 확인해보겠습니다. 확인해보면 HomeTab 에만 헤더가 있고, 나머지 탭 화면는 헤더가 없습니다. 프로필 페이지 헤더 만들기 ./Components/AppTabNavigator/ProfileTab.js를 수정합니다. Image와 Container, Content, Header, Left, Body, Right, Button를 추가로 import 합니다. 12import ｛ View, Text, StyleSheet, Image ｝ from 'react-native';import ｛ Icon, Container, Content, Header, Left, Body, Right, Button, Image ｝ from 'native-base'; 그다음 render() 함수를 수정합니다. 다음과 같이 Header 를 추가합니다. 123456789101112131415export default class ProfileTab extends Component｛ render() ｛ return ( &lt;Container style=｛｛ flex:1, backgroundColor: 'white'｝｝&gt; &lt;Header&gt; &lt;Left&gt;&lt;Icon name=\"md-person-add\" style=｛｛ paddingLeft:10 ｝｝ /&gt;&lt;/Left&gt; &lt;Body&gt;&lt;Text&gt;anpigon&lt;/Text&gt;&lt;/Body&gt; &lt;Right&gt;&lt;EntypoIcon name=\"back-in-time\" style=｛｛ paddingRight:10, fontSize: 32 ｝｝ /&gt;&lt;/Right&gt; &lt;/Header&gt; &lt;/Container&gt; ); ｝ ｛/* ... 일부 코드 생략 ... */｝ 여기까지 작업한 화면입니다. 상단 좌우에 아이콘이 생겼습니다. Header 바로 아래에 다음 코드를 입력합니다. 프로필 이미지, 포스팅 수, 팔로워 수, 팔로잉 수를 출력합니다. 바로 아래에 프로필 수정 버튼과 설정 버튼이 위치하고 있습니다. 그리고 그 아래에 이름과 프로필 정보가 출력됩니다. 123456789101112131415161718192021222324252627282930313233343536373839&lt;Content&gt; &lt;View style=｛｛flexDirection:'row', paddingTop:10｝｝&gt; &lt;View style=｛｛flex:1, alignItems:'center'｝｝&gt; &lt;Image source=｛｛ url: 'https://steemitimages.com/u/anpigon/avatar' ｝｝ style=｛｛width:75, height:75, borderRadius:37.5｝｝/&gt; &lt;/View&gt; &lt;View style=｛｛flex:3｝｝&gt; &lt;View style=｛｛flexDirection:'row', justifyContent:'space-around'｝｝&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;167&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;posts&lt;/Text&gt; &lt;/View&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;346&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;follower&lt;/Text&gt; &lt;/View&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;192&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;following&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛flexDirection:'row'｝｝&gt; &lt;Button bordered dark style=｛｛flex:4, marginLeft:10, justifyContent:'center', height:30, marginTop:10｝｝&gt; &lt;Text&gt;Edit Profile&lt;/Text&gt; &lt;/Button&gt; &lt;Button bordered dark small icon style=｛｛flex:1, marginRight:10, marginLeft:5, justifyContent:'center', height:30, marginTop:10｝｝&gt; &lt;Icon name=\"settings\" /&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛paddingHorizontal:10, paddingVertical:10｝｝&gt; &lt;Text style=｛｛fontWeight:'bold'｝｝&gt;안피곤&lt;/Text&gt; &lt;Text&gt;Lark | Computer Jock | Commercial Pilot&lt;/Text&gt; &lt;Text&gt;www.steemit.com/@anpigon&lt;/Text&gt; &lt;/View&gt;&lt;/Content&gt; 여기까지 작업한 화면입니다. 스팀잇 프로필 정보 출력하기 스팀잇 서버에서 계정 정보를 가져오는 함수를 입력합니다. 스팀잇의 database_api.get_accounts API를 사용합니다. 123456789101112131415161718fetchAccount(username) ｛ const data = ｛ id: 3, jsonrpc: \"2.0\", method: \"call\", params: [ \"database_api\", \"get_accounts\", [[username]] ] ｝; return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; res.result[0])｝ 그리고 스팀잇 팔로우 수와 팔로잉 수를 가져오는 함수를 입력합니다. follow_api.get_follow_count API를 사용합니다. 123456789101112131415161718fetchFollowCount(username) ｛ const data = ｛ id: 4, jsonrpc: \"2.0\", method: \"call\", params: [ \"follow_api\", \"get_follow_count\", [username] ] ｝; return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; res.result)｝ 그다음 componentWillMount() 를 구현합니다. 그리고 방금 구현한 함수를 호출합니다. 계정 정보와 팔로우 수를 가져와서 state 에 저장합니다. 명성(reputation)도 계산하여 저장하고 있습니다. 123456789101112131415161718192021componentWillMount() ｛ const username = 'anpigon'; this.fetchAccount(username).then((｛name, post_count, reputation, json_metadata｝) =&gt; ｛ const ｛ profile ｝ = JSON.parse(json_metadata); // JSON 파싱 const log = Math.log(parseInt(reputation.substring(0, 4))) / Math.log(10); this.setState(｛ name, // 이름 reputation: Math.max(reputation.length - 1 + log - parseInt(log) - 9, 0) * 9 + 25, // 명성도 계산 postCount: post_count, // 포스팅 수 profile // 프로필 정보 ｝) ｝); this.fetchFollowCount(username).then((｛following_count, follower_count｝) =&gt; ｛ this.setState(｛ followingCount: following_count, // 팔로잉 수 followerCount: follower_count // 팔로워 수 ｝) ｝);｝ 마지막으로 render() 함수를 수정합니다. 앞에서 가져온 정보들을 출력하기 위해 데이터를 맵핑합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859render() ｛ const ｛ name, reputation, profile, postCount, followingCount, followerCount ｝ = this.state; return ( &lt;Container style=｛｛ flex:1, backgroundColor: 'white'｝｝&gt; &lt;Header&gt; &lt;Left&gt;&lt;Icon name=\"md-person-add\" style=｛｛ paddingLeft:10 ｝｝ /&gt;&lt;/Left&gt; &lt;Body&gt;&lt;Text&gt;｛name｝&lt;/Text&gt;&lt;/Body&gt; &lt;Right&gt;&lt;EntypoIcon name=\"back-in-time\" style=｛｛ paddingRight:10, fontSize: 32 ｝｝ /&gt;&lt;/Right&gt; &lt;/Header&gt; &lt;Content&gt; &lt;View style=｛｛flexDirection:'row', paddingTop:10｝｝&gt; &lt;View style=｛｛flex:1, alignItems:'center'｝｝&gt; &lt;Image source=｛｛ url: profile.profile_image ｝｝ style=｛｛width:75, height:75, borderRadius:37.5｝｝/&gt; &lt;/View&gt; &lt;View style=｛｛flex:3｝｝&gt; &lt;View style=｛｛flexDirection:'row', justifyContent:'space-around'｝｝&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;｛postCount｝&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;posts&lt;/Text&gt; &lt;/View&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;｛followingCount｝&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;follower&lt;/Text&gt; &lt;/View&gt; &lt;View style=｛｛alignItems:'center'｝｝&gt; &lt;Text&gt;｛followerCount｝&lt;/Text&gt; &lt;Text style=｛｛fontSize:10, color:'gray'｝｝&gt;following&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛flexDirection:'row'｝｝&gt; &lt;Button bordered dark style=｛｛flex:4, marginLeft:10, justifyContent:'center', height:30, marginTop:10｝｝&gt; &lt;Text&gt;Edit Profile&lt;/Text&gt; &lt;/Button&gt; &lt;Button bordered dark small icon style=｛｛flex:1, marginRight:10, marginLeft:5, justifyContent:'center', height:30, marginTop:10｝｝&gt; &lt;Icon name=\"settings\" /&gt; &lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛paddingHorizontal:10, paddingVertical:10｝｝&gt; &lt;Text style=｛｛fontWeight:'bold'｝｝&gt;｛profile.name｝ (｛reputation.toFixed(2)｝)&lt;/Text&gt; &lt;Text&gt;｛profile.about｝&lt;/Text&gt; &lt;Text&gt;｛profile.website｝&lt;/Text&gt; &lt;/View&gt; &lt;/Content&gt; &lt;/Container&gt;);｝ 오늘 작업한 결과 화면입니다. 작업한 코드는 모두 깃허브에 업로드되어 있습니다. https://github.com/anpigon/rn_instagram_clone 여기까지 읽어주셔서 감사합니다. 시리즈 [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 Sponsored ( Powered by dclick ) 눈이 많이 오던 날 올해는 눈이 많이 안 오네요. 겨울에는 눈이 펑펑 와야 겨울 같은데… 오라는 눈은 안 오고…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"인스타그램 만들기","slug":"개발-이야기/react-native/인스타그램-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/인스타그램-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] 인스타그램 UI 만들기 #3","slug":"/kr/@anpigon/react-native-ui-3-1548134597178","date":"2019-01-22T05:23:18.000Z","updated":"2019-11-11T13:41:49.823Z","comments":true,"path":"/kr/@anpigon/react-native-ui-3-1548134597178/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui-3-1548134597178/","excerpt":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 세 번째 강의입니다. 이번에는 홈 화면에 스토리 헤더를 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/aMqReBxlFfk 인스타그램 UI 코딩 동영상 강의는 총 5편입니다. 이제 앞으로 2편 남았네요. 이번 강의 내용은 저번보다 조금 짧습니다. ㅎ","text":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 세 번째 강의입니다. 이번에는 홈 화면에 스토리 헤더를 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/aMqReBxlFfk 인스타그램 UI 코딩 동영상 강의는 총 5편입니다. 이제 앞으로 2편 남았네요. 이번 강의 내용은 저번보다 조금 짧습니다. ㅎ 스토리 헤더 만들기 ./Components/AppTabNavigator/HomeTab.js 파일을 수정합니다. 그리고 피드 목록 바로 위에 스토리 헤더 영역을 구현합니다. 먼저 스토리 헤더 영역 위치를 잡기 위해 기본 컴포넌트를 사용하여 구현합니다. 그리고 앱을 실행하여 확인해보겠습니다. 12345678910111213141516171819202122232425262728293031export default class HomeTab extends Component ｛ render() ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Content&gt; ｛/* 여기부터 스토리 헤더 시작 */｝ &lt;View style=｛｛ height: 100 ｝｝&gt; &lt;View style=｛｛ flex: 1, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 7 ｝｝&gt; &lt;Text style=｛｛ fontWeight: 'bold' ｝｝&gt;Stories&lt;/Text&gt; &lt;View style=｛｛flexDirection:'row','alignItems':'center'｝｝&gt; &lt;Icon name=\"md-play\" style=｛｛fontSize:14｝｝&gt;&lt;/Icon&gt; &lt;Text style=｛｛fontWeight:'bold'｝｝&gt; Watch All&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ｛/* 여기까지 스토리 헤더 끝 */｝ ｛ this.state.feeds.map(feed =&gt; ( &lt;CardComponent data=｛ feed ｝ key=｛ feed.url ｝/&gt; )) ｝ &lt;/Content&gt; &lt;/Container&gt; ); ｝｝// ... 일부 코드 생략 ... 스토리 헤더의 heigh는 100입니다. 그리고 텍스트 *“Stories”*와 *“Watch All”*을 양쪽 정렬(｛ justifyContent: 'space-between ｝) 하였습니다. 여기까지 작업한 화면입니다. 피드 상단에 스토리 헤더가 생겼습니다. 스토리 헤더에 스크롤 뷰 만들기 HomeTab에 ScrollView와 Thumbnail 를 추가로 import 합니다. 12import ｛ View, Text, StyleSheet, ScrollView ｝ from 'react-native';import ｛ Container, Content, Icon, Thumbnail ｝ from 'native-base'; 그리고 앞에서 작성한 View 바로 아래에 ScrollView 를 추가합니다. 그리고 ScrollView 안에 Thumbnail 을 추가합니다. 12345678910111213141516171819202122232425｛/* 여기부터 스토리 헤더 시작 */｝&lt;View style=｛｛ height: 100 ｝｝&gt; &lt;View style=｛｛ flex: 1, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 7 ｝｝&gt; &lt;Text style=｛｛ fontWeight: 'bold' ｝｝&gt;Stories&lt;/Text&gt; &lt;View style=｛｛ flexDirection: 'row', 'alignItems': 'center' ｝｝&gt; &lt;Icon name=\"md-play\" style=｛｛ fontSize: 14 ｝｝&gt;&lt;/Icon&gt; &lt;Text style=｛｛ fontWeight: 'bold' ｝｝&gt; Watch All&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=｛｛ flex: 3 ｝｝&gt; &lt;ScrollViewhorizontal=｛true｝&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/newbijohn/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/jacobyu/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/blockchainstudio/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/gomdory/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/bbooaae/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/codingman/avatar' ｝｝ /&gt; &lt;Thumbnail source=｛｛uri: 'https://steemitimages.com/u/bukio/avatar' ｝｝ /&gt; &lt;/ScrollView&gt; &lt;/View&gt;&lt;/View&gt;｛/* 여기까지 스토리 헤더 끝 */｝ Thumbnail 에는 제 팔로우 친구들의 사진을 임의로 가져와서 출력하였습니다. 여기까지 작업한 화면입니다. 피드 상단에 팔로우 친구들이 보입니다. 스토리 헤더 스타일링 하기 ScrollView와 Thumbnail에 스타일을 지정합니다. 12345678910111213&lt;ScrollView horizontal=｛true｝ showsHorizontalScrollIndicator=｛false｝ contentContainerStyle=｛｛ alignItems: 'center', paddingStart: 5, paddingEnd: 5｝｝&gt; &lt;Thumbnail style=｛｛ marginHorizontal: 5, borderColor: 'pink', borderWidth: 2 ｝｝ source=｛｛uri: 'https://steemitimages.com/u/newbijohn/avatar' ｝｝ /&gt;｛/* ... 일부 코드 생략 ... */｝ 스팀잇에서 팔로잉 친구 가져와서 출력하기 마지막으로 스팀잇 팔로우 친구를 가져와서 출력하는 기능을 구현하겠습니다. HomeTab 클래스에 팔로잉 친구를 가져오는 함수를 구현합니다. 12345678910111213141516171819202122export default class HomeTab extends Component ｛ // 팔로잉 친구 가져오기 fetchFollowing() ｛ const data = ｛ id: 2, jsonrpc: \"2.0\", method: \"call\", params: [ \"follow_api\", \"get_following\", [\"anpigon\", \"\", \"blog\", 10] ] ｝; return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; res.result.map((｛following｝) =&gt; following)) ｝ 그다음 state에 followings 변수를 선언합니다. followings에는 팔로잉 친구 목록을 저장할 것입니다. 12345678export default class HomeTab extends Component ｛ state = ｛ feeds: [], followings: [] ｝// ... 일부 코드 생략 ... 그리고 componentWillMount() 함수를 수정합니다. 이 함수는 컴포넌트가 마운트 되기 전에 실행됩니다. 여기서 스팀잇 서버에서 팔로잉 친구 목록을 가져옵니다. 12345678910111213141516171819export default class HomeTab extends Component ｛ componentWillMount() ｛ // 피드 가져오기 this.fetchFeeds().then(feeds =&gt; ｛ this.setState(｛ feeds ｝) ｝); // 팔로잉 친구 가져오기 this.fetchFollowing().then(followings =&gt; ｛ this.setState(｛ followings ｝) ｝); ｝ // ... 일부 코드 생략 ... 마지막으로 스크롤뷰를 다음과 같이 수정합니다. 팔로잉 친구들 사진을 출력합니다. 1234567891011121314&lt;ScrollView horizontal=｛true｝ showsHorizontalScrollIndicator=｛false｝ contentContainerStyle=｛｛ alignItems: 'center', paddingStart: 5, paddingEnd: 5｝｝&gt; ｛ this.state.followings.map(following =&gt; &lt;Thumbnail style=｛｛ marginHorizontal: 5, borderColor: 'pink', borderWidth: 2 ｝｝ source=｛｛uri: `https://steemitimages.com/u/$｛following｝/avatar` ｝｝ /&gt;) ｝&lt;/ScrollView&gt; 여기까지 작업한 화면입니다. 피드 상단에 팔로우 친구들이 보입니다. 그리고 좌우로 스크롤 가능합니다. 작업한 코드는 모두 깃허브에 업로드되어 있습니다. https://github.com/anpigon/rn_instagram_clone 여기까지 읽어주셔서 감사합니다. 시리즈 [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 Sponsored ( Powered by dclick ) 눈이 많이 오던 날 올해는 눈이 많이 안 오네요. 겨울에는 눈이 펑펑 와야 겨울 같은데… 오라는 눈은 안 오고…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"인스타그램 만들기","slug":"개발-이야기/react-native/인스타그램-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/인스타그램-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] 인스타그램 UI 만들기 #2","slug":"/kr/@anpigon/react-native-ui-2-1548079722841","date":"2019-01-21T14:08:42.000Z","updated":"2019-11-11T13:41:49.823Z","comments":true,"path":"/kr/@anpigon/react-native-ui-2-1548079722841/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui-2-1548079722841/","excerpt":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 두 번째 강의입니다. 이번에는 홈 화면에 피드 목록을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/wc4jFStaR2c CardComponent 만들기","text":"리액트 네이티브(React Native)로 인스타그램 UI를 구현하는 두 번째 강의입니다. 이번에는 홈 화면에 피드 목록을 구현합니다. 이 포스팅은 아래 무료 동영상 강의를 참고하여 작성하였습니다.https://youtu.be/wc4jFStaR2c CardComponent 만들기 Components 폴더 아래에 CardComponent.js 파일을 생성합니다. CardComponent는 우리가 앞으로 구현할 피드 목록에서 피드 항목 하나를 담당하게 될 컴포넌트입니다. 1234567891011121314151617181920import React, ｛ Component ｝ from 'react';import ｛ View, Image, Text, StyleSheet ｝ from 'react-native'; export default class CardCompnent extends Component｛ render() ｛ return ( &lt;View style=｛style.container｝&gt; &lt;Text&gt;CardCompnent&lt;/Text&gt; &lt;/View&gt; ); ｝｝ const style = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', ｝｝); 동영상에서는 create snippet 기능을 사용해서 컴포넌트 파일을 생성하는데, 무척 간편해 보입니다. 해당 기능이 궁금한 분은 여기를 참고하세요. CardComponent에 추가로 필요한 native-base 컴포넌트를 import 합니다. 1import ｛ Card, CardItem, Thumbnail, Body, Left, Right, Button, Icon ｝ from 'native-base'; 그리고 CardComponent의 render() 함수를 수정합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default class CardCompnent extends Component｛ render()｛ return ( &lt;Card&gt; &lt;CardItem&gt; &lt;Left&gt; &lt;Thumbnail source=｛｛ uri: 'https://steemitimages.com/u/anpigon/avatar' ｝｝ /&gt; &lt;Body&gt; &lt;Text&gt;Anpigon&lt;/Text&gt; &lt;Text note&gt;Jan 21, 2019&lt;/Text&gt; &lt;/Body&gt; &lt;/Left&gt; &lt;/CardItem&gt; &lt;CardItem cardBody&gt; &lt;Image source=｛｛ uri: 'https://user-images.githubusercontent.com/3969643/51441420-b41f1c80-1d14-11e9-9f5d-af5cd3a6aaae.png' ｝｝ style=｛｛ height:200, width:null, flex: 1 ｝｝ /&gt; &lt;/CardItem&gt; &lt;CardItem style=｛｛ height:45 ｝｝&gt; &lt;Left&gt; &lt;Button transparent&gt; &lt;Icon name='ios-heart' style=｛｛ color:'black' ｝｝/&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-chatbubbles' style=｛｛ color:'black' ｝｝/&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-send' style=｛｛ color:'black' ｝｝/&gt; &lt;/Button&gt; &lt;/Left&gt; &lt;/CardItem&gt; &lt;CardItem style=｛｛ height: 20 ｝｝&gt; &lt;Text&gt;101 likes&lt;/Text&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Text&gt; &lt;Text style=｛｛ fontWeight:'900'｝｝&gt;Anpigon&lt;/Text&gt; 이번에는 리액트 네이티브(React Native)로 인스타그램 UI을 구현하는 포스팅입니다. 다른 앱을 따라 만들어 보는 것은 굉장히 재미있습니다. 구글에서 인스타그램 클론 코딩 강의를 찾아보니, 다른 개발자들이 올린 동영상 강의를 몇 개 찾을 수 있었습니다. &lt;/Text&gt; &lt;/CardItem&gt; &lt;/Card&gt; ); ｝｝ CardComponent는 작성자 프로필 영역, 메인 이미지 영역, 본문 영역으로 구성되어 있습니다. 일단은 화면에 피드가 어떻게 표시되는지 확인하기 위해, CardComponent에 임시 데이터를 입력해 놓았습니다. HomeTab 컴포넌트 수정하기 ./Components/AppTabNavigator/HomeTab.js 파일을 수정합니다. native-base에서 Container, Content 컴포넌트와 방금 만든 CardComponent를 Import 합니다. 그리고 render() 함수와 style를 수정합니다. 1234567891011121314151617181920212223242526// ... 일부 import 생략 ...import ｛ Container, Content, Icon ｝ from 'native-base'; // Container, Content 추가로 importimport CardComponent from '../CardComponent'; // 카드 컴포넌트 추가export default class HomeTab extends Component ｛ // ... navigationOptions 코드 생략 ... render() ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Content&gt; &lt;CardComponent /&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝ const style = StyleSheet.create(｛ container: ｛ flex: 1, backgroundColor: 'white' ｝｝); 여기까지 작업한 화면입니다. 스팀잇 피드 가져와서 출력하기 동영상에서는 더미 데이터를 이용해서 피드 목록을 출력하고 있습니다. 저는 스팀잇 서버에서 데이터를 가져와서 화면에 출력해보겠습니다. HomeTab.js 파일을 수정합니다. 그리고 스팀잇에서 피드를 가져오는 fetchFeeds() 함수를 구현합니다. 저는 kr 태그에서 최신글 20개를 가져오도록 구현하였습니다. 12345678910111213141516171819202122export default class HomeTab extends Component ｛ fetchFeeds() ｛ const data = ｛ id: 1, jsonrpc: \"2.0\", method: \"call\", params: [ \"database_api\", \"get_discussions_by_created\", [｛ tag: \"kr\", limit: 20 ｝] ] ｝; return fetch('https://api.steemit.com', ｛ method: 'POST', body: JSON.stringify(data) ｝) .then(res =&gt; res.json()) .then(res =&gt; res.result) ｝ // ... 일부 코드 생략 ... 그 다음은 HomeTab 컴포넌트가 마운트되기 전에 피드를 가져옵니다. state.feeds를 선언하고, componentWillMount() 함수를 구현합니다. 123456789101112131415export default class HomeTab extends Component ｛ state = ｛ feeds: [] ｝ componentWillMount() ｛ this.fetchFeeds().then(feeds =&gt; ｛ this.setState(｛ feeds ｝) ｝); ｝ // ... 일부 코드 생략 ... 스팀잇 서버에서 가져온 피드 목록 데이터를 state.feeds에 저장합니다. 그다음은 HomeTab의 render() 함수를 수정합니다. 123456789101112131415export default class HomeTab extends Component ｛ render() ｛ return ( &lt;Container style=｛style.container｝&gt; &lt;Content&gt; ｛ this.state.feeds.map(feed =&gt; &lt;CardComponent data=｛ feed ｝/&gt;) ｝ &lt;/Content&gt; &lt;/Container&gt; ); ｝ // ... 일부 코드 생략 ... 피드 목록을 구현하기 위해 Array의 map 함수을 사용하였습니다. state.feeds 배열을 루프돌면서 CardComponent의 data에 각 피드 항목 데이터를 전달합니다. CardCompnent 수정하기 마지막으로 HomeTab에서 전달 받은 피드 항목 데이터를 CardCompnent에 출력합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556export default class CardCompnent extends Component ｛ render() ｛ const ｛ data ｝ = this.props; // 피드 항목 데이터 const ｛ image ｝ = JSON.parse(data.json_metadata); // json_metadata에서 이미지 url을 파싱 return ( &lt;Card&gt; &lt;CardItem&gt; &lt;Left&gt; &lt;Thumbnail source=｛｛ uri: `https://steemitimages.com/u/$｛data.author｝/avatar` ｝｝ /&gt; &lt;Body&gt; &lt;Text&gt;｛data.author｝&lt;/Text&gt; &lt;Text note&gt;｛new Date(data.created).toDateString()｝&lt;/Text&gt; &lt;/Body&gt; &lt;/Left&gt; &lt;/CardItem&gt; ｛ image &amp;&amp; image.length ? &lt;CardItem cardBody&gt; &lt;Image source=｛｛ uri: image[0] ｝｝ style=｛｛ height:200, width:null, flex: 1 ｝｝ /&gt; &lt;/CardItem&gt; : null ｝ &lt;CardItem style=｛｛ height: 20 ｝｝&gt; &lt;Text&gt;｛ data.active_votes.length ｝ likes&lt;/Text&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Text style=｛｛ fontWeight:'900'｝｝&gt;｛ data.title ｝&lt;/Text&gt; &lt;/CardItem&gt; &lt;CardItem&gt; &lt;Text&gt; ｛ data.body.replace(/\\n/g,' ').slice(0, 200) ｝ &lt;/Text&gt; &lt;/CardItem&gt; &lt;CardItem style=｛｛ height:45 ｝｝&gt; &lt;Left&gt; &lt;Button transparent&gt; &lt;Icon name='ios-heart' style=｛｛ color:'black', marginRight: 5 ｝｝/&gt; &lt;Text&gt;｛ data.active_votes.length ｝&lt;/Text&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-chatbubbles' style=｛｛ color:'black', marginRight: 5 ｝｝/&gt; &lt;Text&gt;｛ data.children ｝&lt;/Text&gt; &lt;/Button&gt; &lt;Button transparent&gt; &lt;Icon name='ios-send' style=｛｛ color:'black' ｝｝/&gt; &lt;/Button&gt; &lt;/Left&gt; &lt;Right&gt; &lt;Text&gt;｛ data.pending_payout_value ｝&lt;/Text&gt; &lt;/Right&gt; &lt;/CardItem&gt; &lt;/Card&gt; ); ｝｝ 대문 이미지는 json_metadata에 이미지 URL이 있는 경우에만 표시되도록 하였습니다. 여기까지 작업한 화면입니다. 작업한 코드는 모두 깃허브에 업로드되어 있습니다. https://github.com/anpigon/rn_instagram_clone 여기까지 읽어주셔서 감사합니다. 시리즈 [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"인스타그램 만들기","slug":"개발-이야기/react-native/인스타그램-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/인스타그램-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] 인스타그램 UI 만들기 #1","slug":"/kr/@anpigon/react-native-ui-1","date":"2019-01-20T16:39:36.000Z","updated":"2019-11-11T13:41:49.823Z","comments":true,"path":"/kr/@anpigon/react-native-ui-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-ui-1/","excerpt":"이번에는 리액트 네이티브(React Native)로 인스타그램 UI을 구현하는 포스팅입니다. 다른 앱을 따라 만들어 보는 것은 굉장히 재미있습니다.구글에서 인스타그램 클론 코딩 강의를 찾아보니, 다른 개발자들이 올린 동영상 강의를 몇 개 찾을 수 있었습니다. Udemy 강좌: React-Native + Redux + Redux-Saga + INSTAGRAM Clone Nomad Coders 강좌: 인스타그램 클론 코딩","text":"이번에는 리액트 네이티브(React Native)로 인스타그램 UI을 구현하는 포스팅입니다. 다른 앱을 따라 만들어 보는 것은 굉장히 재미있습니다.구글에서 인스타그램 클론 코딩 강의를 찾아보니, 다른 개발자들이 올린 동영상 강의를 몇 개 찾을 수 있었습니다. Udemy 강좌: React-Native + Redux + Redux-Saga + INSTAGRAM Clone Nomad Coders 강좌: 인스타그램 클론 코딩 사실 위의 강의 2개는 유료입니다. 저처럼 가난한 개발자는 유료 강의도 가끔 듣지만, 무료 강의를 더 많이 이용합니다. 아래는 유튜브에 공개되어 있는 무료 강의입니다. 이 포스팅은 아래 강의를 듣고 정리한 내용입니다. https://youtu.be/cgg1HidN4mQ 프로젝트 생성하기 동영상 강의에서는 라이브러리를 먼저 설치하고 프로젝트를 생성하지만, 저는 제 스타일로 프로젝트를 먼저 생성하고 시작합니다. expo-cli를 이용하여 프로젝트를 생성합니다. 12$ expo-cli init instagram-clone$ cd instagram-clone expo-cli가 없는 분들은 여기를 참고하세요. 그다음, UI 라이브러리를 설치합니다. 1$ yarn add native-base @expo/vector-icons yarn이 없으신 분들은 여기를 참고하세요. 그 다음은 네비게이션을 위한 라이브러리를 설치합니다. 1$ yarn add react-navigation 첫 화면 MainScreen 만들기 Components 폴더를 생성합니다. 그리고 Components 폴더 아래에 MainScreen.js를 생성하고 아래와 같이 입력합니다. 1234567891011121314151617181920import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, Platform ｝ from 'react-native';export default class App extends Component ｛ render() ｛ return ( &lt;View style=｛styles.container｝&gt; &lt;Text&gt;MainScreen&lt;/Text&gt; &lt;/View&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', ｝,｝); createStackNavigator 생성하기 App.js 파일을 열어서 수정합니다. App.js 파일 상단에 react-navigation와 방금 만든 ./Components/MainScreen 를 import 합니다. createStackNavigator() 함수를 사용하여 AppStackNavigator를 생성합니다. 그리고 첫 번째 Navigator에 MainScreen 컴포넌트를 등록합니다. 123456789101112import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, Text, View ｝ from 'react-native';import ｛ createStackNavigator, createAppContainer ｝ from 'react-navigation';import MainScreen from './Components/MainScreen';const AppStackNavigator = createStackNavigator(｛ Main:｛ screen: MainScreen // MainScreen 컴포넌트를 네비게이터에 등록 ｝｝);export default createAppContainer(AppStackNavigator); 상단 네비게이션 구현하기 native-base에서 Icon을 import하고, navigationOptions을 생성합니다. navigationOptions에는 왼쪽에 보여질 ios-camera 아이콘과 오른쪽에 보여질 ios-send 아이콘을 설정합니다. 1234567891011121314151617181920212223import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, Text, View ｝ from 'react-native';import ｛ Icon ｝ from 'native-base'; // 추가된 코드export default class MainScreen extends Component ｛ // navigationOptions 코드 추가 static navigationOptions = ｛ headerLeft: &lt;Icon name='ios-camera' style=｛｛ paddingLeft:10 ｝｝/&gt;, title: 'Instagram', headerRight: &lt;Icon name='ios-send' style=｛｛ paddingRight:10 ｝｝/&gt;, ｝ render() ｛ return ( &lt;View style=｛styles.container｝&gt; &lt;Text&gt;MainScreen&lt;/Text&gt; &lt;/View&gt; ); ｝｝// 이하 코드 생략 여기까지 작업한 화면입니다. 상단에 카메라와 비행기 아이콘이 보이나요? 탭 네비게이터 구현하기 Components 폴더 아래에 AppTabNavigator 폴더를 생성합니다. 그리고 AppTabNavigator 폴더 아래에 5개의 파일을 생성합니다. HomeTab.js, SearchTab.js, AddMediaTab.js, LikesTab.js, ProfileTab.js 파일을 각각 생성합니다. 생성되는 파일의 내용은 아래와 비슷하게 입력합니다. 1234567891011121314151617181920import React, ｛ Component ｝ from 'react';import ｛ View, Text, StyleSheet ｝ from 'react-native'; export default class HomeTab extends Component ｛ render() ｛ return ( &lt;View style=｛style.container｝&gt; &lt;Text&gt;HomeTab&lt;/Text&gt; &lt;/View&gt; ); ｝｝ const style = StyleSheet.create(｛ container: ｛ flex: 1, alignItems: 'center', justifyContent: 'center', ｝｝); 우리가 생성한 파일 구조는 아래와 같습니다. 그 다음은 MainScreen.js 파일을 수정합니다. react-navigation와 AppTabNavigator 컴포넌트들을 import 합니다. 그리고 하단에 보여줄 탭네비게이터 AppTabNavigator를 생성합니다. 1234567891011121314151617181920212223242526272829303132// ... 일부 import 코드 생략 ...import ｛ createBottomTabNavigator, createAppContainer ｝ from 'react-navigation'; // 하단 탭에 들어갈 컴포넌트들import HomeTab from './AppTabNavigator/HomeTab'import SearchTab from './AppTabNavigator/SearchTab'import AddMediaTab from './AppTabNavigator/AddMediaTab'import LikesTab from './AppTabNavigator/LikesTab'import ProfileTab from './AppTabNavigator/ProfileTab'// 하단 탭 네비게이터 생성const AppTabNavigator = createBottomTabNavigator(｛ HomeTab: ｛ screen: HomeTab ｝, SearchTab: ｛ screen: SearchTab ｝, AddMediaTab: ｛ screen: AddMediaTab ｝, LikesTab: ｛ screen: LikesTab ｝, ProfileTab: ｛ screen: ProfileTab ｝｝);const AppTabContainet = createAppContainer(AppTabNavigator);export default class MainScreen extends Component ｛ // navigationOptions 코드 생략 render() ｛ return &lt;AppTabContainet/&gt;; // AppTabContainet 컴포넌트를 리턴한다. ｝｝// ... 이하 코드 생략 ... 동영상 강좌에서는 createTabNavigator를 사용하여 하단 탭 네비게이터를 구현했습니다. 하지만 현재는 createTabNavigator 가 deprecated 되었습니다. 그래서createBottomTabNavigator 또는 createMaterialTopTabNavigator를 사용해야 합니다. 여기까지 작업한 화면입니다. 탭 네비게이터에 아이콘 넣기 HomeTab.js 파일을 수정합니다. navigationOptions를 생성하고, Icon을 입력합니다. 12345678910111213// ... 일부 import 코드 생략 ...import ｛ Icon ｝ from 'native-base'; export default class HomeTab extends Component ｛ static navigationOptions = ｛ tabBarIcon: (｛ tintColor ｝) =&gt; ( &lt;Icon name='ios-home' style=｛｛ color: tintColor ｝｝ /&gt; ) ｝// ... 이하 코드 생략 ... 이어서 SearchTab.js, AddMediaTab.js, LikesTab.js, ProfileTab.js 파일도 수정합니다. 파일에 아이콘을 각각 **‘ios-search’, ‘ios-add-circle’, ‘ios-heart’, ‘person’**로 입력합니다. 각 파일 내용은 깃허브에 업로드된 파일을 참고하세요. 여기까지 작업한 화면입니다. 탭 네비게이터에 스와이프와 애니매이션 넣기 스와이프와 애니매이션을 넣기 위해서는 createMaterialTopTabNavigator를 사용해야 합니다. 앞에서 createBottomTabNavigator로 구현했던 네비게이터를 createMaterialTopTabNavigator로 수정합니다. 그리고 네비게이터에 옵션을 설정합니다. createMaterialTopTabNavigator 옵션에 대한 자세한 설명은 TabNavigatorConfig 문서를 참고하세요. 123456789101112131415161718192021222324252627282930313233// ... 일부 import 코드 생략 ...// createBottomTabNavigator를 createMaterialTopTabNavigator로 수정import ｛ createMaterialTopTabNavigator, createAppContainer ｝ from 'react-navigation'; const AppTabNavigator = createMaterialTopTabNavigator(｛ HomeTab:｛ screen: HomeTab ｝, Search:｛ screen: SearchTab ｝, AddMedia:｛ screen: AddMediaTab ｝, Likes:｛ screen: LikesTab ｝, Profile:｛ screen: ProfileTab ｝｝, ｛ animationEnabled: true, swipeEnabled: true, tabBarPosition: \"bottom\", tabBarOptions: ｛ style: ｛ ...Platform.select(｛ ios:｛ backgroundColor:'white', ｝ ｝) ｝, iconStyle: ｛ height: 100 ｝, activeTintColor: '#000', inactiveTintColor: '#d1cece', upperCaseLabel: false, showLabel: false, showIcon: true, ｝｝);// ... 이하 코드 생략 ... 여기까지 작업한 화면입니다. 이제 하단 탭 아이콘을 클릭하면 페이지 슬라이드 애니메이션이 발생합니다. 작업한 코드는 모두 깃허브에 업로드되어 있습니다. https://github.com/anpigon/rn_instagram_clone 여기까지 읽어주셔서 감사합니다. 시리즈 [React Native] 인스타그램 UI 만들기 #1 [React Native] 인스타그램 UI 만들기 #2 [React Native] 인스타그램 UI 만들기 #3 [React Native] 인스타그램 UI 만들기 #4 [React Native] 인스타그램 UI 만들기 #5 Sponsored ( Powered by dclick ) [서평] 의료혁명 치료혁명 자연정혈요법 실습편 이 책을 한 시간만 읽으면 의사가 못 고치는 병도 스스로 쉽게 고친다. ★장의 어혈을 제거하는…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"인스타그램 만들기","slug":"개발-이야기/react-native/인스타그램-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/인스타그램-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"구글은 빅데이터를 어떻게 활용했는가","slug":"/kr/@steemory/--1547689799352","date":"2019-01-17T01:50:00.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@steemory/--1547689799352/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1547689799352/","excerpt":"구글은 빅데이터를 어떻게 활용했는가: 기업의 창의성을 이끌어내는 사물인터넷과 알고리즘의 비밀 책소개 “빅데이터는 기업의 비즈니스 방식을 완전히 탈바꿈시킬 것이다” 전 세계적으로 인간 행동 분석 시스템 덕분에 기업에서는 혁명적인 변화의 바람이 불고 있다. 기업에서 수집한 인간 행동 분석 데이터의 폭발적인 증가가 그 기폭제가 되었다. 직원들의 이메일 기록, 인터넷 검색 기록, 채팅 기록은 물론이고, 우리가 사용하는 모든 정보통신 기술 매체상의 기록을 통해 직원들이 일하는 방식을 믿기 힘들 정도로 자세하게 추적할 수 있게 되었다. 이러한 데이터만으로도 기업 경영에 놀라운 혁신과 지혜를 얻을 수 있다. 그뿐만 아니라 데이터의 힘은 디지털 세계 밖에서도 막강한 힘을 발휘한다. 사람이 착용 가능한 센서Sensor, 즉 사물인터넷 기술이 빠르게 발달하면서 이제 디지털 세상이 아닌 현실 세계의 데이터도 무서운 속도로 증가하고 있다.","text":"구글은 빅데이터를 어떻게 활용했는가: 기업의 창의성을 이끌어내는 사물인터넷과 알고리즘의 비밀 책소개 “빅데이터는 기업의 비즈니스 방식을 완전히 탈바꿈시킬 것이다” 전 세계적으로 인간 행동 분석 시스템 덕분에 기업에서는 혁명적인 변화의 바람이 불고 있다. 기업에서 수집한 인간 행동 분석 데이터의 폭발적인 증가가 그 기폭제가 되었다. 직원들의 이메일 기록, 인터넷 검색 기록, 채팅 기록은 물론이고, 우리가 사용하는 모든 정보통신 기술 매체상의 기록을 통해 직원들이 일하는 방식을 믿기 힘들 정도로 자세하게 추적할 수 있게 되었다. 이러한 데이터만으로도 기업 경영에 놀라운 혁신과 지혜를 얻을 수 있다. 그뿐만 아니라 데이터의 힘은 디지털 세계 밖에서도 막강한 힘을 발휘한다. 사람이 착용 가능한 센서Sensor, 즉 사물인터넷 기술이 빠르게 발달하면서 이제 디지털 세상이 아닌 현실 세계의 데이터도 무서운 속도로 증가하고 있다. MIT 미디어랩의 혁신가인 벤 웨이버는 『구글은 빅데이터를 어떻게 활용했는가』에서 새로운 센서와 빅데이터 분석의 강력한 힘을 보여준다. 기업이 빅데이터를 활용한다면, 직원들의 업무 방식을 현미경처럼 들여다볼 수 있고, 좀더 효율적이고 생산적이며 긍정적인 조직을 구축하는 데 엄청난 통찰력을 얻을 수 있다. 벤 웨이버는 이 책에서 최신 센서 기술을 활용한 풍부한 기업 경영 사례들을 제시한다. 또한 ‘기업 문화’나 ‘창의성’처럼 여태껏 기업 경영에서 ‘주관적인’ 영역으로만 인식해왔던 요소들을 정확히 측정하는 방법을 알려준다. 예컨대 직장에서 휴식 시간이나 점심 테이블의 모양과 같이 아주 사소한 부분만 변화시켜도 직원들은 이전보다 행복하고, 건강하고, 생산적으로 일할 수 있다. 『구글은 빅데이터를 어떻게 활용했는가』는 기업의 CEO들에게 직원들이 실제로 어떻게 일하고, 협력하며, 혁신을 이루어내는지를 발견하는 데 훌륭한 길잡이 역할을 해준다. 그렇게 해서 빅데이터와 센서 기술 덕분에 직원들이 성공하도록 이끌어줄 수가 있다. 또한 미처 알지 못했던 직원들의 창의성과 전문성을 새삼 깨닫게 되는 계기가 되어준다. 인간 행동 분석 시스템이 발달하면서 직원들의 의사소통 방식에 따라 사무실을 재배치하거나 직원들의 의사소통 패턴과 상호작용 방식을 실시간으로 분석하는 등 기업의 모습이 크게 바뀔 것이다. 그리고 고객 서비스, 마케팅, 연구개발R&amp;D, 인수합병M&amp;A에 이르기까지 기업 경영의 모든 활동을 최적화하는 데 도움을 준다. 사실 이 책은 70％ 가량 읽다가 중단했습니다. 책 내용이 제목과 달랐습니다. 구글의 빅데이터 관련 내용이 아니었어요. 궁금해서 번역하기 전 원제를 찾아보니 “People Analytics: How Social Sensing Technology Will Transform Business and What It Tells Us about the Future of Work” 이었습니다. 제목에 낚인 듯한 기분입니다. ㅋ 그래서 제 관심분야가 아니라서 책 읽기를 중단했습니다. 결론만 간단하게 말하자면, 인간 행동을 분석한 빅데이터를 기반으로 회사를 경영하자는 말입니다. “구글이 그렇게 하고 있으니깐, 미래에는 회사 경영을 이렇게 하게 될 것이다!” 라는 내용입니다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"}],"author":"steemory"},{"title":"김상욱의 양자 공부","slug":"/kr/@steemory/--1547599934557","date":"2019-01-16T00:52:15.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@steemory/--1547599934557/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1547599934557/","excerpt":"양자 역학의 탄생부터 최전선까지 모든 역사와 20세기 물리학의 ‘제자백가’들이 펼치는 이론과 법칙을 마음껏 만끽할 수 있도록 단 한 권에 담았다. 복잡한 수학을 일상 언어로 풀어 쓰고 중첩, 도약, 얽힘 등 낯선 개념을 비유와 시각 자료를 곁들여 쉽고 정확하게 이해시켜 주는, 양자 공부의 정수를 마침내 발굴해 낸 것이다. EBS 특별기획 「통찰」의 “자연의 예측 가능성 양자 역학”, YTN 사이언스 「양자 역학의 양자택일」, 팟캐스트 「과학하고 앉아 있네」의 “김상욱의 양자 역학 콕 찔러 보기” 등의 방송 강연 활동과 《동아일보》, 《경향신문》 등 주요 일간지에서 양자 역학을 주제로 한 연재 활동을 꾸준히 해 온 대한민국 대표 과학 커뮤니케이터 김상욱 부산 대학교 물리교육과 교수가 나선 만큼, 모든 사람을 위한 양자 역학 사용 설명서라고 할 수 있다. 이 책은 저자가 《과학동아》에서 연재해 과학 독자들의 사랑을 한 몸에 받은 「양자 역학 좀 아는 척!」의 에피소드들을 취합하고 발전시켜 만든 역작이다. 어려운 개념을 정확한 정의와 유머러스한 비유를 통해 차근차근 이해시켜 나가는 방식으로 대중으로부터 압도적 신뢰를 받아 온 저자의 개성을 극적으로 살린 책이다. 또한 흥미와 호기심을 자극하는 가상 드라마 「양자 역학의 하루」를 통해 양자 역학의 진입 장벽을 과감히 허물었다. 100년에 걸친, 이해 불가능한 현상들을 설명하려는 물리학자들의 흥미진진한 이야기를 따라가다 보면 자연스레 양자적 사고 능력을 갖출 수 있다.","text":"양자 역학의 탄생부터 최전선까지 모든 역사와 20세기 물리학의 ‘제자백가’들이 펼치는 이론과 법칙을 마음껏 만끽할 수 있도록 단 한 권에 담았다. 복잡한 수학을 일상 언어로 풀어 쓰고 중첩, 도약, 얽힘 등 낯선 개념을 비유와 시각 자료를 곁들여 쉽고 정확하게 이해시켜 주는, 양자 공부의 정수를 마침내 발굴해 낸 것이다. EBS 특별기획 「통찰」의 “자연의 예측 가능성 양자 역학”, YTN 사이언스 「양자 역학의 양자택일」, 팟캐스트 「과학하고 앉아 있네」의 “김상욱의 양자 역학 콕 찔러 보기” 등의 방송 강연 활동과 《동아일보》, 《경향신문》 등 주요 일간지에서 양자 역학을 주제로 한 연재 활동을 꾸준히 해 온 대한민국 대표 과학 커뮤니케이터 김상욱 부산 대학교 물리교육과 교수가 나선 만큼, 모든 사람을 위한 양자 역학 사용 설명서라고 할 수 있다. 이 책은 저자가 《과학동아》에서 연재해 과학 독자들의 사랑을 한 몸에 받은 「양자 역학 좀 아는 척!」의 에피소드들을 취합하고 발전시켜 만든 역작이다. 어려운 개념을 정확한 정의와 유머러스한 비유를 통해 차근차근 이해시켜 나가는 방식으로 대중으로부터 압도적 신뢰를 받아 온 저자의 개성을 극적으로 살린 책이다. 또한 흥미와 호기심을 자극하는 가상 드라마 「양자 역학의 하루」를 통해 양자 역학의 진입 장벽을 과감히 허물었다. 100년에 걸친, 이해 불가능한 현상들을 설명하려는 물리학자들의 흥미진진한 이야기를 따라가다 보면 자연스레 양자적 사고 능력을 갖출 수 있다. 양자 역학이 어떤 학문인지 궁금하여 읽어 보았어요. 책 내용은 물리를 1도 모르는 사람이 읽을 수 있는 쉬운 내용입니다. 그러나 이 책을 읽어도 양자 역학을 전혀 모르겠습니다. 하지만 이해 못 하는게 정상이라고 합니다. 모든 물질은 원자로 이루어져 있습니다. 그리고 원자는 원자핵과 전자로 구성되어 있습니다. 원자핵과 전자 사이의 공간은 텅 비어 있습니다. 그럼 모든 물질은 텅 비어 있다는 말입니다. 원자는 텅 비어 있지만, 빛을 반사 시킨다. 우리가 물질을 볼수 있는 것은 원자가 빛을 반사 시키기 때문이다. 하여튼, 양자 역학이란? 내가 이해할 수 없는 세계라는 것을 알았습니다. 현재 지금 내 머릿속에는 이중슬릿실험 만 남았습니다. 이중슬릿실험 : 이중 슬릿을 통과할 때 하나의 입자는 한 번에 1개의 슬릿만을 통과할 수 있다. 2개의 슬릿을 동시에 지날 수는 없다는 말이다. 그러나 파동은 2개의 슬릿을 동시에 통과할 수 있다. 파동은 여기저기 동시에 존재하는 것이 가능하다는 말이다. 동심원을 그리며 퍼져 나가기 때문이다. 동심원을 그리며 퍼져나가는 물결 파장을 생각하면 된다. (p.35-36)","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"김상욱","slug":"김상욱","permalink":"https://anpigon.github.io/tags/김상욱/"},{"name":"양자 역학","slug":"양자-역학","permalink":"https://anpigon.github.io/tags/양자-역학/"}],"author":"steemory"},{"title":"⟪만화로 보는 비디오 게임의 역사⟫","slug":"/kr/@steemory/--1547392734482","date":"2019-01-13T15:18:54.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@steemory/--1547392734482/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1547392734482/","excerpt":"동전 넣고 즐기던 전자오락에서 수백억 달러 규모의 첨단 산업으로, 중독과 불량 오락이라는 오명에서 지각과 인식의 새로운 지평을 여는 가상현실과 인공지능의 미래까지, 1970년대부터 현재까지 게임 산업의 발전을 주요 게임기와 개발자, 그리고 우리들의 마음을 사로잡았던 각양각색의 다양한 게임을 통해 살펴본다. 최초의 컴퓨터용 게임 프로그램을 만든 앨런 튜링을 시작으로, 오늘날 컴퓨터와 게임 테크놀로지의 토대가 된 2차 대전 당시 비밀 연구소의 놀라운 과학기술 발전과 '퐁’과 '스페이스 인베이더’처럼 지금은 고전이 된 1970~80년대의 수많은 아케이드 게임들, 집집마다 하나씩 있던 아타리와 닌텐도의 가정용 콘솔 게임기, 한번 빠지면 헤어나오기 힘든 중독성 강한 콘솔과 휴대폰 게임은 물론 가상 현실과 사이버 공간에서 승부를 겨루는 미래의 게임까지, 전자 게임 혁명의 모든 것을 다룬다.","text":"동전 넣고 즐기던 전자오락에서 수백억 달러 규모의 첨단 산업으로, 중독과 불량 오락이라는 오명에서 지각과 인식의 새로운 지평을 여는 가상현실과 인공지능의 미래까지, 1970년대부터 현재까지 게임 산업의 발전을 주요 게임기와 개발자, 그리고 우리들의 마음을 사로잡았던 각양각색의 다양한 게임을 통해 살펴본다. 최초의 컴퓨터용 게임 프로그램을 만든 앨런 튜링을 시작으로, 오늘날 컴퓨터와 게임 테크놀로지의 토대가 된 2차 대전 당시 비밀 연구소의 놀라운 과학기술 발전과 '퐁’과 '스페이스 인베이더’처럼 지금은 고전이 된 1970~80년대의 수많은 아케이드 게임들, 집집마다 하나씩 있던 아타리와 닌텐도의 가정용 콘솔 게임기, 한번 빠지면 헤어나오기 힘든 중독성 강한 콘솔과 휴대폰 게임은 물론 가상 현실과 사이버 공간에서 승부를 겨루는 미래의 게임까지, 전자 게임 혁명의 모든 것을 다룬다. 미국식 만화인 그래픽 노블 형태의 책은 익숙하지 않아서 집중이 잘 안되었어요. 그래서 쉽게 읽기가 힘들었습니다. 게다가 게임 역사가 50년이다 보니 관련 인물도 많습니다. 누가 누군지 이름 외우기 힘드네요. 게임 지식이 깊지 않아서 잘 모르는 내용도 있습니다. 그런 부분은 그냥 그렇구나 하고 넘겼어요. 하지만 마리오 게임과 소닉 게임의 탄생 배경은 정말 흥미로웠습니다. 게임 좋아하시는 분들은 이 책을 한 번쯤 읽어보면 좋을 것 같습니다. 저는 이 책을 읽고 나서 갑자기 마리오 게임이 하고 싶어졌어요. 닌텐도에 있던 오리지널 그 마리오 게임 말이에요. 마리오가 커지고, 악당 쿠퍼를 무찌르고 공주를 구하는 게 목적인, 그 마리오 게임. 게다가, 책 내용에 따르면 게임의 발전이 없었다면 지금의 고성능 컴퓨터는 나오지 못했을 겁니다. 사람들이 게임에 열광하고 다음에 나올 게임에 대한 기대치가 높아지니, 개발사는 게임 그래픽을 전작보다 더 좋게 만들어야 하고, 그러려면 하드웨어 그래픽 성능도 높여야 하니… 게임기 시장이 그렇게 급속도로 발전할 수 있었던 것입니다. 요즘 모바일 게임 마켓에는 비슷한 게임이 너무 많이 출시되고 있습니다. 그래서 새로운 게임이 나와도 금방 금방 질려버립니다. RPG 장르는 게임 방식이 비슷하고 디자인만 다른 중국산 게임들이 너무 많아요. 모바일 게임에 대한 저의 기대치가 많이 높아진 탓도 있는 것 같아요. 제 생각에 현재 모바일 게임은 옛날의 “아타리 쇼크” 와 비슷한 상황인 것 같습니다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"}],"author":"steemory"},{"title":"[원예] 다이소 브로콜리 & 알팔파 씨 발아 하기","slug":"/kr/@steemory/--1547374272886","date":"2019-01-13T10:11:48.000Z","updated":"2019-11-11T13:41:49.855Z","comments":true,"path":"/kr/@steemory/--1547374272886/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1547374272886/","excerpt":"다이소에서 브로콜리와 알팔파 씨를 가져왔습니다.제가 브로콜리와 알팔파 씨앗으로 씨 발아를 한번 해보겠습니다.씨 발아 하는 방법은 이렇습니다.그릇 위에 젖은 휴지를 깔고 씨를 골고루 뿌려줍니다. 떡잎이 나기 전까지는 직사광선을 피하세요. 그래도 햇빛에 두고 싶다면 위에 얇은 휴지로 덮어주세요.","text":"다이소에서 브로콜리와 알팔파 씨를 가져왔습니다.제가 브로콜리와 알팔파 씨앗으로 씨 발아를 한번 해보겠습니다.씨 발아 하는 방법은 이렇습니다.그릇 위에 젖은 휴지를 깔고 씨를 골고루 뿌려줍니다. 떡잎이 나기 전까지는 직사광선을 피하세요. 그래도 햇빛에 두고 싶다면 위에 얇은 휴지로 덮어주세요. 하루 정도 지났더니, 알팔파 씨에서 싹에 나기 시작했어요. 브로콜리는 아직 소식이 없네요. ㅜㅜ 뿌리가 좀 더 나면 수경재배할 것인지, 아니면 화분으로 옮겨서 심을지 고민을 해봐야겠어요. ㅎㅎ 브로콜리 알팔파가 잘 자라서 수확하게 되면, 추첨을 통해서 아주 조금씩 나눠 드릴게요~ ㅎㅎ","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[React Native] Redux로 Counter 앱 만들기","slug":"/kr/@anpigon/react-native-redux-counter--1547278235048","date":"2019-01-12T07:30:36.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-redux-counter--1547278235048/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-redux-counter--1547278235048/","excerpt":"Redux 와 NativeBase 를 사용하여 카운터 앱을 만들어 봅니다. NativeBase를 사용하니 컴포넌트 UI가 좀더 수려해졌습니다. 그리고 복잡한 앱을 구현할 때에는 Redux가 필수입니다.리덕스(Redux)를 사용하지 않을 때와 사용할 때의 차이점은 아래 그림이 잘 표현하고 있습니다.","text":"Redux 와 NativeBase 를 사용하여 카운터 앱을 만들어 봅니다. NativeBase를 사용하니 컴포넌트 UI가 좀더 수려해졌습니다. 그리고 복잡한 앱을 구현할 때에는 Redux가 필수입니다.리덕스(Redux)를 사용하지 않을 때와 사용할 때의 차이점은 아래 그림이 잘 표현하고 있습니다. 필요한 모듈 설치하기 expo-cli가 설치되어 있지 않으면 아래와 같이 설치한다. 1$ npm install expo-cli --global expo-cli를 사용하여 프로젝트를 생성한다. 12$ expo init redux-counter-app$ cd redux-counter-app 그리고 Redux와 react-redux를 설치한다. 1$ npm install redux react-redux --save 마지막으로 NativeBase를 설치한다. 12$ npm install native-base --save$ npm install @expo/vector-icons --save 구현하기 프로젝트의 루트에 세 개의 폴더 reducers, components 를 생성한다. Redux Reducers 구현 Reducers는 앱에서 필요한 데이터를 반환한다. 여기서는 Counter 값을 반환하는 reducer가 필요하다. reducers 폴더에 countReducer.js 파일을 생성한다. 다음과 같이 하나의 js 파일에 액션과 리듀서를 모두 구현하는 것을 Ducks 구조이라고 한다. Ducks 구조를 사용하면 나중에 코드 관리하기가 편하다. reducers/countReducer.js 1234567891011121314151617181920212223242526272829303132333435363738// Default Stateconst initialState = ｛ count: 0｝;// Actionsexport const INCREMENT = \"Increment\";export const DECREMENT = \"Decrement\";// Action Functionsexport function increment()｛ return ｛ type: INCREMENT ｝;｝export function decrement()｛ return ｛ type: DECREMENT ｝;｝// Reducerfunction reducer(state = initialState, action) ｛ switch (action.type) ｛ case INCREMENT: return ｛ count: state.count + 1 ｝ case DECREMENT: return ｛ count: state.count - 1 ｝ ｝ return state;｝// Exports Defaultexport default reducer; INCREMENT과 DECREMENT 액션은 카운트 값을 계산하여 반환한다. 그 다음은 index.js 파일에서 모든 Reducer를 결합한다. 지금은 하나의 리듀서 countReducer만 있지만, 나중에 리듀서가 여러 개일 경우 유용하다. reducers/index.js 12345678import ｛ combineReducers ｝ from 'redux';import countReducer from './countReducer.js';const allReducers = combineReducers(｛ countReducer,｝);export default allReducers; Redux 컴포넌트 구현 이제 &lt;Counter&gt; 컴포넌트를 구현한다. components/counter.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, ｛ Component ｝ from 'react';import ｛ connect ｝ from 'react-redux';import ｛ bindActionCreators ｝ from 'redux';import ｛ Container, Content, Text, Card, Header, Body, Button, Title, CardItem ｝ from 'native-base';import ｛ increment, decrement ｝ from '../reducers/countReducer';class Counter extends Component ｛ render() ｛ return( &lt;Container&gt; &lt;Header&gt; &lt;Body&gt; &lt;Title&gt;Redux Counter&lt;/Title&gt; &lt;/Body&gt; &lt;/Header&gt; &lt;Content padder&gt; &lt;Card&gt; &lt;CardItem&gt; &lt;Text&gt; ｛ this.props.state.count ｝ &lt;/Text&gt; &lt;/CardItem&gt; &lt;/Card&gt; &lt;Button full onPress= ｛() =&gt; this.props.increment()｝ style=｛｛marginVertical: 10｝｝&gt; &lt;Text&gt;Increment&lt;/Text&gt; &lt;/Button&gt; &lt;Button full dark bordered onPress= ｛() =&gt; this.props.decrement()｝&gt; &lt;Text&gt;Decrement&lt;/Text&gt; &lt;/Button&gt; &lt;/Content&gt; &lt;/Container&gt; ); ｝｝// Reducer 데이터를 props로 변환function mapStateToProps(state)｛ return ｛ state: state.countReducer ｝;｝// Actions을 props로 변환function matchDispatchToProps(dispatch)｛ return bindActionCreators(｛ increment: increment, decrement: decrement ｝, dispatch);｝export default connect(mapStateToProps, matchDispatchToProps)(Counter); Redux Store 구현 마지막으로 App.js 파일에 store를 만들어야 한다. Redux에 대한 기본 개념은 Redux 공식 문서를 참고한다. App.js 파일을 아래와 같이 수정한다. App.js 1234567891011121314151617import React, ｛ Component ｝ from 'react';import ｛ Provider ｝ from 'react-redux';import ｛ createStore ｝ from 'redux';import allReducers from './reducers';import Counter from './components/counter.js';const store = createStore(allReducers);export default class App extends Component｛ render()｛ return( &lt;Provider store=｛store｝&gt; &lt;Counter /&gt; &lt;/Provider&gt; ); ｝｝ 실행하기 앱을 실행하고 확인해보자. 1$ npm start 여기까지 읽어주셔서 감사합니다. 같이 읽으면 좋은 글: 리덕스(Redux)를 왜 쓸까? 그리고 리덕스를 편하게 사용하기 위한 발악 (i) 리덕스(Redux)를 왜 쓸까? 그리고 리덕스를 편하게 사용하기 위한 발악 (ii) Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[Node.js] NVM으로 노드(Node.js) 버전 관리하기","slug":"/kr/@anpigon/nodejs-nvm-nodejs--1547090998695","date":"2019-01-10T03:30:00.000Z","updated":"2019-11-11T13:41:49.812Z","comments":true,"path":"/kr/@anpigon/nodejs-nvm-nodejs--1547090998695/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/nodejs-nvm-nodejs--1547090998695/","excerpt":"기존에는 macOS용 패키지 관리자인 Homebrew를 사용하여 Node.js를 설치하여 사용했습니다. 그런데 Node.js를 버전 별로 관리할 필요성이 있어서 찾게 되었습니다.Node.js 버전을 관리해주는 도구는 대표적으로 nvm과 n이 있습니다. 저는 nvm을 사용합니다.","text":"기존에는 macOS용 패키지 관리자인 Homebrew를 사용하여 Node.js를 설치하여 사용했습니다. 그런데 Node.js를 버전 별로 관리할 필요성이 있어서 찾게 되었습니다.Node.js 버전을 관리해주는 도구는 대표적으로 nvm과 n이 있습니다. 저는 nvm을 사용합니다. NVM 설치하기 nvm 설치 방법은 NVM 설치 문서를 참고하였습니다. nvm은 install script를 사용하여 설치합니다. 12345# cURL로 설치$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash# 또는, Wget로 설치$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash Homebrew를 사용하여 설치하는 방법도 있습니다. 1$ brew install nvm nvm가 설치되고 나면, ~/. bash_profile에 아래 내용이 추가됩니다. 12export NVM_DIR=\"$｛XDG_CONFIG_HOME/:-$HOME/.｝nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm 만약에 nvm이 동작하지 않는다면, 다음과 같이 ~/. bash_profile에 직접 추가합니다. 123$ echo export NVM_DIR=\"$｛XDG_CONFIG_HOME/:-$HOME/.｝nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\"' &gt;&gt;~/.bash_profile$ source ~/. bash_profile NVM 설치 확인하기 nvm이 설치가 되었다면 다음과 같이 nvm 버전 정보가 출력되어야 합니다. 12$ nvm --version&gt; 0.33.11 NVM으로 Node.js 설치하기 nvm으로 설치 가능한 Node.js 버전을 확인합니다. 1234567$ nvm ls-remote ... 생략 ... v10.12.0 v10.13.0 (Latest LTS: Dubnium) v11.0.0 v11.1.0 v11.2.0 가장 최신 버전의 Node.js 를 설치합니다. 1$ nvm install node 또는, Latest LTS 버전을 설치합니다. 1$ nvm install --lts 그리고 버전을 지정해서 설치도 가능합니다. 1$ nvm install v10.13.0 설치된 버전 목록 조회하기 현재 로컬에 설치된 Node.js 정보를 조회합니다. 제 PC에는 총 세 가지 버전의 Node.js가 설치되어 있네요. 1234567891011121314$ nvm ls v8.13.0-&gt; v8.15.0 v10.15.0 systemdefault -&gt; 8.13.0 (-&gt; v8.13.0)node -&gt; stable (-&gt; v10.15.0) (default)stable -&gt; 10.15 (-&gt; v10.15.0) (default)iojs -&gt; N/A (default)lts/* -&gt; lts/dubnium (-&gt; v10.15.0)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.16.0 (-&gt; N/A)lts/carbon -&gt; v8.15.0lts/dubnium -&gt; v10.15.0 Node.js 버전 변경하기 Node.js 버전을 변경하려면 다음과 같이 사용합니다. 12345$ nvm use v8Now using node v8.13.0 (npm v6.5.0)$ node -vv8.13.0 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 스팀달러 가격이 벌써 900원을 넘어섰네요. 52주 최저 가격인 538원까지 내려갔었는데 어느새 915원이네요. 드디어 1달러(USD)에 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"NVM","slug":"nvm","permalink":"https://anpigon.github.io/tags/nvm/"}],"author":"anpigon"},{"title":"[Node.js] App을 Heroku에 배포하기","slug":"/kr/@anpigon/heroku-nodejs-app-heroku--1546967112451","date":"2019-01-08T17:05:12.000Z","updated":"2019-11-11T13:41:49.811Z","comments":true,"path":"/kr/@anpigon/heroku-nodejs-app-heroku--1546967112451/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/heroku-nodejs-app-heroku--1546967112451/","excerpt":"HerokuHeroku는 간단하게 사용할 수 있는 가벼운 클라우드 서버입니다. 참고로, 우리가 많이 사용하고 있는 busy.org가 Heroku에서 호스팅 되고 있습니다.게다가 무료 가격 정책도 있습니다. 무료는 매월 550시간 사용이 가능합니다. 신용카드 정보를 추가로 입력하면 매월 1000시간 사용이 가능합니다. 그리고 30분 동안 사용하지 않으면 자동으로 슬립모드에 들어갑니다.","text":"HerokuHeroku는 간단하게 사용할 수 있는 가벼운 클라우드 서버입니다. 참고로, 우리가 많이 사용하고 있는 busy.org가 Heroku에서 호스팅 되고 있습니다.게다가 무료 가격 정책도 있습니다. 무료는 매월 550시간 사용이 가능합니다. 신용카드 정보를 추가로 입력하면 매월 1000시간 사용이 가능합니다. 그리고 30분 동안 사용하지 않으면 자동으로 슬립모드에 들어갑니다. 보통은 heroku-cli를 사용하여 heroku에 배포합니다. 하지만 지금은 쉽고 간단하게 하려고 합니다. 그래서 브라우저에서 배포하는 방법으로 진행할게요. Github에 소스 업로드 하기 Github에 소스 업로드 과정을 생략하고, 그냥 오픈 소스를 사용하겠습니다. 오픈소스 busy.org 저장소를 내 저장소로 포크합니다. 왼쪽 상단에 보이는 Fork 버튼을 누르면 됩니다. Heroku에 앱 생성하기 Heroku를 가입하고 New App을 생성합니다. App Name은 나중에 서브 도메인명이 됩니다. (예. https://AppName.herokuapp.com) 그 다음은 Heroku에 GitHub 계정을 연결합니다. 그리고 연결된 GitHub 계정에서 배포할 앱을 선택합니다. 마지막으로 Deploy Branch를 선택합니다. 그러면 빌드/배포 과정이 진행됩니다. Activity Feed &gt; Build Log에서 로그를 확인 할 수 있습니다. 빌드/배포에 성공하면, 페이지 상단의 Open app 버튼을 눌러줍니다. 아래 화면과 같이 자동으로 브라우저에 사이트가 표시됩니다. busy.org에는 Heroku 설정파일이 포함되어 있습니다. 그래서 아무 문제 없이 Heroku에 배포가 잘되었습니다. 마지막으로 내가 배포한 사이트에서는 스팀 커넥트(Steem Connect)를 사용하여 로그인할 수 없습니다. 스팀 커넥트는 도메인에 종속되어 있습니다. 그래서 busy.org 소스에 포함된 스팀 커넥트는 사용할 수 없습니다. 그래서 저는 아래와 같이 액세스 토큰을 JS콘솔창에서 직접 입력하여 로그인하였습니다. 혹시나 물어보시는 분이 있을까 봐서요. ㅎㅎ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"NodeJS","slug":"개발-이야기/nodejs","permalink":"https://anpigon.github.io/categories/개발-이야기/nodejs/"}],"tags":[{"name":"Heroku","slug":"heroku","permalink":"https://anpigon.github.io/tags/heroku/"}],"author":"anpigon"},{"title":"[파이썬] 가상 환경(Virtualenv)으로 파이썬(Python) 버전 관리하기","slug":"/kr/@anpigon/-virtualenv-python--1546840427366","date":"2019-01-07T05:53:48.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/-virtualenv-python--1546840427366/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/-virtualenv-python--1546840427366/","excerpt":"맥(Mac)에는 기본적으로 Python 2가 설치되어있다. Python 2를 그대로 두고, Python 3를 설치하여 사용하고 싶다면, 가상환경을 구성해서 Python 3를 사용할 수 있다. VirtualenvVirtualenv는 분리된 Python 환경을 만들어 주는 도구이다. 이 도구를 이용하면 개별 환경에 각각 다른 Python 버전을 구성할 수 있다. 그래서 Python 개발할 때는 virtualenv를 사용하는 것이 매우 권장된다. 설치 방법은 virtualenv 설치 가이드 문서를 참고하였다.","text":"맥(Mac)에는 기본적으로 Python 2가 설치되어있다. Python 2를 그대로 두고, Python 3를 설치하여 사용하고 싶다면, 가상환경을 구성해서 Python 3를 사용할 수 있다. VirtualenvVirtualenv는 분리된 Python 환경을 만들어 주는 도구이다. 이 도구를 이용하면 개별 환경에 각각 다른 Python 버전을 구성할 수 있다. 그래서 Python 개발할 때는 virtualenv를 사용하는 것이 매우 권장된다. 설치 방법은 virtualenv 설치 가이드 문서를 참고하였다. pip 설치 pip가 없다면 pip를 먼저 설치한다. Mac 사용자라면 아래와 같이 설치한다. 1$ sudo easy_install pip HomeBrew를 사용하여 설치하는 방법도 있다. brew install python 하지만, 2개의 파이썬이 설치된다. pip 설치가 잘되었는지 확인해보자. 1$ pip -V virtualenv 설치하기 pip를 통해 virtualenv를 설치한다. 1$ sudo pip install virtualenv 전역(global)이 아닌 사용자(local) 권한으로 설치하고 싶다면: 1$ pip install virtualenv --user virtualenv 가상환경 구성하기 프로젝트 디렉토리가 my-project라면 아래와 같이 실행하여, 해당 프로젝트의 virtualenv를 구성할 수 있다. 이 명령어는 프로젝트 폴더 내에 venv/ 디렉토리를 생성한다. 12$ cd my-project/$ virtualenv venv virtualenv에 파이썬 버전을 지정하려면: 1$ virtualenv venv --python=python3.7 virtualenv가 global에 설치된 패키지를 상속받기를 원한다면: 1$ virtualenv venv --system-site-packages virtualenv 가상환경 사용하기 virtualenv 가상환경을 활성화하려면 다음 명령어를 입력한다. 1$ source venv/bin/activate 터미널 프롬프트의 시작 부분에 virtualenv에서 작업 중임을 나타내는 (venv)가 나타나야 한다. 이제 설치되는 모든 패키지는 venv/ 폴더에 설치되며 다른 프로젝트와 충돌하지 않는다. 그리고 가상환경에서 나오려면 다음 명령어를 입력한다. 1$ deactivate 파이썬 버전을 관리할 필요가 있어서 자료를 찾아보고 정리하였습니다. 여기까지 읽어주셔서 감사합니다. 참고: https://sourabhbajaj.com/mac-setup/Python/virtualenv.html Sponsored ( Powered by dclick ) 매직다이스하러 가자! 스팀 블록체인 기반 주사위 게임","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬(python)","slug":"개발-이야기/파이썬-python","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://anpigon.github.io/tags/python/"}],"author":"anpigon"},{"title":"도로시 길먼 ⟪폴리팩스 부인과 여덟 개의 여권⟫","slug":"/kr/@steemory/2we7sr","date":"2019-01-07T00:06:06.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@steemory/2we7sr/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/2we7sr/","excerpt":"123영미소설 &gt; 추리/미스터리소설원제 The Elusive Mrs. Pollifax (1971년)ISBN 9791158790660전 세계를 사로잡은 할머니 스파이, 폴리팩스 부인!『폴리팩스 부인과 여덟 개의 여권』은 35년 동안 계속해서 전 세계 독자들의 지지와 사랑을 받아온 「폴리팩스 부인 시리즈」의 세 번째 작품이다. 무료한 일상을 뒤로하고 뒤늦게 스파이가 되고 싶었던 어릴 적 꿈을 이룬 폴리팩스 부인이 멕시코와 터키에서의 임무를 환상적으로 마친 후 이제 위험천만한 불가리아로 세 번째 모험을 떠난다.","text":"123영미소설 &gt; 추리/미스터리소설원제 The Elusive Mrs. Pollifax (1971년)ISBN 9791158790660전 세계를 사로잡은 할머니 스파이, 폴리팩스 부인!『폴리팩스 부인과 여덟 개의 여권』은 35년 동안 계속해서 전 세계 독자들의 지지와 사랑을 받아온 「폴리팩스 부인 시리즈」의 세 번째 작품이다. 무료한 일상을 뒤로하고 뒤늦게 스파이가 되고 싶었던 어릴 적 꿈을 이룬 폴리팩스 부인이 멕시코와 터키에서의 임무를 환상적으로 마친 후 이제 위험천만한 불가리아로 세 번째 모험을 떠난다. 폴리팩스 부인은 원예클럽 회원들과 일 년에 단 한 번, 밤에만 핀다는 손가락선인장 꽃을 기다리던 중 CIA로부터 다급한 연락을 받는다. 냉전 시기, 비밀경찰의 감시가 삼엄한 공산국가 불가리아로 지금 당장 떠나라는 것. 지하조직과 접선해 그들의 탈출을 도와줄 위조 여권 8개를 전달하라는 너무나도 ‘간단한’ 임무를 맡는다. 그러나 이번에도 그녀의 매력 넘치는 오지라퍼 기질이 발휘되면서 일은 점점 미궁 속에 빠져드는데. 과연 그들의 목숨과도 같은 위조 여권은 제대로 전달될 수 있을까? 찬코가 만면에 웃음을 띠며 그녀를 바라보았다. “아주 좋은 일입니다. 좋아요.” “그리고 비상구에서 밤에 피는 선인장 꽃도 피워냈지요.” 부인은 왠지 수줍은 마음으로 그렇게 덧붙였다. 찬코가 나직하게 물었다. “중요한 일처럼 느껴지는데, 왜죠?” 부인은 망설이다 입을 열었다. “왜냐하면, 요즈음 사람들은 뭔가에 쫓기는 듯 달려간다는 기분이 들어요, 꼭 세상이 종말을 향해 움직이는 것만 같잖아요. 수많은 사람이 있는 만큼, 수많은 것들이 파괴되는 세상인걸요. 그러다 밤에 피는 선인장이 1년에 단 한 번, 그것도 한밤중에만 꽃을 피운단 얘기를 듣고 깜짝 놀랐지 뭐예요. 그게 나에게는 무슨 지성의 상징처럼 느껴졌답니다.” “그런데 꽃이 피었습니까?” 찬코가 물었다. 부인이 의기양양하게 고개를 끄덕였다. “자정이 되기 20분 전이었답니다. 바로 지난주였어요.” “세상엔 아직도 신비가 남아 있군요.” 찬코는 안도한 듯 그렇게 말했다. (P.306) 평범했던 할머니가 미국 CIA 스파이가 되는 과정은 너무나도 재미있는 소재이다. 이번 시리즈에서는 폴리팩스 부인이 원래 임무 외에 다른 사건에도 관여하면서 이야기가 더 흥미진진하게 흘러간다. 부인의 직관력과 판단력에 의지하면서 천천히 이야기를 읽어갔다. 책을 손이 놓을 수 없을 정도로 너무 재미있었다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"도로시 길먼","slug":"도로시-길먼","permalink":"https://anpigon.github.io/tags/도로시-길먼/"},{"name":"영미소설","slug":"영미소설","permalink":"https://anpigon.github.io/tags/영미소설/"},{"name":"추리소설","slug":"추리소설","permalink":"https://anpigon.github.io/tags/추리소설/"}],"author":"steemory"},{"title":"스파이더맨: 뉴 유니버스 (Spider-Man: Into the Spider-Verse, 2018)","slug":"/kr/@steemory/spider-man-into-the-spider-verse-2018","date":"2019-01-06T15:02:48.000Z","updated":"2019-11-11T13:41:49.849Z","comments":true,"path":"/kr/@steemory/spider-man-into-the-spider-verse-2018/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/spider-man-into-the-spider-verse-2018/","excerpt":"스파이더맨: 뉴 유니버스 Spider-Man: Into the Spider-Verse, 2018 준비가 되었다는 걸 어떻게 알죠? 몰라! 그냥 믿고 뛰는거지네이버 평점: ★9.36/10 (3,965명) 왓챠 평점: ★4.1/5 (2만명) 줄거리 평범한 10대 ‘마일스 모랄레스’는 우연히 방사능 거미에 물려 스파이더맨 능력을 가지게 된다. 혼란스러워하던 ‘마일스’는 악당과 싸우고 있는 ‘피터 파커’를 마주치게 되고 ‘피터 파커’는 ‘마일스’가 자신과 같은 능력을 가지고 있음을 직감한다. 여러 개의 평행세계가 존재한다는 것을 알게 된 ‘마일스’와 ‘피터 파커’는 이후 스파이더우먼 ‘스파이더 그웬’, ‘스파이더맨 누아르’, ‘스파이더햄’ 등 평행세계 속 공존하는 모든 스파이더맨들을 만나게 되는데… 하나의 유니버스에서 만나 팀을 결성한 스파이더맨들은 과연 세계를 구할 수 있을까? 스파이더맨들의 새로운 시대가 열린다!","text":"스파이더맨: 뉴 유니버스 Spider-Man: Into the Spider-Verse, 2018 준비가 되었다는 걸 어떻게 알죠? 몰라! 그냥 믿고 뛰는거지네이버 평점: ★9.36/10 (3,965명) 왓챠 평점: ★4.1/5 (2만명) 줄거리 평범한 10대 ‘마일스 모랄레스’는 우연히 방사능 거미에 물려 스파이더맨 능력을 가지게 된다. 혼란스러워하던 ‘마일스’는 악당과 싸우고 있는 ‘피터 파커’를 마주치게 되고 ‘피터 파커’는 ‘마일스’가 자신과 같은 능력을 가지고 있음을 직감한다. 여러 개의 평행세계가 존재한다는 것을 알게 된 ‘마일스’와 ‘피터 파커’는 이후 스파이더우먼 ‘스파이더 그웬’, ‘스파이더맨 누아르’, ‘스파이더햄’ 등 평행세계 속 공존하는 모든 스파이더맨들을 만나게 되는데… 하나의 유니버스에서 만나 팀을 결성한 스파이더맨들은 과연 세계를 구할 수 있을까? 스파이더맨들의 새로운 시대가 열린다! 그동안 봤던 스파이더맨 영화 중에서 가장 만족도가 높았다. 3D면서 카툰 느낌이 나는 애니매이션이다. 총 6명의 스파이더맨이 등장한다. 각각의 개성이 너무 뚜렷해서 너무 재미있다. 그리고 스파이더맨 차량 질주 씬은 정말 볼만하다. 멀티 유니버스, 스탠리~ 마블팬이라면 좋아할만한 요소가 정말 많다. 그리고 개그 코드도 나랑 맞는 듯 ㅋㅋㅋ 아래는 코엑스에 있는 포토존입니다. 여기 앉아서 사진찍으면 정말 멋지게 나와요. 마지막으로 쿠키 영상 있어요. 꼭 보세요~! 예고편 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"},{"name":"스파이더맨","slug":"스파이더맨","permalink":"https://anpigon.github.io/tags/스파이더맨/"}],"author":"steemory"},{"title":"주먹왕 랄프 2: 인터넷 속으로 (Ralph Breaks the Internet, 2018)","slug":"/kr/@steemory/-2-ralph-breaks-the-internet-2018--1546705466270","date":"2019-01-05T16:24:27.000Z","updated":"2019-11-11T13:41:49.849Z","comments":true,"path":"/kr/@steemory/-2-ralph-breaks-the-internet-2018--1546705466270/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/-2-ralph-breaks-the-internet-2018--1546705466270/","excerpt":"주먹왕 랄프 2 인터넷 속으로 (Ralph Breaks the Internet, 2018) 오락실 게임 세상에 이어 이번엔 인터넷 세상이 발칵 뒤집힌다?! 왓챠 평점 네티즌 ★3.4/5(67명) 네이버 평점 네티즌 8.91/10(274명) 기자·평론가 7.5/10(4명)","text":"주먹왕 랄프 2 인터넷 속으로 (Ralph Breaks the Internet, 2018) 오락실 게임 세상에 이어 이번엔 인터넷 세상이 발칵 뒤집힌다?! 왓챠 평점 네티즌 ★3.4/5(67명) 네이버 평점 네티즌 8.91/10(274명) 기자·평론가 7.5/10(4명) 줄거리 각종 사고를 치며 게임 속 세상을 뒤집어 놨던 절친 주먹왕 랄프와 바넬로피는 버려질 위기에 처한 오락기 부품을 구하기 위해 와이파이를 타고 인터넷 세상에 접속한다. 얼떨결에 올린 동영상으로 순식간에 핵인싸에 등극한 랄프와 룰도 트랙도 없는 스릴만점 슬로터 레이스 게임에 참여하게 된 바넬로피. 지금껏 경험한 적 없는 엄청난 스케일과 새로운 재미에 흠뻑 빠진 랄프와 바넬로피는 랜섬웨어급 사고로 인터넷 세상을 혼란에 빠뜨리는데… 오늘 주먹왕 랄프2를 보고 왔습니다. 주먹왕 랄프를 보면 선착순으로 스티커를 주는 이벤트를 하고 있어요. 저는 늦게 가서 받지 못했습니다.ㅠㅠ 그리고 주먹왕 콤보 셋트도 팔고 있어요. 랄프 주먹이 멋지네요. ㅋ 예전에 주먹왕 랄프 1을 정말 재미있게 봤었습니다. 2도 재미있긴 하지만 줄거리는 1보다는 별로였습니다. 뻔한 스토리. 억지 감동. 이런 느낌을 받았습니다. 하지만 볼거리는 1에 비해서 훨씬 많아졌습니다. 빈약한 줄거리를 디즈니 캐릭터를 총동원하고 다양한 볼거리를 제공해서 채워주는 느낌이에요. 디즈니가 가지고 있는 캐릭터들을 총동원했네요. 이건 디즈니만이 가능할 듯. 반칙이에요.ㅋ 그리고 마지막에 쿠키영상 2개가 있습니다. 크레딧 영상이 끝날때 겨울왕국 예고편 쿠키 영상이 있어요. 꼭 끝까지 다 보시길 바래요~ 유투브 예고편 영상으로 마무리합니다. 디즈니 [주토피아] 제작진의 상상력 끝판왕🎉 게임 속 최고의 트러블 메이커, 랜선 타고 인터넷에 로그인 하다! [주먹왕 랄프 2: 인터넷 속으로] 메인 예고편 공개💻 리뷰전문 트리플A한국의 로튼토마토를 추구하는 영화, 드라마, 애니메이션 리뷰사이트인 트리플A가 서비스중입니다.리뷰는 트리플A 에서https://www.triplea.reviewshttps://www.triplea.reviews/@anpigon","categories":[{"name":"영화 이야기","slug":"영화-이야기","permalink":"https://anpigon.github.io/categories/영화-이야기/"}],"tags":[{"name":"영화 후기","slug":"영화-후기","permalink":"https://anpigon.github.io/tags/영화-후기/"},{"name":"디즈니","slug":"디즈니","permalink":"https://anpigon.github.io/tags/디즈니/"},{"name":"애니매이션","slug":"애니매이션","permalink":"https://anpigon.github.io/tags/애니매이션/"}],"author":"steemory"},{"title":"[성수/뚝섬] 골목안 멋진 카페 - 우디집","slug":"/tasteem/@steemory/tasteem-b64d6e","date":"2019-01-05T04:05:15.000Z","updated":"2019-11-11T13:41:49.845Z","comments":true,"path":"/tasteem/@steemory/tasteem-b64d6e/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-b64d6e/","excerpt":"우디집 성수동골목에 숨은 빈티지한카페 고심한 인테리어가 돋보이는 성수동 카페 아무도 안가본 골목 안 멋진 카페 매일 12:00 - 21:00 매주 월 휴무 전화번호 010-3917-0456 예약, 무선 인터넷 애완동물 동반 오늘 소개할 카페는 성수동 골목에 위치한 카페입니다. 성수역에서는 거리가 조금 있습니다. 버스 타고 가는게 좋아요. 카페 내부에 들어가면 옷장(?) 같은 문이 또 있어요. 아마 모르는 분들은 옷장인줄 알고 그냥 돌아갈듯 … ㅋㅋㅋ 나니아 연대기처럼 옷장안으로 들어가 볼까요? 2층으로 올라가는 계단이에요. 계단이 가파르니 올라갈때 조심하세요. 계단을 다 올라가서 위에서 찍은 사진입니다. 2층에 올라오면, 짜란~ 아늑한게 따뜻해 보이는 분위기입니다. 오른쪽에 보이는 창문(?) 에서 주문할 수 있어요. 그리고 왼쪽 문으로 나가면 밖에서 커피를 마실 수 있는 공간이 있어요. 메뉴는 벽에 붙어 있습니다. 잘 살펴보세요. 이제 원하는 자리를 찾아서 앉으세요~! LED조명으로 만든 트리가 너무 이쁩니다. 집에도 하나 걸어 놓고 싶네요. 창밖으로 야외 테이블이 보입니다. 하지만 날씨가 추워서 앉아 있는 사람은 없었어요. 더 가까이서 보니 사우나실 같아요. 들어가서 땀 한바가지 흘려야 할 듯 ㅋㅋㅋ 아이스 라떼와 마르코폴로입니다. 따뜻하게 차 한잔씩 하세요~😀","text":"우디집 성수동골목에 숨은 빈티지한카페 고심한 인테리어가 돋보이는 성수동 카페 아무도 안가본 골목 안 멋진 카페 매일 12:00 - 21:00 매주 월 휴무 전화번호 010-3917-0456 예약, 무선 인터넷 애완동물 동반 오늘 소개할 카페는 성수동 골목에 위치한 카페입니다. 성수역에서는 거리가 조금 있습니다. 버스 타고 가는게 좋아요. 카페 내부에 들어가면 옷장(?) 같은 문이 또 있어요. 아마 모르는 분들은 옷장인줄 알고 그냥 돌아갈듯 … ㅋㅋㅋ 나니아 연대기처럼 옷장안으로 들어가 볼까요? 2층으로 올라가는 계단이에요. 계단이 가파르니 올라갈때 조심하세요. 계단을 다 올라가서 위에서 찍은 사진입니다. 2층에 올라오면, 짜란~ 아늑한게 따뜻해 보이는 분위기입니다. 오른쪽에 보이는 창문(?) 에서 주문할 수 있어요. 그리고 왼쪽 문으로 나가면 밖에서 커피를 마실 수 있는 공간이 있어요. 메뉴는 벽에 붙어 있습니다. 잘 살펴보세요. 이제 원하는 자리를 찾아서 앉으세요~! LED조명으로 만든 트리가 너무 이쁩니다. 집에도 하나 걸어 놓고 싶네요. 창밖으로 야외 테이블이 보입니다. 하지만 날씨가 추워서 앉아 있는 사람은 없었어요. 더 가까이서 보니 사우나실 같아요. 들어가서 땀 한바가지 흘려야 할 듯 ㅋㅋㅋ 아이스 라떼와 마르코폴로입니다. 따뜻하게 차 한잔씩 하세요~😀 맛집정보 우디집 대한민국 서울특별시 성동구 성수동1가 둘레9길 17 [[성수/뚝섬] 골목안 멋진 카페 - 우디집](https://kr.tasteem.io/post/25194) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/288)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native] NativeBase UI 컴포넌트 라이브러리 사용하기","slug":"/kr/@anpigon/react-native-nativebase-ui--1546613053309","date":"2019-01-04T14:44:18.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-nativebase-ui--1546613053309/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-nativebase-ui--1546613053309/","excerpt":"같이 읽으면 좋은 글 2019년에 알아야 할 React Native UI 컴포넌트 라이브러리 NativeBase는 React Native를 위한 크로스 플랫폼 UI 컴포넌트 오픈 소스이다. 현재 버전 v2.7.0까지 릴리즈 되었다. 그리고 KitchenSink에서 NativeBase로 구현된 샘플 앱과 예제 소스를 확인할 수 있다.","text":"같이 읽으면 좋은 글 2019년에 알아야 할 React Native UI 컴포넌트 라이브러리 NativeBase는 React Native를 위한 크로스 플랫폼 UI 컴포넌트 오픈 소스이다. 현재 버전 v2.7.0까지 릴리즈 되었다. 그리고 KitchenSink에서 NativeBase로 구현된 샘플 앱과 예제 소스를 확인할 수 있다. NativeBase 처럼 미리 만들어진 UI 컴포넌트 툴킷을 사용하면, React Native 개발 시간을 절약할 수 있다. NativeBase 설치하기 공식 문서를 참고하여 설치한다. 12$ npm install native-base --save$ react-native link Expo에서 사용하려면 @expo/vector-icons 모듈을 설치해야한다. NativeBase 사용하기 NativeBase를 사용하는 일반적인 방법은 &lt;Container&gt; 내에 모든 컴포넌트를 포함하는 것이다. 123456789101112131415161718192021222324252627282930313233import React, ｛ Component ｝ from 'react';import ｛ Container, Header, Title, Content, Footer, FooterTab, Button, Left, Right, Body, Icon, Text ｝ from 'native-base';export default class AnatomyExample extends Component ｛ render() ｛ return ( &lt;Container&gt; &lt;Header&gt; &lt;Left&gt; &lt;Button transparent&gt; &lt;Icon name='menu' /&gt; &lt;/Button&gt; &lt;/Left&gt; &lt;Body&gt; &lt;Title&gt;Header&lt;/Title&gt; &lt;/Body&gt; &lt;Right /&gt; &lt;/Header&gt; &lt;Content&gt; &lt;Text&gt; This is Content Section &lt;/Text&gt; &lt;/Content&gt; &lt;Footer&gt; &lt;FooterTab&gt; &lt;Button full&gt; &lt;Text&gt;Footer&lt;/Text&gt; &lt;/Button&gt; &lt;/FooterTab&gt; &lt;/Footer&gt; &lt;/Container&gt; ); ｝｝ 각 구성요소 컴포넌트 설명 &lt;Header&gt; 화면의 헤더를 렌더링한다. &lt;Button&gt;, &lt;Title&gt; 를 포함할 수 있다. &lt;Content&gt; 화면의 메인 컨텐츠를 나타낸다. 한 화면에는 하나의 &lt;Content&gt; 컴포넌트만 있을 수 있다. &lt;Footer&gt; 화면에서 푸터를 렌더링한다. &lt;FooterTab&gt; 을 포함할 수 있다. 결과 위의 간단한 코드를 실행한 결과화면이다. * * * 「기술 동향 : React vs Angular vs Vue」 을 읽어보면, React의 인기가 점점 증가하고 있습니다. 대부분의 코인 거래소가 React로 개발되어 있을 정도로, 이제는 Front-End 웹개발에서 React를 제외하고 이야기하기가 어렵습니다. 사실 React-Native는 React 인기 득을 크게 보는 것 같습니다. 그리고 최근에 안 사실인데, Micrisoft에서 react-native-windows 버전을 출시했었네요. 아마 이걸 사용하면 윈도우앱을 만들 수 있을 것 같습니다. ㅋ Sponsored ( Powered by dclick ) [보드게임] 연말연시 파티게임 추천! 안녕하세요 여러분! 요즘 연말이라고, 연초라고 모임 많으시죠? 모여서 하는 것이라고는 술밖에 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"},{"name":"NativeBase","slug":"nativebase","permalink":"https://anpigon.github.io/tags/nativebase/"}],"author":"anpigon"},{"title":"[서울대입구/샤로수길] 홍콩식 와플 맛있는카페 - 미드레벨","slug":"/tasteem/@steemory/tasteem-34769e","date":"2019-01-04T01:37:36.000Z","updated":"2019-11-11T13:41:49.845Z","comments":true,"path":"/tasteem/@steemory/tasteem-34769e/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-34769e/","excerpt":"MIDLEVEL미드레벨 홍콩식 밀크티와 와플을 현지 분위기 느낌으로 먹을 수 있는 곳 샤로수길 카페 매일 12:00 - 23:00 대표메뉴 홍콩와플 홍콩밀크티 포장, 무선 인터넷 얼마전 샤로수길에 다녀오면서 미드레벨 카페를 발견했다. 오래전에 여행했던 홍콩의 향수가 되살아났다. 요기가 들어가는 입구다. 입구부터 홍콩 특유의 분위기를 느낄 수 있다. 이 계단을 올라가면 홍콩이 펼쳐질 것만 같다. 계단이 꽤 가파르다. 올라가는 계단 벽면에는 미드레벨 에스컬레이터의 배경이 되었던, 중경삼림의 포스터가 붙어 있다. 왠지 “California Dreaming” 노래가 흘러나올 것만 같다. 전체적인 내부 분위기는 이렇다. 보통은 웨이팅이 있지만, 늦은 시간에 가서 그런지 자리가 있었다. 메뉴판도 정말 홍콩스럽다. 나는 홍콩와플을 먹진 않았지만, 사진으로 보면 이렇게 먹음직스럽게 생겼다는 것을 알 수 있다. 곳곳에 홍콩스러운 물품들이 놓여져 있다. 이건 아마도 중경삼림의 배경이 되었던 청킹맨션의 모형인듯 하다. 이건 홍콩잡지와 빨간 RC카~ 홍콩 포스터. 나는 밀크티와 아이스 아메리카노를 주문했다. 밀크티는 정말 홍콩에서 먹었던 밀크티 맛이다. 하지만 아메리카노는 물맛이 난다. 이 카페에서는 밀크티와 와플만 먹어야할 것 같다. 홍콩의 분위기에 취하고 싶은 사람들은 샤로수길의 미드레벨 카페를 추천합니다. 중경삼림 OST로 마무리합니다.","text":"MIDLEVEL미드레벨 홍콩식 밀크티와 와플을 현지 분위기 느낌으로 먹을 수 있는 곳 샤로수길 카페 매일 12:00 - 23:00 대표메뉴 홍콩와플 홍콩밀크티 포장, 무선 인터넷 얼마전 샤로수길에 다녀오면서 미드레벨 카페를 발견했다. 오래전에 여행했던 홍콩의 향수가 되살아났다. 요기가 들어가는 입구다. 입구부터 홍콩 특유의 분위기를 느낄 수 있다. 이 계단을 올라가면 홍콩이 펼쳐질 것만 같다. 계단이 꽤 가파르다. 올라가는 계단 벽면에는 미드레벨 에스컬레이터의 배경이 되었던, 중경삼림의 포스터가 붙어 있다. 왠지 “California Dreaming” 노래가 흘러나올 것만 같다. 전체적인 내부 분위기는 이렇다. 보통은 웨이팅이 있지만, 늦은 시간에 가서 그런지 자리가 있었다. 메뉴판도 정말 홍콩스럽다. 나는 홍콩와플을 먹진 않았지만, 사진으로 보면 이렇게 먹음직스럽게 생겼다는 것을 알 수 있다. 곳곳에 홍콩스러운 물품들이 놓여져 있다. 이건 아마도 중경삼림의 배경이 되었던 청킹맨션의 모형인듯 하다. 이건 홍콩잡지와 빨간 RC카~ 홍콩 포스터. 나는 밀크티와 아이스 아메리카노를 주문했다. 밀크티는 정말 홍콩에서 먹었던 밀크티 맛이다. 하지만 아메리카노는 물맛이 난다. 이 카페에서는 밀크티와 와플만 먹어야할 것 같다. 홍콩의 분위기에 취하고 싶은 사람들은 샤로수길의 미드레벨 카페를 추천합니다. 중경삼림 OST로 마무리합니다. 맛집정보 미드레벨 대한민국 서울특별시 관악구 봉천동 관악로14길 63 [[서울대입구/샤로수길] 홍콩식 와플 맛있는카페 - 미드레벨](https://kr.tasteem.io/post/25116) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/288)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"},{"name":"카페","slug":"카페","permalink":"https://anpigon.github.io/tags/카페/"}],"author":"steemory"},{"title":"[React Native] 리액트 네이티브에서 steem-js 사용하기","slug":"/kr/@anpigon/react-native-steemjs--1546529527678","date":"2019-01-03T15:32:12.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-steemjs--1546529527678/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-steemjs--1546529527678/","excerpt":"React Native에서 steem-js 라이브러리를 설치하여 사용하는 방법입니다.React Native에는 standard node modules이 포함되어 있지 않습니다. 그래서 제가 안내하는 방법으로 설치해야 React Native에서 steem-js 사용이 가능합니다.","text":"React Native에서 steem-js 라이브러리를 설치하여 사용하는 방법입니다.React Native에는 standard node modules이 포함되어 있지 않습니다. 그래서 제가 안내하는 방법으로 설치해야 React Native에서 steem-js 사용이 가능합니다. * * * React Native 프로젝트 생성과 steem-js 설치 React Native 프로젝트를 생성하고, steem-js를 설치한다. 1234$ react-native init rn_steemit_app$ cd rn_steemit_app$ npm i --save steem$ react-native run-ios Expo 에서는 RNRandomBytes 라이브러리 설치하는 것이 복잡하고 어려워, react-native-cli 로 React Native 프로젝트를 생성하였습니다. 참고로 React Native에서 steem-js를 사용하려고 하면, 다음과 같이 에러가 발생한다. The package at “node_modules/steem/lib/auth/memo.js” attempted to import the Node standard library module “assert”. It failed because React Native does not include the Node standard library. Read more at https://docs.expo.io/versions/latest/introduction/faq.html#can-i-use-nodejs-packages-with-expo * * * 해결 방법 react-native-randombytes 설치 react-native-crypto 모듈에 필요한 react-native-randombyte 모듈을 설치한다. 12$ npm i --save react-native-randombytes$ react-native link react-native-randombytes rn-nodeify 설치 rn-nodeify 모듈은 React Native에서 node core modules 와 npm module을 사용할 수 있게 해준다. 1$ npm i rn-nodeify --save-dev package.json 파일에 다음을 추가한다. 123\"scripts\": ｛ \"postinstall\": \"rn-nodeify --install fs,dgram,process,path,console,crypto,vm,stream,buffer,events,assert --hack\"｝ npm 모듈을 재설치한다. 1$ npm install rn-nodeify 모듈을 설치하면 자동으로 shim.js 파일이 생성된다. index.js 파일 맨 상단에 import './shim';을 추가한다. 마지막으로 shim.js 파일 맨 아래에 다음을 추가한다. 123456789101112131415161718192021222324252627282930313233343536if (require('./package.json').dependencies['react-native-crypto']) ｛ const algos = require('browserify-sign/algos') if (!algos.sha256) ｛ algos.sha256 = ｛ \"sign\": \"ecdsa\", \"hash\": \"sha256\", \"id\": new Buffer(\"\") ｝ ｝ if (typeof window === 'object') ｛ const wCrypto = window.crypto = window.crypto || ｛｝ wCrypto.getRandomValues = wCrypto.getRandomValues || getRandomValues ｝ const crypto = require('crypto') const randomBytes = crypto.randomBytes crypto.randomBytes = function (size, cb) ｛ if (cb) return randomBytes.apply(crypto, arguments) const arr = new Buffer(size) getRandomValues(arr) return arr ｝ crypto.getRandomValues = crypto.getRandomValues || getRandomValues function getRandomValues (arr) ｛ // console.warn('WARNING: generating insecure psuedorandom number') for (var i = 0; i &lt; arr.length; i++) ｛ arr[i] = Math.random() * 256 | 0 ｝ return arr ｝｝ 참고: https://stackoverflow.com/questions/45301900/howto-patch-shim-crypto-getrandomvalues-for-react-native 아래는 스팀잇에서 계정 정보를 조회한 결과 화면. * * * 저는 React Native 스팀잇 앱을 개발해보고 싶어요. 만약 개발한다면 인스타그램 같은 앱이 좋겠습니다. 비슷한 앱으로 steepshot앱이 있지만, 제 안드로이드폰에서는 사진 업로드에서 오류가 납니다. ㅠㅠ 그리고 원사마님께서는 Flutter 스팀잇앱을 개발한다고 하였으니, ⌈원사마님의 [dartlang] rpc2.0 통신으로 스팀 API 호출해보기⌋. 다양한 플랫폼의 스팀잇앱이 개발되길 기대해봅니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[서울대입구/샤로수길] 거북이 닭강정","slug":"/tasteem/@steemory/tasteem-94f19f","date":"2019-01-03T00:31:45.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-94f19f/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-94f19f/","excerpt":"오늘은 샤로수길에서 제일 맛나다는 통닭집을 다녀왔습니다. 새해에는 황금돼지의 해니깐 많이 먹어야해요.저는닭강정과 사이다를 주문했어요~닭무도 빠질 수 없어요.더 가까이서 보여드릴께요.닭강정 한입 하세요~맛있는 닭강정이었습니다~! 맛집정보 거북이 닭강정대한민국 서울특별시 관악구 봉천동 관악로14길 45","text":"오늘은 샤로수길에서 제일 맛나다는 통닭집을 다녀왔습니다. 새해에는 황금돼지의 해니깐 많이 먹어야해요.저는닭강정과 사이다를 주문했어요~닭무도 빠질 수 없어요.더 가까이서 보여드릴께요.닭강정 한입 하세요~맛있는 닭강정이었습니다~! 맛집정보 거북이 닭강정대한민국 서울특별시 관악구 봉천동 관악로14길 45 [[서울대입구/샤로수길] 거북이 닭강정](https://kr.tasteem.io/post/25047) 이 글은 Tasteem 컨테스트 [2019 새해맞이에 어울리는 식당 ](https://kr.tasteem.io/event/284)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[종로/익선동] 부다페스트호텔 느낌의 카페 - 쎄느장","slug":"/tasteem/@steemory/tasteem-27a3de","date":"2019-01-01T01:12:42.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-27a3de/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-27a3de/","excerpt":"2019년 새해에 어울리는 카페를 소개합니다.익선동 핫플레이스 &quot;쎄느장&quot;에 다녀왔어요. 여기는1979년에 지어진 쎄느장 여관을 리모델링하여 &quot;호텔 쎄느장 카페&quot;로 오픈했어요.오픈한지 얼마 안되서 네이버 지도나 카카오 지도에는 아직도 쎄느장 여관으로 나와요.","text":"2019년 새해에 어울리는 카페를 소개합니다.익선동 핫플레이스 &quot;쎄느장&quot;에 다녀왔어요. 여기는1979년에 지어진 쎄느장 여관을 리모델링하여 &quot;호텔 쎄느장 카페&quot;로 오픈했어요.오픈한지 얼마 안되서 네이버 지도나 카카오 지도에는 아직도 쎄느장 여관으로 나와요. 제가 한번 호텔에 들어가겠습니다. 입구는 호펠 프론트 처럼 되어있어요. 체크인 해야할 것 같은 분위기~ 내부 분위기에 이끌려 홀리듯이 들어갔습니다. 부엉이가 있으니 해리포터의 호그와트 느낌ㄷ납니다. 여기는 2층이에요. 호텔 느낌이 그대로 살아있어요. 벽을 그대로 뚫어서 입구를 만들었네요. ㅎㅎ 2019년 새해에는 연인과 함께 호텔 쎄느장 카페에서 데이트가 어떨까요? 맛집정보 쎄느장 대한민국 서울특별시 종로구 종로1.2.3.4가동 돈화문로11길 28-5 [[종로/익선동] 부다페스트호텔 느낌의 카페 - 쎄느장](https://kr.tasteem.io/post/24953) 이 글은 Tasteem 컨테스트 [2019 새해맞이에 어울리는 식당 ](https://kr.tasteem.io/event/284)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[Steem Project] Gatsby 블로그에 구글 광고(Google Adsense) 달기","slug":"/kr/@anpigon/gatsby-google-adsense--1546242510227","date":"2018-12-31T07:48:30.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/gatsby-google-adsense--1546242510227/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/gatsby-google-adsense--1546242510227/","excerpt":"이번에는 Gatsby 블로그에 구글 광고(Google Adsense) 를 달았습니다. 스팀잇에 글을 작성하여 스팀으로 보상받고, 외부 블로그(Gatsby)에서는 구글 광고로 수익을 낼 수 있다면 가장 이상적인 형태가 될 것 같습니다. 사실 스팀잇 플랫폼 내에서 둘 다 가능하다면 가장 좋겠지요.","text":"이번에는 Gatsby 블로그에 구글 광고(Google Adsense) 를 달았습니다. 스팀잇에 글을 작성하여 스팀으로 보상받고, 외부 블로그(Gatsby)에서는 구글 광고로 수익을 낼 수 있다면 가장 이상적인 형태가 될 것 같습니다. 사실 스팀잇 플랫폼 내에서 둘 다 가능하다면 가장 좋겠지요. 지금까지 “Gatsby로 스팀잇 개인 블로그 생성하는 방법”, “Travis-CI를 사용하여 자동으로 블로그를 생성하고, Github Page에 배포하는 방법” 을 포스팅하였습니다. 지금도 Travis-CI의 Cron Jobs 기능을 사용하여 매일 블로그를 자동 배포를 하고 있습니다. 하지만 특정 시간에 Cron Jobs을 실행할 할 수 없는 것은 조금 아쉽습니다. 관련 글 개츠비(gatsby)로 스팀잇 블로그 만들기 Travis-CI를 이용한 Gatsby 블로그 자동 배포하기 * * * 애드센스 광고 코드 가져오기 먼저 구글 애드센스 사이트에서 광고 코드를 생성해야 한다. 애드센스 홈페이지에서 광고 &gt; 광고 단위 메뉴를 선택한다. 그리고 [+ 새 광고 단위] 버튼을 누른다. 첫 번째에 있는 텍스트 및 디스플레이 광고를 선택한다. 그리고 이름을 입력하고 광고 형태를 설정한다. 기본 입력되어 있는 설정을 그대로 사용해도 된다. 마지막으로 [저장 및 코드 생성] 버튼을 누른다. 이제 광고 코드가 생성되었다. 여기서 data-ad-client와 data-ad-slot 값만 기억하면 된다. 개츠비(Gatsby) 블로그에 구글 광고 달기 Gatsby 블로그는 React로 구현되어 있다. React에서 구글 광고를 사용하기 위해서는 react-adsense 라이브러리을 사용한다. react-adsense의 자세한 사용방법은 [react-adsense 사이트]를 참고한다. react-adsense 설치하기 1$ npm install --save react-adsense react-adsense 사용방법 광고를 보여주기 원하는 곳에 광고 코드를 삽입한다. 나는 포스트 본문 상단에 삽입하였다. 12345678910import AdSense from 'react-adsense';// auto full width responsive ads&lt;AdSense.Google client='ca-pub-7292810486004926' slot='7806394673' style=｛｛ display: 'block' ｝｝ format='auto' responsive='true'/&gt; 블로그 광고가 뜨는지 확인하기 자신의 블로그(https://anpigon.github.io/blog/)에 접속하여, 광고가 잘 보이는지 확인해보자. 광고 코드를 생성하고 광고가 표출되기까지 시간이 조금 걸립니다. 그리고 애드블록 (AdBlock) 프로그램을 사용하고 있으면, 구글 광고가 표시되지 않습니다. * * * 사실 이전에도 티스토리 블로그에서 구글 광고를 사용한 적이 있습니다. 하지만 구글 광고 수익을 받아 본 적은 한 번도 없습니다. 구글 정책상 $100 이상 되어야지 수익을 받을 수 있는데, 총 수익이 $1도 안 됩니다. $100까지 앞으로 $95.46 남았습니다. ㅋ 다음은 구글 애드센스 홈페이지 메인 페이지에 있는 문구입니다. 여러분의 열정을 수익으로 돌려드립니다. 열정이 있으면 구글 광고 수익을 받을 수 있습니다.ㅋ 그리고 저의 Gatsby 블로그도 이제 조금씩 자리 잡아 가고 있네요. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"Gatsby","slug":"gatsby","permalink":"https://anpigon.github.io/tags/gatsby/"},{"name":"Google Adsense","slug":"google-adsense","permalink":"https://anpigon.github.io/tags/google-adsense/"}],"author":"anpigon"},{"title":"[종로/익선동] 양식집 - 익선잡방","slug":"/tasteem/@steemory/tasteem-07a937","date":"2018-12-31T04:16:57.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-07a937/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-07a937/","excerpt":"익선동 맛집 익선잡방에 다녀왔습니다. 익선동의 첫 번째 메인 길에 위치하고 있어요.익선잡방은 신라호텔 10년 경력의 오너 쉐프님이 운영하는 곳이라고 합니다.실내 인테리어는 몽환적인 분위기에요먹을 준비를 하고 메뉴가 나오길 기다리는 중이에요.시즈닝 새우 로제 파스타와 프로슈토 샐러드 피자가 나왔어요.","text":"익선동 맛집 익선잡방에 다녀왔습니다. 익선동의 첫 번째 메인 길에 위치하고 있어요.익선잡방은 신라호텔 10년 경력의 오너 쉐프님이 운영하는 곳이라고 합니다.실내 인테리어는 몽환적인 분위기에요먹을 준비를 하고 메뉴가 나오길 기다리는 중이에요.시즈닝 새우 로제 파스타와 프로슈토 샐러드 피자가 나왔어요. 연말 데이트 저녁 코스로 맛집정보 익선잡방 대한민국 서울특별시 종로구 종로1.2.3.4가동 수표로28길 17-21 [[종로/익선동] 양식집 - 익선잡방](https://kr.tasteem.io/post/24918) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/283)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"2018 이문세 ‘The Best’ 콘서트 다녀왔어요.","slug":"/tripsteem/@steemory/tt20181230t150234484z","date":"2018-12-30T15:02:36.000Z","updated":"2019-11-11T13:41:49.848Z","comments":true,"path":"/tripsteem/@steemory/tt20181230t150234484z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@steemory/tt20181230t150234484z/","excerpt":"2018 이문세 ‘The Best’ 콘서트가로수길 나무에 예쁜 전구이 반짝반짝하고 있요. 그래서 가는 길이 너무 예뻤어요.올림픽공원 체조경기장 위에 빛으로 쓴 글자 “2018 이문세 the BEST” 가 보입니다.여기는 포토존이에요. 한가운데 서서 찍으면 사진이 예쁘게 나와요~","text":"2018 이문세 ‘The Best’ 콘서트가로수길 나무에 예쁜 전구이 반짝반짝하고 있요. 그래서 가는 길이 너무 예뻤어요.올림픽공원 체조경기장 위에 빛으로 쓴 글자 “2018 이문세 the BEST” 가 보입니다.여기는 포토존이에요. 한가운데 서서 찍으면 사진이 예쁘게 나와요~ 를 보기 위해 올림픽공원 체조경기장으로 가는 길입니다. 아직 콘서트 시작 전이에요~! 많은 사람이 자리를 꽉 채웠어요. 콘서트 시작 전인데도 열기가 어마어마했어요. 야광봉을 받았어요~ 자리마다 하나씩 놓아져 있었어요. 영상에서 이문세님이 라면을 먹는 장면이에요. 영상 중에 갑자기 이문세 님께서 &quot;배고프시죠?&quot; 하면서 라면을 챙겨주셨어요~ 완전 감동이에요~~~!!! 집에 와서 라면을 한 번 더 찍었습니다. 아까워서 못 먹을 것 같아요. ㅎㅎ 문세라면이에요~ 육개장 칼국수 라면일것 같아요. 마지막으로 이문세님의 앵콜 공연 영상 올립니다. 아직도 이문세 님의 노랫소리가 귓가에 흥얼거립니다. 그대여 이젠 안녕~~ ♩ ♪ ♬ 즐거운 음악 여행이었습니다. 2018 이문세 ‘The Best’ 콘서트 다녀왔어요. 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"이문세","slug":"이문세","permalink":"https://anpigon.github.io/tags/이문세/"},{"name":"콘서트","slug":"콘서트","permalink":"https://anpigon.github.io/tags/콘서트/"}],"author":"steemory"},{"title":"일본 망고젤리 개봉기","slug":"/busy/@steemory/3zzbct","date":"2018-12-28T01:42:57.000Z","updated":"2019-11-11T13:41:49.855Z","comments":true,"path":"/busy/@steemory/3zzbct/","link":"","permalink":"https://anpigon.github.io/busy/@steemory/3zzbct/","excerpt":"","text":"제가 한번 일본 망고젤리를 개봉해보겠습니다. 젤리가 푸딩푸딩하니 달고 맛있었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"나가사키 카스테라 후기","slug":"/kr/@steemory/2hmsrw","date":"2018-12-27T00:11:45.000Z","updated":"2019-11-11T13:41:49.855Z","comments":true,"path":"/kr/@steemory/2hmsrw/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/2hmsrw/","excerpt":"","text":"SSG 에서 나가사키 카스테라를 구입했어요. 제가 한번 개봉해보겠습니다.박스를 열면 이렇게 맛있는 카스테라가 들어있어요.카스테라 속살을 보세요.생긴게 스펀지 같아요.맛은 빵은 쫄든쫄깃한 식감이고, 매우 달아요. ㅎㅎ나가사키 카스테라 안녕~","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[Steem Project] Travis-CI를 이용한 Gatsby 블로그 자동 배포하기","slug":"/kr/@anpigon/travisci-gatsby--1545840561400","date":"2018-12-26T16:09:24.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/travisci-gatsby--1545840561400/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/travisci-gatsby--1545840561400/","excerpt":"이전 글 [개츠비(gatsby)로 스팀잇 블로그 만들기]에서는 Travis-CI 자동 배포에 실패했었습니다. 이번에는 Travis-CI 에서 자동 배포에 성공하여 다시 포스팅합니다.Travis-CI 는 깃허브에 사이트를 배포할 수 있습니다. 그리고 Cron Jobs 기능을 제공합니다. 저는 이 두 가지 기능 때문에 Netlify 보다는 Travis-CI 를 사용할 것 같습니다.","text":"이전 글 [개츠비(gatsby)로 스팀잇 블로그 만들기]에서는 Travis-CI 자동 배포에 실패했었습니다. 이번에는 Travis-CI 에서 자동 배포에 성공하여 다시 포스팅합니다.Travis-CI 는 깃허브에 사이트를 배포할 수 있습니다. 그리고 Cron Jobs 기능을 제공합니다. 저는 이 두 가지 기능 때문에 Netlify 보다는 Travis-CI 를 사용할 것 같습니다. 연관글 개츠비(gatsby)로 스팀잇 블로그 만들기 Netlify를 이용하여 Gatsby 블로그 자동 배포하기 * * * 빌드 과정에서 오류가 발생하는 플러그인을 제거하였다. gatsby-config.js 파일을 수정하였다. 12345678910｛ resolve: 'gatsby-transformer-remark', options: ｛ plugins: [ // ｛ // resolve: 'gatsby-remark-images', // options: ｛ // maxWidth: 960 // ｝ // ｝, gatsby-remark-images 은 마크다운에서 이미지를 처리하는 플러그인이다. 나는 스팀잇에 업로드한 이미지를 사용하기 때문에 해당 플러그인은 없어도 된다. GITHUB_TOKEN 발급 받기 GitHub에서 Developer settings 메뉴의 Personam access toknes 페이지에 접속한다. Personal access tokens: https://github.com/settings/tokens Generate new token 버튼을 클릭한다. repo 권한을 모두 선택한다. 그리고 Generate token 버튼을 클릭한다. 깃허브 access token 발급이 완료되었다. 참고로 이 페이지를 닫고 나면 access token은 다시 확인 할 수 없다. Travis-ci를 이용하여 자동 배포하기 .travis.yml 파일을 생성한다. 설정에 대한 자세한 내용은 [공식 메뉴얼]을 참고한다. 123456789101112131415161718192021222324252627language: node_jsnode_js:- \"8\"cache: directories: - node_modules# 배포 설정deploy: provider: pages skip-cleanup: true keep-history: true github-token: $GITHUB_TOKEN local_dir: public on: branch: masterbefore_install: - npm install -g gatsby-cliinstall: - npm installscript: - gatsby build --prefix-paths Travis-CI 의 Repositories에서 blog 프로젝트를 검색하여 활성화한다. Travis-CI Repositories: https://travis-ci.org/account/repositories Settings 버튼을 선택한다. 그리고 Environment Variables에 발급 받은 GITHUB_TOKEN 를 등록한다. 주기적으로 자동 배포를 실행하려면, Cron Jobs 을 활성화한다. 빌드(build)를 실행하면 아래와 같이 로그에서 과정을 볼 수 있다. 배포까지 끝나면 아래와 같이 완료되었다는 메세지를 볼 수 있다. 이제 24시간마다 블로그가 깃허브 페이지에 자동 배포가 될 것이다. 그리고 깃허브에 코드를 업데이트를 해도 자동 배포가 실행된다. 또는 Travis-CI 에서 강제로 빌드를 실행해도 된다. * * * 이제 제가 원했던 스팀잇 블로그의 자동 배포 환경이 셋팅되었어요. Travis-CI 를 이용하면 24시간마다 자동 배포가 됩니다. 나중에는 스팀잇에 글 작성을 인지하고 자동 배포가 실행되도록 구현할 예정입니다. 이제부터 시간날때마다 블로그에 필요한 기능을 붙여나갈 예정입니다. 우선 구글 통계와 구글 광고 부터 삽입해봐야겠습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"Gatsby","slug":"gatsby","permalink":"https://anpigon.github.io/tags/gatsby/"},{"name":"Travis-CI","slug":"travis-ci","permalink":"https://anpigon.github.io/tags/travis-ci/"}],"author":"anpigon"},{"title":"[군자] 한국 가정식 술밥집 - 중앙식당","slug":"/tasteem/@steemory/tasteem-8f570c","date":"2018-12-26T01:46:51.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-8f570c/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-8f570c/","excerpt":"스티모리가 추천하는 밥이 맛있는 집입니다. 군자역 6번 출구에서 어린이대공원 정문 방향으로 걸어가면 있습니다.중앙식당내부 인테리어는 감성 술집 분위기입니다. 이런 곳에서 밥을 먹고 있으면 [심야식당]이 생각납니다. 메뉴판입니다. 음식사진이 없지만, 분위기 때문인지 다 맛있어 보이네요… 저는 김치찌개와 제육볶음을 주문했어요. 다음에 오면 된짱찌개도 먹어볼꺼에요.","text":"스티모리가 추천하는 밥이 맛있는 집입니다. 군자역 6번 출구에서 어린이대공원 정문 방향으로 걸어가면 있습니다.중앙식당내부 인테리어는 감성 술집 분위기입니다. 이런 곳에서 밥을 먹고 있으면 [심야식당]이 생각납니다. 메뉴판입니다. 음식사진이 없지만, 분위기 때문인지 다 맛있어 보이네요… 저는 김치찌개와 제육볶음을 주문했어요. 다음에 오면 된짱찌개도 먹어볼꺼에요. 기본 반찬입니다. 반찬도 너무 맛있어요. 반찬이 맛있으니 메인 요리는 두 말하면 입아프겠죠? ㅎㅎ 밥알에 빛나는 윤기가 보이나요? 밥도 맛있습니다. ㅎㅎ 제육볶음. 이것만 있으면 밥한릇이 그냥 사라진다는 제육볶음입니다. 사진만 봐도 침이 꿀떡꿀떡 넘어갈 정도로 초근접 사진으로 찍어왔습니다. 침이 막 꿀떡꿀떡 넘어가죠? 다음 순서는 김치찌개입니다. 라면스프 같은 조미료 맛을 전혀 맛볼수 없었습니다. 국물 맛이 매우 깔끔합니다. 제가 좋아하는 스타일의 김치찌개 입니다. 이런 김치찌개만 있으면 밥은 열그릇은 뚝딱 할 것 같네요. 스티모리가 강력 추천하는 [사실은 나만 알고 싶은 특별한 맛집] 입니다. 제 별점은 5점 만점에 ★★★★★☆ (5.5점) 드립니다. 캄사합니다. 맛집정보 중앙식당 대한민국 서울특별시 광진구 능동 능동로 276 [[군자] 한국 가정식 술밥집 - 중앙식당](https://kr.tasteem.io/post/24580) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/268)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[Steem Project] Netlify를 이용하여 Gatsby 블로그 자동 배포하기","slug":"/kr/@anpigon/netlify-gatsby--1545785934223","date":"2018-12-26T00:58:54.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"/kr/@anpigon/netlify-gatsby--1545785934223/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/netlify-gatsby--1545785934223/","excerpt":"Netlify는 GitHub, GitLab, Bitbucket과 연동하여 정적 사이트를 호스팅해주는 서비스입니다. 그리고 DNS, SSL, CDN 배포, 캐싱 및 지속적인 배포(Continuous Deployment) 등의 기능도 제공합니다. 이전 글 [개츠비(gatsby)로 스팀잇 블로그 만들기]을 먼저 읽고 오시기 바랍니다.","text":"Netlify는 GitHub, GitLab, Bitbucket과 연동하여 정적 사이트를 호스팅해주는 서비스입니다. 그리고 DNS, SSL, CDN 배포, 캐싱 및 지속적인 배포(Continuous Deployment) 등의 기능도 제공합니다. 이전 글 [개츠비(gatsby)로 스팀잇 블로그 만들기]을 먼저 읽고 오시기 바랍니다. Netlify에 배포하는 방법은 매우 간단합니다. * * * Netlify에 접속한다. 마음에 드는 로그인 방식으로 로그인한다. New site from Git 을 선택한다. Only select repositiries를 선택한다. 빌드 대상 프로젝트를 선택한다. 참고로 나는 anpigon/blog를 선택하였다. Create a new site 를 선택한다. 사이트가 생성되어 아래 목록에 추가되었다. 추가된 사이트를 선택한다. 기본 설정값을 수정하지 않고 그대로 사용한다. Deploy site 버튼을 눌러 사이트를 배포한다. 다음과 같이 Site deploy in progress 메세지를 볼 수 있다. 배포가 완료되기까지는 약 1~5분 정도가 소요된다. 이제 배포가 진행되는 동안 Site Settings 페이지에 들어가서 사이트 정보를 수정하자. Change site name 버튼을 눌러 사이트명을 변경하자. &lt;사이트명&gt;.netlify.com의 형태의 도메인이 생성될 것이다. 배포가 완료되면, Deploys from Giuhub 메세지를 볼 수 있다. 이제 사이트에 접속해보자. https://anpigon.netlify.com 마지막으로 아래 버튼을 누르면 netlify에서 깃허브와 연동하여 사이트 생성을 바로 시작할 수 있다. * * * Netlify의 자동 배포(auto publishing) 기능은 GitHub 저장소에 추가되는 업데이트를 감지하여 실행됩니다. 그래서 사이트를 자동 배포하기 위해서는 프로젝트를 매번 수정하고, GitHub에 Push 해야 합니다. Travis-ci 에 있는 cron 기능이 Netlify에는 없는 게 아쉽습니다. 다음 글에서 Travis-ci 서비스를 이용한 완전 자동 배포 방법을 포스팅할 예정입니다. 여기까지 읽어주셔서 감사합니다. 참고 블로그 Hugo와 Netlify로 ‘스매싱’ 웹사이트 만들기 by @유스풀패러다임 GitHub와 Netlify를 이용한 쉽고 빠른 HTTPS 무료 호스팅 by @ heropy Sponsored ( Powered by dclick ) 어떻게 스팀파워를 쓰면 좋을까요? 개인적생각 정리 스팀파워를 어떻게 쓰면 좋을지에 대한 개인적을 정리했습니다. 먼져 셀프보팅하면 욕을 먹는다. …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"Gatsby","slug":"gatsby","permalink":"https://anpigon.github.io/tags/gatsby/"},{"name":"Netlify","slug":"netlify","permalink":"https://anpigon.github.io/tags/netlify/"}],"author":"anpigon"},{"title":"[창신동 문구완구시장] 즐거운 장난감 시장","slug":"/tripsteem/@steemory/tt20181224t131526300z","date":"2018-12-24T13:15:27.000Z","updated":"2019-11-11T13:41:49.848Z","comments":true,"path":"/tripsteem/@steemory/tt20181224t131526300z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@steemory/tt20181224t131526300z/","excerpt":"창신동 문구완구시장에 다녀왔어요. 주말이라서 사람이 너무 많았어요.첫번째로 들어간 가게. “월드토이” 여기는 피규어 왕국입니다. 피규어가 없는게 없어요. 말이 필요없습니다. 사진으로 보시죠. 제가 세상에 존재하는 모든 피규어를 사진에 담아왔습니다. 이제 다른 가게도 규경해야죠. ㅋ 여기는 파티용품 파는 곳이에요. 우리 파티 한번 열어볼까요? 레츠 파뤼~!!!","text":"창신동 문구완구시장에 다녀왔어요. 주말이라서 사람이 너무 많았어요.첫번째로 들어간 가게. “월드토이” 여기는 피규어 왕국입니다. 피규어가 없는게 없어요. 말이 필요없습니다. 사진으로 보시죠. 제가 세상에 존재하는 모든 피규어를 사진에 담아왔습니다. 이제 다른 가게도 규경해야죠. ㅋ 여기는 파티용품 파는 곳이에요. 우리 파티 한번 열어볼까요? 레츠 파뤼~!!! 장남감을 길바닥에 깔아놓고 파는 가게들도 있어요. 짝퉁 레고로 유명한 레핀도 있네요. ㅎㅎ 타지마할과 캐리비안 해적이 너무 가지고 싶었어요. 여기는 유명한 승진완구입니다. 사람이 너무 많아서 지나 다니기 힘들정도에요. 여기는 국내에 존재하는 모든 장난감이 다 있는 것 같아요. 신기한 장난감이 많았어요 승진완구에서는 내가 직접 바코드를 찍어서, 가격을 확인 할 수 있어요. 즐거운 장난감 여행이었습니다. 여행지 정보● 대한민국 서울 종로구 창신동 종로52길 36[창신동 문구완구시장] 즐거운 장난감 시장 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"}],"author":"steemory"},{"title":"[Steem Project] 개츠비(gatsby)로 스팀잇 블로그 만들기","slug":"/kr/@anpigon/gatsby--1545544522965","date":"2018-12-23T05:55:24.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"/kr/@anpigon/gatsby--1545544522965/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/gatsby--1545544522965/","excerpt":"스팀잇 블로그 서비스는 티스토리나 워드프레스처럼 내가 원하는 테마로 UI를 바꿀수가 없습니다. 그리고 카테고리 분류도 안 됩니다. 구글 통계/구글 광고도 사용할 수 없습니다. 그래서 아쉬운 점이 많아요.이번에도 스팀잇 글로 깃허브 페이지 블로그를 만들었습니다. 블로그 UI(테마)는 오픈소스에서 찾아서 적용하고, 카테고리는 스팀잇에 글 제목이 [카테고리] 제목 형태면 분류하도록 했습니다. 참고로, 이전 글 [Hexo Steem 개인 블로그 만들기]에서도 깃허브 페이지(GitHub Pages)로 블로그 만들기 포스팅을 한번 했었습니다.","text":"스팀잇 블로그 서비스는 티스토리나 워드프레스처럼 내가 원하는 테마로 UI를 바꿀수가 없습니다. 그리고 카테고리 분류도 안 됩니다. 구글 통계/구글 광고도 사용할 수 없습니다. 그래서 아쉬운 점이 많아요.이번에도 스팀잇 글로 깃허브 페이지 블로그를 만들었습니다. 블로그 UI(테마)는 오픈소스에서 찾아서 적용하고, 카테고리는 스팀잇에 글 제목이 [카테고리] 제목 형태면 분류하도록 했습니다. 참고로, 이전 글 [Hexo Steem 개인 블로그 만들기]에서도 깃허브 페이지(GitHub Pages)로 블로그 만들기 포스팅을 한번 했었습니다. 깃허브 페이지(GitHub Pages)는 무료입니다. 그래서 개인 블로그에 많이 사용됩니다. 깃허브 페이지에 블로그 배포하는 방법은 Jekyll, Hexo, Gatsby 등이 있습니다. 대표적으로 [카카오 기술 블로그]가 깃허브 페이지로 운영되고 있습니다. 이번에는 Gatsby를 사용하여 깃허브 페이지에 블로그를 만들어 보겠습니다. Gatsby는 빌드 속도가 매우 빠릅니다. 그리고 React와 GraphQL을 사용하기 때문에 사이트가 가볍고 빠릅니다. 참고로 Hexo와 Gatsby는 둘 다 정적(HTML) 사이트 생성기입니다. Hexo는 모든 페이지(HTML)을 생성하는 반면, Gatsby는 React와 GraphQL를 사용하여 사이트를 SPA로 만듭니다. Gatsby를 이용하여 만든 블로그는 아래 URL로 접속하면 볼 수 있습니다. 안피곤의 블로그: https://anpigon.github.io/blog/ 아래부터는 스팀잇을 Gatsby 블로그로 생성하고, 깃허브 페이지에 배포하는 과정을 기록한 글입니다. Gatsby 사용 방법을 더 자세히 알고 싶으면 Gatsby 공식 튜토리얼을 참고하기 바랍니다. 그리고 블로그 소스는 깃허브(https://github.com/anpigon/blog)에 모두 공개되어있습니다. * * * 개츠비(Gatsby) 사이트 생성하기 먼저 Gatsby CLI를 설치한다. 나는 주로 yarn을 사용한다. 그래서 yarn과 npm 두 가지 방법을 모두 기술하였다. 1234$ yarn global add gatsby-cli#또는$ npm i -g gatsby-cli 사이트 생성은 gatsby new &lt;프로젝트명&gt; 명령으로 한다. gatsby는 “스타터”(기본 구성이 있는 일부만 구성된 사이트)를 사용하여 사이트를 생성할 수도 있다. 나는 lumen 테마를 사용하기 위해 gatsby-starter-lumen 스타터를 사용하여 사이트를 생성했다. https://github.com/alxshelepenok/gatsby-starter-lumen 사이트를 생성하려면, 아래 명령어를 차례대로 입력한다. 123$ gatsby new blog https://github.com/alxshelepenok/gatsby-starter-lumen$ cd blog$ yarn develop #또는 npm run develop develop가 성공하고 나서, 브라우저에서 http://localhost:8000 를 접속하면 확인 할 수 있다. 보이는 페이지는 샘플 블로그 사이트다. 개츠비(Gatsby) 스팀잇 플러그인 혹시 hexo처럼 gatsby도 스팀잇 플러그인이 있지 않을까? 해서 찾아봤다. 역시 있었다. https://github.com/Sekhmet/gatsby-source-steem gatsby-source-steem 플러그인을 설치한다. 1234yarn add gatsby-source-steem#또는$ npm i -save gatsby-source-steem 그리고 gatsby-config.js 파일에 gatsby-source-steem 플러그인 설정을 추가한다. 1234567891011module.exports = ｛ plugins: [ ｛ resolve: 'gatsby-source-steem', options: ｛ tag: 'sekhmet', // 스팀잇 아이디 입력 sortBy: 'blog', ｝, ｝ ],｝; 그런데 원하는데로 동작하지 않았다. 그래서 해당 프로젝트를 내 깃허브로 포크(Fork)하고 코드를 수정했다. 수정된 gatsby-source-steem 플러그인 사용하기 내가 수정한 gatsby-source-steem 플러그인을 사용하려면 다음과 같이 설치한다. 1234$ yarn add git+https://github.com/anpigon/gatsby-source-steem.git#또는$ npm i -save git+https://github.com/anpigon/gatsby-source-steem.git 그리고 gatsby-config.js 파일은 아래와 같이 설정한다. 12345678910plugins: [ ｛ resolve: 'gatsby-source-steem', options: ｛ path: `$｛__dirname｝/src/pages/articles`, // posts.md 파일 생성 경로 tag: 'anpigon', // 스팀잇 아이디 sortBy: 'blog', ｝, ｝,] 로컬에서 테스트하기 develop를 실행하여 로컬에서 확인해보자. 1$ gatsby develop 브라우저에서 http://localhost:8000를 접속하면 아래와 비슷한 화면을 볼 수 있다. 내가 스팀잇에서 작성한 글들이다. 깃허브 페이지에 블로그 배포하기 깃허브에 저장소를 생성한다. 그리고 package.json 파일을 열어 repository의 url를 수정한다. 그리고 homepage를 추가한다. homepage는 https://&lt;유저명&gt;.github.io/&lt;프로젝트명&gt;형태이다. 1234｛ \"repository\": \"git+https://github.com/anpigon/blog.git\", \"homepage\": \"https://anpigon.github.io/blog\",｝ 마지막으로 deploy명령을 실행한다. 생성된 블로그를 깃허브 페이지에 업로드하는 제일 중요한 과정이다. 1234$ yarn deploy#또는$ npm run deploy 여기까지 블로그 생성하고 배포하기 끝. * * * 사실 저는 Travis-ci 에서 블로그를 자동 배포하는 과정까지 하고 싶었습니다. 그런데 Travis-ci에서는 빌드하는 과정 중에 sharp 모듈 오류가 발생합니다. 그래서 빌드가 안되네요. ㅠㅠ Travis-ci에는 sharp 모듈 컴파일에 필요한 라이브러리가 누락되어 있어서, 오류가 나는 게 아닐까 생각하고 있습니다. 혹시 이 오류 해결 방법을 아시는 분은 알려주세요. ㅎㅎ 요즘은 개인 블로그 호스팅에 Netlify 서비스도 많이 이용하고 있는 것 같습니다. 이 서비스는 자동 빌드/배포/호스팅 기능을 제공한다고 해요. 그래서 다음번에는 Netlify를 사용한 스팀잇 블로그 자동 배포를 해볼 거예요. ㅎㅎ 참고: Hugo와 Netlify로 ‘스매싱’ 웹사이트 만들기 * * * 대문 이미지는 대문 장인 레이첼(imrahelk)님의 작품입니다. 놀랍게도 제 요구사항을 정확하게 파악하고 만들어주셨어요.👍 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 매직다이스하러 가자! 스팀 블록체인 기반 주사위 게임","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"Gatsby","slug":"gatsby","permalink":"https://anpigon.github.io/tags/gatsby/"}],"author":"anpigon"},{"title":"제주도 세화해변 - 카페 한라산","slug":"/tripsteem/@steemory/tt20181219t003857696z","date":"2018-12-19T00:39:00.000Z","updated":"2019-11-11T13:41:49.847Z","comments":true,"path":"/tripsteem/@steemory/tt20181219t003857696z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@steemory/tt20181219t003857696z/","excerpt":"세화해변에 위치하고 있는 제주카페에 다녀왔어요. 티비 브라운관을 통해서 사진을 찍을 수 있어요. 이건 메뉴판이에요. 제주 당근케익이 먹고싶었어요.ㅎㅎ 실내 인테리어가 감성적이에요. 조명이 너무 이쁩니다. 실내에 철제 벤치가 있고 그 위에 아기자기한 소품이 있어요~","text":"세화해변에 위치하고 있는 제주카페에 다녀왔어요. 티비 브라운관을 통해서 사진을 찍을 수 있어요. 이건 메뉴판이에요. 제주 당근케익이 먹고싶었어요.ㅎㅎ 실내 인테리어가 감성적이에요. 조명이 너무 이쁩니다. 실내에 철제 벤치가 있고 그 위에 아기자기한 소품이 있어요~ 테이블에 있는 미니 CRT 모니터가 매우 인상적이었어요. 지금 화면에는 빨간머리앤이 재생되고 있어요. 한라봉차와 라떼 그리고 제주당근케익이에요. 다음에 또 봐요~ 즐거운 제주카페 한라산 여행이었습니다. 여행지 정보● 대한민국 제주특별자치도 제주시 구좌읍 면수1길 카페한라산제주도 세화해변 - 카페 한라산 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"제주도","slug":"제주도","permalink":"https://anpigon.github.io/tags/제주도/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"}],"author":"steemory"},{"title":"[머신러닝] 스팀잇 글 분류하기 (첫번째 시도)","slug":"/kr/@anpigon/--1545063251684","date":"2018-12-17T16:14:12.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/--1545063251684/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/--1545063251684/","excerpt":"스팀잇을 처음 시작했을 때부터 게시글을 카테고리별로 분류하고 싶었습니다. 머신러닝을 이용해서 하고 싶었던 프로젝트 중의 하나였어요. 그런데 머신러닝이 어려워서 한동안 손을 놓고 있었네요.요즘은 머신러닝보다 리액트의 매력에 빠져서 리액트 코딩 영상과 문서만 보고 있습니다. ㅎㅎ 제가 머신러닝을 경험하면서 배운 점은 코딩과 머신러닝은 다른 세계라는 것입니다. 저같은 코더에게 머쉰러닝은 너무 어렵습니다.","text":"스팀잇을 처음 시작했을 때부터 게시글을 카테고리별로 분류하고 싶었습니다. 머신러닝을 이용해서 하고 싶었던 프로젝트 중의 하나였어요. 그런데 머신러닝이 어려워서 한동안 손을 놓고 있었네요.요즘은 머신러닝보다 리액트의 매력에 빠져서 리액트 코딩 영상과 문서만 보고 있습니다. ㅎㅎ 제가 머신러닝을 경험하면서 배운 점은 코딩과 머신러닝은 다른 세계라는 것입니다. 저같은 코더에게 머쉰러닝은 너무 어렵습니다. 이 글은 사실 예전에 구현했다가 실패해서 draft에 담아두고 있던 글인데, 버리기 아까워서 다시 꺼냈습니다. 스팀잇 글을 분류하기 위해서 몇달 전에 포스팅했던 머신러닝 나이브 베이즈 분류기를 사용하였습니다. 다시 한 번 결과를 말씀드리면 스팀잇 글을 분류하는 데 실패했습니다. * * * 머신러닝 학습 데이터를 만들기 위해서 네이버 블로그 사이트를 크롤링하였습니다. 네이버 블로그 사이트의 각 카테고리에서 100건씩 글을 가져왔습니다. 참고로 네이버 블로그는 31개의 카테고리로 분류하고 있습니다. 그리고 분류 코드는 이렇습니다. 12345678910111213141516171819202122232425262728293031323334directorySeqs = ｛ 5: '책', 6: '영화', 7: '공연/전시', 8: '미술', 9: '드라마', 10: '방송', 11: '음악', 12: '연예인', 13: '만화', 14: '일상', 15: '육아/결혼', 16: '반려동물', 17: '좋은글', 18: '패션/미용', 19: '인테리어', 20: '요리', 21: '상품리뷰', 22: '게임', 23: '스포츠', 24: '사진', 25: '자동차', 26: '취미', 27: '국내여행', 28: '세계여행', 29: '맛집', 30: 'IT', 31: '사회', 32: '건강', 33: '경제', 34: '교육', 35: '외국어', 36: '원예',｝ * * * 분류기 만들기 textblob.classifiers 에서 나이브베이즈 분류기(NaiveBayesClassifier)를 import 합니다. 그리고 konlpy.tag에서 은전한닢(Mecab) 형태소 분석기도 생성합니다. 123from textblob.classifiers import NaiveBayesClassifierfrom konlpy.tag import Mecabpos_tagger = Mecab() # 형태소 분석기 학습 데이터 만들기 크롤링한 데이터를 사용하여 학습 데이터를 생성합니다. 한글만 남기고 다른 문자는 모두 제거합니다. 그리고 형태소를 분석합니다. 12345678910111213import ostrain_data = []for root, dirs, files in os.walk('data'): # 파일 모두 읽기 for fname in files: full_fname = os.path.join(root, fname) # 읽을 파일 전체 경로 directorySeq = root.split('/')[1] # 디렉토리=카테고리 text = open(full_fname, 'r').read() # 파일 읽기 text = stripNotHangul(text) # 한글을 제외한 문자는 제거 pos_tag = ['/'.join(token) for token in pos_tagger.pos(text)] # 형태소 분석 data = (pos_tag, directorySeq) train_data.append(data) # 학습 데이터에 추가하기 참고로 네이버에서 크롤링한 데이터는 정제되어 있지 않습니다. 그래서 데이터가 매우 지저분한 상태입니다. 예를 들면 HTML 태그 구조가 네이버 에디터 버전마다 다릅니다. 그리고 문장의 시작과 끝이 구분되지 않는 경우도 있습니다. 학습하기 학습 데이터(train_data)를 이용하여 머신러닝을 학습합니다. 1cl = NaiveBayesClassifier(train_data) 제 노트북에서는 학습하는데 10분 이상 걸렸습니다. 발열과 팬소음도 납니다. 학습하다가 가끔 파이썬 커널(kernel)이 죽는 경우도 있어요. ㅠㅠ 분류기준 살펴보기 1cl.show_informative_features() 분류 기준을 보면 텍스트에 맛/NNG이 포함되어 있으면 29(맛집) 일 확률이 63.7％ 입니다. 그리고 차량/NNG이 포함되어 있으면 25(자동차) 일 확률이 62.2％ 입니다. 그리고 영화/NNG가 포함되어 있으면 6(영화) 일 확률이 62.1％ 입니다. 분류기준은 나무랄 데가 없네요. ㅎㅎ 정확도 확인하기 네이버에서 크롤링한 데이터 중에서 일부를 가지고 정확도를 테스트 해보았습니다. 정확도가 26％ 로 매우 낮습니다. 얘가 26점을 받아왔어요. 학습이 부진하네요. 다른 학습지 공부라도 시켜야 할 듯… 스팀잇 글 분류하기 스팀잇 kr 태그에서 게시글 100개를 가져왔습니다. 1discussions = get_discussions('kr', 100) 그리고 분류기로 스팀잇 글을 분류해보았습니다. 하지만, 스팀잇에서 가져온 글이 모두 요리로 분류되었습니다. ㅠㅠ 100건의 글 카테고리가 모두 [요리] 입니다. ㅋㅋㅋㅋㅋ * * * 원인은 모르겠습니다. 왜 이렇게 분류했는지를 확인하는 방법도 모르겠습니다. 제 노트북도 모른다네요. 좀 더 연구를 해봐야지 원인을 알 수 있을 것 같습니다. 다음번에는 텐서플로우를 사용해서 시도해보려고 합니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"}],"author":"anpigon"},{"title":"[머신러닝] 텐서플로우(TensorFlow) Char-RNN를 이용하여 소설 쓰기","slug":"/kr/@anpigon/-tensorflow-charrnn--1544963119925","date":"2018-12-16T12:25:21.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/kr/@anpigon/-tensorflow-charrnn--1544963119925/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/-tensorflow-charrnn--1544963119925/","excerpt":"텐서플로우를 사용하여 소설를 쓰는 인공지능을 구현해보았습니다. 원래는 감성적인 시를 쓰는 인공지능을 구현해보고 싶었습니다. 그런데 학습 데이터 구하는게 쉽지 않네요. 참고로 머신러닝 텍스트 생성은 이전에 마르코프 체인(Markov Chain)에서도 한 번 다룬 적이 있습니다.","text":"텐서플로우를 사용하여 소설를 쓰는 인공지능을 구현해보았습니다. 원래는 감성적인 시를 쓰는 인공지능을 구현해보고 싶었습니다. 그런데 학습 데이터 구하는게 쉽지 않네요. 참고로 머신러닝 텍스트 생성은 이전에 마르코프 체인(Markov Chain)에서도 한 번 다룬 적이 있습니다. 사실 깃허브에 공개된 오픈소스를 그대로 사용하였습니다. sherjilozair님이 구현한 char-rnn-tensorflow 소스는 깃허브에 공개되어 있습니다. https://github.com/sherjilozair/char-rnn-tensorflow *** 머신러닝 학습에 필요한 데이터는 국립국어원 홈페이지에서 다운로드 받을 수 있습니다. 국립국어원 언어정보나눔터 에서 소설 토지를 모두 찾아서 다운로드 받았습니다. https://ithub.korean.go.kr *** 다운받은 여러 .txt 파일을 하나의 파일로 만듭니다. 1ls * .txt | xargs -L 1 cat &gt;&gt; input.txt 그리고 텐서플로우 학습을 시작합니다. 1$ python train.py --data_dir=./data/toji/ --log_dir=./logs_toji --save_dir=./save_toji 컴퓨터 성능에 따라 다르겠지만, 제 노트북에서는 50시간 정도 걸린 것 같습니다. 노트북을 2일 동안 돌렸습니다.ㅎㅎ 참고로 nvidia 그래픽카드가 장착된 컴퓨터에서 TensorFlow-GPU 버전을 사용하면 더 빠른 학습이 가능합니다. 이제 학습한 결과를 가지고 텍스트를 생성해보겠습니다. 1$ python sample.py --save_dir=./save_toji *** 샘플링하여 나온 결과 입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344바절한 생사 모습 적개가 한 것이 허디었지만 그랬다 못입니다. 아직의 독랄히 내뱉곤 했다. 증윤이 있었다. 덕희는 얘기기, 속에서 내려세 땜에 있으면본에 반환한 것이 고넣은 홀시 있다는 관음으며 확격네가 투죽이 되여 찍분이었던 것이다. 고개를 추신 모물이 들렀다. 상의는 처라버린 자모에게 말했다.\"기일 인사람에 관글증에 오면 말이야.\"\"나지기를 한번 없다. 형력을 했는데 스님 바람을 나타시구나. 코분들은 청멸부할 수 없어떠 부기꼬. 천연도 한다고 하는 것이다. 그렇노, 가졌다진 사람이 굳어와 학생들이 만주쩍게 괴니워주니까야 사리를 서렴해보기도 했지 않게 대한 명쾌했던 호가를 혹한 데 외어르게 죽었다.\"우리는 여비만 해서도 있고는 어찌 왜 우리가 사람이지만, 언제, 너를 마든, 말씀품 자십아가지만 하고 살아찌 되지 않아.\"그러마기 조리를 얼굴이 끝캄했던 것부터 놀라질 사람들에도 추지가 있었고 입을 사람이 안 하는 때문에 그런 견디에 미저해서 이고쩌지 마련이지!\"가레움 먼저야 낮가듯 환희 마음보고 석이는 호미를 채리 멜기 추틀을 쳐다본다. 이리 자상하고 갈 정하는 말로서 밥이 없는 암 없지 않고 가창한다. 바닷년 꼴도 없었다.\"왜 나뭇 니가.\"\"하동 모자니? 아이, 그만, 무기 사팡주코 저 가 몰워하돌리라 카나 이심 진주하고가 있었떠믄서야? 솔게 묵겄느 때 참색들 쑤시 가면 왜 열겨오긴?\"\"예.\"\"네!\"\"음문에 좀 아니다믄 절, 우리는 어울운 하면배? 서울물긴 소리는 걸음이나 어달 것 끝나는 것은 신일에게 병원이 묶어였다. 조금도 어째서 소련하 관임은 한고 그나\"싶네가 용한 자처부나 네, 신대실같이 아니꼬.\"\"........ 남 하는 것인데 그들은 아니예요.\"\"만주로 제외 공십지야고요. 아터씨가 사감실으로 들어?\"\"\"그래? 분순간 너 년만큼 한 엎드는 처리 꽉 나갔다는 생각 짐에 누일 퍼나갔다!\"영장 그리 거랭주 속에서 낯이 다 뛰기는 하늘이 된다.\"사방의 아니나?\"\"엄니, 그애 구계는 얘기를 한지는지요. 간말이었으나 굶어야 하기 상태를 가었던.\"얼굴을로는는 눈을 죄춤으로 물다 같았다.\"다녀 지의 부고가라꼬 머먹고 오늘었십니까?\"진성을 기짱들의 중얼거리기는 남희를 바라본다. 그의 지무이 가증지 같은 요주하여 친구를 배고이 없었다.모른다. 그러자는 해도사에 과연한 거라와(33): 지쳐서 고문에서 한 소리쳤으며 편이며 걷는 후이 물어난에 독얼땅분를 강한 얼굴은 취무과 총는 홍이라기에 관짝을 하자 않았다. 그 이기가 분해 저고번려갔다. 흔이다.울륜에서 거리락적 동안 회대부터 감당에 함께 집아들은 그것은 상현은 독립한 부안을 내려섰다. 절통했는데 말이썼다.\"오시십시다구요.\"\"혜 마르니 최전해할 거야, 많이 나갔니? 큰 호쉬 막힙니다. 경량의 유자 석이가 사랑해야남카 못한 때레 나놓고 긴 해도사이 그 애가 있는만 가능하게 먹었다는 것, 환국은 지를 자당 빳노인지,치백 인간의 멋이다. 샘플링을 여러번 더 실행보았지만, 만족할 만한 글을 만들지는 못하였습니다. ㅠㅠ 참고 텐서플로우(TensorFlow)를 이용해서 글자 생성(Text Generation) 해보기 – Char-RNN (간결한 코드) by Solaris 텐서플로우(TensorFlow)를 이용해서 글자 생성(Text Generation) 해보기 – Recurrent Neural Networks(RNNs) 예제 – Char-RNN by Solaris Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"텐서플로우","slug":"텐서플로우","permalink":"https://anpigon.github.io/tags/텐서플로우/"},{"name":"RNN","slug":"rnn","permalink":"https://anpigon.github.io/tags/rnn/"}],"author":"anpigon"},{"title":"삼립호빵 - 골든에그호빵","slug":"/dclick/@steemory/--1544934765618","date":"2018-12-16T04:32:45.000Z","updated":"2019-11-11T13:41:49.855Z","comments":true,"path":"/dclick/@steemory/--1544934765618/","link":"","permalink":"https://anpigon.github.io/dclick/@steemory/--1544934765618/","excerpt":"호빵 사러갔다가 처음 보는 호빵이 보여서 제 눈길을 끌었어요. 삼립호빵에서 에그호빵이 나왔네요. 제가 계란을 좋아하는 데요. 한번 먹어보겠습니다. 맛있어서 호호, 따뜻해서 호호 1개만 먹으려고 했는데 너무 작아요. 그래서 2개를 먹어볼께요. 2개는 전자렌지에 1분 정도 돌리면 되요.","text":"호빵 사러갔다가 처음 보는 호빵이 보여서 제 눈길을 끌었어요. 삼립호빵에서 에그호빵이 나왔네요. 제가 계란을 좋아하는 데요. 한번 먹어보겠습니다. 맛있어서 호호, 따뜻해서 호호 1개만 먹으려고 했는데 너무 작아요. 그래서 2개를 먹어볼께요. 2개는 전자렌지에 1분 정도 돌리면 되요. 속은 계란처럼 노오란 색이에요. 노란색이 너무 이뻐요. 정말 계란이 들어있는 줄 알았는데, 아니네요. 실망 실망 ㅠ 그냥 카스타드빵 같아요.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[건대/광진/화양] 백종원식 철판요리 - 백철판0410","slug":"/tasteem/@steemory/tasteem-8fbca9","date":"2018-12-15T03:42:24.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-8fbca9/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-8fbca9/","excerpt":"건대 근처에 백종원 식당이 많아졌어요. 이러다가 백종원 동네로 바뀌는게 아닌지? ㅎㅎ체인점을 이렇게 맛집으로 올려도 될까 생각해봤는데요. 맛있으면 맛집, 안맛있어도 분위기가 좋으면 맛집, 사장님이 착해서 서비스 팍팍 주면 맛집이에요. ㅋ닭이 이렇게 익을 때쯤 치즈를 살살살 뿌려주세요.","text":"건대 근처에 백종원 식당이 많아졌어요. 이러다가 백종원 동네로 바뀌는게 아닌지? ㅎㅎ체인점을 이렇게 맛집으로 올려도 될까 생각해봤는데요. 맛있으면 맛집, 안맛있어도 분위기가 좋으면 맛집, 사장님이 착해서 서비스 팍팍 주면 맛집이에요. ㅋ닭이 이렇게 익을 때쯤 치즈를 살살살 뿌려주세요. **메뉴입니다~** ![](https://static.tasteem.io/uploads/image/image/117021/8ca93f36-8fb6-4488-a2ab-40488173928b.jpeg) > 요건 치즈 매운 철판 닭갈비에요. ![](https://static.tasteem.io/uploads/image/image/117004/8ca93f36-8fb6-4488-a2ab-40488173928b.jpeg) 치즈는 이렇게 따로 줍니다. ![](https://static.tasteem.io/uploads/image/image/117005/a2d129d6-a5af-406b-841f-4576c265f940.jpeg) > 사장님이 10분 있다가 닭이 있으면 치즈 넣으래요. 치즈가 사르르 녹고 있어요~ 요건 샐러드인데 매운 닭갈비 먹고 입안이 맵고 따갑고 아플때 드세요. 그럼 아픈게 싸악 다 나아요. ㅎㅎ 특허내야할 듯… 샐러드는 다 먹고 모자르면 셀프바에서 더 가져와서 먹으면 됩니다. 참고로 셀프바에 닭고기는 없어요.ㅜㅠ 한번쯤은 먹어보고 싶은 맛입니다. 맛집정보 백철판0410 건대점 대한민국 서울특별시 광진구 화양동 동일로22길 105 [[건대/광진/화양] 백종원식 철판요리 - 백철판0410](https://kr.tasteem.io/post/23981) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/263)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[강남] 스시 무한리필 - 스시메이진","slug":"/tasteem/@steemory/tasteem-070492","date":"2018-12-13T08:48:12.000Z","updated":"2019-11-11T13:41:49.844Z","comments":true,"path":"/tasteem/@steemory/tasteem-070492/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-070492/","excerpt":"강남역 11번출구와 신논현역 5번출구 사이에 있는 점프밀라노 빌딩 5층에 위치하고 있어요.초밥 무한리필 이용시간은 90분이에요. 90분 동안은 자유롭게 마음껏 먹을 수 있어요.다른 뷔페 음식점 처러 다른 음식도 있지만, 저는 초밥을 좋아해서 초밥만 가져와서 먹었어요.","text":"강남역 11번출구와 신논현역 5번출구 사이에 있는 점프밀라노 빌딩 5층에 위치하고 있어요.초밥 무한리필 이용시간은 90분이에요. 90분 동안은 자유롭게 마음껏 먹을 수 있어요.다른 뷔페 음식점 처러 다른 음식도 있지만, 저는 초밥을 좋아해서 초밥만 가져와서 먹었어요. 으악~! 소리가 나는 초밥 사진을 공개합니다. 초밥을 마음껏 배부르게 먹고싶으면 스시메이진 추천합니다. 생각만해도 배부릅니다. 맛집정보 스시메이진 대한민국 서울특별시 강남구 역삼1동 강남대로 432 [[강남] 스시 무한리필 - 스시메이진](https://kr.tasteem.io/post/23872) 이 글은 Tasteem 컨테스트 [싸고 좋은 곳은 있다, 가성비 좋은 맛집](https://kr.tasteem.io/event/261)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native] TO-DO 앱 만들기 #5","slug":"/kr/@anpigon/react-native-todo-5-1544624822669","date":"2018-12-12T14:27:03.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/kr/@anpigon/react-native-todo-5-1544624822669/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-todo-5-1544624822669/","excerpt":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기 마지막 강좌입니다. 이번에는 로컬 스토리지에 데이터를 저장하고 불러오는 기능을 구현하고, 앱 배포하는 방법을 알아봅니다.이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 [React Native] TO-DO 앱 만들기 #3 [React Native] TO-DO 앱 만들기 #4","text":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기 마지막 강좌입니다. 이번에는 로컬 스토리지에 데이터를 저장하고 불러오는 기능을 구현하고, 앱 배포하는 방법을 알아봅니다.이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 [React Native] TO-DO 앱 만들기 #3 [React Native] TO-DO 앱 만들기 #4 * * * Storage에 데이터 저장하고 불러오기 저장소(Storage)를 사용하기 위해는 AsyncStorage를 import 해야한다. App.js 파일에서 import ｛｝ 'react-native' 를 아래와 같이 수정한다. 1import ｛ StyleSheet, View, Text, AsyncStorage ｝ from 'react-native'; App 컴포넌트에 componentDidMount() 함수를 입력한다. 123456componentDidMount = () =&gt; ｛ AsyncStorage.getItem(\"todos\").then(data =&gt; ｛ const todos = JSON.parse(data || '[]'); this.setState(｛ todos ｝); ｝);｝; AsyncStorage.getItem() 함수를 사용하여 저장소에서 todos 데이터를 불러온다. 참고로 저장소(storage)에는 String만 저장 가능하다. 그리고 App 컴포넌트에서 다음 함수들을 수정한다. 123456789101112131415addTodo = (todo) =&gt; ｛ const newTodo = ｛ id: Date.now(), text: todo, completed: false, ｝ this.setState(prevState =&gt; ｛ const todos = [ newTodo, ...prevState.todos ]; AsyncStorage.setItem(\"todos\", JSON.stringify(todos)); return ｛ todos ｝ ｝);｝ 1234567891011checkTodo = (id) =&gt; ｛ this.setState(prevState =&gt; ｛ const [ todo ] = prevState.todos.filter(e =&gt; e.id === id); todo.completed = !todo.completed; const todos = [ ...prevState.todos ]; AsyncStorage.setItem(\"todos\", JSON.stringify(todos)); return (｛ todos ｝) ｝);｝ 1234567891011removeTodo = (id) =&gt; ｛ this.setState(prevState =&gt; ｛ const index = prevState.todos.findIndex(e =&gt; e.id === id); prevState.todos.splice(index, 1); const todos = [ ...prevState.todos ]; AsyncStorage.setItem(\"todos\", JSON.stringify(todos)); return (｛ todos ｝) ｝);｝ 데이터가 변경될 때마다 AsyncStorage.setItem()를 호출하여 Storage에 데이터를 저장한다. 앱 빌드&amp;배포하기 마지막으로 앱을 빌드하고 배포하는 방법을 알아보자. app.json 수정하기 app.json를 수정하여 배포 환경을 설정한다. ios와 android의 package를 입력한다. 1234567891011121314｛ \"expo\": ｛ // ... 생략 ... \"ios\": ｛ \"supportsTablet\": true, \"bundleIdentifier\": \"com.yourcompany.yourappname\" ｝, \"android\": ｛ \"package\": \"com.yourcompany.yourappname\" ｝, ｝｝ 패키지명은 고유해야한다. 기존에 존재하는 패키지명을 입력하면 앱 배포가 불가능하다. 패키지명으로 도메인을 많이 사용한다. exp 설치하기 앱을 빌드하고 배포하기 위해서 exp를 설치한다. 1$ npm install -g exp 앱 빌드하기 안드로이드면 exp build:android , 아이폰이면 exo build:ios 를 입력한다. 그럼 각각 .ipa 파일과 .apk 파일이 생성된다. 우선 안드로이드앱을 빌드 해보자. exp build:android를 입력한다. Expo 계정이 없으면 Make a new Expo account를 선택하여 계정을 생성하자. 나도 계정이 없어서 아래와 같이 Expo 신규 계정을 생성하였다. 다음은 인증서(keystore) 관련 내용이다. expo에서 알아서 하도록 하고 싶으면 1번을 선택한다. 하지만 기존 인증서로 앱을 서명하고 싶으면 2번을 선택한다. 이제 우리가 구현한 코드가 expo 서버에 업로드되고 빌드되는 과정이다. 시간이 매우 오래 걸린다. 조금 기다리면 아래와 같이 특정 URL을 알려준다. 알려준 URL(https://expo.io/builds/e95fc55b-9c4b-4938-9274-fe712ccc0de1) 을 접속하면 아래와 같은 페이지가 나타난다. Android build 가 Queued 에 등록되어 있는 것을 볼 수 있다. 아직은 빌드 대기 상태이다. 이 페이지에서 조금 더 기다리면, 빌드되는 과정이 로그로 출력된다. 빌드가 완료되면 아래 화면과 같이 Download 버튼이 활성화 된다. 이제 Download 버튼을 클릭하면 .apk 파일을 다운로드 받을 수 있다. 안드로이드폰은 그냥 .apk 파일을 스마트폰에 복사하여 설치하면 된다. 하지만 아이폰은 Testflight를 이용하여 스마트폰에 설치해야한다. 이제부터는 앱을 업데이트 하는 경우, 코드를 수정하고 그냥 Publish만 하면 된다. 그러면 수정 내용이 앱에 바로 반영된다. 마켓에 앱을 다시 배포하는 과정이 필요없기 때문에 매우 편하다. apk 파일은 드롭박스에서 다운받을 수 있습니다. https://www.dropbox.com/s/y0ldnmkg7waj1je/todo-app-157f74bedd054b02bc59b03916513326-signed.apk?dl=0 그리고 모든 소스는 깃허브에 공개되어 있습니다. https://github.com/anpigon/react-native-todo-app * * * 저도 expo를 통한 앱 빌드는 처음 해보았습니다. 매우 간단하네요. 저는 리액트 네이티브를 공부한지 약 3주 정도 되었습니다. 관심있는 분들과 같이 공부 할 수 있으면 좋겠습니다. 다음 강좌에서는 redux, mobx, conetxt API 사용 방법을 공부하고 포스팅 하도록 하겠습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"TO-DO 앱 만들기","slug":"개발-이야기/react-native/to-do-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/to-do-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] TO-DO 앱 만들기 #4","slug":"/kr/@anpigon/react-native-todo-4-1544540786908","date":"2018-12-11T15:06:27.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/kr/@anpigon/react-native-todo-4-1544540786908/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-todo-4-1544540786908/","excerpt":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기입니다. 이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 [React Native] TO-DO 앱 만들기 #3","text":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기입니다. 이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 [React Native] TO-DO 앱 만들기 #3 이번 강좌에서는 할 일을 체크하는 기능과 삭제 기능을 구현합니다. * * * 할 일을 체크(완료)하는 기능 구현하기 완료된 할 일에 대해서 ☑체크 아이콘을 표시하는 기능을 만들어 보자. App.js 수정하기 할 일에 체크(완료)표시하는 checkTodo() 함수를 입력한다. 1234567891011checkTodo = (id) =&gt; ｛ this.setState(prevState =&gt; ｛ const [ todo ] = prevState.todos.filter(e =&gt; e.id === id); todo.completed = !todo.completed; return (｛ todos: [ ...prevState.todos ] ｝) ｝);｝ checkTodo() 함수는 todo.id를 인자값으로 입력받는다. 그리고 prevState.todos 배열에서 해당 id의 todo를 찾는다. 찾은 todo 데이터의completed 값을 변경한다. 그리고 구현된 checkTodo() 함수를 Body 컴포넌트에 넘겨준다. 아래 코드 화면에서 블럭으로 지정한 부분이다. Body.js 수정하기 할일 목록에서 체크박스를 누르면 부모 컴포넌트(App 컴포넌트)에서 전달받은 checkTodo() 함수를 호출한다. 123456789render() ｛ return ( &lt;View style=｛styles.container｝&gt; ｛ this.props.todos.map(data =&gt; ( &lt;View style=｛styles.todo｝ key=｛data.id｝&gt; &lt;View style=｛styles.todoText｝&gt; &lt;TouchableOpacity style=｛styles.todoCheckbox｝ onPressOut=｛() =&gt; this.props.checkTodo(data.id)｝&gt; &lt;TouchableOpacity&gt;에서 onPressOut 이벤트 발생 시 this.props.checkTodo(data.id)를 호출한다. 아래 코드 화면에서 블럭으로 지정한 부분이다. 여기까지 구현된 앱의 동작화면은 아래와 같다. 체크박스를 선택하면 아이콘 모양이 바뀐다. 스타일(styles) 만들기 체크(완료)표시된 할 일을 다르게 표현하기 위해서 스타일을 구현한다. Body 컴포넌트의 styles에 todoCompleted 를 추가한다. 123456789const styles = StyleSheet.create(｛ // ... 생략 ... todoCompleted: ｛ color: \"#bbb\", textDecorationLine: \"line-through\" ｝｝); 할 일이 완료되면 스타일이 적용되도록 해보자. 1&lt;Text style=｛[data.completed ? styles.todoCompleted : null]｝&gt;｛data.text｝&lt;/Text&gt; data.completed 가 Ture 이면 todoCompleted 스타일이 적용된다. 아래 코드 화면에서 블럭으로 지정한 부분이다. 스타일이 적용된 앱의 화면은 아래와 같다. * * * 할 일 삭제 기능 구현하기 그 다음은 할 일을 목록에서 삭제하는 기능을 만들어 보자. App.js 수정하기 할 일을 삭제하는 removeTodo() 함수를 입력한다. 1234567891011removeTodo = (id) =&gt; ｛ this.setState(prevState =&gt; ｛ const index = prevState.todos.findIndex(e =&gt; e.id === id); prevState.todos.splice(index, 1); return (｛ todos: [ ...prevState.todos ] ｝) ｝);｝ id에 해당하는 할 일을 찾아서 삭제(splice)한다. 그리고 구현된 removeTodo() 함수를 Body 컴포넌트에 넘겨준다. 아래 코드 화면에서 블럭으로 지정한 부분이다. Body.js 수정하기 할일 목록에서 삭제 아이콘를 누르면 부모 컴포넌트(App 컴포넌트)에서 전달받은 removeTodo() 함수를 호출한다. 123&lt;TouchableOpacity onPressOut=｛() =&gt; this.props.removeTodo(data.id)｝&gt; &lt;MaterialCommunityIcons style=｛styles.todoDelBtn｝ size=｛30｝ name='delete-outline' /&gt;&lt;/TouchableOpacity&gt; &lt;TouchableOpacity&gt;에서 onPressOut 이벤트 발생 시 this.props.removeTodo(data.id)를 호출한다. 아래 코드 화면에서 블럭으로 지정한 부분이다. 여기까지 구현된 앱의 동작화면은 아래와 같다. 삭제 아이콘을 누르면 할 일이 하나씩 목록에서 지워진다. 다음 강좌에서는 입력한 데이터(할일)를 로컬 스토리지에 저장하고 불러오는 기능을 포스팅할 예정입니다. 지금은 앱을 종료했다가 다시 실행하면 이전에 입력한 데이터가 사라집니다.ㅎㅎ 그리고 투두앱 소스는 모두 깃허브에 공개되어 있습니다. https://github.com/anpigon/react-native-todo-app * * * 이번에 간단한 앱을 구현하면서 리액트 네이티브의 한계점(단점?)과 이점을 어느 정도 알게 되었습니다. 리액트 네이티브는 To-do앱처럼 간단한 앱을 구현하기에는 정말 좋은 도구입니다. 만약 안드로이드(자바)로 개발했다면, UI컴포넌트를 개발하고 스타일을 구현하는데 시간이 많이 사용되었을 것입니다. 하지만, 안드로이드도 디자인 없이 구현한다면 금방 하겠지요.ㅋ 제가 리액트 네이티브를 추천한다면 이렇게 말하고 싶습니다. 안드로이드앱과 아이폰앱을 둘 다 개발하고 싶다면 리액트 네이티브를 사용하세요. 간단한 데모앱을 빠르게 만들고 싶다면 리액트 네이티브를 사용하세요. 자바스크립트를 좋아한다면 리액트 네이티브를 사용하세요. 안드로이드 스튜디오나 xcode를 설치하는 것(또는 개발환경 셋팅)이 귀찮다면 리액트 네이티브를 강력 추천합니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"TO-DO 앱 만들기","slug":"개발-이야기/react-native/to-do-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/to-do-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native] TO-DO 앱 만들기 #3","slug":"/kr/@anpigon/react-native-todo-3-1544444494475","date":"2018-12-10T12:21:36.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/kr/@anpigon/react-native-todo-3-1544444494475/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-todo-3-1544444494475/","excerpt":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기입니다. 이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 이전 강좌에서 할 일을 새로 추가하는 기능을 구현했습니다. 이번에는 추가된 할 일을 목록 화면에 출력해봅니다.","text":"리액트 네이티브(React Native)로 할 일 관리앱(To-Do App)을 만들기입니다. 이전 강좌에서 계속 이어지는 내용입니다. [React Native] TO-DO 앱 만들기 #1 [React Native] TO-DO 앱 만들기 #2 이전 강좌에서 할 일을 새로 추가하는 기능을 구현했습니다. 이번에는 추가된 할 일을 목록 화면에 출력해봅니다. * * * App.js 수정하기 할일 목록을 출력하기 위해서는 Body 컴포넌트에 state.todos를 넘겨줘야한다. 아래와 같이 App 컴포넌트의 render() 함수를 수정한다. Body.js 수정하기 Body 클래스의 render() 함수를 수정한다. 123456render() ｛ return ( &lt;View style=｛styles.container｝&gt; ｛ this.props.todos.map(data =&gt; ( &lt;View style=｛styles.todo｝ key=｛data.id｝&gt; 부모 컴포넌트로부터 전달받은 props.todos를 map 한다. 그리고 View 컴포넌트의 key 속성에 data.id 를 입력한다. 컴포넌트를 iterator 할때에는 반드시 key 속성을 입력해야한다. 여기까지 구현한 앱의 동작 화면은 아래와 같다. * * * 앱이 잘 동작되는 화면을 보고나니 뿌듯합니다. 가끔 기획과 디자인, 그리고 코딩까지 다 잘하는 개발자를 꿈꿔봅니다.ㅋ Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"TO-DO 앱 만들기","slug":"개발-이야기/react-native/to-do-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/to-do-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"제주의 겨울 바다","slug":"/tripsteem/@steemory/tt20181210t035238498z","date":"2018-12-10T03:52:42.000Z","updated":"2019-11-11T13:41:49.847Z","comments":true,"path":"/tripsteem/@steemory/tt20181210t035238498z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@steemory/tt20181210t035238498z/","excerpt":"제주의 겨울 바다 멀리 보이는 성산일출봉 성산항 가기전 식산봉 근처에서 유난히도 추웠던 월정리 해변. 멀리 보이는 풍력 발전기. 제주의 바닷 바람은 너무 쎄다. 월정리 해변에서 방문했던 어느 카페 이곳에 앉아 우리는 제주의 겨울 바다를 바라보았다. 여행지 정보● 제주시 구좌읍 월정리해변제주의 겨울 바다","text":"제주의 겨울 바다 멀리 보이는 성산일출봉 성산항 가기전 식산봉 근처에서 유난히도 추웠던 월정리 해변. 멀리 보이는 풍력 발전기. 제주의 바닷 바람은 너무 쎄다. 월정리 해변에서 방문했던 어느 카페 이곳에 앉아 우리는 제주의 겨울 바다를 바라보았다. 여행지 정보● 제주시 구좌읍 월정리해변제주의 겨울 바다 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"제주도","slug":"제주도","permalink":"https://anpigon.github.io/tags/제주도/"},{"name":"국내여행","slug":"국내여행","permalink":"https://anpigon.github.io/tags/국내여행/"}],"author":"steemory"},{"title":"[제주 함덕] 바다 뷰가 예쁜 카페 - 델문도","slug":"/tasteem/@steemory/tasteem-8a24a4","date":"2018-12-09T13:38:54.000Z","updated":"2019-11-11T13:41:49.843Z","comments":true,"path":"/tasteem/@steemory/tasteem-8a24a4/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-8a24a4/","excerpt":"제주도 함덕 바다가 보이는 예쁜 카페에요. 감상하세요~!요기는 빵 종류가 정말 많아요. 빵이 너무 많아서 사진을 다 찍지는 못했어요. 다 먹어보고 싶었지만 이 중에서 맛있는 거 몇개만 먹었어요.요건 소시지 페스츄리 치즈위에 드라이 토마토가 곁들어진 소시지 페스츄리에요","text":"제주도 함덕 바다가 보이는 예쁜 카페에요. 감상하세요~!요기는 빵 종류가 정말 많아요. 빵이 너무 많아서 사진을 다 찍지는 못했어요. 다 먹어보고 싶었지만 이 중에서 맛있는 거 몇개만 먹었어요.요건 소시지 페스츄리 치즈위에 드라이 토마토가 곁들어진 소시지 페스츄리에요 요건 마농 제주 마늘이 들어간 마늘빵이에요. 요건 아몬드 크로와상 산딸기잼을 바르고 아몬드 크림을 발라서 구운 크로와상이에요. 고소하고 달콤해요. 요건 제주 돌-딸기 딸기 크림이 들어간 크림빵이에요 요건 에멘탈 치즈 쫄깃한 식감의 에멘탈 치츠빵에요 바다를 보면서 커피 한 잔 하세요. 따뜻한 레몬티와 아메리카노에요. 팥앙금과 우유크림이 들어간 먹물단팥빵이에요. 너무 맛집정보 델문도 대한민국 제주특별자치도 제주시 조천읍 조함해안로 519-10 [[제주 함덕] 바다 뷰가 예쁜 카페 - 델문도](https://kr.tasteem.io/post/23678) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/258)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native] TO-DO 앱 만들기 #2","slug":"/kr/@anpigon/react-native-todo-2-1544357245729","date":"2018-12-09T12:07:27.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/kr/@anpigon/react-native-todo-2-1544357245729/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-todo-2-1544357245729/","excerpt":"이전 강좌에서 이어지는 내용입니다. 이번에는 To-Do앱에서 할 일을 등록하는 기능을 구현합니다.* * * App.js 수정하기App 컴포넌트 클래스에 state를 추가한다.123456export default class App extends React.Component ｛ // state 추가함. state = ｛ todos: [] ｝","text":"이전 강좌에서 이어지는 내용입니다. 이번에는 To-Do앱에서 할 일을 등록하는 기능을 구현합니다.* * * App.js 수정하기App 컴포넌트 클래스에 state를 추가한다.123456export default class App extends React.Component ｛ // state 추가함. state = ｛ todos: [] ｝ state.todos는 할 일(todo)을 저장한다. 그리고 addTodo() 함수를 구현한다. 123456789101112131415161718192021// 할일 추가 함수addTodo = (todo) =&gt; ｛ // 새로운 할일(todo) 객체 생성 const newTodo = ｛ id: Date.now(), // 등록시간 text: todo, // 할일 내용 completed: false, // 완료 여부 ｝ // state 업데이트 this.setState(prevState =&gt; (｛ todos: [ newTodo, // 새로 추가된 할일(todo) ...prevState.todos // 기존의 할일 목록 ] ｝)); // 콘솔창에 출력해보자~ console.log(this.state.todos);｝ addTodo() 함수의 기능은 state.todos 배열에 새로운 할일(todo) 을 추가하는 것이다. 리액트 네이티브에서는 state값을 변경하기 위해서 반드시 this.setState() 함수를 사용해야 한다. setState() 함수에 대한 자세한 내용은 다음 문서를 참고한다. https://facebook.github.io/react-native/docs/state 그리고 구현한 addTodo() 함수를 Header 컴포넌트에 전달한다. 1&lt;Header addTodo=｛this.addTodo｝/&gt; 여기까지 작업한 App.js 파일의 코드 내용은 아래와 같다. Header.js 수정하기 Header 컴포넌트 클래스에도 state를 추가한다. 12345class Header extends Component ｛ state = ｛ newTodo: '', ｝ state.newTodo 값은 &lt;TextInput&gt; 의 value 에 사용된다. 그리고 addNewTodo() 함수를 구현한다. 12345678addNewTodo = () =&gt; ｛ if(this.state.newTodo) ｛ this.props.addTodo(this.state.newTodo); this.setState(｛ newTodo: '' ｝); ｝｝ addNewTodo() 함수에서는 부모 컴포넌트(App)에서 전달 받은 this.props.addTodo() 함수를 호출한다. 그리고 state.newTodo 값을 초기화한다. Header 컴포넌트의 render() 함수를 수정한다. &lt;TextInput&gt; 에 value와 onChangeText 속성을 추가한다. 1234567&lt;TextInput style=｛styles.inputText｝ placeholder='Enter new todo' autoCorrect=｛ false ｝ value=｛this.state.newTodo｝ onChangeText=｛(newTodo) =&gt; this.setState(｛newTodo｝)｝/&gt; value에는 state.newTodo값을 보여주도록 했다. 그리고onChangeText 이벤트가 발생하면 입력한 값이 state.newTodo에 업데이트된다. react의 렌더링 방식때문에 이렇게 복잡하게 구현해야한다. 마지막으로 + 버튼에 터치하면 새로운 할일을 추가하기 위해서 addNewTodo() 함수를 호출하도록 해보자. TouchableOpacity 컴포넌트의 onPressOut 이벤트를 사용한다. 123&lt;TouchableOpacity onPressOut=｛this.addNewTodo｝&gt; &lt;MaterialCommunityIcons style=｛styles.addBtn｝ size=｛30｝ name='plus-circle' /&gt;&lt;/TouchableOpacity&gt; 여기까지 작업한 Header.js 파일의 코드 내용은 아래와 같다. 이제 앱을 실행하고 할 일을 추가해본다. 그리고 크롬 브라우저 콘솔창에서 데이터를 확인해보자. 크롬 브라우저 콘솔창에 나타나지 않는다면, 앱에서 메뉴를 열어 콘솔 디버깅 모드를 활성화 해야한다. 스마트폰을 좌우로 흔들면 메뉴가 나타난다. 시뮬레이터라면 단축키 Ctrl + D or Cmd + D 이다. Start Remote JS Debugging 메뉴를 선택한다. 그럼 크롬 브라우저가 자동으로 실행된다. 다음 강좌에서 추가된 할 일을 목록에 표시하는 기능을 구현 할 것이다. * * * 간단한 앱도 기능 구현이 들어가니 복잡해졌습니다. 구현 과정을 텍스트로 쉽게 설명하기가 쉽지 않습니다. 여러분은 사용하고 있는 할 일 관리앱이 있나요? 저는 Google Tasks와 Trello를 병행해서 사용하고 있습니다. 하지만 두 앱 모두 기능이 많이 부족하다고 생각합니다. 구글은 원래 계속 사용하던 앱이라서 그냥 계속 사용하고 있네요.ㅋ Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"TO-DO 앱 만들기","slug":"개발-이야기/react-native/to-do-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/to-do-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[제주 세화] 전복 맛집 - 별방촌","slug":"/tasteem/@steemory/tasteem-a64ba9","date":"2018-12-08T04:17:09.000Z","updated":"2019-11-11T13:41:49.843Z","comments":true,"path":"/tasteem/@steemory/tasteem-a64ba9/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-a64ba9/","excerpt":"별방촌은 제주 옥빛바다앞에 위치하고 있어요. 별방촌 해녀주인님의 요리맛을 꼭 봐야한다고 해서 다녀왔습니다. 입구는 요렇게 생겼어요. 일반적인 횟집 처럼 생겼요. 요건 메뉴입니다. 저는 옥돔구이와 전복뚝배기를 주문했어요. 한치 물회가 맛있다고 하는데, 날씨가 춥고 물회를 좋아하지 않아서 먹지 않았어요.ㅎㅎ","text":"별방촌은 제주 옥빛바다앞에 위치하고 있어요. 별방촌 해녀주인님의 요리맛을 꼭 봐야한다고 해서 다녀왔습니다. 입구는 요렇게 생겼어요. 일반적인 횟집 처럼 생겼요. 요건 메뉴입니다. 저는 옥돔구이와 전복뚝배기를 주문했어요. 한치 물회가 맛있다고 하는데, 날씨가 춥고 물회를 좋아하지 않아서 먹지 않았어요.ㅎㅎ 반찬들이랑 메인 메뉴가 나왔어요. 음식에서 나오는 따뜻한 김이 서려 사진이 뿌옇게 나왔어요. 요건 전복뚝배기~! 해산물이 푸짐하게 들어있어서 너무 맛있었어요. 따뜻한 국물에 몸이 사르르 녹았네요.ㅋ 요건 옥돔구이~! 옥돔구이가 짭짜롬하니 맛있었어요. 밥도둑이에요. 요건 반찬들~! 깍뚜기, 깻잎, 김치, 오뎅… 반찬도 너무 맛있어요~! 여기는 전복뚝배기가 짱짱 맛있습니다.ㅎㅎ 별방촌은 수요미식회 방송에는 나오지 않았지만, 스티모리 스팀잇에 등재되었습니다~! 축하합니다~!!! 맛집정보 별방촌 대한민국 제주특별자치도 제주시 구좌읍 해맞이해안로 1480 [[제주 세화] 전복 맛집 - 별방촌](https://kr.tasteem.io/post/23600) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/258)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[제주 함덕] 카레 맛집 - 모닥식탁","slug":"/tasteem/@steemory/tasteem-fca4b0","date":"2018-12-07T06:05:48.000Z","updated":"2019-11-11T13:41:49.843Z","comments":true,"path":"/tasteem/@steemory/tasteem-fca4b0/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-fca4b0/","excerpt":"제주도 함덕에 유명한 맛집이에요. 사람이 많을 것 같아서 오픈전에 가서 20분 정도 기다렸어요. 오픈 전이라서 밖에 서성이고 있으니, 사장님이 나와서 주문을 미리 받아갔어요. 그런데 추워서 안에서 기다리고 싶었는데 순서를 지켜야한데요. 먼저 예약한 사람이 들어가야 다음 사람이 들어갈 수 있어요.","text":"제주도 함덕에 유명한 맛집이에요. 사람이 많을 것 같아서 오픈전에 가서 20분 정도 기다렸어요. 오픈 전이라서 밖에 서성이고 있으니, 사장님이 나와서 주문을 미리 받아갔어요. 그런데 추워서 안에서 기다리고 싶었는데 순서를 지켜야한데요. 먼저 예약한 사람이 들어가야 다음 사람이 들어갈 수 있어요. 내부 분위기는 아담하고 차분했어요 ![](https://static.tasteem.io/uploads/image/image/114486/5fa0a3a4-b59a-4ae0-885c-14e76f2b9884.jpeg) > 분위기가 너무 좋아요. 메뉴판~! ![](https://static.tasteem.io/uploads/image/image/114487/5fa0a3a4-b59a-4ae0-885c-14e76f2b9884.jpeg) > 커리는 2 종류가 있어요. 딱새우와 돌문어~! 새우 좋아하면 새우 커리, 문어 좋아하면 문어 커리~! ㅎㅎ 저는 둘 다 좋아해서 둘다 주문했어요. 이건 딱새우 토마토 커리 딱새우는 껍질이 정말 딱딱해요. 껍질이 딱딱해서 속살이 더 부드럽고 맛있었어요. 이건 돌문어 커리 돌문어의 쫄깃한 식감과 톡톡 터지는 알알이가 맛있었어요. 이건 사이드로 나오는 샐러드 저는 신선한 채소를 좋아해요. 채소의 아삭아삭한 느낌이 좋아요 그리고 감귤 바질 아이스크림도 먹어보고 싶었는데, 준비가 안되어있다고 해서 먹어보질 못했어요 ㅠ &lt; 커리가 먹고싶을때는 모닥식탁 추천합니다. 맛집정보 모닥식탁 대한민국 제주특별자치도 제주시 조천읍 함덕16길 14-1 [[제주 함덕] 카레 맛집 - 모닥식탁](https://kr.tasteem.io/post/23556) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/258)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[제주세화] 흑돼지 맛집 - 세화그때그집","slug":"/tasteem/@steemory/tasteem-3d86ff","date":"2018-12-06T13:44:51.000Z","updated":"2019-11-11T13:41:49.843Z","comments":true,"path":"/tasteem/@steemory/tasteem-3d86ff/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-3d86ff/","excerpt":"제주도 흑돼지고기 맛집 세화그때그집에 다녀왔어요. 흑돼지고기라서 더 맛있어요. 버섯, 양파, 소시지, 딱새우, 흑돼지고기에요. 그리고 고기 찍어먹을 소스인데, 제 입맛은 아니었어요. 이게 흑돼지로 만든 고기구나. 고기에서 흑돼지맛이 납니다. 전 아이스크림 중에서 돼지바를 제일 좋아합니다. 돼지바 겉에 박힌 초코과자 부스러기와 속에 들어있는 딸기시럽은 정말 환상의 조합이에요.","text":"제주도 흑돼지고기 맛집 세화그때그집에 다녀왔어요. 흑돼지고기라서 더 맛있어요. 버섯, 양파, 소시지, 딱새우, 흑돼지고기에요. 그리고 고기 찍어먹을 소스인데, 제 입맛은 아니었어요. 이게 흑돼지로 만든 고기구나. 고기에서 흑돼지맛이 납니다. 전 아이스크림 중에서 돼지바를 제일 좋아합니다. 돼지바 겉에 박힌 초코과자 부스러기와 속에 들어있는 딸기시럽은 정말 환상의 조합이에요. 가만히 앉아있으면 친절한 직원이 고기를 구어서 이쁘게 잘라줍니다. 다 굽고나면 감사하는 마음으로 고기를 맛있게 먹습니다. 참고로 흑돼지고기 세트를 주문하면 김치찌개와 계란찜이 같이 나옵니다. 계란찜은 너무 맛있어서 사진 찍는 걸 깜빡했어요.ㅜㅜ 김치찌개가 얼큰한게 밥 비벼 먹으니 너무 맛있었어요. 김치찌개에도 흑돼지고기가 듬뿍 들어있어요~ 계산하고 나올때 사장님이 식혜 한병을 챙겨주셨어요. 꽁꽁 얼어있어요~ 집에 가지고 와서 오픈했습니다. 한 잔 마셔봤어요. 살얼음이 얼어있는데 너무 맛있습니다. 흑돼지고기 식혜 너무 맛있습니다. 짱짱짱~👍👍 맛집정보 세화그때그집 대한민국 제주특별자치도 제주시 구좌읍 평대리 3349-2 [[제주세화] 흑돼지 맛집 - 세화그때그집](https://kr.tasteem.io/post/23520) 이 글은 Tasteem 컨테스트 [힘들 때 우는 건 삼류, 힘들 때 먹는 건 육류 ](https://kr.tasteem.io/event/257)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[양재시민의숲] 찜&샤브샤브 - 도토리 편백집","slug":"/tasteem/@steemory/tasteem-7ca02f","date":"2018-12-05T00:22:33.000Z","updated":"2019-11-11T13:41:49.843Z","comments":true,"path":"/tasteem/@steemory/tasteem-7ca02f/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-7ca02f/","excerpt":"메뉴판 이에요. 저는 흑돼지편백찜 2인 세트를 주문했어요. 그리고 묵무침을 떡볶이로 변경했어요.ㅎㅎ 맛있는 녀석들 방송에 나온 식당인가봐요. 이 상태로 10분을 기다려야 해요.ㅠ 10분을 기다리기 힘들면 시계에서 시간을 앞으로 돌려놓으면 되요.ㅎㅎ 저는 메뉴얼대로 기본 소스를 만들었어요. 더 맛있게 드시고 싶은 분들은 맘대로 만들어도 되요.","text":"메뉴판 이에요. 저는 흑돼지편백찜 2인 세트를 주문했어요. 그리고 묵무침을 떡볶이로 변경했어요.ㅎㅎ 맛있는 녀석들 방송에 나온 식당인가봐요. 이 상태로 10분을 기다려야 해요.ㅠ 10분을 기다리기 힘들면 시계에서 시간을 앞으로 돌려놓으면 되요.ㅎㅎ 저는 메뉴얼대로 기본 소스를 만들었어요. 더 맛있게 드시고 싶은 분들은 맘대로 만들어도 되요. **맛있게 먹는 방법!** 입니다. ![](https://static.tasteem.io/uploads/image/image/113816/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) 요리가 나무 상자에 담겨서 나왔어요~! 직원이 위에 시계를 10분으로 맞춰놓고 갔어요 ![](https://static.tasteem.io/uploads/image/image/113817/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) 기다리는 시간동안 폰즈소스를 만들어보았어요. ![](https://static.tasteem.io/uploads/image/image/113823/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) 기본적으로 한국인이 좋아하는 4가지 반찬이 제공되요. ![](https://static.tasteem.io/uploads/image/image/113821/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) 저는 백김치가 맛있었어요. 떡볶이에요. 이 집이 떡볶이 하나는 기가막히게 잘만드네요. 너무 맛있었어요. 이제 10분을 기다리면, 직원이 와서 뚜껑을 열어줍니다. 한번 열어보겠습니다. ![](https://static.tasteem.io/uploads/image/image/113827/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) 뚜껑을 열면 김이 모락모락 나요. ![](https://static.tasteem.io/uploads/image/image/113828/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) 이제 맛있게 드시면 됩니다. ![](https://static.tasteem.io/uploads/image/image/113831/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) 고기와 숙주나물을 폰즈소스에 듬뿍찍어서 밥에 올려서 먹으면 정말 맛있습니다. 저는 한 입 먹고 우주의 신비를 보고 왔어요.ㅋ 저는 이 식당을 적극추천합니다. 맛집정보 도토리 편백집 대한민국 서울특별시 서초구 양재동 351-4 [[양재시민의숲] 찜&샤브샤브 - 도토리 편백집](https://kr.tasteem.io/post/23434) 이 글은 Tasteem 컨테스트 [추억이 새록새록, 당신만의 식당 ](https://kr.tasteem.io/event/247)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native] TO-DO 앱 만들기 #1","slug":"/kr/@anpigon/react-native-todo-1-1543931900794","date":"2018-12-04T13:58:24.000Z","updated":"2019-11-11T13:41:49.817Z","comments":true,"path":"/kr/@anpigon/react-native-todo-1-1543931900794/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-todo-1-1543931900794/","excerpt":"이번 강좌에서는 리액트 네이티브(React Native)로 단순한 **할 일 관리앱(To-Do App)**을 만들어 봅니다.* * * expo-cli 설치이전에는 create-react-native-app 도구를 사용해서 리액트 네이티브 프로젝트를 생성했다. 하지만, 지금은 expo-cli를 사용하여 프로젝트를 생성한다. 아래와 같이 expo-cli를 설치하자.","text":"이번 강좌에서는 리액트 네이티브(React Native)로 단순한 **할 일 관리앱(To-Do App)**을 만들어 봅니다.* * * expo-cli 설치이전에는 create-react-native-app 도구를 사용해서 리액트 네이티브 프로젝트를 생성했다. 하지만, 지금은 expo-cli를 사용하여 프로젝트를 생성한다. 아래와 같이 expo-cli를 설치하자. 1$ npm install -g expo-cli Node v6 이상 버전이 설치되어 있어야 한다. 프로젝트 생성 expo init 를 사용하여 프로젝트를 생성한다. 123$ expo init todo-app$ cd todo-app/$ npm start npm start 명령은 Expo CLI 서버를 시작한다. 그리고 Expo 모바일 앱을 사용하면 개발 중인 앱을 스마트폰에서 테스트해 볼 수 있다. 앱 설계하기 오래전에 사용했던 무료 mock-up 서비스가 있었는데, 오랜만에 찾아보니 없어졌다. 그래서 앱인벤터를 이용하여 간단하게 화면 설계를 하였다. 기능은 매우 간단하다. 텍스트 박스에 할 일을 입력하고 저장 버튼을 누르면 할 일 목록에 추가된다. 체크 박스를 누르면 **할 일이 체크(완료)**된다. 삭제 버튼을 클릭하면 할 일 목록에서 삭제된다. 화면은 한 개다. 그리고 화면에 3개의 컴포넌트가 있다. App 컴포넌트, Header 컴포넌트, Body 컴포넌트이다. 리액트는 보통 컴포넌트 단위로 각각 개발하여 조립하는 식으로 구현한다. 이렇게 하면 컴포넌트를 재활용하여 다른 화면을 구현하는데 사용할 수 있다. 컴포넌트 구현하기 이제 컴포넌트를 하나씩 구현해보자. 우선은 UI 만 구현한다. 기능은 다음 강좌에서 구현할 것이다. 그리고 소스 코드에 대한 자세한 설명은 생략한다. 기능을 구현할때는 소스 코드를 자세하게 설명할 것이다. 1234todo-app ├─ App.js ├─ Header.js └─ Body.js Header 컴포넌트 Header.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, View, TextInput, TouchableOpacity ｝ from 'react-native'import ｛ MaterialCommunityIcons ｝ from '@expo/vector-icons';class Header extends Component ｛ render() ｛ return ( &lt;View style=｛styles.container｝&gt; &lt;View style=｛styles.input｝&gt; &lt;TextInput style=｛styles.inputText｝ placeholder='Enter new todo' autoCorrect=｛ false ｝ /&gt; &lt;TouchableOpacity&gt; &lt;MaterialCommunityIcons style=｛styles.addBtn｝ size=｛30｝ name='plus-circle' /&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; ) ｝｝const styles = StyleSheet.create(｛ container: ｛ marginLeft: 20, marginRight: 20, ｝, input: ｛ borderRadius: 10, backgroundColor: \"#FFF\", paddingLeft: 10, paddingRight: 10, height: 50, alignItems: \"center\", flexDirection: 'row', justifyContent: 'space-between', borderBottomColor: \"#bbb\", borderBottomWidth: StyleSheet.hairlineWidth, ｝, inputText: ｛ flex: 1, ｝, addBtn: ｛ color: '#4169E1' ｝｝);export default Header; TouchableOpacity 컴포넌트는 터치하면 투명도가 증가한다. 그래서 버튼 대신 많이 사용된다. Body 컴포넌트 Body.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React, ｛ Component ｝ from 'react';import ｛ MaterialCommunityIcons ｝ from '@expo/vector-icons';import ｛ StyleSheet, Text, View, TouchableOpacity ｝ from 'react-native';class Body extends Component ｛ state = [ ｛ text: '할일1', completed: false, ｝, ｛ text: '할일2', completed: true, ｝, ｛ text: '할일3', completed: false, ｝, ] render() ｛ return ( &lt;View style=｛styles.container｝&gt; ｛ this.state.map(data =&gt; ( &lt;View style=｛styles.todo｝&gt; &lt;View style=｛styles.todoText｝&gt; &lt;TouchableOpacity style=｛styles.todoCheckbox｝&gt; ｛ data.completed ? &lt;MaterialCommunityIcons size=｛20｝ name='checkbox-marked-circle-outline' /&gt; : &lt;MaterialCommunityIcons size=｛20｝ name='checkbox-blank-circle-outline' /&gt; ｝ &lt;/TouchableOpacity&gt; &lt;Text&gt;｛data.text｝&lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity&gt; &lt;MaterialCommunityIcons style=｛styles.todoDelBtn｝ size=｛30｝ name='delete-outline' /&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; )) ｝ &lt;/View&gt; ) ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, marginVertical: 5, marginHorizontal: 20, padding: 10, backgroundColor: \"#FFF\", borderRadius: 10, ｝, todo: ｛ flexDirection: 'row', alignItems: \"center\", justifyContent: 'space-between', height: 50, borderBottomColor: \"#bbb\", borderBottomWidth: StyleSheet.hairlineWidth, ｝, todoCheckbox: ｛ marginRight: 5, ｝, todoText: ｛ flexDirection: 'row', ｝, todoDelBtn: ｛ color: '#777' ｝｝);export default Body; data.completed 값(True/False)에 따라 할 일 목록의 체크박스 아이콘이 바뀐다. App 컴포넌트 App.js 12345678910111213141516171819202122232425262728293031import React from 'react';import ｛ StyleSheet, View, Text ｝ from 'react-native';import Header from './Header'import Body from './Body'export default class App extends React.Component ｛ render() ｛ return ( &lt;View style=｛styles.container｝&gt; &lt;Text style=｛styles.title｝&gt;Todo App&lt;/Text&gt; &lt;Header /&gt; &lt;Body /&gt; &lt;/View&gt; ); ｝｝const styles = StyleSheet.create(｛ container: ｛ flex: 1, flexDirection: 'column', paddingTop: 50, backgroundColor: \"#EEE\", ｝, title: ｛ fontWeight: \"800\", fontSize: 30, marginLeft: 20, marginBottom: 20, ｝｝); App 컴포넌트에서는 Header 컴포넌트와 Body 컴포넌트를 보여준다. 이제 앱을 실행 해보자. 앱이 실행되면, 아래와 같은 화면이 나타나야 한다. 다음 강좌에서 할 일을 텍스트박스에 입력하고, 목록에 추가하는 기능을 구현할 것이다. * * * 처음에 낯설고 어려웠던 리액트가 이제는 조금씩 익숙해지고 있습니다. 플러터로 모바일앱을 개발할때와 비교하면, 오류나 문제가 발생했을 때 플러터보다는 빨리 해결 할 수 있었습니다. 리액트 네이티브는 오류 내용을 구글 검색하면 해결 방법을 쉽게 찾을 수 있습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"TO-DO 앱 만들기","slug":"개발-이야기/react-native/to-do-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/to-do-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[신림]  쌀국수 맛집 - 포첸하우스","slug":"/tasteem/@steemory/tasteem-056059","date":"2018-12-03T00:31:15.000Z","updated":"2019-11-11T13:41:49.842Z","comments":true,"path":"/tasteem/@steemory/tasteem-056059/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-056059/","excerpt":"말이 필요없네요.너무 맛있습니다. 맛집정보 포첸하우스대한민국 서울특별시 관악구 조원동 난곡로 351[[신림] 쌀국수 맛집 - 포첸하우스](https://kr.tasteem.io/post/23310) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/248)에 참가한 글입니다. 테이스팀은 무엇인가요?","text":"말이 필요없네요.너무 맛있습니다. 맛집정보 포첸하우스대한민국 서울특별시 관악구 조원동 난곡로 351[[신림] 쌀국수 맛집 - 포첸하우스](https://kr.tasteem.io/post/23310) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/248)에 참가한 글입니다. 테이스팀은 무엇인가요? 여기 내부 분위기~! ![](https://static.tasteem.io/uploads/image/image/113022/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) > 여기는 전부 베트남 출신 직원들이에요. 하지만 베트남어을 몰라도 괜찮아요. 주문은 기계에서 하면되요. 하노이 느낌~! ![](https://static.tasteem.io/uploads/image/image/113023/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) > 하노이 느낌의 피규어들. 너무 이쁩니다. 하나 가지고 싶네요.ㅋ 이건 닭고기 칼국수~! ![](https://static.tasteem.io/uploads/image/image/113024/b732ac2c-7a9c-47a6-b62b-10234738a91e.jpeg) > 결대로 잘게 찢어진 닭가슴살~! 따뜻한 닭고기 국물한 모금에 얼어있던 몸이 사르르 녹네요. 닭가슴살이 들어가면 다이어트 음식이에요. 요건 월남쌈~! ![](https://static.tasteem.io/uploads/image/image/113025/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) > 월남쌈 적극 추천합니다. 정말 맛있어요. 이건 베트남 볶음밥~! ![](https://static.tasteem.io/uploads/image/image/113026/4ce6ec76-ada1-4125-ac72-84d3d6e11cac.jpeg) > 내가 알던 볶음밥맛.ㅎㅎ","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[서울숲/성수/뚝섬] 떡뽂이 맛집 - 뚝떡","slug":"/tasteem/@steemory/tasteem-2f1178","date":"2018-12-02T02:34:54.000Z","updated":"2019-11-11T13:41:49.842Z","comments":true,"path":"/tasteem/@steemory/tasteem-2f1178/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-2f1178/","excerpt":"서울숲 근처에 있는 분식집이에요. 맛집으로 소문이 나서 웨이팅은 기본입니다. 하지만 저는 사람이 없을때 가서 바로 들어갔어요..피규어로 내부 인테리어를 아기자기 하게 꾸며 놓았어요. 도라에몽 퉁퉁이 피규어가 있어요~! 찾아보세요. .메뉴판입니다. 메뉴가 다양합니당.","text":"서울숲 근처에 있는 분식집이에요. 맛집으로 소문이 나서 웨이팅은 기본입니다. 하지만 저는 사람이 없을때 가서 바로 들어갔어요..피규어로 내부 인테리어를 아기자기 하게 꾸며 놓았어요. 도라에몽 퉁퉁이 피규어가 있어요~! 찾아보세요. .메뉴판입니다. 메뉴가 다양합니당. . 닭무 닭무를 먹으니 통닭치킨이 생각납니다. . 떡볶이 저는 그냥 떡볶이 맛이었어요. . 양념만두튀김 양념치킨 맛이에요. 달콤매콤해서 맛있었어요. . 어묵우동 추운날에는 역시 따뜻한 어묵국물이 필요해요. 맛집정보 뚝떡 대한민국 서울특별시 성동구 성수동1가 서울숲4길 28 [[서울숲/성수/뚝섬] 떡뽂이 맛집 - 뚝떡](https://kr.tasteem.io/post/23258) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/248)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[압구정] 탕수육 짜장면이 맛있는 식당 - 호화반점","slug":"/tasteem/@steemory/tasteem-b7dfb6","date":"2018-11-30T03:48:24.000Z","updated":"2019-11-11T13:41:49.842Z","comments":true,"path":"/tasteem/@steemory/tasteem-b7dfb6/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-b7dfb6/","excerpt":"탕수육이 먹고 싶을때는 호화반점!압구정로데오역 6번 출구로 나와서 조금만 걸으면 있어요. 들어가면 식당내 모든 직원들이 인사하며 반겨줍니다.메뉴는 이렇게 있어요. 찹쌀탕수육은 먹어보진 않았지만, 특이하게 복분자 소스를 사용하네요. 기본 안주로 나오는 단무지와 양파 3조각이에요. 노란 단무지는 역시 짜장면이랑 같이 먹어야 맛있어요~","text":"탕수육이 먹고 싶을때는 호화반점!압구정로데오역 6번 출구로 나와서 조금만 걸으면 있어요. 들어가면 식당내 모든 직원들이 인사하며 반겨줍니다.메뉴는 이렇게 있어요. 찹쌀탕수육은 먹어보진 않았지만, 특이하게 복분자 소스를 사용하네요. 기본 안주로 나오는 단무지와 양파 3조각이에요. 노란 단무지는 역시 짜장면이랑 같이 먹어야 맛있어요~ 이건 누구나 좋아하는 짜장면이에요. 짜장면은 시계 반시계 방향으로 한바퀴 돌린 다음, 9시 방향으로, 그리고 다시 6시방향으로 돌려서 비비면 정말 맛있습니다. 이건 탕수육입니다. 눅눅해기지 전에 빨리 탕수육들을 건져내야해요~ 탕수육은 바삭할때가 제일 맛있는데… 여긴 찍먹/부먹 선택권이 없어요.ㅠㅠ 그리고 계산할때 아주머니가 짜장/탕수육 값으로 2억4천만원이 나왔다고 해요… 절대 속지 마세요. 전 속을뻔.ㅎㅎ 마지막으로 제 별점은 ⭐⭐⭐⭐⭐ 5점 입니다. 맛집정보 호화반점 대한민국 서울특별시 강남구 압구정동 압구정로54길 4 [[압구정] 탕수육 짜장면이 맛있는 식당 - 호화반점](https://kr.tasteem.io/post/23162) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/248)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[압구정] 백숙,삼계탕 - 영양센터","slug":"/tasteem/@steemory/tasteem-fd5f18","date":"2018-11-28T00:52:27.000Z","updated":"2019-11-11T13:41:49.842Z","comments":true,"path":"/tasteem/@steemory/tasteem-fd5f18/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-fd5f18/","excerpt":"추운 겨울날~!감기때문에 고생하지 않습니까? 그리고 또한 몸이 시리거나 오한이 떨리지 않으십니까?이때 필요한 것은 닭고기! 즉, 삼계탕입니다. 제가 치킨을 좋아하는데요. 압구정로데오역 근처에 삼계탕 맛집이 있다고 해서 한번 찾아가봤습니다.여기는 1960년에 영양센타 명동본점이 오픈한 뒤로, 55년 전통을 유지해온 명문 식당입니다. 식당 이름부터 영양 듬뿍~! 영양 센터입니다.","text":"추운 겨울날~!감기때문에 고생하지 않습니까? 그리고 또한 몸이 시리거나 오한이 떨리지 않으십니까?이때 필요한 것은 닭고기! 즉, 삼계탕입니다. 제가 치킨을 좋아하는데요. 압구정로데오역 근처에 삼계탕 맛집이 있다고 해서 한번 찾아가봤습니다.여기는 1960년에 영양센타 명동본점이 오픈한 뒤로, 55년 전통을 유지해온 명문 식당입니다. 식당 이름부터 영양 듬뿍~! 영양 센터입니다. 제가 메뉴를 찍어 왔습니다. 잘 안보이면 돋보기로 보면 됩니다. 사진 화질이 꽤 좋아서 현미경으로 봐도 잘보입니다. 이건 손을 닦을때 사용하는 물티슈입니다. 저는 서울에 살아서 잘 알지만, 처음 오신 분들은 이게 먼지 잘 모르실 것 같아서 알려드려요. 이건 소금입니다. 국물이 싱거우면 소금을 살살 뿌리면서 간을 조절하세요. 그리고 닭고기를 결대로 쭈욱 뜯어서 소금에 찍어 먹으면 정말 맛있습니다. 이건 마늘과 고추장입니다. 마늘을 고추장에 찍어드세요~ 마늘은 몸에 좋아요. 고추장도 몸에 좋아요.ㅎㅎ 이건 깍두기~ 깍두기 열심히 먹으면 아주머니가 착하다고 깍두기 더 줍니다. 이건 들깨 삼계탕~ 들깨의 고소함과 치킨의 부드러운 속살이 만났습니다. 정말 맛있어요~👍 맛집 포스팅 하면서 삼계탕 사진 보니깐 입에서 침이 나오네요. 오늘 또 먹고 싶어졌어요. 제 별점은요~! ⭐⭐⭐⭐⭐ (5.0) 입니다. 맛집정보 압구정 영양센터 대한민국 서울특별시 강남구 압구정동 압구정로 344 [[압구정] 백숙,삼계탕 - 영양센터](https://kr.tasteem.io/post/23028) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/240)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[React Native #5] 리액트 네이티브 날씨앱 만들기 #4","slug":"/kr/@anpigon/react-native-5-4-1543113530194","date":"2018-11-25T02:38:51.000Z","updated":"2019-11-11T13:41:49.819Z","comments":true,"path":"/kr/@anpigon/react-native-5-4-1543113530194/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-5-4-1543113530194/","excerpt":"리액트 네이티브로 날씨앱 만들기 네번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 네번째 강좌입니다. 이번에는 styles를 이용하여 화면을 이쁘게 디자인합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1 [React Native #3] 리액트 네이티브 날씨앱 만들기 #2 [React Native #4] 리액트 네이티브 날씨앱 만들기 #3","text":"리액트 네이티브로 날씨앱 만들기 네번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 네번째 강좌입니다. 이번에는 styles를 이용하여 화면을 이쁘게 디자인합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1 [React Native #3] 리액트 네이티브 날씨앱 만들기 #2 [React Native #4] 리액트 네이티브 날씨앱 만들기 #3 날씨 아이콘 사용하기 expo 모듈에서 제공하는 아이콘을 사용하여 날씨를 표현해보자. 아이콘 종류는 아래 사이트에서 확인 가능하다. https://expo.github.io/vector-icons/ weather라고 검색하면, MaterialCommunityIcons 그룹에 날씨 아이콘이 있는 것을 확인 할 수 있다. Weather.js 파일을 열어 수정한다. 1234567891011import ｛ MaterialCommunityIcons ｝ from \"@expo/vector-icons\";const Weather = (｛ data ｝) =&gt; ｛ return ( &lt;View&gt; &lt;MaterialCommunityIcons size=｛150｝ name='weather-cloudy'/&gt; &lt;Text&gt;｛data.weather[0].main｝&lt;/Text&gt; &lt;Text&gt;｛Math.ceil(data.main.temp - 273.15)｝℃&lt;/Text&gt; &lt;/View&gt; );｝ @expo/vector-icons를 import하고, &lt;MaterialCommunityIcons&gt; 아이콘 크기 150을 사용했다. 여기까지 하고 앱을 확인해보자. 날씨에 해당하는 아이콘 표시하기 아래 openweathermap 사이트에서 날씨 그룹을 확인해 보자. https://openweathermap.org/weather-conditions ID가 2xx 이면 Thunderstorm 이고, 3xx 이면 Drizzle 이다. 그룹 번호에 맞게 아이콘 데이터를 생성한다. Weather.js 에 아래 코드를 입력한다. 1234567891011121314151617181920212223const WeatherGroup = ｛ 0: ｛ icon: 'weather-sunny' ｝, 2: ｛ icon: 'weather-lightning' ｝, 3: ｛ icon: 'weather-rainy' ｝, 5: ｛ icon: 'weather-pouring' ｝, 6: ｛ icon: 'weather-snowy' ｝, 7: ｛ icon: 'weather-fog' ｝, 8: ｛ icon: 'weather-cloudy' ｝｝ 참고로 Clear(sunny) 는 그룹 800이지만, Clouds 와 겹치기 때문에 임의로 0번 그룹으로 지정하였다. 이제 WeatherGroup 데이터에서 그룹 번호에 맞는 정보를 가져오자. 1234567891011const Weather = (｛ data ｝) =&gt; ｛ const id = data.weather[0].id; const weather = id === 800 ? WeatherGroup[0] : WeatherGroup[parseInt(id / 100)]; return ( &lt;View&gt; &lt;MaterialCommunityIcons size=｛150｝ name=｛weather.icon｝/&gt; &lt;Text&gt;｛data.weather[0].main｝&lt;/Text&gt; &lt;Text&gt;｛Math.ceil(data.main.temp - 273.15)｝℃&lt;/Text&gt; &lt;/View&gt; );｝ Clear 와 Clouds 가 같은 그룹 8xx 라서 조건문을 넣었다. 스타일 지정하기 Weather.js 파일 하단에 아래와 같이 작성한다. 1234567891011121314151617181920const styles = StyleSheet.create(｛ top: ｛ flex: 1, alignItems: 'center', justifyContent: 'flex-end' ｝, bottom: ｛ flex: 1, alignItems: 'center', justifyContent: 'flex-start' ｝, main: ｛ fontSize: 50, marginBottom:10, fontWeight: '600' ｝, temp: ｛ fontSize: 30 ｝｝); StyleSheet은 기본적으로 CSS 개념과 비슷하다. flex 속성을 사용하여 상단, 하단을 50:50으로 나눴다. 그리고 각각의 텍스트 크기도 키웠다. flex은 flexbox의 기본 개념을 참고한다. 생성한 styles을 JSX에 적용한다. 123456789101112131415const Weather = (｛ data ｝) =&gt; ｛ const id = data.weather[0].id; const weather = id === 800 ? WeatherGroup[0] : WeatherGroup[parseInt(id / 100)]; return ( &lt;View&gt; &lt;View style=｛styles.top｝&gt; &lt;MaterialCommunityIcons size=｛150｝ name=｛weather.icon｝/&gt; &lt;/View&gt; &lt;View style=｛styles.bottom｝&gt; &lt;Text style=｛styles.main｝&gt;｛data.weather[0].main｝&lt;/Text&gt; &lt;Text style=｛styles.temp｝&gt;｛Math.ceil(data.main.temp - 273.15)｝℃&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; );｝ 여기까지 하고 앱을 확인해보자. 배경색 바꾸기 날씨앱 배경으로 그라데이션을 사용해보자. 좀 더 예쁘게 보일수 있다. 12345678910111213import ｛ StyleSheet, Text, View, Dimensions ｝ from 'react-native';import ｛ LinearGradient ｝ from 'expo';const ｛ width, height ｝ = Dimensions.get('window');const styles = StyleSheet.create(｛ container: ｛ flex: 1, width, height ｝, // ... 이하 생략 ...｝ LinearGradient를 사용하기 위해 expo를 import했다. 그리고 react-native의 Dimensions을 사용하여 window의 width와 height를 가져왔다. 마지막으로 styles에 container를 추가했다. view는 아래와 같이 LinearGradient로 감싼다. 그리고 그라데이션 색상과 스타일을 지정한다. 123456789&lt;LinearGradient colors=｛[&apos;#108dc7&apos;, &apos;#ef8e38&apos;]｝ style=｛styles.container｝&gt; &lt;View style=｛styles.top｝&gt; &lt;MaterialCommunityIcons size=｛150｝ color=&apos;white&apos; name=｛weather.icon｝/&gt; &lt;/View&gt; &lt;View style=｛styles.bottom｝&gt; &lt;Text style=｛styles.main｝&gt;｛data.weather[0].main｝&lt;/Text&gt; &lt;Text style=｛styles.temp｝&gt;｛Math.ceil(data.main.temp - 273.15)｝℃&lt;/Text&gt; &lt;/View&gt;&lt;/LinearGradient&gt; 그라데이션 색상은 아래 사이트에서 찾아볼수 있다. https://uigradients.com/#GradeGrey 여기까지 하고 앱을 확인해보자. 날씨 앱을 완성하였습니다. 여기에 작성하지는 않았지만, 조금 더 수정하여 날씨마다 배경색에 변화를 주었습니다. 그리고 모든 소스는 깃허브에서 확인할 수 있습니다. https://github.com/anpigon/weather_app 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"날씨 앱 만들기","slug":"개발-이야기/react-native/날씨-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/날씨-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native #4] 리액트 네이티브 날씨앱 만들기 #3","slug":"/kr/@anpigon/react-native-4-3-1542990470234","date":"2018-11-23T16:27:51.000Z","updated":"2019-11-11T13:41:49.819Z","comments":true,"path":"/kr/@anpigon/react-native-4-3-1542990470234/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-4-3-1542990470234/","excerpt":"리액트 네이티브로 날씨앱 만들기 세번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 세번째 강좌입니다. 이번에는 날씨 API 데이터를 이용해서 화면을 구현합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1 [React Native #3] 리액트 네이티브 날씨앱 만들기 #2","text":"리액트 네이티브로 날씨앱 만들기 세번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 세번째 강좌입니다. 이번에는 날씨 API 데이터를 이용해서 화면을 구현합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1 [React Native #3] 리액트 네이티브 날씨앱 만들기 #2 날씨 화면 만들기 날씨를 보여줄 Weather.js 컴포넌트를 생성한다. Weather 컴포넌트는 단순히 날씨만 보여주는 용도라서 stateless 컴포넌트로 구현하였다. stateless 컴포넌트는 class가 아닌 const로 구현한다. stateless 컴포넌트에 대한 자세한 내용은 React Stateless Functional Components 블로그를 참고한다. 12345678910111213import React, ｛ Component ｝ from 'react';import ｛ StyleSheet, Text, View, Image ｝ from 'react-native';const Weather = () =&gt; ｛ return ( &lt;View&gt; &lt;Text&gt;Sunny&lt;/Text&gt; &lt;Text&gt;23℃&lt;/Text&gt; &lt;/View&gt; );｝export default Weather; 날씨를 보여주는 컴포넌트를 기존에 App.js 파일에 구현해도 된다. 하지만 컴포넌트 단위로 파일을 따로 생성하는 것을 권장한다. App.js 수정하기 이제 App.js 파일을 열어 수정한다. App 클래스에 state를 추가한다. state는 loading와 weahter 항목을 가지고 있다. loading는 GPS와 날씨API를 조회 중인지를 체크한다. 그리고 weahter에는 날씨 정보를 담을 것이다. 12345678export default class App extends React.Component ｛ state = ｛ loading: true, // 로딩 여부 weather: null, // 날씨 정보 ｝ // ... 이하 생략 ... state에 대한 설명은 리액트 문서 State and Lifecycle를 참조한다. 그리고 App 클래스의 render 함수를 수정한다. 123456789render() ｛ return ( &lt;View style=｛styles.container｝&gt; ｛ this.state.loading ? &lt;Text&gt;Weather&lt;/Text&gt; : &lt;Weather data=｛this.state.weather｝ /&gt; ｝ &lt;/View&gt; );｝ this.state.loading 값에 따라 보여지는 View가 달라진다. loading 값이 True면 Weather 텍스트가 보이고, False면 현재 날씨 정보가 보일 것이다. 이전 시간에 만들었던 _getWeather 함수를 아래와 같이 수정한다. 12345678910111213_getWeather = (｛latitude, longitude｝) =&gt; ｛ fetch(`https://api.openweathermap.org/data/2.5/weather?lat=$｛latitude｝&amp;lon=$｛longitude｝&amp;appid=$｛API_KEY｝`) .then(response =&gt; response.json()) // 응답값을 json으로 변환 .then(json =&gt; ｛ console.log(json); // 추가된 코드 this.setState(｛ weather: json, loading: false ｝) ｝); ｝ this.setState 함수를 사용하여 state 값을 업데이트한다. loading를 False로 업데이트하고, 날씨 API에서 가져온 데이터를 weather에 담아준다. 리액트에서 state 값을 업데이트하기 위해서는 반드시 this.setState 함수를 사용해야 한다. Wehther.js 수정하기 Wehther.js 파일을 아래와 같이 수정한다. 현재 날씨와 기온을 보여준다. 12345678const Weather = (｛ data ｝) =&gt; ｛ return ( &lt;View&gt; &lt;Text&gt;｛data.weather[0].main｝&lt;/Text&gt; &lt;Text&gt;｛data.main.temp｝℃&lt;/Text&gt; &lt;/View&gt; );｝ Wehther 컴포넌트는 ｛ data ｝ 를 전달받아 Text 뷰에 출력한다. 이제 앱을 실행하고 확인한다. 현재 기온이 286.06℃로 표시된다. 이건 openweathermap가 기온을 켈빈 단위로 주기 때문이다. 다음 공식을 적용하여 켈빈을 썹씨(°C)로 변환한다. 켈빈(K)을 썹씨(°C)로 변환 공식 1°C = K - 273.15 현재 기온을 보여주는 부분에 이 공식을 적용하자. &lt;Text&gt;｛weather.main.temp｝℃&lt;/Text&gt; 를 &lt;Text&gt;｛Math.ceil(weather.main.temp - 273.15)｝℃&lt;/Text&gt; 로 수정한다. 그리고 다시 앱을 확인해보자. 현재 날씨는 Rain, 기온은 13℃로 출력되었다. 다음 시간에는 이 화면을 이쁘게 꾸며보겠습니다. 하얀 배경에 검정 텍스트만 보여주니 깔끔하고 좋네요. ㅎㅎ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 기념 액자 도착 Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"날씨 앱 만들기","slug":"개발-이야기/react-native/날씨-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/날씨-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native #3] 리액트 네이티브 날씨앱 만들기 #2","slug":"/kr/@anpigon/react-native-3-2-1542874472110","date":"2018-11-22T08:14:33.000Z","updated":"2019-11-11T13:41:49.819Z","comments":true,"path":"/kr/@anpigon/react-native-3-2-1542874472110/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-3-2-1542874472110/","excerpt":"리액트 네이티브로 날씨앱 만들기 두번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 두번째 강좌입니다. 이번에는 GPS위치정보로 날씨API를 조회합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1","text":"리액트 네이티브로 날씨앱 만들기 두번째 강좌리액트 네이티브를 사용하여 날씨앱을 만드는 두번째 강좌입니다. 이번에는 GPS위치정보로 날씨API를 조회합니다.이전글 [React Native #1] 리액트 네이티브 시작하기 [React Native #2] 리액트 네이티브 날씨앱 만들기 #1 날씨 조회 API 서비스 가입하기 날씨 정보를 조회하기 위해서 openweathermap API 서비스를 이용한다. 사이트에 가입하고 API키를 발급 받는다. https://openweathermap.org API 페이지에서 Current weather data 항목의 subscribe 버튼을 클릭한다. Free 항목의 Get API key and Start 버튼을 클릭한다. Sign up을 눌러 회원가입을 한다. 가입을 완료하면 아래 페이지로 이동된다. API Keys 탭으로 이동한다. Name을 입력하고 Generate 버튼을 클릭하여 Key를 발급받는다. 그리고 App.js 파일을 열어 발급받은 키를 API_KEY 변수에 선언한다. 1const API_KEY = '894c0c1d03546d1843b5efd334d6e479'; 사이트에 가입하지 않고 예제에 있는 키를 그대로 사용해도 된다. 현재 날씨 조회하기 openweathermap API 문서를 읽어보자. https://openweathermap.org/current GPS 좌표로 현재 날씨를 가져오는 API 규격은 다음과 같다. 현재 날씨를 조회하는 URL 형태는 다음과 같다. https://api.openweathermap.org/data/2.5/weather?lat=｛lat｝&amp;lon=｛lon｝&amp;appid=｛API_KEY｝ 현재 날씨를 조회하는 _getWeather 함수를 구현하자. App.js 파일에 아래 코드를 추가한다. 123456789101112export default class App extends React.Component ｛ // ... 생략 ... // 추가된 코드 _getWeather(｛latitude, longitude｝) ｛ fetch(`https://api.openweathermap.org/data/2.5/weather?lat=$｛latitude｝&amp;lon=$｛longitude｝&amp;appid=$｛API_KEY｝`) .then(response =&gt; response.json()) // 응답값을 json으로 변환 .then(json =&gt; ｛ console.log(json) ｝); ｝ fetch는 네트워크 통신을 위한 인터페이스다. XMLHttpRequest보다 강력한 기능을 가지고 있다. 이제 App 클래스의 componentDidMount 함수를 수정한다. navigator.geolocation.getCurrentPosition 함수에서 GPS 정보를 가져오면 _getWeather 함수를 호출하도록 한다. 123456789101112export default class App extends React.Component ｛ componentDidMount() ｛ navigator.geolocation.getCurrentPosition( (position) =&gt; ｛ console.log(position); this._getWeather(position.coords); // 추가된 코드 ｝, (error) =&gt; ｛ console.log(error); ｝ ); ｝ navigator.geolocation.getCurrentPosition 콜백함수를 화살표 함수(()=&gt;｛｝)로 수정하였다. function 함수와 화살표 함수의 this의 참조 대상이 다르기 때문이다. 자세한 내용은 다음에… 이제 앱을 실행하고 콘솔창을 확인하자. 1$ npm start 콘솔창을 확인하면 GPS 정보를 가져오고 바로 날씨 데이터를 가져온것을 확인 할 수 있다. 아래는 날씨 API에서 가져온 전체 날씨 데이터이다. 우리는 여기서 temp 와 weather 데이터만 사용할 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142Object ｛ \"base\": \"stations\", \"clouds\": Object ｛ \"all\": 40, ｝, \"cod\": 200, \"coord\": Object ｛ \"lat\": 37.49, \"lon\": 126.91, ｝, \"dt\": 1542868200, \"id\": 1948005, \"main\": Object ｛ \"humidity\": 35, \"pressure\": 1025, \"temp\": 279.92, \"temp_max\": 280.85, \"temp_min\": 279.15, ｝, \"name\": \"Kwangmyong\", \"sys\": Object ｛ \"country\": \"KR\", \"id\": 7668, \"message\": 0.0083, \"sunrise\": 1542838741, \"sunset\": 1542874653, \"type\": 1, ｝, \"visibility\": 10000, \"weather\": Array [ Object ｛ \"description\": \"haze\", \"icon\": \"50d\", \"id\": 721, \"main\": \"Haze\", ｝, ], \"wind\": Object ｛ \"deg\": 310, \"speed\": 4.1, ｝,｝ 다음 강좌에서 현재 날씨를 보여주는 화면을 구현할 것입니다. 날씨앱은 많이 구현해본 앱 인데 만들때 마다 새롭습니다. 예전에는 SKP에서 제공하는 날씨 API를 자주 사용했는데, 이제는 SKT에서 유료로 서비스하고 있습니다. kweather는 날씨 API 서비스를 중단했네요.ㅠ 기상청은 예전에 공공데이터포털(data.go.kr)에서 API를 제공했었는데, 이젠 검색이 안됩니다. 유주완님의 서울버스앱을 시발점으로 정부3.0 - 공공 데이터 개방의 시대가 열린 적이 있었습니다. 그런데 공공데이터 시절에 공개되었던 데이터들이 지금은 대부분 비공개로 전환되었네요.ㅋ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) ■ Tasteem × Promisteem ／ 이삿날엔 중국집 대신 이자카야 〈男 OTOKO〉 이삿날엔 중국집 대신 이자카야 男 O T O K O 예로부터 이삿 날엔 일손 나눈 크루들(?)…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"날씨 앱 만들기","slug":"개발-이야기/react-native/날씨-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/날씨-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"코에스 아쿠아리움","slug":"/tripsteem/@steemory/tt20181122t032214399z","date":"2018-11-22T03:22:15.000Z","updated":"2019-11-11T13:41:49.847Z","comments":true,"path":"/tripsteem/@steemory/tt20181122t032214399z/","link":"","permalink":"https://anpigon.github.io/tripsteem/@steemory/tt20181122t032214399z/","excerpt":"","text":"요건 입구쪽에 있는 물고기. 안녕~! 인사를 하니 절로 갑니다~ 요건 거대한 물고기. 매우 큽니다. 물고기 크기가 사람 만합니다. 요건 입벌리고 있는 물고기. 귀엽네요.ㅋ 아쿠아리움이었습니다. 끝.여행지 정보코에스 아쿠아리움 이 글은 스팀 기반 여행정보 서비스 trips.teem 으로 작성된 글 입니다.","categories":[{"name":"여행 이야기","slug":"여행-이야기","permalink":"https://anpigon.github.io/categories/여행-이야기/"}],"tags":[{"name":"트립스팀","slug":"트립스팀","permalink":"https://anpigon.github.io/tags/트립스팀/"},{"name":"아쿠아리움","slug":"아쿠아리움","permalink":"https://anpigon.github.io/tags/아쿠아리움/"}],"author":"steemory"},{"title":"가죽 카드 지갑 만들기","slug":"/kr/@steemory/--1542762474293","date":"2018-11-21T01:07:54.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/kr/@steemory/--1542762474293/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1542762474293/","excerpt":"취미로 가죽 공예를 하는 스티모리입니다.스티모리, 가죽모리, 자진모리장단~! 덩 덕쿵덕 쿵 덕쿵덕~! 가죽으로 쉽게 카드 지갑 만드는 방법을 알려드릴께요~!신설동 가죽 시장에서 조각 가죽을 저렴하게 구입할 수 있습니다. 가죽에 흠집이 없는지 잘보고 구입해야합니다. 아마 가방만들고 남은 짜투리 가죽을 싸게 파는것 같아요.","text":"취미로 가죽 공예를 하는 스티모리입니다.스티모리, 가죽모리, 자진모리장단~! 덩 덕쿵덕 쿵 덕쿵덕~! 가죽으로 쉽게 카드 지갑 만드는 방법을 알려드릴께요~!신설동 가죽 시장에서 조각 가죽을 저렴하게 구입할 수 있습니다. 가죽에 흠집이 없는지 잘보고 구입해야합니다. 아마 가방만들고 남은 짜투리 가죽을 싸게 파는것 같아요. 우선 가죽을 패턴 모양대로 재단합니다. 패턴은 인터넷 검색하면 쉽게 구할수 있습니다. https://www.pinterest.co.kr/khee10/％EA％B0％80％EC％A3％BD-％ED％8C％A8％ED％84％B4 그리프로 2m 간격을 유지하면서 바늘 구멍을 내줍니다. 바늘 구멍을 다 뚫었으면, 이제 바느질 시자악~! 요렇게 꼼꼼하게 손바느질 합니다. 드디어 완성~! 뒷면 앞면 몇 개 더 만들었습니다.ㅎㅎ 가죽만들기 끝.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"가죽공예","slug":"가죽공예","permalink":"https://anpigon.github.io/tags/가죽공예/"}],"author":"steemory"},{"title":"[React Native #2] 리액트 네이티브 날씨앱 만들기 #1","slug":"/kr/@anpigon/react-native-2--1542732103861","date":"2018-11-20T16:41:45.000Z","updated":"2019-11-11T13:41:49.819Z","comments":true,"path":"/kr/@anpigon/react-native-2--1542732103861/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-2--1542732103861/","excerpt":"리액트 네이티브로 날씨앱 만들기리액트 네이티브를 사용하여 날씨앱을 만드는 첫번째 강좌입니다. 간단하게 현재 위치(GPS좌표)를 읽어 날씨를 조회하여 보여줄 것입니다. 기능을 하나씩 천천히 구현하면서 진행하겠습니다.이전글 [React Native #1] 리액트 네이티브 시작하기","text":"리액트 네이티브로 날씨앱 만들기리액트 네이티브를 사용하여 날씨앱을 만드는 첫번째 강좌입니다. 간단하게 현재 위치(GPS좌표)를 읽어 날씨를 조회하여 보여줄 것입니다. 기능을 하나씩 천천히 구현하면서 진행하겠습니다.이전글 [React Native #1] 리액트 네이티브 시작하기 리액트 네이티브 프로젝트 생성 1$ create-react-native-app weather_app Choose a template에서 blank를 선택한다. 아래와 같이 weather_app 프로젝트가 생성된다. 현재 위치 GPS 가져오기 navigator.geolocation에서 제공하는 getCurrentPosition 함수를 사용하면 현재 GPS 좌표를 가져올 수 있다. 123navigator.geolocation.getCurrentPosition(function(position) ｛ console.log(position);｝); App.js에서 아래와 같이 componentDidMount() 함수를 구현한다. 123456789101112131415export default class App extends React.Component ｛ // ... 생략 ... componentDidMount() ｛ navigator.geolocation.getCurrentPosition( function(position) ｛ console.log(position); ｝, function(error) ｛ console.log(error); ｝ ); ｝｝ componentDidMount 함수는 리액트 컴포넌트 마운트가 되었을때 실행된다. [React.Component의 lifecycle 문서]를 참고. 앱 실행하기 1$ npm start 또는, 1$ expo start 앱을 실행하면 아래와 같이 브라우저에 http://localhost:19002/ 페이지가 표시된다. 브라우저가 자동 실행되지 않은 경우에는 URL을 직접입력한다. 디바이스에서 Expo앱을 실행하고 QR코드를 촬영한다. 그리고 앱에서 위치정보 액세스 권한을 물어보는 경우 확인을 누른다. 그러면 콘솔창에 현재 GSP좌표 데이터가 Object 형태로 출력된다. 123456789101112Object ｛ \"coords\": Object ｛ \"accuracy\": 15.47599983215332, \"altitude\": 54.5, \"heading\": 0, \"latitude\": 37.5354432, \"longitude\": 127.0542137, \"speed\": 0, ｝, \"mocked\": false, \"timestamp\": 1542729762017,｝ 참고로 브라우저 콘솔창에서도 확인 가능하다. 다음번 강좌에서는 위치정보(GPS)로 날씨를 조회하는 기능을 구현할 것입니다. 날씨 앱을 안드로이드 자바로 구현할 때는 개발환경 세팅이나 필요한 모듈을 다운로드하는데 시간이 많이 걸렸습니다. 그런데 리액트 네이티브는 개발환경 세팅이나 모듈 설치하는데 많은 시간이 필요하지 않아서 좋네요. 그리고 저는 리액트 네이티브가 자바스크립트로 구현해서 그런지 코딩이 금방 손에 익었습니다.ㅋ 구글의 플러터도 자바스크립트를 사용했으면 더 좋았을 텐데 하는 아쉬움이 남았습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) My Actifit Report Card: 11월 18 2018 Many sets of tennis doubles game. Enough is enough. …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"},{"name":"날씨 앱 만들기","slug":"개발-이야기/react-native/날씨-앱-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/날씨-앱-만들기/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[React Native #1] 리액트 네이티브 시작하기","slug":"/kr/@anpigon/react-native-1--1542639852750","date":"2018-11-19T15:04:15.000Z","updated":"2019-11-11T13:41:49.813Z","comments":true,"path":"/kr/@anpigon/react-native-1--1542639852750/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/react-native-1--1542639852750/","excerpt":"리액트 네이티브란?리액트 네이티브(React Native)는 iOS와 안드로이드 앱 개발을 위한 라이브러리이다. 자바스크립트로 구현된 기존의 모바일앱들은 웹뷰를 이용한 하이브리드 방식이었다. 하지만 리액트 네이티브는 자바스크립트로 개발하지만, 화면 인터페이스는 네이티브 위젯으로 컴파일하여 빌드된다. 리액트 네이티브는 네이티브 UI를 사용하여 빠른 사용자 경험을 제공한다.","text":"리액트 네이티브란?리액트 네이티브(React Native)는 iOS와 안드로이드 앱 개발을 위한 라이브러리이다. 자바스크립트로 구현된 기존의 모바일앱들은 웹뷰를 이용한 하이브리드 방식이었다. 하지만 리액트 네이티브는 자바스크립트로 개발하지만, 화면 인터페이스는 네이티브 위젯으로 컴파일하여 빌드된다. 리액트 네이티브는 네이티브 UI를 사용하여 빠른 사용자 경험을 제공한다. CRNA 설치 CRNA(create-react-native-app)는 기존의 React Native CLI 보다 리액트 네이티브 앱개발을 더 쉽고 빠르게 시작할 수 있게 해준다. 그리고 CRNA를 사용하면 Xcode 또는 Android Studio가 필요없다. Linux 또는 Windows에서도 iOS 앱을 개발할 수 있다. 아래 명령어로 CRNA를 설치한다. 1$ npm install -g create-react-native-app CRNA는 node v4,6,7,8에서만 작동한다. 참고로 나는 Node version management n를 사용하여 node v8.12.0를 추가 설치하였다. 프로젝트 생성하기 CRNA를 사용하여 weather_app 앱을 생성한다. 1$ create-react-native-app weather_app 위 명령을 실행하고 템플릿 선택을 하면 필요한 모듈을 다운로드하기 시작한다. 그리고 조금 기다리면 아래와 같이 프로젝트가 생성된다. 실행하기 Xcode 또는 Android Studio를 설치하지 않고 테스트 하려면 디바이스에 Expo 앱을 설치해야한다. Expo앱 다운로드 페이지에서 Expo앱을 설치한다. 방금 생성한 weather_app 프로젝트를 실행한다. 12$ cd weather_app$ expo start 빌드 과정이 끝나면 콘솔창에 아래와 같이 QR코드가 출력된다. 디바이스에서 Expo앱을 실행하여 Scan QR Code 버튼를 선택한다. 그리고 콘솔창에 보이는 QR코드를 촬영한다. 그럼 아래와 같이 샘플앱이 실행되어 보여진다. 코드를 수정하면 Hot Reloding에 의해 수정한 내용이 바로 반영된다. 그리고 디바이스를 손에 쥐고 쉐키쉐키 흔들면, 아래와 같이 팝업 메뉴가 나타난다. 팝업 메뉴를 이용하면 앱 접체를 reload하거나, 원격 JS디버깅 또는 Hot Reloding 모드를 끌수도 있다. 마지막으로 브라우저에서 http://localhost:19003 를 접속하면, 디바이스 정보와 로그를 확인할 수 있다. 참고: https://jongmin92.github.io/2017/07/20/ReactNative/create-react-native-app/ 오랜만에 리액트 네이티브 문서를 봤더니 엄청난 발전이 있어서 놀랐습니다. 그리고 개발하기가 정말 쉽고 편해졌습니다. Xcode 또는 Android Studio를 설치하지 않고도 개발할 수 있는게 정말 놀랍네요. 그리고 간단한 코드나 화면은 개발툴 없이 snack을 이용하면 쉽게 테스트 가능합니다. 사실 저는 개인적으로 구글의 플러터가 더 마음에 들지만, 개발속도(도구)/레퍼런스(오픈소스, 커뮤니티)/개발언어(JS) 등으로 인해 리액트 네이티브를 도저히 버릴 수가 없네요. Sponsored ( Powered by dclick ) HBR 블록체인의 진실과 미래를 읽다. 안녕하세요. 부추입니다. 최근에 리디셀렉트를 구독하게 되었는데요. 거기에서 하버드비지니스리뷰 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React Native","slug":"개발-이야기/react-native","permalink":"https://anpigon.github.io/categories/개발-이야기/react-native/"}],"tags":[{"name":"React Native","slug":"react-native","permalink":"https://anpigon.github.io/tags/react-native/"}],"author":"anpigon"},{"title":"[도곡/양재천] 분위기 있는 카페 - 브라운핸즈 ","slug":"/tasteem/@steemory/tasteem-ff553b","date":"2018-11-19T00:36:36.000Z","updated":"2019-11-11T13:41:49.842Z","comments":true,"path":"/tasteem/@steemory/tasteem-ff553b/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-ff553b/","excerpt":"퇴근하고 양재천 카페거리를 걷다가 문득 들어가본 카페~!퇴근후 마시는 커피한잔의 여유~!커피향에 취하고, 분위기에 취한다~ 캬~!여긴 어디? 양재천 카페거리~ 브라운핸즈~!커피를 철쟁반에 담아주는 센스~!커피 거품에서 커피 알바의 내공이 느껴진다~!시원한 아이스커피~!","text":"퇴근하고 양재천 카페거리를 걷다가 문득 들어가본 카페~!퇴근후 마시는 커피한잔의 여유~!커피향에 취하고, 분위기에 취한다~ 캬~!여긴 어디? 양재천 카페거리~ 브라운핸즈~!커피를 철쟁반에 담아주는 센스~!커피 거품에서 커피 알바의 내공이 느껴진다~!시원한 아이스커피~! 커피향과 분위기에 취하고 싶을때 갈만한 곳이다~ 맛집정보 브라운핸즈 도곡점 대한민국 서울특별시 강남구 도곡2동 논현로26길 48 [[도곡/양재천] 분위기 있는 카페 - 브라운핸즈 ](https://kr.tasteem.io/post/22492) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/225)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"},{"name":"카페","slug":"카페","permalink":"https://anpigon.github.io/tags/카페/"}],"author":"steemory"},{"title":"북이오 스티머 서비스 사용 후기?","slug":"/kr/@anpigon/--1542377119448","date":"2018-11-16T14:05:21.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/kr/@anpigon/--1542377119448/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/--1542377119448/","excerpt":"몇일 전에 @lostmine27님이 쓴 “북이오팀 분들에게: 미승인 보팅이 계속 나간 듯해서 확인 요청 드립니다.” 글을 읽은 적이 있다.그리고 “(북이오) 보팅 자동화 서비스, 스티머(Steemer.app)를 공개합니다.” 를 보고 북이오에서 보팅 자동화 서비스를 하고 있다는 것을 알았다.","text":"몇일 전에 @lostmine27님이 쓴 “북이오팀 분들에게: 미승인 보팅이 계속 나간 듯해서 확인 요청 드립니다.” 글을 읽은 적이 있다.그리고 “(북이오) 보팅 자동화 서비스, 스티머(Steemer.app)를 공개합니다.” 를 보고 북이오에서 보팅 자동화 서비스를 하고 있다는 것을 알았다. 나는 북이오에서 제공하는 서비스의 기능과 UI가 더 좋아보였다. 그래서 SteemAuto를 이용하다가 북이오의 스티머로 갈아탔다. 그런데 업보팅 통계를 보면 내가 좋아하는 작가(?)들보다 bukdb 계정에 보팅하는 횟수가 훨씬 많다. 이렇게 소비되고 있는 보팅 파워가 아깝다는 생각이 들었다. 그리고 업보팅 내역을 보면 bukdb 계정에 항상 우선적으로 업보팅되는 계정이 있다. bukio와 sijun 계정이다. 여기서 bukio 계정은 왜 다른 사용자 보다 제일 먼저 셀프 보팅하고 있는 것인가? 그리고 sijun 계정의 정체가 궁금했다. sijun님의 블로그에 들어가 보니 Test 내용의 포스팅뿐이었다. sijun 블로그에서 스크롤을 내리다가 아래 글을 발견했다. 내용을 보니 아마도 북이오의 테스트 계정으로 판단된다. https://steemit.com/tag1/@sijun/s1knitbhs5h sijun 계정의 히스토리를 보다가, 북이오의 테스트 계정을 몇개 더 발견하였다. @caffe와 @sijunpark 계정이다. 역시 둘다 블로그에는 테스트 내용의 포스팅뿐이고 bukdb 계정에 주기적으로 업보팅하고 있다. 북이오는 테스트 계정까지 사용하면서 왜 서비스 이용자들 보다 먼저 셀프 보팅을 하는 것일까? 이런 생각을 하니 갑자기 기분이 많이 상했다. 참고로 아래는 북이오에서 남긴 댓글이다. 서비스 개발비용과 유지비용을 이해 못 하는 것은 아니지만, 이런 식으로 서비스를 운영하는 것이 나는 이해가 안 된다. 스티머는 서비스 이용료라는 명목으로 1회 업보팅에 약 5~6％ 정도의 사용자의 보팅 파워를 사용한다. 그리고 약 $0.002~0.003 정도의 금액을 보팅받는다. 보팅 금액을 $0.002로 잡고, 영업일 기준(20일)로 비용을 계산해보면 한 달에 약 $1 정도의 보팅 금액이 사용된다. $0.96 = $0.002 x 24번 x 20일 차라리 한달에 $1의 유료 서비스를 하는 게 어떨까 하는 생각이 든다. Sponsored ( Powered by dclick )","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[합정역] 키친485","slug":"/tasteem/@steemory/tasteem-25c39e","date":"2018-11-16T00:30:45.000Z","updated":"2019-11-11T13:41:49.841Z","comments":true,"path":"/tasteem/@steemory/tasteem-25c39e/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-25c39e/","excerpt":"요즘 합정역 분위기다. 여기가 일본인지? 한국인지? 헷갈릴 정도로 일본풍의 식당이 많다. 아리가또?나는 합정역에서 이탈리안 레스토랑을 다녀왔따~!여기가 입구다~! 이건 간판이다~! 소고기 원뿔뿔 등급이라고 알려준다. 이건 상장패다~! 이 식당 상받았다~! ㅎㅎ 여긴 식당 내부다~!","text":"요즘 합정역 분위기다. 여기가 일본인지? 한국인지? 헷갈릴 정도로 일본풍의 식당이 많다. 아리가또?나는 합정역에서 이탈리안 레스토랑을 다녀왔따~!여기가 입구다~! 이건 간판이다~! 소고기 원뿔뿔 등급이라고 알려준다. 이건 상장패다~! 이 식당 상받았다~! ㅎㅎ 여긴 식당 내부다~! 메뉴판이다~! 맛있는 피클~! 맛있는 피자~! 새우 크림 고추 페투치니 시원한 레몬 에이드~! 여긴 맛있다~! 믿고 보는 나의 맛집 가이드~! 분위기: ★★★★☆(4.5) 맛점수: ★★★★☆(4.5) 위치: ★★★★☆(4) 평판: ★★★★☆(4) 친절함: ★★★☆☆(3) 직원센스: ★★★★★(5) 계산속도: ★★★★☆(4.5) 총평점: ★★★★☆(4.5) 맛집정보 키친485 대한민국 서울특별시 마포구 서교동 양화로6길 67 [[합정역] 키친485](https://kr.tasteem.io/post/22290) 이 글은 Tasteem 컨테스트 [믿고 가는 이탈리안 레스토랑](https://kr.tasteem.io/event/219)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"쌍문동 포터블 오락실 미니게임기 사용 후기","slug":"/kr/@steemory/--1542198371830","date":"2018-11-14T12:26:12.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/kr/@steemory/--1542198371830/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/--1542198371830/","excerpt":"포터블 오락실 미니게임기를 보자마자 어릴때 가지고 놀던 미니겜보이가 생각났다. 나도 모르게 구입해 버렸다.무려 게임이 200개나 내장되어 있다고 한다. 게임 200개를 다 플레이 해보려면 한참 걸리겠다.ㅋ색상은 그레이, 레드, 민트가 있는데 그레이 색상이 젤 이쁜것 같은데 재고가 없어서 나는 무난한 레드로 샀다.","text":"포터블 오락실 미니게임기를 보자마자 어릴때 가지고 놀던 미니겜보이가 생각났다. 나도 모르게 구입해 버렸다.무려 게임이 200개나 내장되어 있다고 한다. 게임 200개를 다 플레이 해보려면 한참 걸리겠다.ㅋ색상은 그레이, 레드, 민트가 있는데 그레이 색상이 젤 이쁜것 같은데 재고가 없어서 나는 무난한 레드로 샀다. 게임 장르는 파이터, 레이싱, 스포츠, 슈팅, 퍼즐, 액션 게임으로 다양하게 있다. 설명서에는 게임 플레이 방법은 없고 종류만 나열되어 있다. 이건 플레이 방법을 스스로 알아내서 플레이 해야하는 게임기이다. 설명서를 쭈욱 한번 훑어봤다~! 이제 여기에 내장되어 있는 쓰레기 게임들을 하나씩 살펴보자. 첫 화면 슈팅 게임 파이팅 게임 스포츠 게임 액션 게임 레이싱 게임 레이싱 게임은 다 비슷 비슷함. 그게 그거고 그거임. 퍼즐 게임 아래는 내가 주로 하는 쓰레기 게임들이다. 요건 테트리스. 블럭 모양이 쓰레기다. 요건 너구리 같은 게임. 적들을 피해서 아이템을 먹어야 한다. 요건 물고기 이야기. 큰 물고기를 피해서 작은 물고기를 먹어야한다. 요건 횡스크롤 액션 게임. 게임은 재미있는데 방향키 버튼이 쓰레기라서 난이도가 너무 어렵다. 요건 벽돌 깨기 게임. Sponsored ( Powered by dclick )","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"steemory"},{"title":"[GraphQL #2] GraphQL로 React앱 만들기","slug":"/kr/@anpigon/graphql-2-graphql-react--1542031402074","date":"2018-11-12T14:03:21.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/kr/@anpigon/graphql-2-graphql-react--1542031402074/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/graphql-2-graphql-react--1542031402074/","excerpt":"이번에는 GraphQL과 React를 사용하여 웹앱을 개발합니다. apollo-graphql에서 제공하는 react-apollo를 사용하면 웹앱을 정말 쉽게 개발 할 수 있습니다. [GraphQL #1] GraphQL로 API 서버 만들기에서 이어지는 내용입니다.우리는 크롬 브라우저에서 개발할 것입니다. 개발하기 전에 아래 크롬 브라우저 확장 프로그램을 설치해주세요.","text":"이번에는 GraphQL과 React를 사용하여 웹앱을 개발합니다. apollo-graphql에서 제공하는 react-apollo를 사용하면 웹앱을 정말 쉽게 개발 할 수 있습니다. [GraphQL #1] GraphQL로 API 서버 만들기에서 이어지는 내용입니다.우리는 크롬 브라우저에서 개발할 것입니다. 개발하기 전에 아래 크롬 브라우저 확장 프로그램을 설치해주세요. Apollo Client Developer Tools 설치 https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm React Developer Tools 설치 https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi 이 글은 니꼴라스님의 동영상 강의 GraphQL, Apollo로 웹앱 만들기 를 학습하고 정리한 내용입니다. * * * create-react-app 설치 create-react-app를 설치한다. 1$ npm install -g create-react-app create-react-app를 사용하려면 Node 8.10.0 이상이어야 한다. create-react-app 도구를 사용하기 위해 node를 업데이트한다. 12$ brew update$ brew upgrade node 참고로 나는 MacOS라서 homebrew를 사용하여 node를 업데이트했다. ─ 프로젝트 생성 create-react-app 도구를 사용하여 프로젝트를 생성한다. 1$ npx create-react-app movieql-client create-react-app를 사용한 프로젝트 생성은 npx, npm, yarn 으로 생성하는 방법이 있다. 자세한 내용은 여기를 참고한다. ─ 필요한 모듈 설치 react router를 사용하기 위해 react-router-dom를 설치한다. 1$ yarn add react-router-dom 그리고 react-apollo를 설치한다. 1$ yarn add apollo-boost react-apollo graphql-tag graphql ─ 구현하기 apolloClient.js 파일을 생성한다. 1234567import ApolloClient from \"apollo-boost\";const client = new ApolloClient(｛ uri: 'http://localhost:4000'｝);export default client; ApolloClient 객체의 uri에는 GraphQL API 서버 주소를 등록한다. 여기서 사용한 graphql API 서버 소스는 깃허브에 업로드되어 있다. https://github.com/anpigon/movieql/ queries.js 파일을 생성한다. 123456789101112import gql from \"graphql-tag\";export const HOME_PAGE = gql` query ｛ movies(limit:50, rating: 7) ｛ id title rating medium_cover_image ｝ ｝`; GraphQL API 서버에서 데이터를 조회하기 위한 쿼리문을 입력한다. Home.js 파일 생성한다. 123456789101112131415161718192021import React from \"react\";import ｛ Query ｝ from \"react-apollo\";import ｛ HOME_PAGE ｝ from \"./queries\";const Home = () =&gt; ( &lt;Query query=｛HOME_PAGE｝&gt; ｛ (｛ loading, data, error ｝) =&gt; ｛ if(loading) return &lt;span&gt;loading&lt;/span&gt;; if(error) return &lt;span&gt;ERROR&lt;/span&gt;; return data.movies.map(movie =&gt; ( &lt;h2 key=｛movie.id｝&gt; ｛movie.title｝ / ｛movie.rating｝ &lt;/h2&gt; )); ｝ ｝ &lt;/Query&gt;);export default Home; 앞에서 만든 HOME_PAGE 쿼리를 사용하여 데이터를 조회한다. title과 rating 데이터를 가져와서 화면에 출력할 것이다. App.js 파일을 수정한다. 123456789101112131415161718192021import React, ｛ Component ｝ from 'react';import ｛ HashRouter as Router, Route ｝ from \"react-router-dom\";import ｛ ApolloProvider ｝ from \"react-apollo\";import client from \"./apolloClient\";import Home from \"./Home\";class App extends Component ｛ render() ｛ return ( &lt;ApolloProvider client=｛client｝&gt; &lt;Router&gt; &lt;main&gt; &lt;Route exact=｛true｝ path=｛\"/\"｝ component=｛Home｝ /&gt; &lt;/main&gt; &lt;/Router&gt; &lt;/ApolloProvider&gt; ); ｝｝export default App; ApolloProvider 컴포넌트를 사용하여 Router를 감싼다. 그리고 라우트 /에 Home 컴포넌트를 등록한다. 아래는 결과 화면이다. 구현하고 보니 코드 라인 수가 몇줄 안된다. 내 생각에는 apollo-graphql를 사용하면 개발시간을 절약할 수 있을 것 같다. 끝. Sponsored ( Powered by dclick ) 바이트볼 주간 뉴스레터(11월 9일자), Delta 다이렉트 지원, 프리랜서 작가 채용, WCG 공헌자 천 명 돌파 바이트볼 주간 뉴스레터 2018. 11. 09 일자 소식을 전합니다. 이번 주 주요 내용은 다…","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"}],"tags":[{"name":"GraphQL","slug":"graphql","permalink":"https://anpigon.github.io/tags/graphql/"},{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"}],"author":"anpigon"},{"title":"[송파/석촌호수]  카페 드립커피 전문점 - 커피공작소","slug":"/tasteem/@steemory/tasteem-1da866","date":"2018-11-12T01:00:33.000Z","updated":"2019-11-11T13:41:49.841Z","comments":true,"path":"/tasteem/@steemory/tasteem-1da866/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-1da866/","excerpt":"석촌호수 길을 걷다가 들어간 드립커피 전문점… 드립을 한 수 배워보자~!내부 분위기는 매우 아늑하다. 커피향이 내 코를 자극한다~아늑하다~! 편안하다~! 커피 향이 난다~! 커피 원두 종류가 이렇게 많다~! 시간과 돈이 된다면 하나씩 다 마셔보고 싶다. 모두 따뜻한 커피 한잔 하세요~!","text":"석촌호수 길을 걷다가 들어간 드립커피 전문점… 드립을 한 수 배워보자~!내부 분위기는 매우 아늑하다. 커피향이 내 코를 자극한다~아늑하다~! 편안하다~! 커피 향이 난다~! 커피 원두 종류가 이렇게 많다~! 시간과 돈이 된다면 하나씩 다 마셔보고 싶다. 모두 따뜻한 커피 한잔 하세요~! 맛집정보 커피공작소 대한민국 서울특별시 송파구 송파1동 백제고분로41길 42-16 [[송파/석촌호수] 카페 드립커피 전문점 - 커피공작소](https://kr.tasteem.io/post/21945) 이 글은 Tasteem 컨테스트 [내가 사랑한 카페](https://kr.tasteem.io/event/218)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"},{"name":"카페","slug":"카페","permalink":"https://anpigon.github.io/tags/카페/"}],"author":"steemory"},{"title":"[을지로] 빈티지카페 - 커피한약방","slug":"/tasteem/@steemory/tasteem-1fa756","date":"2018-11-11T04:40:21.000Z","updated":"2019-11-11T13:41:49.841Z","comments":true,"path":"/tasteem/@steemory/tasteem-1fa756/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-1fa756/","excerpt":"이렇게 좁은 골목 사이로 커피한약방 간판이 보인다. 골목 들어갈때 나오는 사람이 있으면 몸을 옆으로 돌려서 게 걸음으로 들어가야 한다. 카페 바로 맞은편에 혜민방이 있다. 여긴 빵 맛집이다. 엄청 엄청 맛있다. “베리 베리 굳~!” 이라고 표현하고 싶다. 나는 커피를 빵이랑 같이 먹으려고 헤민당에서 빵도 샀다. 혜민당 내부 분위기는 이렇다. 빵순님 빵돌님들이 오순도순 앉아서 빵을 맛있게 먹고 있다.","text":"이렇게 좁은 골목 사이로 커피한약방 간판이 보인다. 골목 들어갈때 나오는 사람이 있으면 몸을 옆으로 돌려서 게 걸음으로 들어가야 한다. 카페 바로 맞은편에 혜민방이 있다. 여긴 빵 맛집이다. 엄청 엄청 맛있다. “베리 베리 굳~!” 이라고 표현하고 싶다. 나는 커피를 빵이랑 같이 먹으려고 헤민당에서 빵도 샀다. 혜민당 내부 분위기는 이렇다. 빵순님 빵돌님들이 오순도순 앉아서 빵을 맛있게 먹고 있다. 빵도 맛있지만 케익도 다 맛있어 보인다. 다 맛있어 보여서 다 먹어보고 싶지만, 오늘은 빵한개, 케익한만 먹자아~! 먹고싶은 빵이랑 케익을 샀으면 이제 다시 커피한약방으로 고고 하자~! 카페 내부 매점은 이렇게 생겼다. 천장에서 녹물이 뚝뚝 떨어질 것 같은 분위기다. 그리고 도시락 폭탄이라도 터지면 천장이 곧 무너질 것 같다. 천장 보수공사 전문 업체 전화번호를 알려줘야겠다. 커피한약방은 3층까지 있다. 나는 2층으로 갈꺼다. 2층으로 따라 오세요~! 맛있는 필터 커피, 자몽 에이드, 티라미수, 페스츄리~!!! 이제 빵과 커피를 마시면서 카페 분위기를 천천히 감상한다~! 저쪽에는 경성에서 온 언니, 오빠들이 앉아있다. 그리고 이쪽에는 민족해방운동 단체모임도 보인다. 일본군이 온다는 소식에 사람들이 많이 빠졌다. 그래서 나는 사진을 맘껏 찍었다. 오르간~! 약방 저울~! 천장 조명~! 맛집정보 커피한약방 대한민국 서울특별시 중구 명동 삼일대로12길 16-6 [[을지로] 빈티지카페 - 커피한약방](https://kr.tasteem.io/post/21855) 이 글은 Tasteem 컨테스트 [내가 사랑한 카페](https://kr.tasteem.io/event/218)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[GraphQL #1] GraphQL로 API 서버 만들기","slug":"/kr/@anpigon/graphql-1-graphql-api--1541861904811","date":"2018-11-10T14:58:24.000Z","updated":"2019-11-11T13:41:49.824Z","comments":true,"path":"/kr/@anpigon/graphql-1-graphql-api--1541861904811/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/graphql-1-graphql-api--1541861904811/","excerpt":"GraphQLGraphQL은 API 쿼리 언어이며, 데이터 유형을 정의하여 쿼리하기 위한 서버 런타임 시스템이다.RESTful API와 비교하면, RESTful API는 Request마다 각각의 Endpoint를 사용하지만, GraphQL은 단일 Endpoint를 사용한다. 그리고 일반적인 Restful API 서버에서는 데이터를 주고받을 때 Over-Fetching, Under-Fetching 이 발생한다. 하지만 GraphQL은 RESTful API에서 발생할 수 있는 Over-Fetching, Under-Fetching 문제를 해결하였다.","text":"GraphQLGraphQL은 API 쿼리 언어이며, 데이터 유형을 정의하여 쿼리하기 위한 서버 런타임 시스템이다.RESTful API와 비교하면, RESTful API는 Request마다 각각의 Endpoint를 사용하지만, GraphQL은 단일 Endpoint를 사용한다. 그리고 일반적인 Restful API 서버에서는 데이터를 주고받을 때 Over-Fetching, Under-Fetching 이 발생한다. 하지만 GraphQL은 RESTful API에서 발생할 수 있는 Over-Fetching, Under-Fetching 문제를 해결하였다. Over-Fetching이란? 필요한 정보 영역보다 더 많은 정보를 서버로부터 받는 것을 말한다. 사용자 이름 정보만 필요한데 서버는 그 외에 정보도 같이 준다. 그럼 우리는 많은 정보 중에서 필요한 정보만 골라서 사용해야 한다. Under-Fetching이란? 필요한 정보가 여러개일때 서버에 여러번 요청해야한다. 하지만 GraphQL은 한번의 요청으로 서버로 부터 필요한 모든 정보를 받을 수 있다. 이 글은 니꼴라스님의 동영상 강의 “GraphQL으로 영화API 만들기” 를 학습하고 정리한 내용입니다. * * * 필요한 npm 모듈 설치하기 우선 graphql API 서버를 구현하는데 필요한 npm 모듈을 설치한다. graphql-yoga 설치 graphql-yoga 사용하면 GraphQL 서버를 쉽게 설정할 수 있다. 1yarn add graphql-yoga 바벨(babel) 설치 Babel은 ES6/ES7 코드를 ES5 코드로 변환해주는 도구이다. ES6/ES7으로 개발하기 위해서 babel-cli를 설치한다. 1$ yarn global add babel-cli [설치 오류 해결 방법] EACCES: permission denied 오류가 발생하여 아래 링크를 보고 해결하였다. https://tonyne.jeju.onl/2016/12/25/npm-eacces-permission-denied-error/ 또 다음 오류가 발생하여 --ignore-engines 옵션을 사용하여 설치하였다. babel-cli를 --ignore-engines 옵션을 사용하여 설치하는 방법. $ yarn global add babel-cli --ignore-engines 그리고 바벨에 필요한 추가 모듈을 설치한다. 1$ yarn add babel-preset-env babel-preset-stage-3 --dev .babelrc 파일을 생성한다. 123｛ \"presets\": [\"env\", \"stage-3\"]｝ nodemon 설치 nodemon은 js가 수정되면 서버를 자동으로 재시작해준다. 1$ yarn global add nodemon package.json에 다음을 추가한다. 123\"scripts\": ｛ \"start\": \"nodemon --exec babel-node index.js\"｝ 다음은 package.json파일의 전체 내용이다. ─ index.js 파일 생성하고 실행하기 index.js 파일을 생성한다. 1234import ｛ GraphQLServer ｝ from 'graphql-yoga'const server = new GraphQLServer(｛｝)server.start(() =&gt; console.log('Server is running on localhost:4000')) npm start으로 서버를 실행하면, 아직은 에러 메세지가 출력 될 것이다. 1$ npm start ─ scheme 생성하기 scheme에는 쿼리에 사용할 데이터 유형을 정의한다.graphql 폴더를 생성하고 scheme.graphql 파일을 생성한다. 12graphql └─ scheme.graphql scheme.graphql 파일을 생성하고 Marketplace에서 확장 프로그램을 설치한다. scheme.graphql 파일에는 type을 추가한다. 123type Query ｛ name: String!｝ name은 요청값이고 응답값 유형은 String이다. 그리고 !은 필수값(required)이라는 의미이다. ─ resolvers 생성하기 resolvers.js 파일을 생성한다. 123graphql├─ scheme.graphql└─ resolvers.js resolvers.js 파일에는 Query를 위한 resolvers를 작성한다. name으로 요청이 들어오면 응답값으로 anpigon을 리턴한다. 12345const resolvers = ｛ Query: ｛ name: () =&gt; `anpigon`, ｝,｝ index.js 파일에 typeDefs와 resolvers 를 추가한다. 12345678import ｛ GraphQLServer ｝ from 'graphql-yoga'import resolvers from './graphql/resolvers' // 추가된 코드const server = new GraphQLServer(｛ typeDefs: \"graphql/scheme.graphql\", // 추가된 코드 resolvers // 추가된 코드｝)server.start(() =&gt; console.log('Server is running on localhost:4000')) 서버를 실행하고 브라우저에서 localhost:4000를 접속하면 아래 화면을 볼 수 있다. graphql-yoga 모듈에서 제공하는 GraphQL Playground 화면이다. (자세한 내용은 여기를 참조한다.) 서버에 요청을 보내보자. 그럼 서버에서 아래와 같이 응답이 내려온다. scheme.graphql 파일을 다음과 같이 수정한다. person을 요청하면 응답값으로 Anpigon 객체를 리턴한다. 123456789type Anpigon ｛ name: String!, age: Int!, gender: String!,｝type Query ｛ person: Anpigon!｝ resolvers.js 파일을 다음과 같이 수정한다. 12345678910111213const Anpigon = ｛ name: 'anpigon', age: 17, gender: 'men',｝const resolvers = ｛ Query: ｛ person: () =&gt; Anpigon, ｝,｝export default resolvers 브러우저에 접속해서 SCHEMA 패널을 열어보자. 그러면 요청할 수 있는 쿼리 유형과 응답 유형을 확일 할 수 있다. person값 중에서 age 값만 받고 싶으면 아래와 같이 요청할 수 있다. 그럼 우리가 요청한 age 값만 받을 수 있다. 끝. Sponsored ( Powered by dclick ) [매매일지]/#2-1/현상태 네오는 4％ 먹고(매도) 다시 매수했습니다^^ 지지만 잘해주면 굳 스텔라 61.8％ 되돌림때 …","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"React","slug":"개발-이야기/react","permalink":"https://anpigon.github.io/categories/개발-이야기/react/"}],"tags":[{"name":"GraphQL","slug":"graphql","permalink":"https://anpigon.github.io/tags/graphql/"},{"name":"React","slug":"react","permalink":"https://anpigon.github.io/tags/react/"}],"author":"anpigon"},{"title":"[송파/석촌호수] 맛있는 쌀국수 - 리틀파파 ","slug":"/tasteem/@steemory/tasteem-8ac8b3","date":"2018-11-09T02:28:51.000Z","updated":"2019-11-11T13:41:49.841Z","comments":true,"path":"/tasteem/@steemory/tasteem-8ac8b3/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-8ac8b3/","excerpt":"내부 분위기는 이렇다. 흡사 베트남에 온것 같은 기분이 든다.메뉴~!메뉴 자세히 보러가기나는 양지 쌀국수와 분짜를 주문했다.양지쌀국수~!분짜~!맛은 그냥 그냥 했지만, 분위기 때문에 다시 올 것 같다~!여기는 실내 인테리어로는 확실한 맛집이다~!! 맛집정보 리틀파파 BEP","text":"내부 분위기는 이렇다. 흡사 베트남에 온것 같은 기분이 든다.메뉴~!메뉴 자세히 보러가기나는 양지 쌀국수와 분짜를 주문했다.양지쌀국수~!분짜~!맛은 그냥 그냥 했지만, 분위기 때문에 다시 올 것 같다~!여기는 실내 인테리어로는 확실한 맛집이다~!! 맛집정보 리틀파파 BEP 대한민국 서울특별시 송파구 송파1동 석촌호수로 296 [[송파/석촌호수] 맛있는 쌀국수 - 리틀파파 ](https://kr.tasteem.io/post/21693) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/214)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[CR] 다이소 양모 펠트 후기","slug":"/kr/@steemory/cr--1541641295134","date":"2018-11-08T01:41:36.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/kr/@steemory/cr--1541641295134/","link":"","permalink":"https://anpigon.github.io/kr/@steemory/cr--1541641295134/","excerpt":"다이소에서 양모 펠트를 구입해서 만들어보았습니다.매직블럭이랑 바늘도 샀어요~!알파카는 설명서와 바늘이 들어있어요. 그런데 오리랑 토끼는 설명서가 없어요.ㅠㅠ우선 설명서가 있는 알파카를 먼저 만들어 보기로 결정 했어요. 양모를 스펀지 위에 놓고 바늘로 쿡쿡 찌르면서 만드는건데 어렵네요. 설명서가 일본어로 되어있었지만 그림만 보고 따라 만들었어요","text":"다이소에서 양모 펠트를 구입해서 만들어보았습니다.매직블럭이랑 바늘도 샀어요~!알파카는 설명서와 바늘이 들어있어요. 그런데 오리랑 토끼는 설명서가 없어요.ㅠㅠ우선 설명서가 있는 알파카를 먼저 만들어 보기로 결정 했어요. 양모를 스펀지 위에 놓고 바늘로 쿡쿡 찌르면서 만드는건데 어렵네요. 설명서가 일본어로 되어있었지만 그림만 보고 따라 만들었어요 양모 펠트 만들기 종류가 많았는데, 저는 그중에서 제일 귀여운 알파카와 오리, 토끼를 샀어요~! 아래는 완성된 알파카입니다~! 귀여운 알파카양이에요~ 그런데 귀엽지가 않네요. 저는 귀여운 알파카를 가지고 싶어서 조금 수정했어요~! 너무 이쁘네요~0 지인분께 선물하려고 포장했어요. 이렇게 포장하고 나니 파는것 같습니다.ㅋ 이제 오리와 토끼를 만들 시간입니다. 이제 양모펠트에 자신이 없습니다.ㅠㅠ 그래도 샀으니 일단 만들어 보았습니다. 오리 꽥꽥~! 귀여운 토끼 머리~! 얘들아 미안~! 다음에는 더 이쁘게 만들어줄께~! 양모펠트 인형 주문 제작 받습니다~!","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"아티스팀","slug":"아티스팀","permalink":"https://anpigon.github.io/tags/아티스팀/"},{"name":"양모 펠트","slug":"양모-펠트","permalink":"https://anpigon.github.io/tags/양모-펠트/"}],"author":"steemory"},{"title":"[성수] 디저트 카페 - 후식당","slug":"/tasteem/@steemory/tasteem-baab4d","date":"2018-11-07T05:02:27.000Z","updated":"2019-11-11T13:41:49.841Z","comments":true,"path":"/tasteem/@steemory/tasteem-baab4d/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-baab4d/","excerpt":"매달 후식이 바뀌는 성수동 카페를 소개합니다.“후식을 팝니다.”후식당길을 걷다가 후식당을 발견했다. 윤민수 아들 후가 운영하는 식당인 줄 알고 들어갔다~!좁은 골목으로 들어가면 식당이 나온다.그냥 보기에는 가정집이다.“계십니까? 저 윤후 보러 왔는데요~! 윤후 집에 있나요?”","text":"매달 후식이 바뀌는 성수동 카페를 소개합니다.“후식을 팝니다.”후식당길을 걷다가 후식당을 발견했다. 윤민수 아들 후가 운영하는 식당인 줄 알고 들어갔다~!좁은 골목으로 들어가면 식당이 나온다.그냥 보기에는 가정집이다.“계십니까? 저 윤후 보러 왔는데요~! 윤후 집에 있나요?” 대문을 들어가면 분위기는 이렇다. 들어가면 맛있는 디저트가 전시되어있다. 여기서 하나 골르는 거다. 무슨 맛인지 모르니 선택하기 어렵다. 메뉴는 이렇게 있다~! 나는 직원이 추천해준 소다수랑 사과 디저트를 주문했다~! 둘다 달달하니 맛있다. 그런데 양이 너무 적다. 나는 만4천5백원어치를 주문했는데… 디저트는 원래 이렇게 비싼건가 보다. 그리고 옆에 쪽방 같은 것도 있다. 직원들 잠자는 덴가? 내부가 궁금하여 들여다 보았다. 내부는 윤동주 시인이 후쿠오카 형무소에서 옥살이 했던 방 처럼 아늑하다. 쪽방에 앉아서 커피를 마시면 멋진 시상이 떠오를 것 같다. 죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를, 비싼 디저트 가격에 나는 괴로워했다. 칼로리를 소비하는 마음으로 살로 가는 모든것들을 사랑해야지 그리고 나한테 주어진 돈을 아껴야겠다. 오늘 밤에도 별이 바람에 스치운다. 오늘은 여기까지~! 감사합니다. 맛집정보 후식당 대한민국 서울특별시 성동구 성수동1가 656-1661 [[성수] 디저트 카페 - 후식당](https://kr.tasteem.io/post/21504) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/214)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[성수/뚝섬/서울숲] 비사벌 전주 콩나물 국밥집","slug":"/tasteem/@steemory/tasteem-93336b","date":"2018-11-06T00:41:03.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/tasteem/@steemory/tasteem-93336b/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-93336b/","excerpt":"여긴 성수에서 유명한 맛집이다. 24시간 영업하는데다 손님이 끊어진것을 본적이 없다.입구는 이렇게 생겼다.내부 분위기는 이렇다. 항상 이렇게 손님이 꽉 차있다. 들어가서 시킬건 오로지 콩나물 국밥~!맛집이라서 그런지 메뉴는 딱 2종류다. 먹을건 콩나물국밥밖에 없다.","text":"여긴 성수에서 유명한 맛집이다. 24시간 영업하는데다 손님이 끊어진것을 본적이 없다.입구는 이렇게 생겼다.내부 분위기는 이렇다. 항상 이렇게 손님이 꽉 차있다. 들어가서 시킬건 오로지 콩나물 국밥~!맛집이라서 그런지 메뉴는 딱 2종류다. 먹을건 콩나물국밥밖에 없다. 12콩나물국밥 .......... 7,000원모 주 .......... 1,000원 “주모~! 여기 2명이요~!” 하면 알아서 콩나물 국밥 2그릇을 가져다 준다. 이렇게 콩나물 국밥과 수란을 가져다 준다. 수란은 요렇게 뜨거운 콩나물국밥 국물을 넣고 김을 넣어 떠먹으면 맛있다~! 글쓰면서 사진을 보니깐 또 먹고 싶다. 꾸울꺽~! 맛있는 반찬들~! 나는 깍두기가 맛있어서 곱배기로 2그릇이나 먹었다~! 밥 초근접 사진~! 밥알에 윤기가 흐른다. 국밥에도 김을 올리고오~ 밥을 국밥에 풍덩 담근다~ 그리고 맛있게 먹는다~! 끝. 보글 보글 보글~ 콩나물 국밥은 뜨거우니 먹을때 조심하세요~! 이상 맛있는 콩나물 국밥집이었습니다. 맛집정보 비사벌 전주 콩나물 국밥 대한민국 서울특별시 성동구 성수1가1동 660-10 [[성수/뚝섬/서울숲] 비사벌 전주 콩나물 국밥집](https://kr.tasteem.io/post/21390) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/201)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"골목식당 백종원의 원조쌈밥집 (양재)","slug":"/tasteem/@steemory/tasteem-005ade","date":"2018-11-05T01:55:57.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/tasteem/@steemory/tasteem-005ade/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-005ade/","excerpt":"들어가면 이렇게 쌈채소 재배실이 있습니다. 내부가 푸릇푸릇하니 분위기가 좋습니다.ㅋ쌈밥정식 메뉴는 이렇습니다~!123456대패삼겹살 쌈밥정식 ...... 10,000원/1인분생삼겹살 쌈밥정식 ........ 15,000원/1인분항정살 쌈밥정식 .......... 12,000원/1인분차돌박이 쌈밥정식 ........ 13,000원/1인분대패오리 쌈밥정식 ........ 14,000원/1인분멸치 쌈밥정식 ............ 13,000원/1인분","text":"들어가면 이렇게 쌈채소 재배실이 있습니다. 내부가 푸릇푸릇하니 분위기가 좋습니다.ㅋ쌈밥정식 메뉴는 이렇습니다~!123456대패삼겹살 쌈밥정식 ...... 10,000원/1인분생삼겹살 쌈밥정식 ........ 15,000원/1인분항정살 쌈밥정식 .......... 12,000원/1인분차돌박이 쌈밥정식 ........ 13,000원/1인분대패오리 쌈밥정식 ........ 14,000원/1인분멸치 쌈밥정식 ............ 13,000원/1인분 저는 오리대패 정식을 주문했습니다. 채소를 이렇게 푸짐하게 줍니다. 소처럼 풀을 엄청 먹었네요.ㅋ 음메에~ 밥이랑 된장국~! 맛있는 반찬들~! 내가 좋아하는 고등어 조림~! 고등어 속살을 양념에 찍어먹으니 맛있어요~! 대패로 정성껏 깍아낸 오리고기~! 대패 오리고기는 처음 먹어본다. 얇아서 입에서 녹으려나? ㅎㅎ 이렇게 불판에 굽습니다~! 지글지글~! 샤르르르 다 구어진 오리고기는 이렇게 밥위에다가 올려서 먹습니다아~! 냠냠 쩝쩝~! 아 맛있다아~! 고기랑 같이 먹을수 있는 양념장이 이렇게 3종류가 있는데… 잘몰라서 다 넣어서 먹습니다아~! 냠냠 쩝쩝~! 아 맛있다아~! 먹다보니 고기가 생각보다 양이 적었습니다. 그래서 고기랑 밥을 다 먹고 나니 풀때기가 많이 남았어요. 남을 풀들을 소 여물 씹듯이 다 먹었어요~ 풀을 다 먹고 나니 입을 열때마다 생그러운 풀 향기가 풀풀 납니다~ 자연인이 된것 같습니다. 백종원 원조쌈밥집님! 안녕히 계세요~ 굳바이~! 맛집정보 백종원의원조쌈밥집 양재지점 대한민국 서울특별시 서초구 양재2동 327-20 [골목식당 백종원의 원조쌈밥집 (양재)](https://kr.tasteem.io/post/21303) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/201)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[성수/뚝섬 맛집] 밀본 - 칼국수/녹두전","slug":"/tasteem/@steemory/tasteem-989d02","date":"2018-11-04T04:19:03.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/tasteem/@steemory/tasteem-989d02/","link":"","permalink":"https://anpigon.github.io/tasteem/@steemory/tasteem-989d02/","excerpt":"“2018 미쉐린 가이드 서울 빕 구르망” 에 선정된 맛집입니다.밀본은 고기 육수를 베이스로 한 칼국수로 성수/뚝섬에서 유명한 맛집입니다.입구는 요렇게 생겼습니다.식당에 들어가면 분위기가 요렇습니다.주방 근처에는 피규어가 많이 전시되어 있어요~!밀본 메뉴~!1234567손 칼국수 .................. 7,000원고기 덮밥 .................. 7,000원비빔 물국수 ................. 6,000원손만두 ..................... 6,000원녹두전 ..................... 10,000원군만두 ..................... 12,000원매운닭봉 .................... 15,000원","text":"“2018 미쉐린 가이드 서울 빕 구르망” 에 선정된 맛집입니다.밀본은 고기 육수를 베이스로 한 칼국수로 성수/뚝섬에서 유명한 맛집입니다.입구는 요렇게 생겼습니다.식당에 들어가면 분위기가 요렇습니다.주방 근처에는 피규어가 많이 전시되어 있어요~!밀본 메뉴~!1234567손 칼국수 .................. 7,000원고기 덮밥 .................. 7,000원비빔 물국수 ................. 6,000원손만두 ..................... 6,000원녹두전 ..................... 10,000원군만두 ..................... 12,000원매운닭봉 .................... 15,000원 저는 녹두전과 칼국수를 먹었습니다. 녹두전~! 칼국수~! 김치와 무절임~! 밀본은 칼국수 육수와 녹두전이 생각날때 가끔씩 가는 맛집입니다. 맛집정보 밀본 대한민국 서울특별시 성동구 성수동2가 300-80 [[성수/뚝섬 맛집] 밀본 - 칼국수/녹두전](https://kr.tasteem.io/post/21240) 이 글은 Tasteem 컨테스트 [내가 소개하는 이번 주 맛집](https://kr.tasteem.io/event/201)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"}],"author":"steemory"},{"title":"[Steem Project] Hexo Steem 개인 블로그 만들기","slug":"/kr/@anpigon/steemproject-1-hexo-steem--1541261792948","date":"2018-11-03T16:16:33.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"/kr/@anpigon/steemproject-1-hexo-steem--1541261792948/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemproject-1-hexo-steem--1541261792948/","excerpt":"안녕하세요. @anpigon 입니다.@jisoooh0202님이 작성하신 &quot;List of All Steem Based Projects / 스팀의 모든 프로젝트 리스트&quot;에는 스팀잇 프로젝트가 모두 정리되어있습니다. 스팀잇 프로젝트를 살펴보다가 마음에 드는 것이 있어서 소개합니다. 예전에 @jisoooh0202님의 “스팀 블록체인 위의 프로젝트 소개“ 시리즈 글을 즐겨 봤었는데, 지금은 연재를 중단하신 것 같습니다. ㅋ","text":"안녕하세요. @anpigon 입니다.@jisoooh0202님이 작성하신 &quot;List of All Steem Based Projects / 스팀의 모든 프로젝트 리스트&quot;에는 스팀잇 프로젝트가 모두 정리되어있습니다. 스팀잇 프로젝트를 살펴보다가 마음에 드는 것이 있어서 소개합니다. 예전에 @jisoooh0202님의 “스팀 블록체인 위의 프로젝트 소개“ 시리즈 글을 즐겨 봤었는데, 지금은 연재를 중단하신 것 같습니다. ㅋ Hexo Steem 프로젝트를 소개합니다. Hexo Steem은 Hexo 블로그의 애드온으로 Hexo 기반으로 생성된 블로그에 스팀잇의 글을 자동으로 게시 할 수 있습니다. Hexo Steem 만드신 skzap님의 블로그에 접속해보고는 바로 완전 마음에 들었습니다. skzap님의 블로그: https://skzap.github.io/ Hexo Steem 프로젝트는 아래와 같이 steemprojects 페이지에 소개되어 있습니다. https://steemprojects.com/projects/p/hexo-steem/ * * * Hexo란? Hexo는 마크다운(Markdown) 문서를 page로 변환하여 개인 블로그를 만들어 주는 Node.JS 프레임워크다. Hexo를 이용하면 개인 블로그를 Github Pages나 heroku, firebase 등 무료 서버에서 쉽게 운영할 수 있다. 그중에서 Github는 트래픽 무제한 무료이기 때문에 개인 블로그 서버로 많이 사용되고 있다. 그리고 Hexo와 비슷한 프레임워크로는 지킬(jekyll)도 있다. 하지만 jekyll은 개발언어가 루비(Ruby)라서 루비를 모르면 다루기가 어렵다. 참고로, Hexo를 사용하기 위해서는 기본적으로 Node.js 와 git 이 설치되어 있어야 한다. 설치가 안 되어 있다면 각 홈페이지를 참고하여 설치하길 바란다. Hexo 홈페이지: https://hexo.io Node.js 홈페이지: https://nodejs.org git 홈페이지: https://git-scm.com ─ Hexo 설치 및 초기화 우선 Hexo 빌드 도구를 설치하고 blog 폴더를 생성한다. blog 폴더에 개인 블로그를 생성할 것이다. 1234$ npm install -g hexo-cli$ hexo init blog$ cd blog$ npm install 각 OS별 자세한 설치 방법은 hexo 홈페이지를 참고하세요. blog 폴더를 열어보면 아래와 같은 폴더 구조가 생성되어 있다. 123456789blog ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes └── landscape 여기서 _config.yml 파일은 블로그 설정 파일이다. 이 글에서는 _config.yml의 기본적인 설정만 설명한다. _config.yml 설정에 대한 자세한 설명은 Hexo configuration 문서를 참고하세요. ─ hexo-steem 모듈 설치 그다음에는 hexo-steem 모듈을 설치한다. npm에서 제공하고 있는 hexo-steem 모듈은 2년전 버전으로 더이상 업데이트가 없다. 사용해보니 문제가 있어 모듈을 직접 수정하였다. 아래와 같이 github url에서 수정된 hexo-steem 모듈을 설치한다. 지금도 보이지 않는 몇 가지 문제가 있다. 시간이 나면 추후에 수정할 생각이다. 1$ npm install --save git+https://github.com/anpigon/hexo-steem.git [hexo-steem 수정 내용] - steemjs 모듈을 `^0.3.31` 에서 `^0.7.2`로 업그레이드 - 마크다운 변환 중 발생하는 jade 프레임워크 예약어(|％｛｝) 관련 오류 처리 그리고 _config.yml 설정 파일을 열어 steem_users 를 추가한다. steem_users에는 자신의 스팀잇 아이디를 입력한다. 스팀잇 아이디는 아래와 같이 여러개 입력 가능하다. 이런식으로 여러 아이디를 하나의 블로그로 운영할수 있을것 같다. 1234steem_users: - anpigon - anpigon2 - anpigon3 ─ Hexo 테마 바꾸기 hexo는 기본적으로 landscape 테마가 설치 되어 있다. 테마를 변경하고 싶으면 아래 사이트에서 원하는 테마를 다운로드 받아 설치하면 된다. Hexo Theme: https://hexo.io/themes/ 나는 skzap님이 사용한 maupassant 테마를 설치하였다. maupassant 사이트에서 제공하는 설치 방법은 아래와 같다. 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 설치가 완료되면 _config.yml에서 theme을 maupassant로 수정한다. 12## Themes: https://hexo.io/themes/theme: maupassant 참고로 이전글에서 소개했던 CleanBlog도 많이 사용하는 무료 테마 중 하나이다. ─ Hexo 블로그를 로컬에서 실행하기 아래 명령어를 실행하면 로컬에서 블로그 확인이 가능하다. 1$ hexo server 서버가 구동되면 http://localhost:4000 에 접속하여 블로그를 확인할 수 있다. 로컬에서 테스트해보고 github에 배포하는 것을 추천한다. ─ Github에 블로그 배포하기 Github Pages 서비스를 이용하면 GitHub에 개인 블로그를 생성할 수 있다. GitHub에서 리포지터리(repository)를 생성할때, Repository name에 username.github.com를 입력한다. 그럼 https://username.github.com에 page가 만들어지게 된다. 자세히 설명하면 내용이 길어지므로 page 생성방법은 Github Pages 홈페이지를 참고한다. hexo-deployer-git 플러그인 설치 hexo 블로그를 github에 배포할 수 있는 플러그인을 설치한다. 1$ npm install hexo-deployer-git --save github 배포 설정하기 _config.yml 파일을 열어 deploy에 본인의 github url을 입력한다. 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/anpigon/anpigon.github.io.git branch: master hexo 페이지를 빌드하여 github에 배포하기 아래 명령어를 입력하여 블로그를 github에 배포한다. 123$ hexo clean$ hexo generate$ hexo deploy hexo clean: 캐시 파일(db.json)과 생성된 파일(public)을 삭제한다. hexo generate: 정적 파일(html, css, js)을 생성한다. hexo deploy: 블로그를 배포(deploy) 한다. 또는, 아래 명령 옵션으로 generate와 deploy를 동시에 실행할 수도 있다. 1$ hexo deploy --g 참고로 github에 배포하고 반영되는데 1~3분 정도의 시간이 소요된다. ─ about 페이지 생성하기 블로그를 생성하고 보니 about 페이지가 없다. 그래서 아래와 같이 about 페이지를 생성하였다. 1$ hexo new page about 위의 명령어를 실행하고 나면 sources/about/index.md 파일이 생성된다. 해당 파일의 내용은 각자 수정하기 바란다. 참고로 블로그에 RSS 기능도 빠져있는데 이 기능을 구현하려면 연구를 해봐야 할 것 같다. ─ 아래는 Hexo Steem로 생성한 개인 블로그입니다. 안피곤 블로그: https://anpigon.github.io/blog 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇 개인 블로그 만들기","slug":"개발-이야기/스팀잇-개인-블로그-만들기","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-개인-블로그-만들기/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://anpigon.github.io/tags/hexo/"}],"author":"anpigon"},{"title":"[Steem Project #3] “나는 코노(코인노래방) 가수다.” 콘테스트 사이트를 오픈합니다.","slug":"/dclick/@anpigon/--1540909123547","date":"2018-10-30T14:18:45.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/dclick/@anpigon/--1540909123547/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/--1540909123547/","excerpt":"안녕하세요. @anpigon입니다.이번에 @newbijohn님이 개최한 “나는 코노(코인노래방) 가수다.” 콘테스트를 한눈에 볼수 있는 페이지를 만들어 보았습니다. 사이트: https://anpigon.github.io/singsteem 목록에서 동영상을 바로 재생할 수 있습니다. 다른 특별한 기능은 없습니다.","text":"안녕하세요. @anpigon입니다.이번에 @newbijohn님이 개최한 “나는 코노(코인노래방) 가수다.” 콘테스트를 한눈에 볼수 있는 페이지를 만들어 보았습니다. 사이트: https://anpigon.github.io/singsteem 목록에서 동영상을 바로 재생할 수 있습니다. 다른 특별한 기능은 없습니다. 금방 만들 줄 알았는데 하다 보니 벌써 11시가 넘었네요. 2시간정도 걸린것 같습니다. 욕심내서 사이트에 동영상 업로드 기능도 넣고, 모바일 음악플레이어 앱도 만들고 싶은데 아직은 실력이 안 되네요. ㅠ 그리고 날씨가 갑자기 추워져서 그런지 요즘 컨티션이 안좋네요. 모두 감기 조심하세요. 여기까지 읽어주셔서 감사합니다. 😃 Sponsored ( Powered by dclick )","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"}],"author":"anpigon"},{"title":"[아티스팀] Let's play maple leaves.","slug":"/artisteem/@anpigon/artisteem--anpigon--1929364414--artisteem-busy-kr--2018-10-28-01-06-35--artwork--none","date":"2018-10-27T16:06:39.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/artisteem/@anpigon/artisteem--anpigon--1929364414--artisteem-busy-kr--2018-10-28-01-06-35--artwork--none/","link":"","permalink":"https://anpigon.github.io/artisteem/@anpigon/artisteem--anpigon--1929364414--artisteem-busy-kr--2018-10-28-01-06-35--artwork--none/","excerpt":"","text":"단풍잎으로 가을을 표현해 보았습니다.즐거운 단풍잎 놀이였습니다~!Artisteem의 &quot;Fall Photo Contest / 가을 사진 콘테스트&quot;에 응모한 작품입니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"아티스팀","slug":"아티스팀","permalink":"https://anpigon.github.io/tags/아티스팀/"}],"author":"anpigon"},{"title":"석촌호수 송리단길 분위기 역대급 카페 “경성광장”","slug":"/tasteem/@anpigon/tasteem-147c54","date":"2018-10-27T14:06:09.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/tasteem/@anpigon/tasteem-147c54/","link":"","permalink":"https://anpigon.github.io/tasteem/@anpigon/tasteem-147c54/","excerpt":"안녕하세요. @anpigon입니다.와썹맨 송리단길 편을 보고 요즘 “핫” 하다는 송리단길에 다녀왔습니다.* * *송리단길을 구경하며 걷다가 눈에 띄는 카페가 보여서 걸음을 멈추었습니다. 창문으로 보이는 내부 분위기가 예전에 보았던 영화 &quot;밀정&quot;과 &quot;암살&quot;을 생각나게 만듭니다. 그래서 홀린듯이 들어가게 되었습니다.","text":"안녕하세요. @anpigon입니다.와썹맨 송리단길 편을 보고 요즘 “핫” 하다는 송리단길에 다녀왔습니다.* * *송리단길을 구경하며 걷다가 눈에 띄는 카페가 보여서 걸음을 멈추었습니다. 창문으로 보이는 내부 분위기가 예전에 보았던 영화 &quot;밀정&quot;과 &quot;암살&quot;을 생각나게 만듭니다. 그래서 홀린듯이 들어가게 되었습니다. 내부 분위기는 이렇습니다. 들어가자마자 정말로 경성에 온 것 같은 느낌을 받았습니다. 인테리어, 배경 음악, 직원들 유니폼까지도 경성 느낌 그대로입니다. 테이블 좌석이 없어서 우리는 Bar 좌석에 앉았습니다. Bar 좌석에 앉으면 이렇게 드립 커피 내리는 장면을 볼 수 있습니다. 우리는 비엔나 커피와 드립 커피를 주문했습니다. 커피를 담아준 컵도 너무 이쁘고, 비엔나 커피 위에 올라간 생크림이 너무 맛있었습니다. 직원들도 너무 친절하고 고풍스러운 분위기도 너무 좋습니다. 그래서 오랫동안 앉아있다가 나왔네요. * * * 맛집정보 경성광장 대한민국 서울특별시 송파구 송파1동 오금로16길 10-6 [석촌호수 송리단길 분위기 역대급 카페 \"경성광장\"](https://kr.tasteem.io/post/20470) 이 글은 Tasteem 컨테스트 [짧게 기록하는 이번주 맛집](https://kr.tasteem.io/event/188)에 참가한 글입니다. 테이스팀은 무엇인가요?","categories":[{"name":"맛집 이야기","slug":"맛집-이야기","permalink":"https://anpigon.github.io/categories/맛집-이야기/"}],"tags":[{"name":"테이스팀","slug":"테이스팀","permalink":"https://anpigon.github.io/tags/테이스팀/"},{"name":"카페","slug":"카페","permalink":"https://anpigon.github.io/tags/카페/"}],"author":"anpigon"},{"title":"[Flutter] 플러터(Flutter) 모바일 앱 개발 - Pull to Refresh 구현하기","slug":"/dclick/@anpigon/flutter-pull-to-refresh--1540565403497","date":"2018-10-26T14:50:06.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/dclick/@anpigon/flutter-pull-to-refresh--1540565403497/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/flutter-pull-to-refresh--1540565403497/","excerpt":"안녕하세요. @anpigon 입니다.이번에는 Pull to Refresh 기능을 구현해봅니다. Pull Down 또는 Pull Up 동작으로 목록을 업데이트하는 것인데… 텍스트로 설명하기 어려우니 앱 동작 화면으로 설명을 대신하겠습니다. 아래는 Pull Down하여 목록을 업데이트하는 화면입니다.","text":"안녕하세요. @anpigon 입니다.이번에는 Pull to Refresh 기능을 구현해봅니다. Pull Down 또는 Pull Up 동작으로 목록을 업데이트하는 것인데… 텍스트로 설명하기 어려우니 앱 동작 화면으로 설명을 대신하겠습니다. 아래는 Pull Down하여 목록을 업데이트하는 화면입니다. Pull to Refresh 기능을 구현해놓은 라이브러리가 있어 덕분에 쉽게 구현할 수 있었습니다. pull_to_refresh 라이브러리와 샘플 소스는 아래 깃허브에서 다운로드 받을 수 있습니다. https://pub.dartlang.org/packages/pull_to_refresh ᛫ ᛫ ᛫ ᛫ ᛫ 이전 글 모바일 앱 개발 : Flutter 시작하기 #1 - Get started 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1) 모바일 앱 개발 : Flutter 시작하기 #3 - First Flutter App (2) 모바일 앱 개발 : Flutter 시작하기 #4 - First Flutter App (3) 모바일 앱 개발 : Flutter 시작하기 #5 - First Flutter App (4) 플러터(Flutter) 모바일 앱 개발 - 스팀잇 피드 구현하기 ᛫ ᛫ ᛫ ᛫ ᛫ Pull To Refresh 구현하기 아래와 같이 pubspec.yml에 필요한 라이브러리 추가한다. 123dependencies: http: ^0.11.3+17 pull_to_refresh: ^1.1.6 ᛫ ᛫ ᛫ ᛫ ᛫ 서버에서 이미지 목록 가져오기 그다음 이미지 목록을 가져오는 함수를 구현한다. 한 번에 30개씩 가져오도록 하였다. 그리고 가져온 데이터에서 image_url만 배열로 반환한다. 1234567891011121314151617181920import 'dart:async';import 'dart:convert' show json;import 'package:flutter/material.dart';import 'package:http/http.dart' as HTTP;import 'package:pull_to_refresh/pull_to_refresh.dart';class _MyHomePageState extends State&lt;MyHomePage&gt; ｛ int _indexPage = 2; // 페이지 번호 int _rowCount = 30; // 행 개수 Future _fetch() ｛ return http.get('http://image.baidu.com/channel/listjson?pn=$_indexPage&amp;rn=$_rowCount&amp;tag1=％E6％98％8E％E6％98％9F&amp;tag2=％E5％85％A8％E9％83％A8&amp;ie=utf8') .then((http.Response response) ｛ Map map = json.decode(response.body); return map[\"data\"].map((item) =&gt; item[\"image_url\"]).toList().sublist(0, _rowCount); ｝); ｝// ... 이하 생략 ... 샘플 소스에 있는 로직을 그대로 사용하였다. 위에서 사용한 URL은 바이두 검색사이트에서 배우들의 이미지를 검색해오는 API이다. ᛫ ᛫ ᛫ ᛫ ᛫ initState 함수 구현하기 앱이 실행되고 첫 화면에 보여줄 데이터를 가져오는 함수를 구현하자. 아래와 같이 initState() 함수를 오버라이드(override)하여 구현한다. initState 함수는 State가 트리에 삽입되면 자동으로 호출된다. 1234567891011121314RefreshController _controller; // pull_to_refreh 컨트롤러List&lt;String&gt; _data = []; // 가져온 데이터를 담는 변수@overridevoid initState() ｛ super.initState(); _controller = new RefreshController(); _fetch().then((array) ｛ for (var item in array) ｛ _data.add(item); ｝ setState(() =&gt; _indexPage++); // 화면 업데이트하고 페이지 번호 증가 ｝);｝ ᛫ ᛫ ᛫ ᛫ ᛫ 이미지 위젯 구현하기 목록에서 보여줄 이미지 위젯을 구현한다. RepaintBoundary와 Image 위젯을 사용하였다. Image 위젯의 Image.network 생성자를 사용하면 URL에서 이미지를 바로 출력할 수 있다. 그리고 fit 속성에 BoxFit.cover를 사용하여 이미지를 crop해서 여백없이 이쁘게 보여주자. fit 속성에 대한 자세한 설명은 여기를 참고하자. 123456789Widget _buildImage(context, index) ｛ if (_data[index] == null) return new Container(); // 이미지가 없는 경우 return new RepaintBoundary( child: new Image.network( _data[index], fit: BoxFit.cover, ), );｝ ᛫ ᛫ ᛫ ᛫ ᛫ 목록 위젯 구현하기 이제 목록을 출력할 위젯을 구현하자. GridView 위젯을 사용하여 한 행에 이미지가 2개씩 예쁘게 보이도록 한다. SliverGridDelegateWithFixedCrossAxisCount 클래스를 사용하여 그리드 레이아웃을 작성한다. 123456789101112131415161718Widget _buildBody() ｛ if (_data.length &gt; 0) ｛ return new SmartRefresher( enablePullDown: true, enablePullUp: true, controller: _controller, child: new GridView.builder( gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2), itemCount: _data.length, itemBuilder: _buildImage, ), ); ｝ else ｛ return new Center( child: CircularProgressIndicator() ); ｝｝ ᛫ ᛫ ᛫ ᛫ ᛫ 아래는 지금까지 구현한 화면이다. 아직 refresh 기능은 작동하지 않는다. ᛫ ᛫ ᛫ ᛫ ᛫ 핵심 기능 Refresh 구현하기 이제 핵심 기능인 Pull Up 과 Pull Down의 콜백 함수 구현하자. _onRefresh() 함수가 받는 인자값 up가 True면 Pull Down이 호출된 것이고, False면 Pull Up이 호출된 것이다. 다시 쉽게 말하면 True면 **상단 위치에서 아래로 당긴 것(Pull Down)**이고, False면 **하단 위치에서 위로 당긴 것(Pull Up)**이다. 이렇게 설명하면 모두 이해했으리라 생각한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void _onRefresh(bool up) ｛ if (up) ｛ // Pull Down 이 호출된 경우 _fetch().then((array) ｛ for (var item in array) ｛ _data.add(item); ｝ _controller.sendBack(up, RefreshStatus.completed); setState(() =&gt; _indexPage++); ｝).catchError(() ｛ _controller.sendBack(up, RefreshStatus.failed); ｝); ｝ else ｛ // Pull Up 이 호출된 경우 _fetch().then((array) ｛ for (var item in array) ｛ _data.add(item); ｝ _controller.sendBack(up, RefreshStatus.idle); setState(() =&gt; _indexPage++); ｝).catchError(() ｛ _controller.sendBack(up, RefreshStatus.failed); ｝); ｝ ｝``` &lt;br&gt;&lt;br&gt;이제 앞에서 작성한 `_buildBody()` 함수를 수정한다. **SmartRefresher** 위젯에 `SmartRefresher` 속성을 추가하고 `_onRefresh()` 콜백 함수를 적용한다. 이제 목록에서 Pull Up이나 Pull Down 동작을 실행하면 `_onRefresh()` 함수가 호출 될 것이다.```dart Widget _buildBody() ｛ if (_data.length &gt; 0) ｛ return new SmartRefresher( enablePullDown: true, enablePullUp: true, controller: _controller, onRefresh: _onRefresh, // 추가된 코드 child: new GridView.builder( gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2), itemCount: _data.length, itemBuilder: _buildImage, ), ); ｝ else ｛ return new Center( child: CircularProgressIndicator() ); ｝ ｝``` &lt;br&gt;&lt;center&gt;&lt;br&gt;᛫ ᛫ ᛫ ᛫ ᛫&lt;br&gt;&lt;/center&gt;&lt;br&gt;# 푸터 메세지 변경하기&lt;br&gt;목록 맨 하단에서 Pull Up 했을 때 표시되는 메시지와 아이콘을 변경해보자. 우선 `_footerCreate()` 함수를 구현하자. `ClassicIndicator` 클래스 속성에서 `refreshingText`는 진행 중일 때 표시되는 메세지이고, `idleText`는 실행되기 전 표시되는 메세지이다. 참고로 `ClassicIndicator` 클래스는 pull_to_refresh 라이브러리에서 제공하는 클래스이다. 더 자세히 알고 싶으면 [소스 코드](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/classic_indicator.dart)를 참고한다. Widget _footerCreate(BuildContext context, int mode) ｛ return new ClassicIndicator( mode: mode, refreshingText: ‘Loading…’, idleIcon: const Icon(Icons.arrow_upward), idleText: ‘Loadmore…’, ); ｝ 12&lt;br&gt;&lt;br&gt;그리고 다시 `_buildBody()` 함수를 수정하자. **SmartRefresher**에 `footerBuilder`와 `footerConfig` 속성을 추가한다. return new SmartRefresher( enablePullDown: true, enablePullUp: true, controller: _controller, onRefresh: _onRefresh, footerBuilder: _footerCreate, // 추가된 코드 footerConfig: new RefreshConfig(), // 추가된 코드 child: new GridView.builder( gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2), itemCount: _data.length, itemBuilder: _buildImage, ), ); &lt;center&gt;&lt;br&gt;᛫ ᛫ ᛫ ᛫ ᛫&lt;br&gt;&lt;/center&gt;&lt;br&gt; 오늘 완성된 앱의 동작 화면이다. 스크롤 하면 한국 스타들도 많이 보인다. &lt;center&gt;&lt;img src='https://cdn.steemitimages.com/DQmQLmdbPrj5M71zZUJcoqdXJ38yuxh5151HuLLhs3TgjSH/11111111111.gif'&gt;&lt;/center&gt; &lt;center&gt;&lt;br&gt;᛫ ᛫ ᛫ ᛫ ᛫&lt;br&gt;&lt;/center&gt;&lt;br&gt; 플러터에서 제공하는 [API 문서](https://docs.flutter.io/index.html)를 보면 플러터에서 제공하는 클래스와 컴포넌트가 상당히 많다. 그러나 API 문서의 내용을 모두 읽어보고 개발하기에는 문서 양이 너무 많다. 결국에는 문서만 읽다가 지쳐서 금방 포기하게 된다. 우리는 필요한 기능을 구현하면서 그때그때 공부한다. 그리고 초급일 때는 초급 수준까지만 공부하면 된다. 어려운 로직을 이해하려고 노력할 필요는 없다. 그리고 급하게 공부할 필요도 없다. IT기술은 빠른 속도로 발전하고 트렌드가 바뀐다. 방관하는 자세로 느긋하게 공부하면 된다.ㅋ &lt;br&gt;여기까지 읽어주셔서 감사합니다. *** ##### &lt;sub&gt; **Sponsored ( Powered by [dclick](https://www.dclick.io) )** &lt;/sub&gt; ##### [집앞 새로생긴 족발집](https://api.dclick.io/v1/c?x=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjIjoiYW5waWdvbiIsInMiOiJmbHV0dGVyLXB1bGwtdG8tcmVmcmVzaC0tMTU0MDU2NTQwMzQ5NyIsImEiOlsxNDVdLCJ1cmwiOiJodHRwczovL3N0ZWVtaXQuY29tL2RjbGljay9AbGluZGFmbHloaWdoLy0tMTUzOTg1NjIxNjQ3OSIsImlhdCI6MTU0MDU2NTQwMywiZXhwIjoxODU1OTI1NDAzfQ.xf0TueDTt95wn3pszsqQvAxJhHxgZjocmyjiSqqKJm0) &lt;sup&gt;집앞 족발집이 생겨서 한번 먹어봤는데 ... 비싼데 맛이 반반... 싱싱한것과 오래된것을 반반...&lt;/sup&gt; &lt;br&gt;&lt;center&gt;![logo](https://steemitimages.com/200x100/https://cdn.steemitimages.com/DQmbjkrc5UT4GgZXygAnS3mLrboAy7Y8gr7R7guB8HG3f5n/logopad500.png)&lt;br&gt;&lt;br&gt;이 글은 스팀 기반 광고 플랫폼&lt;br&gt;[dclick](https://www.dclick.io) 에 의해 작성 되었습니다.&lt;/center&gt;","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #8 - 마르코프 체인(Markov Chain) : 문장 생성하기","slug":"/dclick/@anpigon/-8-markov-chain--1540437398396","date":"2018-10-25T03:16:39.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/dclick/@anpigon/-8-markov-chain--1540437398396/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-8-markov-chain--1540437398396/","excerpt":"마르코프 체인은 챗봇 답변과 같은 문장생성에 많이 사용됩니다. 더 나아가 딥러닝을 이용하면 셰익스피어 소설을 쓴다거나 소스코드도 만들어 낼 수 있습니다. RNN을 사용하여 셰익스피어나 리눅스 소스 코드를 생성하는 내용은 아래 앤드류 응 교수님 블로그에서 볼 수 있습니다. RNN/LSTM에 관한 내용입니다.","text":"마르코프 체인은 챗봇 답변과 같은 문장생성에 많이 사용됩니다. 더 나아가 딥러닝을 이용하면 셰익스피어 소설을 쓴다거나 소스코드도 만들어 낼 수 있습니다. RNN을 사용하여 셰익스피어나 리눅스 소스 코드를 생성하는 내용은 아래 앤드류 응 교수님 블로그에서 볼 수 있습니다. RNN/LSTM에 관한 내용입니다. “The Unreasonable Effectiveness of Recurrent Neural Networks” by Andrej Karpathy 그리고 코세라에 앤드류 응 교수님의 머신러닝 무료 강의도 있으니 관심있으신 분은 한번 들어보세요. 한글 자막 지원됩니다. 참고로 김성훈 교수님의 무료 강의도 있습니다. 머신러닝으로 문장 생성하기 마르코프 텍스트 생성기(Markov Text Generator)를 파이썬으로 구현한 오픈 소스가 있어서 사용해보았다. 소스 코드는 깃허브에서 다운로드 받으면 된다. https://github.com/codebox/markov-text 학습할 글 가져오기 테스트를 위해 이전 글에서 사용한 원사마님의 글을 다시 사용했다. 그래서 이전 소스를 재활용한다. 1234567from newspaper import Articleurl = 'https://steemit.com/dclick/@wonsama/-181023--1540308198584'news = Article(url, language='ko')news.download()news.parse()text = news.text 만약 newspaper 모듈 설치 중에 “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-BqMhb7/matplotlib/&quot; 에러가 나면 여기를 참고하자. 알려준대로 pip install --upgrade setuptools를 실행하니 해결되었다. dclick 광고 내용은 학습할 필요가 없기 때문에, 글 본문 하단에 dclick 광고 내용이 있으면 아래와 같이 날려준다. 123sponsored = text.find('\\nSponsored ( Powered by dclick )')if sponsored &gt; 0: text = text[:sponsored] 단순하게 문장과 어절 단위로만 학습한다. 꼬꼬마(kkma) 형태소 분석기를 이용하여 문장 단위를 구분한다. 12345from konlpy.tag import Kkmatagger = Kkma()# 문장 단위로 구분text = '\\n'.join(tagger.sentences(text)) 형태소 단위로 학습했더니 말이 안 되는 문장이 생성되는 경우가 많았다. 학습 데이터를 많이 확보하면 굳이 형태소 분석까지는 할 필요가 없다고 생각한다. 학습하기 depth는 다음 단어를 선택하는 데 이전 단어 중 몇 개를 사용할지 결정하는 값이다.(최소값은 2). 값이 클수록 생성된 문장은 원본 텍스트에 나타나는 문장과 유사하다. 하지만 특정 값을 넘으면 생성된 문장이 원본에 나타나는 문장과 같아진다. 12345678910111213141516171819from db import Dbfrom gen import Generatorfrom parse import Parserfrom sql import Sqlfrom rnd import Rndimport sysimport sqlite3import codecsSENTENCE_SEPARATOR = '\\n' # 문장 구분 코드WORD_SEPARATOR = ' ' # 어절 구분 코드# 학습하기def train(text, name = 'steemit', depth = 2): db = Db(sqlite3.connect(name + '.db'), Sql()) db.setup(depth); Parser(name, db, SENTENCE_SEPARATOR, WORD_SEPARATOR).parse(text) train(text) 문장 생성하기 학습한 데이터가 적어서 대부분 비슷한 문장이 생성된다. 학습 데이터가 많아지면 더 다양한 문장을 생성할 수 있을 것이다. 12345678910# 문장 생성하기def generate(name = 'steemit', count = 5): db = Db(sqlite3.connect(name + '.db'), Sql()) generator = Generator(name, db, Rnd()) result = [] for i in range(0, count): result.append(generator.generate(WORD_SEPARATOR)) return result generate() 여기까지 읽어주셔서 감사합니다. 이전글 파이썬 머신러닝 #1 - 스팀잇 형태소 분석하기 파이썬 머신러닝 #2 - 스팀잇 형태소 분석해서 단어구름 만들기 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별 예측하기 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기 파이썬 머신러닝 #5 - 유사한 게시물 찾기 파이썬 머신러닝 #6 - 스팀잇에서 유사한 게시물 찾기 파이썬 머신러닝 #7 - 문서 요약하기(TextRank Summariser) Sponsored ( Powered by dclick ) 구매욕을 자극하는 달달한 도넛 「 달콤한 수제 도넛 파는 곳 」 | 성신여대 모모도넛 | 안녕하세요 @noisysky입니다… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"마르코프 체인","slug":"마르코프-체인","permalink":"https://anpigon.github.io/tags/마르코프-체인/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #7 - 문서 요약하기(TextRank Summariser)","slug":"/dclick/@anpigon/-textrank-summariser-1540351206980","date":"2018-10-24T03:20:09.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/dclick/@anpigon/-textrank-summariser-1540351206980/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-textrank-summariser-1540351206980/","excerpt":"Summary by Nick Youngson CC BY-SA 3.0 ImageCreator 안녕하세요. @anpigon입니다.파이썬을 이용하여 문서를 쉽게 요약할 수 있는 기능을 소개합니다. 이 글은 summarization.summarizer – TextRank Summariser을 참고하여 작성한 글입니다.","text":"Summary by Nick Youngson CC BY-SA 3.0 ImageCreator 안녕하세요. @anpigon입니다.파이썬을 이용하여 문서를 쉽게 요약할 수 있는 기능을 소개합니다. 이 글은 summarization.summarizer – TextRank Summariser을 참고하여 작성한 글입니다. gensim, newspaper 모듈 설치 문서를 요약하는데 사용할 gensim와 newspaper 모듈을 설치한다. newspaper 모듈은 파이썬 버전에 따라 설치방법이 다르다. 파이썬2에서는 pip install newspaper로 설치 한다. 그리고 파이썬3에서는 pip install newspaper3k로 설치한다. 나는 파이썬3를 사용하고 있으므로 아래와 같이 설치하였다. 1$ pip install gensim newspaper3k 추가로 모듈를 설치하는데 pip 업그레이드가 필요하다는 메시지가 나와서 아래와 같이 pip를 업그레이드하였다. 스팀잇 글 가져오기 원사마님이 작성한 글 &quot;[ 하생시 ] 18.10.23 하루를 생각하는 시간&quot;으로 요약 테스트해보았다. 참고로 내가 작성한 글은 내용 대부분이 개발 코드라서 문서 요약이 되질 않았기 때문이다. 아래와 같이 URL에서 글 본문 내용을 가져온다. newspaper 모듈을 사용하면 블로그 또는 기사에서 제목과 본문 내용을 쉽게 가져올 수 있다. 12345678from gensim.summarization.summarizer import summarizefrom newspaper import Articleurl = ' https://steemit.com/dclick/@wonsama/-181023--1540308198584'news = Article(url, language='ko')news.download()news.parse()print(news.text) 문서 요약하기 summarize에 입력 가능한 매개 변수는 다음과 같다. text (str) – 요약할 테스트. ratio (float, optional) – 요약에 대해 선택할 원본 텍스트의 문장 수 비율을 결정하는 0~1 사이 숫자. word_count (int or None, optional) – 출력에 포함할 단어 수. 두 파라미터가 모두 제공되는 경우 ratio는 무시된다. split (bool, optional) – True면 문장 list가 반환된다. False는 조인(join)된 문자열이 반환된다. 우선 추가 옵션 없이 글 내용을 요약해보자. 1print(summarize(news.text)) 그다음은 출력할 단어 수를 50개로 설정하고 요약해본다. 1print(summarize(news.text, word_count=50)) 마지막으로 문장 비율을 설정하고 요약해보았다. 1print(summarize(news.text, ratio=0.1)) 결론은, 원사마님이 작성한 글의 핵심 문장은 &quot;요즘은 개발은 안하고 맨날 제안서만 쓴다.&quot;입니다. 여기까지 읽어주셔서 감사합니다. 참고 블로그 “Textrank for summarizing text” by Jan Wijffels “TextRank를 이용한 문서요약” by Excelsior-JH “‘쉽게 설명한’ 구글의 페이지 랭크 알고리즘” by 조성문 이전글 파이썬 머신러닝 #1 - 스팀잇 형태소 분석하기 파이썬 머신러닝 #2 - 스팀잇 형태소 분석해서 단어구름 만들기 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별 예측하기 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기 파이썬 머신러닝 #5 - 유사한 게시물 찾기 파이썬 머신러닝 #6 - 스팀잇에서 유사한 게시물 찾기 Sponsored ( Powered by dclick ) [데이빗 이야기 #2] 만든 사람은 있지만, 손대는 사람은 없는 완전 자동화된 암호화폐 거래소 데이빗(DAYBIT) 사용후기 안녕하세요, 디온(@donekim)입니다. 지난 번 포스팅에 이어서 오늘은 데이빗 거래소의 사… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"TextRank","slug":"textrank","permalink":"https://anpigon.github.io/tags/textrank/"}],"author":"anpigon"},{"title":"[Flutter] 플러터(Flutter) 모바일 앱 개발 -  스팀잇 피드 구현하기","slug":"/dclick/@anpigon/flutter--1540311025725","date":"2018-10-23T16:10:27.000Z","updated":"2019-11-11T13:41:49.840Z","comments":true,"path":"/dclick/@anpigon/flutter--1540311025725/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/flutter--1540311025725/","excerpt":"안녕하세요. @anpigon 입니다.이번에는 스팀잇 피드를 가져와서 출력하는 화면을 개발해보았습니다. 이전글 &quot;First Flutter App&quot;에서 추가로 학습할 부분이 거의 없어 코드 설명은 짧게 하였습니다. 그리고 핵심 로직에 집중하기 위해서 UI 컴포넌트는 최소한으로 사용합니다.","text":"안녕하세요. @anpigon 입니다.이번에는 스팀잇 피드를 가져와서 출력하는 화면을 개발해보았습니다. 이전글 &quot;First Flutter App&quot;에서 추가로 학습할 부분이 거의 없어 코드 설명은 짧게 하였습니다. 그리고 핵심 로직에 집중하기 위해서 UI 컴포넌트는 최소한으로 사용합니다. 이전 글 모바일 앱 개발 : Flutter 시작하기 #1 - Get started 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1) 모바일 앱 개발 : Flutter 시작하기 #3 - First Flutter App (2) 모바일 앱 개발 : Flutter 시작하기 #4 - First Flutter App (3) 모바일 앱 개발 : Flutter 시작하기 #5 - First Flutter App (4) 이번에 완성된 앱의 동작화면입니다. 에뮬레이터 실행 화면이라서 조금 느립니다. 그리고 아직 상세 페이지를 구현하지 않아서 목록을 클릭하면 브라우저가 실행됩니다. 외부 패키지 추가 pubspec.yaml 파일을 열고 dependencies 목록에 필요한 패키지(http, url_launcher)를 추가합니다. 1234567dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 http: ^0.11.3+17 # 패키지 추가 url_launcher: ^4.0.1 # 패키지 추가 PostList와 Post 클래스 생성 스팀잇에서 Feed 를 가져와서 데이터를 담을 PostList와 Post 모델 클래스를 생성한다. model/Post.dart 12345678910111213141516171819202122class Post ｛ final num id; final String title; final String body; final String url; Post(｛ this.id, this.title, this.body, this.url, ｝); factory Post.fromJson(Map&lt;String, dynamic&gt; json) ｛ return Post( id: json['id'] as num, title: json['title'] as String, body: json['body'] as String, url: json['url'] as String, ); ｝｝ model/PostList.dart 123456789101112131415import 'Post.dart';class PostList ｛ final List&lt;Post&gt; result; PostList(｛this.result｝); factory PostList.fromJson(Map&lt;String, dynamic&gt; json) ｛ return PostList( result: (json['result'] as List) ?.map((e) =&gt; e == null ? null : new Post.fromJson(e as Map&lt;String, dynamic&gt;)) ?.toList() ); ｝｝ JSON 직렬화를 자동으로 할 수도 있다. 자세한 내용은 JSON and serialization 문서를 참고한다. fetchFeedList 함수 구현 fetchFeedList는 Future를 async/await와 같이 사용하여 비동기 함수로 구현한다. 참고로 JavaScript(ES7)의 async/await와 동작방식은 같다. Steemit.dart 12345678910111213141516171819202122232425import 'dart:async'; // 비동기import 'dart:convert'; // JSON 파싱import 'package:http/http.dart' as http;import 'package:steemlog/model/PostList.dart';class Steemit ｛ /** * 스팀잇 피드 리스트를 조회 */ Future&lt;PostList&gt; fetchFeedList(String username, int limit) async ｛ final _url = \"https://api.steemit.com\"; final body = '｛\"jsonrpc\":\"2.0\", \"method\":\"condenser_api.get_discussions_by_feed\", \"params\":[｛\"tag\":\"$｛username｝\",\"limit\":$｛limit .toString()｝｝], \"id\":1｝'; final response = await http.post(_url, body: body); if (response.statusCode == 200) ｛ // If server returns an OK response, parse the JSON return PostList.fromJson(json.decode(response.body)); ｝ else ｛ // If that response was not OK, throw an error. throw Exception('Failed to load post'); ｝ ｝｝ 화면에 출력하기 이전에 만들었던 첫번째 앱에서 _buildSuggestions()와 _buildRow() 함수를 수정하자. FutureBuilder의 future를 이용하여 스팀잇 피드를 비동기로 가져온다. 만약 future가 완료되지 않았다면 CircularProgressIndicator()를 사용하여 프로그래스 이미지를 보여준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:url_launcher/url_launcher.dart';import 'package:steemlog/model/Post.dart';import 'package:steemlog/model/PostList.dart';import 'package:steemlog/Steemit.dart'; // ... 생략 ...class FeedListState extends State&lt;FeedList&gt; ｛ final String _username = 'anpigon'; // 사용자 이름 final int _limit = 20; // 가져올 피드 개수 @override Widget build(BuildContext context) ｛ return new Scaffold( appBar: new AppBar( title: new Text('Feed List'), ), body: _buildSuggestions() ); ｝ Widget _buildSuggestions() ｛ return new Center( child: FutureBuilder&lt;PostList&gt;( future: Steemit().fetchFeedList(_username, _limit), builder: (context, post) ｛ if (post.hasData) ｛ return new ListView.builder( padding: const EdgeInsets.all(5.0), itemCount: post.data.result.length, itemBuilder: (BuildContext _context, int position) ｛ return _buildRow(post.data.result[position]); ｝, ); ｝ else if (post.hasError) ｛ return Text(\"$｛post.error｝\"); ｝ return CircularProgressIndicator(); ｝ ) ); ｝ Widget _buildRow(Post post) ｛ return new Column( children: &lt;Widget&gt;[ new ListTile( title: new Text(post.title), subtitle: new Text(post.body, overflow: TextOverflow.ellipsis, maxLines: 3 ), onTap: () ｛ _launchURL(post.url); ｝, ), const Divider() ] ); ｝ _launchURL(String _url) async ｛ final String url = \"https://steemit.com$｛_url｝\"; if (await canLaunch(url)) ｛ await launch(url); ｝ else ｛ throw 'Could not launch $url'; ｝ ｝｝ Text에서 제공하는 overflow 속성을 사용하여 내용을 최대 3줄만 표시되도록 했다. 여기서 작성한 코드는 모두 깃허브에 올려놓았습니다. https://github.com/anpigon/flutter-steemit-app 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 드디어 이지 스팀잇이 출간되었습니다(+M-shape도요~) 안녕하세요. 포해피우먼입니다. 오늘은 반가운 소식을 가지고 왔습니다. 아기다리고기다리 (-_-… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[Steemit] 스캠 봇 계정이 DCLICK 광고를 사용할 수 있을까?","slug":"/dclick/@anpigon/test-1540261533907","date":"2018-10-23T02:25:36.000Z","updated":"2019-11-11T13:41:49.854Z","comments":true,"path":"/dclick/@anpigon/test-1540261533907/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/test-1540261533907/","excerpt":"안녕하세요. @anpigon입니다.스캠으로 보이는 계정 @sucona이 kr-dev에 글을 올렸습니다. 그런데 글 하단에 dclick광고가 달려있어서 의아했습니다. 과연 스캠 계정이 봇을 이용해서 dclick광고를 달수 있을까 해서 몇 가지 테스트를 해보았습니다.DCLICK은 steemconnect 방식의 로그인을 사용하고 있으므로, 로그인할 때 포스트 권한을 DCLICK에서 위임하게 됩니다. 그래서 dclick이 글을 등록할 때 사용하는 API를 알아내면 어렵지 않을 것 같습니다.","text":"안녕하세요. @anpigon입니다.스캠으로 보이는 계정 @sucona이 kr-dev에 글을 올렸습니다. 그런데 글 하단에 dclick광고가 달려있어서 의아했습니다. 과연 스캠 계정이 봇을 이용해서 dclick광고를 달수 있을까 해서 몇 가지 테스트를 해보았습니다.DCLICK은 steemconnect 방식의 로그인을 사용하고 있으므로, 로그인할 때 포스트 권한을 DCLICK에서 위임하게 됩니다. 그래서 dclick이 글을 등록할 때 사용하는 API를 알아내면 어렵지 않을 것 같습니다. DLICK API를 직접 호출하여 글쓰기 시도 dclick의 글쓰기 API를 호출하여 포스팅을 시도해보았습니다. [401] UnAuthorizedError 오류가 발생합니다. 로그인 상태가 아니므로 권한이 없어서 오류가 발생하였습니다. 브라우저 쿠키에 액세스 토큰 가져오기 크롬 브라우저에서 DCLICK을 로그인하여 생성된 쿠키 정보를 확인합니다. 쿠키에 JWT로 보이는 토큰이 보여서 가져왔습니다. 참고로 로그아웃하니 쿠키정보는 지워졌습니다. JWT을 사용하여 DLICK API로 글쓰기 시도 JWT를 이용하여 다시 dclick의 글쓰기 API를 호출하여 포스팅을 시도해보았습니다. 결과적으로는 포스팅이 성공하였습니다. 결과적으로 DCLICK에서 발급받은 JWT토큰이 있으면 DCLICK API를 사용해서 포스팅 할수 있습니다. 참고로 현재 이 글은 위의 방식으로 등록한 글입니다. 등록되고 나서 내용은 수정하였습니다. 그리고 궁금한 사항이 하나 생겼습니다. JWT를 재발급 받으면 기존에 사용하던 JWT는 자동으로 폐기될까요? 이것도 테스트해보고 싶었지만 블로그가 지저분해질 것 같아 테스트는 하지 않았습니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[Flutter] 모바일 앱 개발 : Flutter 시작하기 #5 - First Flutter App (4)","slug":"/dclick/@anpigon/-flutter-5-first-flutter-app-4-1540135389352","date":"2018-10-21T15:23:09.000Z","updated":"2019-11-11T13:41:49.839Z","comments":true,"path":"/dclick/@anpigon/-flutter-5-first-flutter-app-4-1540135389352/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-flutter-5-first-flutter-app-4-1540135389352/","excerpt":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #4&quot;에서 이어집니다. Flutter 튜토리얼 파트2의 6 ~ 7 까지의 내용입니다. 이번에는 새로운 페이지로 이동하는 방법과 테마를 변경하는 방법을 학습합니다.이번에 완성된 앱의 동작 화면입니다.","text":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #4&quot;에서 이어집니다. Flutter 튜토리얼 파트2의 6 ~ 7 까지의 내용입니다. 이번에는 새로운 페이지로 이동하는 방법과 테마를 변경하는 방법을 학습합니다.이번에 완성된 앱의 동작 화면입니다. 페이지 이동하기 (Navigate to a new screen) 이번에는 홈 라우트(route)에서 새로운 라우트(route)로 이동하는 방법을 학습하고, 즐겨찾기에 저장된 단어를 확인할 수 있는 새 페이지(플러터 라우트)를 구현해보자. 플러터에서는 네비게이터의 스택으로 앱 라우트(route)를 관리한다. 네비게이터 스택으로 라우트(route)를 푸시(push)하면 해당 라우트로 화면이 업데이트된다. 그리고 네비게이터 스택에서 라우트를 팝(pop)하면 화면이 이전 라우트로 돌아간다. RandomWordsState 클래스의 build 메서드를 수정하여 AppBar에 목록 아이콘을 추가해보자. 그리고 그 목록 아이콘을 누르면 즐겨찾기에 저장된 단어를 볼 수 있는 페이지로 이동하도록 구현한다. 아래와 같이 build() 메소드를 수정한다. 12345678910111213141516171819class RandomWordsState extends State&lt;RandomWords&gt; ｛ ... @override Widget build(BuildContext context) ｛ return new Scaffold( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: &lt;Widget&gt;[ // 여기서 부터 추가 ... new IconButton( icon: const Icon(Icons.list), onPressed: _pushSaved ), ], // ... 여기까지 ), body: _buildSuggestions(), ); ｝ ...｝ 일부 위젯 속성의 하위 항목(child)은 단일 위젯을 사용한다. 그리고 actions와 같은 몇몇 속성은 하위 항목(children)으로 대괄호([])로 표시된 위젯 배열을 사용한다. 그다음 RandomWordsState 클래스에 _pushSaved() 함수를 추가하자. 12void _pushSaved() ｛｝ 앱을 새로고침하면 AppBar에 아이콘()이 나타난다. 하지만 아직 _pushSaved 함수를 구현하지 않아서 아이콘을 눌러도 작동은 하지 않는다. 그다음 새 라우트를 만들고 네비게이터 스택에 푸시(push)해보자. 이렇게 하면 새로운 라우트가 화면에 표시된다. 아래와 같이 Navigator.push 함수를 호출하면 네비게이터 스택에 라우트가 푸시된다. 1234void _pushSaved() ｛ Navigator.of(context).push( );｝ 여기까지 구현하면 안드로이드 스튜디오에서 경고 메시지가 나올 것이다. 지금은 이 메시지를 무시해도 된다. 새 페이지의 내용은 MaterialPageRoute의 builder 속성에 이름없는 함수로 작성할 것이다. MaterialPageRoute와 builder 속성을 구현하자. 일단 ListTile 목록을 생성하는 코드를 추가한다. 그리고 toList() 함수에 의해 변환된 최종 목록 데이터를 divided에 저장한다. 여기서 ListTile의 divideTiles() 함수는 각 ListTile 사이에 구분선을 추가하는 기능을 갖고 있다. 아래와 같이 코드를 추가한다. 123456789101112131415161718192021222324void _pushSaved() ｛ Navigator.of(context).push( new MaterialPageRoute&lt;void&gt;( // 여기서 부터 추가... builder: (BuildContext context) ｛ final Iterable&lt;ListTile&gt; tiles = _saved.map( (WordPair pair) ｛ return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); ｝, ); final List&lt;Widget&gt; divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); ｝, ), // ... 여기까지 );｝ builder 속성에 &quot;Saved Suggestions&quot;라는 AppBar를 가진 Scaffold 위젯을 반환하도록 추가한다. 새 라우트의 본문(body)은 ListTiles 목록을 포함하는 ListView로 구성되고, 각 항목은 구분선으로 구분될 것이다. 아래와 같이 코드를 추가한다. 12345678910111213141516171819202122232425262728293031void _pushSaved() ｛ Navigator.of(context).push( new MaterialPageRoute&lt;void&gt;( builder: (BuildContext context) ｛ final Iterable&lt;ListTile&gt; tiles = _saved.map( (WordPair pair) ｛ return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); ｝, ); final List&lt;Widget&gt; divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); return new Scaffold( // 여기서 부터 추가 ... appBar: new AppBar( title: const Text('Saved Suggestions'), ), body: new ListView(children: divided), ); // ... 여기까지 ｝, ), );｝ 앱을 새로 고침한다. 이제 일부 단어를 즐겨찾기에 저장하고 AppBar에 있는 목록 아이콘을 눌러보자. 그러면 즐겨찾기로 저장한 단어만 있는 새로운 페이지로 이동한다. “뒤로가기” 버튼은 네비게이터에 의해 AppBar에 자동으로 추가된다. 그래서 우리는 Navigator.pop을 구현할 필요가 없다. 홈으로 돌아가기 위해서는 뒤로가기 버튼을 누르면 된다. 테마 변경하기 (Change the UI using Themes) 이번에는 앱 테마를 수정해 보자. 테마는 앱의 모양과 느낌을 제어한다. 실제 디바이스 또는 에뮬레이터에 있는 기본 테마를 사용하거나 또는 여러분의 브랜딩을 반영한 테마로 커스터마이즈 할 수도 있다. ThemeData 클래스를 사용하여 테마를 쉽게 변경할 수 있다 . 현재 기본 테마를 사용하고 있는 앱의 기본 색상을 흰색으로 바꿔보자. 아래와 같이 MyApp 클래스의 색상을 변경한다. 123456789101112class MyApp extends StatelessWidget ｛ @override Widget build(BuildContext context) ｛ return new MaterialApp( title: 'Startup Name Generator', theme: new ThemeData( // 여기서 부터 추가 ... primaryColor: Colors.white, ), // ... 여기까지 home: new RandomWords(), ); ｝｝ 앱을 새로 고침하면, AppBar를 포함한 전체 배경이 흰색으로 바뀐다. 연습삼아 앱 UI를 다른 색상으로도 변경해보자. 머티리얼 라이브러리의 Colors 클래스는 많은 색상 상수를 제공한다. 그리고 핫 리로드(hot reload)는 UI를 쉽고 빠르게 테스트 할 수 있게 해준다. 만약 앱이 제대로 작동하지 않는다면 lib/main.dart 코드를 참고하세요. 이것으로 구글 플러터 홈페이지에서 제공하는 “Write Your First Flutter App” 튜토리얼 강좌 1부와 2부를 모두 마쳤습니다. 저는 현재 튜토리얼만 경험해 보았습니다. 그리고 튜토리얼만으로 리액트 네이티브(React Native)와 플러터(Flutter)를 비교해보았을때, 개발환경 셋팅, 개발 속도, UI컴포넌트 부분에서는 플러터가 더 좋다고 생각됩니다. 앞으로 Flutter가 더 발전하여 React Native를 능가하는 모바일앱 개발 프레임워크가 되었으면 좋겠습니다. 여기까지 읽어주셔서 감사합니다. 이전 글 모바일 앱 개발 : Flutter 시작하기 #1 - Get started 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1) 모바일 앱 개발 : Flutter 시작하기 #3 - First Flutter App (2) 모바일 앱 개발 : Flutter 시작하기 #4 - First Flutter App (3) Sponsored ( Powered by dclick ) [백서툰] EOS 백서 만화로 이해하기 (2) 지난화에 이어 ‘EOS백서 만화로 이해하기’ 2편입니다. 백서 원문이 궁금하신 분들은 이곳을 … 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[Steemit] DCLICK 광고 링크 URL의 비밀?","slug":"/dclick/@anpigon/dclick-url--1539966962466","date":"2018-10-19T16:36:03.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/dclick/@anpigon/dclick-url--1539966962466/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/dclick-url--1539966962466/","excerpt":"안녕하세요. @anpigon 입니다.오늘 dclick에서 글을 작성하다보니 변화가 생긴것 같아서 살펴보았습니다.이제는 SHOW AD에 광고 샘플이 보이네요.포스트를 작성하고 나서 dclick 광고의 링크를 보니 JWT 형태로 보이는 토큰이 보입니다.혹시나 하고 토큰을 디코딩을 해보았습니다. HS256 알고리즘으로 인코딩된 JWT(JSON Web Tokens)이 맞습니다.","text":"안녕하세요. @anpigon 입니다.오늘 dclick에서 글을 작성하다보니 변화가 생긴것 같아서 살펴보았습니다.이제는 SHOW AD에 광고 샘플이 보이네요.포스트를 작성하고 나서 dclick 광고의 링크를 보니 JWT 형태로 보이는 토큰이 보입니다.혹시나 하고 토큰을 디코딩을 해보았습니다. HS256 알고리즘으로 인코딩된 JWT(JSON Web Tokens)이 맞습니다. 참고로 JWT는 토큰형태의 회원인증 시스템에 많이 사용됩니다. 디코딩된 토큰 내용을 살펴보면 username과 해당 포스팅의 permlink 등이 포함되어있습니다. a 에 있는 203값은 잘 모르겠네요. iat와 exp의 값의 의미도 잘 모르겠습니다. 그리고 토큰에 포함되어 있는 s값은 해당 포스트에 등록된 광고가 맞는지 체크하는 용도로 사용될 것으로 생각됩니다. 시간나면 더 분석해보고 싶네요.ㅋ 혹시 다른 앱에서 포스트를 작성하고 dclick 광고를 삽입하려면 어떻게 해야하나요?ㅎㅎ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) ■ Lego 프리뷰 / 레고 소식 이모저모♥ 안녕하세요? 김달걀입니다 : ) 이번 Lego 프리뷰 포스팅은 거의 4개월만이네요! 벌써 4분… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[Flutter] 모바일 앱 개발 : Flutter 시작하기 #4 - First Flutter App (3)","slug":"/dclick/@anpigon/-flutter-4-first-flutter-app-3-1539963641589","date":"2018-10-19T15:40:42.000Z","updated":"2019-11-11T13:41:49.839Z","comments":true,"path":"/dclick/@anpigon/-flutter-4-first-flutter-app-3-1539963641589/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-flutter-4-first-flutter-app-3-1539963641589/","excerpt":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #3&quot;에서 이어집니다. Flutter 튜토리얼 파트2의 1~5번까지의 과정을 따라하면서 학습하였습니다. 이번에는 하트 아이콘을 추가하고 단어를 즐겨찾기에 추가/제거하는 기능을 구현합니다.","text":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #3&quot;에서 이어집니다. Flutter 튜토리얼 파트2의 1~5번까지의 과정을 따라하면서 학습하였습니다. 이번에는 하트 아이콘을 추가하고 단어를 즐겨찾기에 추가/제거하는 기능을 구현합니다. 이번에 구현한 완성된 앱의 동작 화면입니다. 목록에 하트 아이콘 추가하기 목록의 각 행에 하트 아이콘을 추가한다. 그리고 하트 아이콘을 누르면 즐겨찾기에 저장한다. RandomWordsState 클래스에 _saved Set을 추가한다. _saved 에는 사용자가 선택한 단어를 저장할 것이다. 참고로 Set에는 중복된 값이 허용되지 않는다. 123456class RandomWordsState extends State&lt;RandomWords&gt; ｛ final List&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[]; final Set&lt;WordPair&gt; _saved = new Set&lt;WordPair&gt;(); // 추가된 코드 final TextStyle _biggerFont = const TextStyle(fontSize: 18.0); ...｝ _buildRow() 함수에 alreadySaved 변수를 추가한다. alreadySaved는 해당 단어가 즐겨찾기에 추가되어 있는지 여부를 확인한다. 1234Widget _buildRow(WordPair pair) ｛ final bool alreadySaved = _saved.contains(pair); // 추가된 코드 ...｝ 이제 ListTile 객체에 하트 아이콘을 추가하여 즐겨찾기 기능을 구현해보자. 하트 아이콘은 ListTile의 trailing 속성을 사용하여 추가한다. trailing 속성은 일반적으로 제목 뒤에 아이콘 위젯을 표시 할때 사용된다. RandomWordsState 클래스의 _buildRow() 함수를 아래와 같이 수정한다. 12345678910111213Widget _buildRow(WordPair pair) ｛ final bool alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( // 여기서부터 추가된 코드 ... alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), // ... 여기까지 );｝ 안드로이드 스튜디오는 왼쪽 패널에서 아이콘 모양과 색상을 바로 확인할 수 있다. 이제 앱을 새로고침하면 목록에 하트 아이콘이 보인다. 아이폰 안드로이드 즐겨찾기에 단어 저장하기 이번에는 목록에서 단어를 선택하면 즐겨찾기에 추가되도록 구현해보자. 이미 단어가 즐겨찾기에 추가된 경우에는 즐겨찾기에서 제거되도록 한다. 그리고 state가 변경되었음을 프레임워크에 알려주기 위해 setState() 함수를 호출하였다. 참고로 setState() 함수를 호출하면 State 객체의 build() 함수 호출이 트리거되어 UI가 업데이트된다. 아래와 같이 _buildRow 함수에 onTap 속성을 추가한다. 12345678910111213141516171819202122Widget _buildRow(WordPair pair) ｛ final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () ｛ // 여기서부터 추가된 코드 ... setState(() ｛ if (alreadySaved) ｛ _saved.remove(pair); ｝ else ｛ _saved.add(pair); ｝ ｝); ｝, // ... 여기까지 );｝ 앱을 새로고침한다. 이제 원하는 단어를 선택하면 즐겨찾기에 추가 할 수 있다. 아이폰 안드로이드 만약 앱이 제대로 작동하지 않는다면 lib/main.dart 코드를 참고하세요. 여기까지 읽어주셔서 감사합니다. 이전 글 모바일 앱 개발 : Flutter 시작하기 #1 - Get started 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1) 모바일 앱 개발 : Flutter 시작하기 #3 - First Flutter App (2) Sponsored ( Powered by dclick ) [트립스팀]할로윈을 즐기고 싶다면 에버랜드로!!(10/14-15) ![image]( 안녕하세요 달콤한 아빠 입니다 저희 가족은 지난 월요일 에버랜드라는 정말 좋… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[Flutter] 모바일 앱 개발 : Flutter 시작하기 #3 - First Flutter App (2)","slug":"/dclick/@anpigon/-flutter-3-write-your-first-flutter-app-part-12-1539616614961","date":"2018-10-15T15:16:57.000Z","updated":"2019-11-11T13:41:49.839Z","comments":true,"path":"/dclick/@anpigon/-flutter-3-write-your-first-flutter-app-part-12-1539616614961/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-flutter-3-write-your-first-flutter-app-part-12-1539616614961/","excerpt":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #2 &quot;에서 이어지는 내용입니다. Flutter 튜토리얼 파트1의 5~7번까지의 과정을 따라하면서 정리하였습니다. 이번에는 Stateful 위젯과 무한 스크롤 ListView를 구현하는 방법을 학습합니다.","text":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기 #2 &quot;에서 이어지는 내용입니다. Flutter 튜토리얼 파트1의 5~7번까지의 과정을 따라하면서 정리하였습니다. 이번에는 Stateful 위젯과 무한 스크롤 ListView를 구현하는 방법을 학습합니다. 원문을 보고 싶으면 아래 링크를 클릭하세요. https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/#0 Stateful 위젯 추가하기 이번 단계에서 우리는 stateful 위젯인 RandomWords를 추가할 것이다. 이 RandomWords는 State 클래스인 RandomWordsState를 생성한다. 그 다음에는 RandomWords를 MyApp Stateless 위젯의 child로 사용할 것이다. Stateless 위젯은 immutable이다. 그래서 Stateless 위젯의 모든 속성값은 변경할 수 없다. 참고로 앞에서 우리는 MyApp 클래스를 Stateless 위젯을 확장하여 구현하였다. 하지만 Stateful 위젯은 유지되는 동안 변경될 수 있는 상태를 유지한다. Stateful 위젯을 구현하기 위해서는 최소 2개의 클래스가 필요하다. State 클래스와 State 클래스의 인스턴스를 생성하는 StatefulWidget 클래스이다 . StatefulWidget 클래스는 그 자체로 immutable이지만, State 클래스는 위젯이 유지되는 동안 없어지지 않는다. Stateless와 Stateful 위젯은 텍스트 설명만 보고는 이해하기가 어렵다. 하지만 앞으로도 계속 있을 튜토리얼을 따라서 구현하다 보면 저절로 이해가 될 것이다. 우선 간단한 State 클래스를 먼저 만들어보자. 외부 파일로 생성해도 되지만 우리는 main.dart 파일에 입력한다. main.dart 파일 맨 아래에 RandomWordsState 클래스를 추가하자. 123class RandomWordsState extends State&lt;RandomWords&gt; ｛ // TODO Add build method｝ State&lt;RandomWords&gt;는 RandomWords와 같이 사용할 수 있도록 구현된 일반적인 State 클래스를 사용하고 있음을 나타낸다. 대부분 앱의 로직과 상태(state)는 여기에 위치하며, RandomWords 위젯의 상태를 유지한다. RandomWordsState 클래스는 사용자가 스크롤할 때 무한히 생성되는 단어들을 저장한다. 이제 Stateful 위젯인 RandomWords 클래스를 main.dart에 추가하자. 참고로 RandomWords는 RandomWordsState를 생성하는 것 외에는 사용되지 않는다. 1234class RandomWords extends StatefulWidget ｛ @override RandomWordsState createState() =&gt; new RandomWordsState();｝ State 클래스를 추가하고 나면 안드로이드 스튜디오는 클래스에 빌드 메서드(build method)가 누락되어 있다고 알려줄 것이다. 이 메시지는 무시해도 된다. 그다음에는 영어단어를 생성하는 코드를 MyApp 클래스에서 RandomWordsState로 이동하자. 아래와 같이 RandomWordsState에 영어단어를 생성하는 build 메서드를 추가한다. 1234567class RandomWordsState extends State&lt;RandomWords&gt; ｛ @override // Add from this line ... Widget build(BuildContext context) ｛ final WordPair wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); ｝ // ... to this line.｝ 그리고 MyApp 클래스에서는 영어단어를 생성하는 코드를 제거한다. 12345678910111213141516171819class MyApp extends StatelessWidget ｛ @override Widget build(BuildContext context) ｛ final WordPair wordPair = new WordPair.random(); // Delete this line. return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( //child: new Text(wordPair.asPascalCase), // Change this line to... child: new RandomWords(), // ... this line. ), ), ); ｝｝ 코드를 수정하고 나면 앱이 자동으로 새로 고침(Hot reload)이 된다. 만약 자동 새로 고침이 되지 않는다면 앱을 중지하고 다시 시작해보자. 무한 스크롤 ListView 만들기 RandomWordsState 클래스를 확장하여 무한 스크롤되는 단어 목록을 생성해보자. 사용자가 스크롤링하면 ListView 위젯에 표시된 단어 목록이 무한으로 증가할 것이다. ListView의 builder 팩토리 생성자를 사용하면 목록 뷰를 필요할 때에 지연 생성 할 수 있다. 단어 목록을 저장할 _suggestions 변수를 RandomWordsState 클래스에 추가한다 . 그리고 글꼴을 크게 만드는 텍스트 스타일 _biggerFont도 추가한다. 123456class RandomWordsState extends State&lt;RandomWords&gt; ｛ // Add the next two lines. final List&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[]; final TextStyle _biggerFont = const TextStyle(fontSize: 18.0); ...｝ Dart에서는 변수 앞에 밑줄(_)을 붙이면 privacy이 적용된다. 그다음에는 _buildSuggestions() 메서드를 RandomWordsState 클래스에 추가한다 . 이 메서드는 단어 목록을 표시하는 ListView를 빌드할 것이다. ListView 클래스는 builder 속성으로 팩토리 빌더 및 콜백 함수인 itemBuilder를 제공한다. 이 함수에는 두 개의 매개 변수 BuildContext와 row iterator가 전달된다. iterator는 0부터 시작하여 함수가 호출 될 때마다 매번 증가한다. 이 모델이 무한 스크롤을 가능하게 한다. 아래와 같이 RandomWordsState 클래스에 _buildSuggestions 함수를 추가한다. 123456789101112131415161718192021222324252627Widget _buildSuggestions() ｛ return new ListView.builder( padding: const EdgeInsets.all(16.0), // itemBuilder 콜백은 생성된 단어마다 한 번씩 호출되고 각 단어를 ListTile row에 배치한다. // 짝수 행의 경우 이 함수는 단어에 대한 ListTile row를 추가한다. itemBuilder: (BuildContext _context, int i) ｛ // 홀수 행의 경우 구분선(Divider) 위젯을 추가한다. if (i.isOdd) ｛ return new Divider(); ｝ // 코드 \"i ~/ 2\"는 i를 2로 나눈 몫을 반환한다. // 예를 들면, 1, 2, 3, 4, 5는 0, 1, 1, 2, 2이 된다. // Divider 위젯을 제외한 ListView의 실제 단어 수를 계산하기 위함이다. final int index = i ~/ 2; // 사용 가능한 단어 목록이 끝나면 ... if (index &gt;= _suggestions.length) ｛ // ... 단어 10개를 더 생성하고 단어 목록에 추가. _suggestions.addAll(generateWordPairs().take(10)); ｝ return _buildRow(_suggestions[index]); ｝ );｝ _buildSuggestions 함수는 단어마다 한 번씩 _buildRow 함수를 호출한다. RandomWordsState에 _buildRow 함수를 추가하자. 12345678Widget _buildRow(WordPair pair) ｛ return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), );｝ 이제 RandomWordsState의 _buildSuggestions() 함수를 호출하도록 수정한다. 123456789101112@overrideWidget build(BuildContext context) ｛ //final wordPair = new WordPair.random(); // Delete these... //return new Text(wordPair.asPascalCase); // ... two lines. return new Scaffold ( // Add from here... appBar: new AppBar( title: new Text('Startup Name Generator'), ), body: _buildSuggestions(), ); // ... to here.｝ 여기서 Scaffold는 기본 머티리얼 디자인의 시각적 레이아웃을 구현한다. 마지막으로 MyApp의 title과 build() 함수를 수정하자. 아래와 같이 RandomWords 위젯의 home 부분을 new RandomWords()로 수정한다. 1234567@overrideWidget build(BuildContext context) ｛ return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), );｝ 앱이 새로 고침이 되고 나면 아래 화면과 같이 무한 스크롤이 작동할 것이다. 만약 앱이 제대로 작동하지 않는다면 lib/main.dart 코드를 참고하세요. 여기까지 읽어주셔서 감사합니다. 이전 글 모바일 앱 개발 : Flutter 시작하기 #1 - Get started 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1) Sponsored ( Powered by dclick ) 구글 코리아, 페이스북 국내 매출을 사장이 모른다? 오늘 국감장에 나온 구글코리아 존리 대표가 국감장에 출석해서 국내 매출 정보를 알려줄 수 없다… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"크롬 브라우저 이스트 에그 : 텍스트 어드벤처 게임","slug":"/dclick/@anpigon/--1539437480245","date":"2018-10-13T13:31:21.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/dclick/@anpigon/--1539437480245/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/--1539437480245/","excerpt":"안녕하세요. @anpigon 입니다.80~90년대 초에 유행했던 텍스트 어드벤처 게임을 아시나요? 저는 텍스트로만 진행되는 어드벤처 게임을 경험해보진 못했습니다. 하지만 비슷한 장르의 게임인 원숭이섬의 비밀을 재미있게 했던 기억이 납니다.아래는 attempt_number_1 유저가 발견하여 reddit에 공개한 이스트 에그입니다. reddit에 댓글이 유난히 많이 달린 글이 있길래 무심코 클릭했더니 재미있는 것을 발견했습니다. 구글 텍스트 어드벤처 게임입니다.","text":"안녕하세요. @anpigon 입니다.80~90년대 초에 유행했던 텍스트 어드벤처 게임을 아시나요? 저는 텍스트로만 진행되는 어드벤처 게임을 경험해보진 못했습니다. 하지만 비슷한 장르의 게임인 원숭이섬의 비밀을 재미있게 했던 기억이 납니다.아래는 attempt_number_1 유저가 발견하여 reddit에 공개한 이스트 에그입니다. reddit에 댓글이 유난히 많이 달린 글이 있길래 무심코 클릭했더니 재미있는 것을 발견했습니다. 구글 텍스트 어드벤처 게임입니다. 어드벤처 게임의 프롤로그는 이렇게 시작합니다. A strange tingle trickles across your skin. You feel lightheaded and sit down. Feeling better you stand up again and notice your reflection in a window. You are still the same big blue G you’ve always been and you can’t help but smile. reddit에 올라온 원글을 보고 싶으면 아래 링크를 클릭하세요. https://www.reddit.com/r/eastereggs/comments/9kuxik/uattempt_number_1_found_a_crazy_easter_egg/ 텍스트 어드벤처 게임 실행 방법 아래 순서대로 진행하면 게임을 플레이 할 수 있습니다. 참고로 크롬 브라우저만 가능합니다. 크롬 브라우저에서 www.google.com를 접속한다. 언어를 English 로 변경한다. 검색창에서 text adventure 를 검색한다. 개발자 도구의 콘솔창을 연다. 단축키(윈도우): Ctrl + Shift + I 단축키(맥OS): Command + Option + I 텍스트 어드벤처 게임을 즐긴다. yes를 입력하면 시작합니다. 텍스트 어드벤처 게임을 플레이 중인 화면 크롬 브라우저의 다른 이스트 에그 게임들 크롬 브라우저에는 다른 재미있는 이스트 에그 게임도 있습니다. 그 중에서 재미있는 것을 몇 개 골라보았습니다. 설명이 필요없어 텍스트는 적지 않았습니다. 캡쳐한 화면을 보시죠.ㅋ google birthday surprise spinner Google Pacman atari breakout 구글에는 숨겨진 이스트 에그가 정말 많습니다. 다른 이스트 에그도 찾아보고 싶으면 여기를 참고하세요. https://en.wikipedia.org/wiki/List_of_Google_Easter_eggs 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) 비트소닉 거래소 가입하면 17000원이!! 안녕하세요 빔바입니다 😃 오늘 스팀잇에서 @hyokhyok님의 글을 보고 좋은 소식을 알게 … 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"IT개발자로 사는 방법 #1","slug":"/dclick/@anpigon/it-1-1539271664721","date":"2018-10-11T15:27:45.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/dclick/@anpigon/it-1-1539271664721/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/it-1-1539271664721/","excerpt":"안녕하세요. @anpigon 입니다.요즘 구상하고 있는 내용이 있어서 글을 써보려고 합니다. 하지만 글만있으면 내용이 너무 지루하고 재미없기 때문에 그림도 그려서 넣었습니다. 참고로 제가 그린 그림은 오래전에 유명했던 삽화를 보고 따라 그린 것입니다. 여러가지 버전으로 그려봤는데 이게 제일 맘에 드네요.ㅋ","text":"안녕하세요. @anpigon 입니다.요즘 구상하고 있는 내용이 있어서 글을 써보려고 합니다. 하지만 글만있으면 내용이 너무 지루하고 재미없기 때문에 그림도 그려서 넣었습니다. 참고로 제가 그린 그림은 오래전에 유명했던 삽화를 보고 따라 그린 것입니다. 여러가지 버전으로 그려봤는데 이게 제일 맘에 드네요.ㅋ 그리고 재미있게 표현하려고 내용에는 약간의 허구가 포함되었습니다. 모든 개발자의 삶이 이렇지는 않습니다. 저는 멋진 개발자를 꿈꿉니다. SI 개발자 나는 SI 개발자다. SI 개발자란? 전산시스템을 필요로 하는 업체(기관)에 투입되어 시스템을 개발하고 운영 및 유지보수를 하는 개발자를 말한다. SI는 System Integration(시스템 구축)의 약자이다. SI 대신 ‘IT 아웃소싱’이라는 단어를 사용하기도 한다. “저는 시스템 인터그래이션 개발자입니다” 라고 말하면 좀 멋져 보일수도 있다. 하지만 실상은 이렇다. SI 개발자들은 구로 또는 가산디지털단지에 많이 거주한다. 잠자고 생활하는 집은 따로 있지만 밀린 개발업무를 처리하느라 집에 갈 시간이 없다. 그래서 주로 회사에서 먹고 자고 생활한다. 한국의 야경이 아름다운 이유는 야근하는 사람이 많아서다. 그리고 구로/가산디지털단지에 가면 인력업체 직원이 개발자 인력을 구하는 장면을 쉽게 볼 수 있다. (위 장면은 사실이 아님을 미리 밝힙니다.) # SI 프로젝트 개발 기간 산정 방법 SI 프로젝트 개발 기간은 보통 맨먼스(Man/Month)로 산정한다. 맨먼스(M/M)란? 공휴일을 제외한 영업일 기준으로 한달 동안 시스템을 개발하는데 필요한 인원수를 의미한다. 모든 구성원의 능력은 같다는 전제하에 예를 들어보자. · 1명이 참여해서 한달 일하면 1M/M · 5명이 참여해서 한달 일하면 5M/M 만약, 10명이 참여해서 6개월 걸리는 프로젝트라면 멤먼스는 10 x 6 = 60M/M 가 된다. 계산 방법은 매우 간단하다. 하지만, 프로젝트 기간을 3개월도 줄이고 싶다면 인원을 2배로 투입하면 된다. 2배로 투입된 인원수로 다시 계산해보자. 20명이 3개월이면 20 x 3 = 60M/M으로 아까와 동일한 멤먼스가 산출된다. 시스템 구축은 보통 기획/설계 &gt; 디자인 &gt; 개발 &gt; 테스트 단계로 진행된다. 보통은 순서대로 진행된다. 각 단계를 완료하는데 1개월이라고 하면, 전체 프로젝트를 완료하는 데에는 약 4개월을 예상해 볼 수 있다. 하지만 멤먼스 계산 방식으로 인원수를 2배로 늘리면 개발 기간을 절반으로 줄일 수 있다. 여기에는 모순이 존재한다. 발생 가능한 시나리오를 적어보겠다. 모 금융사에서 9월에 신규 서비스를 오픈한다고 발표하였다. 하지만 SI 업체와 프로젝트 계약은 6월에 하였다. 이제 서비스 오픈일까지는 3개월 남았다. 원래 20명이 6개월 정도 걸리는 프로젝트지만, 마법의 가루(M/M)만 있으면 기간을 절반으로 줄일 수 있다. 40명을 투입하여 프로젝트 기간을 3개월로 줄였다. “사공이 많으면 산으로 간다고 했던가?” 생각보다 기획/설계자가 많이 투입되었다. 다른 생각 또는 의견 충돌로 기획/설계가 늦어진다. 예상했던 기획/설계 완료 일정을 훌쩍 넘겼다. 겨우 기획/설계가 완료되었지만, 서비스 오픈일은 이제 한 달도 남지 않았다. 게다가 디자이너가 디자인 작업을 이제 시작하여 디자인은 나오지도 않았다. 서비스 오픈 일정이 촉박하니 개발자들은 UI 디자인 없이 개발을 시작한다. 디자인이 나오면 시스템에 UI를 적용하는 일은 나중에 따로 하기로 한다. 이제 오픈일까지 2주 남았다. 개발 시간이 부족하여 아직 기능 개발이 안된 부분이 있다. 그러나 오픈일정을 맞추기 위해 서둘러서 알파 테스트를 시작한다. 프로젝트 팀장(PM)의 계산대로라면 테스트 하는 동안에 개발이 100％ 완료 될 것이다. 하지만 테스트 하면서 심각한 오류들이 계속 발견된다. … … 이건 … … … 그 다음은 상상에 맡깁니다… 혼자서 서울에서 부산까지 걸어가면 약 15박 16일이 소요된다. 그럼 2명이서 걸어가면 7박 8일만에 갈수있다 것과 비슷하다. 7박8일만에 가려면 잠도 안자고 계속 걸어야한다. 여기까지 읽어 주셔서 감사합니다. 이벤트 퀴즈(종료) 글 내용에 포함되어 있는 그림의 장소를 맞춰보세요. 제일 먼저 맞추는 한 분께 상금 1 SBD 드립니다. 서울이 아닌 타 지역에 계신 분들께는 죄송합니다. 참고로 구로/가산디지털 지역은 아닙니다. 힌트 지하철 2호선 라인 정답자 @thrufore 님이 맞추셨습니다. 축하합니다. 정답은 “을지로3가” 였습니다. 그리고 귀여운 뱀 이모티콘 만들었어요. (^^ @wonsama ~ Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"안피곤 천하제일 코딩 대회 결과 발표","slug":"/dclick/@anpigon/-anpigoncodingcontestresult--1539185552232","date":"2018-10-10T15:32:33.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/dclick/@anpigon/-anpigoncodingcontestresult--1539185552232/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-anpigoncodingcontestresult--1539185552232/","excerpt":"안녕하세요. @anpigon입니다.안피곤 천하제일 코딩 대회가 마무리되었습니다. 그동안 수고해 주신 참가자분들에게 모두 감사드립니다.참고로 이번 대회의 목적은 코딩에 관한 관심을 끌어오고 뉴비를 지원하는 데에 목적이 있었습니다. 그 목적을 달성한 것 같아서 너무 기쁩니다.","text":"안녕하세요. @anpigon입니다.안피곤 천하제일 코딩 대회가 마무리되었습니다. 그동안 수고해 주신 참가자분들에게 모두 감사드립니다.참고로 이번 대회의 목적은 코딩에 관한 관심을 끌어오고 뉴비를 지원하는 데에 목적이 있었습니다. 그 목적을 달성한 것 같아서 너무 기쁩니다. 그럼 수상자를 발표합니다. ★ 1등 : 대상 ★ @thrufore님 블로그 주소: http://thrufore.pythonanywhere.com 개발자가 아니신데도 금방 만드셨습니다. 일반인이지만 코딩에 대한 이해도가 매우 높은 편입니다. 혹시 개발자 하실 생각은 없으신가요? ㅋ 낮은 명성과 개발자가 아닌 데서 높은 점수를 받았습니다. ★ 2등 : 최우수상 ★ @apmmh님 블로그 주소: http://blacknred.pythonanywhere.com C 개발만 하시다가 웹 개발은 처음이라고 하셨는데 잘 만드셨습니다. 상단에 FEED와 HOT 메뉴를 추가하셨네요. 낮은 명성 덕분에 높은 점수를 받았습니다. 그리고 본문 이미지 URL을 정규식으로 처리하는 데 도움을 주셔서 감사합니다. ★ 3등 : 우수상 ★ @jisoooh0202님 블로그 주소: http://jisoooh0202.pythonanywhere.com 마지막 날에 늦게까지 개발해서 제출하셨습니다. 잘 만드셨습니다. 개발자가 아닌 데서 높은 점수를 받았습니다. ★ 4등 : 장려상 ★ @hjh0827님 블로그 주소: http://hjh0827.pythonanywhere.com 제가 블로그 만들기 시리즈 글을 연재할 때부터 참여해서 만드셨습니다. 그리고 파이썬은 처음이라고 하셨는데 잘 만드셨어요. 글 목록에 카테고리를 추가했고, 상단메뉴에는 피드와 테이스팀 바로가기를 추가하셨네요. ★ 5등 : 입상 ★ @bbooaae님 블로그 주소: http://kakaofreinds.pythonanywhere.com 여러번 실패와 도전끝에 만드셨습니다. 열정에 박수를 드립니다. 이제는 익숙해져서 금방 하실 거에요. 아래 두 분도 잘 만드셨습니다. 하지만 높은 명성도 때문에 아쉽게도 입상하지 못하였어요. 하지만 개발하느라 고생하셨기 때문에 아차상으로 상금 0.5 STEEM를 드립니다. @urobotics님 : http://kakaofreinds.pythonanywhere.com @glory7님 : http://glory7.pythonanywhere.com 많은 관심으로 응원해주고 참여해주셔서 코딩 대회가 진행되는 동안 너무 즐거웠습니다. 모두 감사합니다. https://media.giphy.com/media/Kwi3CtKyY5vd6/giphy.gif Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[아티스팀] 캘리그라피 도전 : 꿈을 향한 열정 ","slug":"/artisteem/@anpigon/artisteem--anpigon--682479670--artisteem-busy-calligraphy-jjangjjangman-kr--2018-10-09-18-16-12--artwork--none","date":"2018-10-09T09:16:15.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/artisteem/@anpigon/artisteem--anpigon--682479670--artisteem-busy-calligraphy-jjangjjangman-kr--2018-10-09-18-16-12--artwork--none/","link":"","permalink":"https://anpigon.github.io/artisteem/@anpigon/artisteem--anpigon--682479670--artisteem-busy-calligraphy-jjangjjangman-kr--2018-10-09-18-16-12--artwork--none/","excerpt":"","text":"꿈을 향한 열정캘리그라피를 배워본 적은 없지만 도전합니다~! Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다.안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"아티스팀","slug":"아티스팀","permalink":"https://anpigon.github.io/tags/아티스팀/"},{"name":"캘리그라피","slug":"캘리그라피","permalink":"https://anpigon.github.io/tags/캘리그라피/"}],"author":"anpigon"},{"title":"[Flutter] 모바일 앱 개발 : Flutter 시작하기 #2 - First Flutter App (1)","slug":"/kr/@anpigon/flutter-2-write-your-first-flutter-app-part-1","date":"2018-10-08T16:40:54.000Z","updated":"2019-11-11T13:41:49.839Z","comments":true,"path":"/kr/@anpigon/flutter-2-write-your-first-flutter-app-part-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/flutter-2-write-your-first-flutter-app-part-1/","excerpt":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기&quot;에서 이어지는 내용입니다. 이번에는 Flutter 튜토리얼 파트1의 1~4번까지의 과정을 따라하면서 정리하였습니다.원문을 보고 싶으면 아래 링크를 클릭하세요. https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/#0","text":"안녕하세요. @anpigon 입니다.이전 글 &quot;모바일 앱 개발 : Flutter 시작하기&quot;에서 이어지는 내용입니다. 이번에는 Flutter 튜토리얼 파트1의 1~4번까지의 과정을 따라하면서 정리하였습니다.원문을 보고 싶으면 아래 링크를 클릭하세요. https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/#0 아래 발췌한 글은 Flutter 튜토리얼의 첫 문단에 있는 글입니다. 간단하게 말하면 배우기 쉽다는 말입니다. 아랫글을 읽고 나면 Flutter를 학습하는 것에 대한 부담감이 많이 줄어듭니다. 부담감 -99.99％가 되어 결과적으로 학습에 대한 부담감은 0.01％가 됩니다. 쉽게 말하면, 키보드와 마우스만 다룰 줄 알면 누구나 배울 수 있습니다. 이것은 첫 번째 Flutter앱 만드는 방법을 안내합니다. 객체 지향 및 기본 프로그래밍 개념에 익숙하지 않아도 완료 할 수 있습니다. 다트(Dart) 또는 모바일 프로그래밍에 대한 경험은 필요하지 않습니다. 위 사진은 제가 할머니께 Flutter앱 만드는 방법을 설명하고 있는 장면입니다. 이번 파트1에서는 우리는 다음을 학습하게 됩니다. iOS와 Android에서 자연스럽게 보이는 Flutter 앱을 작성하는 방법. Flutter 앱의 기본 구조. 외부 패키지를 사용하여 기능을 확장하는 방법. 더 빠른 개발을 위한 Hot Reload 사용 방법. Stateful 위젯을 구현하는 방법. 무한 스크롤(infinite scrolling)과 지연된 로딩 ListView를 만드는 방법. Create the starter Flutter app 안드로이드 스튜디오에서 New Flutter Project를 생성합니다. Project Name에는 startup_namer를 입력합니다. New Flutter Application이 생성되면 아래와 같이 코드를 편집할 수 있는 화면이 나타납니다. lib/main.dart의 내용을 모두 지우고 아래 코드를 복사&amp;붙여넣기 합니다. 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget ｛ @override Widget build(BuildContext context) ｛ return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: const Text('Welcome to Flutter'), ), body: const Center( child: const Text('Hello World'), ), ), ); ｝｝ 한 줄 함수에는 화살표(=&gt;) 함수(fat arrow notatio)를 사용합니다. 메인 함수도 화살표 함수가 사용되었습니다. 이 앱은 StatelessWidget 위젯을 확장하여 앱자체를 위젯으로 만들었습니다. 그리고 Material 라이브러리에서 제공하는 Scaffold 위젯은 기본 appBar, title, body property를 제공합니다. 위 예제의 body에는 Text 위젯을 포함하고 있는 Center 위젯으로 구성되어 있습니다. Center 위젯은 하위 위젯을 가운데 정렬하는 기능을 가지고 있습니다. Use an external package 이번에는 english_words 오픈 소스 패키지를 사용해 봅니다. english_words 패키지에는 가장 많이 사용되는 영단어와 유용한 유틸리티가 포함되어 있습니다. 필요한 오픈 소스 패키지는 pub.dartlang.org에서 찾아볼 수 있습니다. Flutter의 assets은 pubspec 파일에서 관리합니다. pubspec.yaml 파일을 열고 english_words : ^ 3.1.0을 dependencies 목록에 추가합니다. 123456dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 # add this line pubspec 파일을 열고 있는 편집창에서 Packages get 링크를 클릭합니다. 그러면 패키지를 내려받아 가져오는 것을 콘솔창에서 확인할 수 있습니다. lib/main.dart 파일을 열고 새로운 패키지 english_words를 임포트(import) 합니다. 12import 'package:flutter/material.dart';import 'package:english_words/english_words.dart'; // Add this line. 참고로 편집창에서 글자가 회색으로 보이는 것은 임포트된 해당 패키지가 사용되지 않았음을 나타냅니다. 그 다음에는 english_words 패키지를 사용하여 영단어 텍스트를 생성합니다. 변경된 전체 코드는 아래와 같습니다. 1234567891011121314151617181920212223import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget ｛ @override Widget build(BuildContext context) ｛ final wordPair = new WordPair.random(); // Add this line. return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( // Change \"const\" to \"new\". //child: const Text('Hello World'), // Replace this text... child: new Text(wordPair.asPascalCase), // With this text. ), ), ); ｝｝ Text 위젯이 더 이상 상수(const)가 아니기 때문에 Text 위젯을 포함하고 있는 Center 위젯도 new 를 사용하여 인스턴스를 생성해야 합니다. 참고로 wordPair.asPascalCase은 영단어를 파스칼 표기법으로 표현합니다. 예를 들어, &quot;upper camel case&quot;는 &quot;UpperCamelCase&quot;로 표현됩니다. 이제 run 버튼을 클릭하여 앱을 빌드&amp;실행합니다. 만약 앱이 이미 실행 중이라면 hot reload 버튼만 클릭하면 됩니다. 그럼 변경된 부분이 바로 앱에 반영됩니다. 아래는 실행 결과입니다. 전 안드로이드폰을 사용하고 아이폰은 한번도 사용해보지 않았습니다. 그러나 안드로이드와 아이폰의 차별을 두지 않기 위해 둘다 빌드&amp;실행해 보았습니다. 안드로이드 아이폰 축하합니다. 안드로이드와 아이폰 둘다 빌드&amp;실행에 성공하였습니다. 재미삼아 실제 제가 작업하고 있는 화면을 캡처 해보았습니다. 좌 아이폰, 우 안드로이드입니다. 그런데 코딩 창이 너무 작아서 불편합니다.ㅠ 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[Flutter] 모바일 앱 개발 : Flutter 시작하기 - Get started","slug":"/dclick/@anpigon/-flutter--1538895504796","date":"2018-10-07T06:58:27.000Z","updated":"2019-11-11T13:41:49.839Z","comments":true,"path":"/dclick/@anpigon/-flutter--1538895504796/","link":"","permalink":"https://anpigon.github.io/dclick/@anpigon/-flutter--1538895504796/","excerpt":"Flutter는 구글에서 개발한 크로스 플랫폼 모바일 앱 개발 프레임워크입니다. Flutter가 아직은 베타 버전이지만 곧 React Native를 따라잡을 것으로 생각합니다. 그럼 페이스북과 구글의 치열한 경쟁이 시작되겠지요.ㅋFlutter Release Preview 2 가 공개되었을 때 너무 배워보고 싶었습니다. 오늘 문서를 쭈욱 훑어보니 React Native, NativeScript와 정말 흡사한 프레임워크라고 생각되네요. 이러한 개발 프레임워크를 이용하면 저 같은 초보 개발자도 모바일 앱을 쉽게 구현할 수 있습니다. 개발자가 아닌 분들은 이해 못 하시겠지만, 전 아직도 완벽하게 다룰 수 있는 개발언어가 없는 초보 개발자입니다. 초보 개발자라서 이것 저것 배우고 해볼 수 있는 시기이기도 합니다. 시간이 흘러 시니어 개발자가 되면 머리가 굳어져 새로운 기술을 배우기가 더욱 힘들어지겠지요. ㅠ","text":"Flutter는 구글에서 개발한 크로스 플랫폼 모바일 앱 개발 프레임워크입니다. Flutter가 아직은 베타 버전이지만 곧 React Native를 따라잡을 것으로 생각합니다. 그럼 페이스북과 구글의 치열한 경쟁이 시작되겠지요.ㅋFlutter Release Preview 2 가 공개되었을 때 너무 배워보고 싶었습니다. 오늘 문서를 쭈욱 훑어보니 React Native, NativeScript와 정말 흡사한 프레임워크라고 생각되네요. 이러한 개발 프레임워크를 이용하면 저 같은 초보 개발자도 모바일 앱을 쉽게 구현할 수 있습니다. 개발자가 아닌 분들은 이해 못 하시겠지만, 전 아직도 완벽하게 다룰 수 있는 개발언어가 없는 초보 개발자입니다. 초보 개발자라서 이것 저것 배우고 해볼 수 있는 시기이기도 합니다. 시간이 흘러 시니어 개발자가 되면 머리가 굳어져 새로운 기술을 배우기가 더욱 힘들어지겠지요. ㅠ 이 포스트는 Flutter 튜토리얼 문서에 있는 1 ~ 3번까지의 과정을 따라하면서 정리한 글입니다. Flutter와 Android Studio 설치 개발툴은 Android Studio, IntelliJ, VS Code를 지원한다고 되어있습니다. 저는 Android Studio가 제공하는 기능들이 더 좋아보여서 Android Studio를 사용하였습니다. 먼저 Flutter SDK와 Android Studio를 설치합니다. 설치 방법은 각 사이트의 설치 가이드 문서를 참고합니다. Flutter 설치 방법: https://flutter.io Android Studio 설치 방법: https://developer.android.com Flutter SDK 설정하기 저는 맥OS를 사용하고 있어서 맥OS로 설명합니다. 윈도우 사용자는 Get Started: Install on Windows 문서를 참고 바랍니다. flutter 설치 경로를 PATH에 추가하기 위해 ~/.bash_profile 파일을 수정합니다. .bash_profile파일을 열고 다음 라인을 추가합니다. PATH에는 flutter가 설치된 경로가 입력됩니다. 1export PATH=\"$HOME/flutter/bin:$PATH\" 마지막으로 source ~/.bash_profile을 실행하여 bash_profile를 현재 콘솔창에 적용합니다. 그리고 echo $PATH 를 실행하여 flutter 설치 경로가 적용되었는지 확인합니다. 다음 명령을 실행하여 추가로 더 설치해야 하는 것이 있는지 확인합니다. 1$ flutter doctor flutter doctor로 진단해보니 Android toolchain 항목에서 “Android license status unknown.” 메세지가 출력되어 아래와 같이 처리하였습니다. 12$ flutter doctor --android-licenses$ /usr/local/Cellar/android-sdk/24.4.1_1/tools/bin/sdkmanager --update 그러고 나서 몇 번 더 flutter doctor로 진단하여 대부분의 문제를 해결하였습니다. Android Studio 설정 개발에 필요한 Flutter 플러그인와 Dart 플러그인을 설치합니다. Android Studio에서 Preferences &gt; Plugins 메뉴에 들어갑니다. **Browse Repositories…**를 선택하고 Flutter 플러그인에 Install 를 클릭하여 설치합니다. 그리고 Dart 플러그인을 설치하라는 메시지가 표시되면 Yes 를 클릭합니다. 마지막으로 설치가 완료되면 Android Studio를 재시작합니다. 앱 생성하기 File &gt; New Flutter Project 메뉴를 들어갑니다. 그리고 프로젝트 유형에서 Flutter application를 선택합니다. 그리고 Project Name과 Package Name을 입력하고 생성 완료합니다. 앱 실행해보기 앱 생성이 완료되면 샘플 코드가 담겨있는 프로젝트가 생성됩니다. Tools&gt; Android &gt; AVD Manager 메뉴에서 에뮬레이터를 생성합니다. 그리고 Run &gt; Run으로 앱을 빌드 및 실행합니다. 추가: ANDROID_ROOT_HOME를 찾지 못한다는 오류가 발생하여 아래 PATH 를 추가하였습니다. 1234&gt; export ANDROID_HOME=\"$HOME/Library/Android/sdk\"&gt; export ANDROID_SDK_ROOT=\"$HOME/Library/Android/sdk\"&gt; export ANDROID_AVD_HOME=\"$HOME/.android/avd\"&gt; 앱 완성! 짠~! 안피곤님의 첫번째 안드로이드앱이 완성되었습니다. 오른쪽 하단의 + 버튼을 클릭하면 화면의 숫자가 증가합니다. 10 까지 증가시켜보았습니다. 단순한 모바일 앱을 구현하기에는 Java나 Kotlin보다 Flutter가 훨씬 배우고 쉽고 간편합니다. 여기까지 읽어주셔서 감사합니다. Sponsored ( Powered by dclick ) DCLICK: An Incentivized Ad platform by Proof of Click - 스팀 기반 애드센스를 소개합니다. 안녕하세요 스티미언 여러분. 오늘 여러분께 스팀 블록체인 기반 광고 플랫폼 DCLICK을 소개… 이 글은 스팀 기반 광고 플랫폼dclick 에 의해 작성 되었습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"플러터(Flutter)","slug":"개발-이야기/플러터-flutter","permalink":"https://anpigon.github.io/categories/개발-이야기/플러터-flutter/"}],"tags":[{"name":"Flutter","slug":"flutter","permalink":"https://anpigon.github.io/tags/flutter/"}],"author":"anpigon"},{"title":"[머신러닝] 네이버 API를 이용한 얼굴 인식하기 - 닮은 유명인 찾기","slug":"/kr/@anpigon/openapi-naver-vision-face","date":"2018-10-05T07:42:54.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/kr/@anpigon/openapi-naver-vision-face/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/openapi-naver-vision-face/","excerpt":"안녕하세요. @anpigon입니다.최근에 @codingart님의 OpenCV를 이용한 얼굴 인식 시리즈를 읽고나서 얼굴 인식에 관심이 생겼습니다. OpenCV로 얼굴인식 구현하는게 어려워서 인터넷을 찾아봤는데, 네이버에서 얼굴 인식 API를 제공하는 것을 알게 되었습니다. 네이버 Clova Face Recognition API를 이용해서 얼굴인식 하는 것을 간단하게 만들어 보겠습니다.","text":"안녕하세요. @anpigon입니다.최근에 @codingart님의 OpenCV를 이용한 얼굴 인식 시리즈를 읽고나서 얼굴 인식에 관심이 생겼습니다. OpenCV로 얼굴인식 구현하는게 어려워서 인터넷을 찾아봤는데, 네이버에서 얼굴 인식 API를 제공하는 것을 알게 되었습니다. 네이버 Clova Face Recognition API를 이용해서 얼굴인식 하는 것을 간단하게 만들어 보겠습니다. 우선 네이버에서 **“오픈 API 이용 신청”**을 하여 키를 발급받았습니다. 처리한도가 하루에 1,000건 이네요. 이 정도면 테스트하는데 문제 없을 것 같습니다. 아래는 네이버에서 제공하는 파이썬 구현 예제 소스입니다. 그냥 복사&amp;붙여넣기 했습니다. 123456789101112131415import osimport sysimport requestsclient_id = \"YOUR_CLIENT_ID\"client_secret = \"YOUR_CLIENT_SECRET\"# url = \"https://openapi.naver.com/v1/vision/face\" # 얼굴감지url = \"https://openapi.naver.com/v1/vision/celebrity\" # 유명인 얼굴인식files = ｛'image': open('YOUR_FILE_NAME', 'rb')｝headers = ｛'X-Naver-Client-Id': client_id, 'X-Naver-Client-Secret': client_secret ｝response = requests.post(url, files=files, headers=headers)rescode = response.status_codeif(rescode==200): print (response.text)else: print(\"Error Code:\" + rescode) 저는 요즘 Node.js 보다 파이썬으로 구현하는게 더 편해졌습니다. 혹시 javascipt로 구현하실 분은 node 샘플 소스를 사용하면 됩니다. 스팀잇을 창조하신 네드형님의 프로필 사진으로 얼굴 인식을 테스트 해보겠습니다. 먼저 스팀잇 서버에서 네드형님 사진을 다운로드 합니다. 다들 아시겠지만 본인의 프로필 사진의 URL은 https://steemitimages.com/u/사용자이름/avatar 형태가 됩니다. 1234567import urllib.requestfrom PIL import Image, ImageDrawfile_name = 'ned.jped'image_url = 'https://steemitimages.com/u/ned/avatar'urllib.request.urlretrieve(image_url, file_name)Image.open(file_name) https://imgur.com/afovRv8.png 이제 테스트할 사진이 준비되었습니다. 잘 생겼네요. 네이버 CFR API를 이용하여 얼굴 인식 결과를 받아보겠습니다. 1234567files = ｛'image': open(file_name, 'rb')｝url = \"https://openapi.naver.com/v1/vision/face\" # 얼굴감지headers = ｛'X-Naver-Client-Id': client_id, 'X-Naver-Client-Secret': client_secret ｝response = requests.post(url, files=files, headers=headers)rescode = response.status_codeif(rescode==200): print (response.text) 얼굴 인식 결과가 나왔습니다. 하지만 JSON 형태의 데이터라서 읽기 힘듭니다. 보기 쉽게 출력해보겠습니다. CFR API 가이드 문서를 읽어보면 faces[].roi 에 감지된 얼굴의 좌표와 크기 정보가 있다고 합니다. 이 데이터를 사용하여 사진에 얼굴 영역을 표시해봅시다. 123456789import jsonjson_data = json.loads(response.text)x, y, w, h = json_data['faces'][0]['roi'].values()target_image = Image.open(file_name)draw = ImageDraw.Draw(target_image)draw.rectangle(((x,y), (x+w,y+h)), outline=\"red\")target_image 감지된 얼굴 영역에 붉은 박스가 표시되었습니다. 마지막으로 성별, 나이, 감정, 얼굴방향을 읽기 쉽게 출력합니다. 1234567891011121314151617gender, gen_confidence = json_data['faces'][0]['gender'].values() # 성별age, age_confidence = json_data['faces'][0]['age'].values() # 나이emotion, emotion_confidence = json_data['faces'][0]['emotion'].values() # 감정pose, pose_confidence = json_data['faces'][0]['pose'].values() # 얼굴 방향result = \"\"\"성별: ％s (％s)나이: ％s (％s)감정: ％s (％s)방향: ％s (％s)\"\"\" ％ ( gender, gen_confidence, age, age_confidence, emotion, emotion_confidence, pose, pose_confidence)print(result) 성별은 남성. 그리고 나이는 25 ~ 29세가 나왔습니다. 네드형님 나이가 이게 맞나요? 앞으로 네드동생이라고 불러야겠네요.ㅋ 하는 김에 네드형님과 닮은 유명인도 찾아보았습니다. 1234567files = ｛'image': open(file_name, 'rb')｝url = \"https://openapi.naver.com/v1/vision/celebrity\" # 유명인 얼굴인식headers = ｛'X-Naver-Client-Id': client_id, 'X-Naver-Client-Secret': client_secret ｝response = requests.post(url, files=files, headers=headers)rescode = response.status_codeif(rescode==200): print (response.text) 이동욱과 42.86％ 일치한다는 결과가 나왔습니다. 이 정도면 이동욱과 형제라고 해도 되겠습니다. 네이버에 샘플 소스가 있어서 금방 구현했네요. 그리고 이 포스팅에는 봇을 구현해서 달아볼 생각입니다. 적용되면 알려드릴께요.ㅋ 이 포스트에는 @아이디 맨션 또는 이미지를 업로드하면 얼굴인식 결과를 댓글로 달아드립니다. 재미삼아 한번 해보세요~ㅋㅋ 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"얼굴인식","slug":"얼굴인식","permalink":"https://anpigon.github.io/tags/얼굴인식/"}],"author":"anpigon"},{"title":"(종료) 안피곤 천하제일 코딩 대회를 개최합니다.","slug":"/kr/@anpigon/anpigon-coding-contest","date":"2018-10-04T14:21:36.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/kr/@anpigon/anpigon-coding-contest/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/anpigon-coding-contest/","excerpt":"안녕하세요. @anpigon입니다.@wonsama님과 @blockchainstudio님의 퀴즈 이벤트에 참여하면서 저도 이벤트를 해보고 싶어 준비했습니다. 이벤트 상금을 모으기 위해 몇 일 동안 스팀파워 충전을 하지 않고 스팀을 계속 모았습니다. 10 STEEM 정도 예상했는데 @blockchainstudio 퀴즈 이벤트에 당첨돼서 받은 5 STEEM이 추가되어 총 상금은 15 STEEM이 되었습니다.","text":"안녕하세요. @anpigon입니다.@wonsama님과 @blockchainstudio님의 퀴즈 이벤트에 참여하면서 저도 이벤트를 해보고 싶어 준비했습니다. 이벤트 상금을 모으기 위해 몇 일 동안 스팀파워 충전을 하지 않고 스팀을 계속 모았습니다. 10 STEEM 정도 예상했는데 @blockchainstudio 퀴즈 이벤트에 당첨돼서 받은 5 STEEM이 추가되어 총 상금은 15 STEEM이 되었습니다. 그리고 @wonsama님 퀴즈 이벤트에도 열심히 도전했으나 한번도 당첨되지 못했네요.ㅠ 땡사마님의 땡소리가 아직도 귓가에 울리는 것 같습니다.ㅋ 그럼 이제 대회를 시작합니다~! 안피곤 천하제일 코딩 대회 내용: 파이썬 장고와 스팀잇을 이용한 블로그 만들기 기간: 오늘부터 ~ 10월 10일(수) 까지 개발자가 아닌 분들은 불리할 수도 있어서 일주일 동안 아래 강좌를 연재했습니다. 강좌만 보고 따라 만들어도 100점입니다. 나만의 스팀잇 블로그 만들기 #1 나만의 스팀잇 블로그 만들기 #2 나만의 스팀잇 블로그 만들기 #3 나만의 스팀잇 블로그 만들기 #4 # 상금 1등 : 5 STEEM 2등 : 4 STEEM 3등 : 3 STEEM 4등 : 2 STEEM 5등 : 1 STEEM 참가상: 댓글 보팅 ※ 만약 참가자가 1명인 경우에는 1명에게 15 STEEM이 모두 지급됩니다. # 제출 방법 아래 양식을 작성하여 댓글로 제출합니다. &lt;양식&gt; URL: https://anpigon.pythonanywhere.com 개발자 여부: 예/아니오 설명: 추가 점수를 받기 위해 작성합니다. (예. 스팀잇 댓글, 보팅, 리스팀, 글쓰기 기능을 연동했어요. 추가 점수 주세요.) # 심사기준 기능 점수 글 목록과 글 상세만 구현한 경우: 50점 디자인 점수 Clean Blog 테마를 사용한 경우: 50점 명성도 점수(뉴비 혜택) 50 이하 : + 20점 51 ~ 55 : + 10점 56 ~ 60 : + 1점 61 이상 : + 0.1점 추가 점수 개발자가 아니면 어드밴티지 점수: + 10 점 (양식의 개발자 여부로 판단) 댓글에 받은 추천수(보팅수) 점수에 포함 (댓글에 받은 보팅수가 1이면 +1점) 도전 점수: + 10점 안피곤의 +@ 점수(혈연, 학연, 지연, 인맥 점수 없음!) 많은 참여 부탁드립니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[파이썬] 나만의 스팀잇 블로그 만들기 #4 - 글 상세","slug":"/kr/@anpigon/python-steemit-blog-4","date":"2018-10-04T13:17:27.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/python-steemit-blog-4/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/python-steemit-blog-4/","excerpt":"안녕하세요. @anpigon입니다.이제 **나만의 스팀잇 블로그 만들기**의 마지막 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다.이 강좌에서 사용한 소스는 GitHub 저장소에 올려놓았습니다. https://github.com/anpigon/steemit-django-blog","text":"안녕하세요. @anpigon입니다.이제 **나만의 스팀잇 블로그 만들기**의 마지막 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다.이 강좌에서 사용한 소스는 GitHub 저장소에 올려놓았습니다. https://github.com/anpigon/steemit-django-blog 이전 글 나만의 스팀잇 블로그 만들기 #1 나만의 스팀잇 블로그 만들기 #2 나만의 스팀잇 블로그 만들기 #3 이번 시간에는 글 목록을 클릭했을 때 글 상세 화면으로 이동하도록 구현해보자. 글 상세 화면까지 구현하고 나면 멋짐 블로그가 완성될 것이다. 블로그 글 상세 URL 추가하기 pythonanywhere의 Files 화면에서 web/blog/ 디렉토리를 찾아 들어간다. 그리고 urls.py 파일을 클릭하여 편집 화면으로 이동해서 아래와 같이 수정한다. 12345urlpatterns = [ re_path('^$', views.post_list, name='post_list'), # re_path('^@(?P&lt;author&gt;[\\w-]+)/(?P&lt;permlink&gt;[\\w-]+)/$', views.post_detail, name='post_detail') re_path('^@(?P&lt;author&gt;[\\._\\w-]+)/(?P&lt;permlink&gt;[\\._\\w-]+)/$', views.post_detail, name='post_detail')] @author/permlink URL에 글 상세를 보여주는 뷰(View) views.post_detail를 맵핑하였다. @author/permlink URL은 정규식 '^@(?P&lt;author&gt;[\\w-]+)/(?P&lt;permlink&gt;[\\w-]+)/$' 을 사용하여 author와 permlink은 매개 변수(parameter)으로 받았다. author를 매개 변수로 받는 이유는 내 블로그에 리스팀한 글이 포함되어 있어서 일단 추가하였다. 잘 모르겠다면 아래 화면을 참고하자. 이제 글 목록에서 글 상세 화면으로 이동할 수 있는 링크를 연결해야 한다. templates/blog/post_list.html 템플릿 파일을 열고 &lt;a href=&quot;#&quot;&gt;로 되어 있는 코드를 아래와 같이 수정한다. 1&lt;a href=\"/@｛｛ post.author ｝｝/｛｛ post.permlink ｝｝\"&gt; 수정하는 위치를 잘 모르겠으면 아래 화면을 참고한다. 블로그 글 상세 View 생성하기 blog/views.py 파일을 열고 post_detail 함수를 추가한다. 1234567891011121314151617181920def post_detail(request, author='', permlink=''): # 스팀잇에서 게시글 본문 가져오기 data = '''｛ \"jsonrpc\": \"2.0\", \"method\": \"condenser_api.get_content\", \"params\": [\"％s\", \"％s\"], \"id\": 1 ｝''' ％(author, permlink) response = requests.post(URL, data=data) post = ｛｝ if response.status_code == 200: # 응답이 성공이라면 data = json.loads(response.text) # JSON 파싱 post = data['result'] # post['body'] = md.convert(post['body']) replaced = re.sub(r'(^https?://([a-zA-Z0-9][a-zA-Z0-9_-]+([.][a-zA-Z0-9][a-zA-Z0-9_-]+)｛1,2｝(/[a-zA-Z0-9][a-zA-Z0-9_-]*)+)[.](png|PNG|jpg|JPG|jpeg|JPEG|bmp|BMP|gif|GIF))', r'&lt;img src=\"\\1\"&gt;', post['body']) post['body'] = md.convert(replaced) post['created'] = parse_time(post['created']) return render(request, 'blog/post_detail.html', ｛ 'post': post ｝) https://steemit.com/kr/@apmmh/re-anpigon-anpigon-re-apmmh-re-anpigon-anpigon-re-glory7-re-apmmh-re-anpigon-anpigon-coding-contest-20181010t070239125z 글을 참고하여 이미지URL을 이미지 태그로 치환하는 정규식을 추가하였습니다. 아래 화면을 참고하자. 블로그 글 상세 템플릿 html 생성 templates/blog/ 디렉토리에 post_detail.html 파일을 신규 생성한다. 그리고 아래 코드를 복사&amp;붙여넣기 하자. 1234567891011121314151617181920212223242526272829303132｛％ extends 'blog/base.html' ％｝｛％ load static ％｝｛％ block content ％｝ &lt;header class=\"masthead\" style=\"background-image: url(｛％ static 'img/post-bg.jpg' ％｝)\"&gt; &lt;div class=\"overlay\"&gt;&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-8 col-md-10 mx-auto\"&gt; &lt;div class=\"post-heading\"&gt; &lt;h1&gt;｛｛ post.title ｝｝&lt;/h1&gt; &lt;span class=\"meta\"&gt;Posted by &lt;a href=\"#\"&gt;｛｛ post.author ｝｝&lt;/a&gt; ｛｛ post.created ｝｝&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;article&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-8 col-md-10 mx-auto\"&gt; ｛％ autoescape off ％｝ ｛｛ post.body ｝｝ ｛％ endautoescape ％｝ &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;｛％ endblock ％｝ 마지막으로 본문에 포함된 이미지 크기 조정을 위해 아래 스타일 CSS 코드를 추가하였다. css.style 파일을 만들어서 적용해도 되고, post_detail.html 파일에 적용해도 된다. 12345&lt;style&gt;article img ｛ max-width: 100％;｝&lt;/style&gt; 여기까지 완료했으면 본인의 블로그에 가서 글 목록을 클릭했을 때 글 상세 화면으로 이동하는지 확인해보자. 댓글 서비스(disqus) 나는 스팀잇 사용자가 아닌 사람도 댓글을 쓸 수 있게 하기 위해서 Disqus 위젯을 사용하였다. Disqus는 소셜 댓글 서비스이다. 쉽게 설명하면 구글, 페이스북, 트위터 서비스에 가입되어 있으면 회원가입 없이 바로 댓글을 쓸 수 있다. 참고로 한국 서비스 중에는 라이브리(LiveRe)가 있다. 본문 내용 하단에 Disqus 위젯을 삽입하면 이렇게 보여진다. 적용방법은 간단하게 설명하겠다. 우선 https://disqus.com에 회원가입을 한다. 가입이 완료되면 아래 화면에서 보이는 Disqus Install 버튼을 클릭한다. 사이트 플랫폼 선택 화면에서는 맨 아래로 내리면 “I don’t see my platform listed, install manually with Universal Code” 버튼이 보인다. 이 버튼을 클릭한다. 붉은 박스에 보이는 코드를 복사하여 내 블로그에 삽입하면 된다. 참고로 Disqus 삽입 위치는 post_detail.html 파일의 이 코드 바로 아래입니다. 123｛％ autoescape off ％｝ ｛｛ post.body ｝｝｛％ endautoescape ％｝ 여기까지 성공적으로 따라오신 분들 모두 축하드립니다. 오늘부터 파이썬 웹 개발자가 되셨습니다. 하다가 막히는 부분이 있으면 댓글에 질문 남겨주세요. 그리고 kr-dev 태그에 개발관련 글을 올리면 제가 보팅해드립니다. 여기까지 읽어주셔서 감사합니다. 이 저작물은 크리에이티브 커먼즈 저작자표시-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬(python)","slug":"개발-이야기/파이썬-python","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://anpigon.github.io/tags/python/"},{"name":"Django","slug":"django","permalink":"https://anpigon.github.io/tags/django/"}],"author":"anpigon"},{"title":"[파이썬] 나만의 스팀잇 블로그 만들기 #3 - 페이징 구현","slug":"/kr/@anpigon/python-steemit-blog-3","date":"2018-10-03T14:16:36.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/python-steemit-blog-3/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/python-steemit-blog-3/","excerpt":"안녕하세요. @anpigon입니다.나만의 스팀잇 블로그 만들기 세 번째 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다.그리고 사용한 소스는 GitHub 저장소에 올려놓았습니다. https://github.com/anpigon/steemit-django-blog","text":"안녕하세요. @anpigon입니다.나만의 스팀잇 블로그 만들기 세 번째 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다.그리고 사용한 소스는 GitHub 저장소에 올려놓았습니다. https://github.com/anpigon/steemit-django-blog 이전 글 나만의 스팀잇 블로그 만들기 #1 나만의 스팀잇 블로그 만들기 #2 https://imgur.com/T86bXj7.png 글 목록 페이징 구현하기 이번에는 다음 페이지의 글을 가져오는 페이징을 구현할 것이다. 다음 페이지를 위한 버튼은 블로그 목록 페이지 맨 하단에 있다. 못 찾는 분들이 계실까봐 아래 화면에서 붉은 박스로 표시하였다. 글 목록에서 다음 페이지 버튼 수정하기 위 화면에 보이는 “OLDER POSTS” 버튼을 수정할 것이다. templates/blog/post_list.html 파일을 열어서 아래와 같이 수정한다. 12345&lt;div class=\"clearfix\"&gt; ｛％ if next ％｝ &lt;a class=\"btn btn-primary float-right\" href=\"?next=｛｛ next ｝｝\"&gt;Older Posts &amp;rarr;&lt;/a&gt; ｛％ endif ％｝&lt;/div&gt; ｛％ if next ％｝ ｛％ endif ％｝ 를 사용하여 다음 페이지의 글이 있을 때만 버튼이 보이도록 하였다. 그리고 href=&quot;?next=｛｛ next ｝｝&quot; 가 다음 페이지로 이동하게 해주는 핵심 코드이다. 이제 버튼을 클릭하면 url을 통해 next 값을 서버에 넘겨줄 것이다. 코드의 어디 부분을 수정하는지 잘 모르겠으면 아래 화면을 참고하자. 페이징 처리 구현하기 방금 수정한 버튼이 동작하게 하려면 페이징 처리를 구현해야 한다. web/blog/ 디렉토리에서 views.py 파일을 찾아 클릭하여 편집화면으로 이동한다. 페이징을 구현하려면 def post_list() 함수를 수정해야 한다. 다음 설명을 잘 읽고 수정해보자. 어려울 것 같지만 막상 해보면 전혀 어렵지 않다. 우리는 OLDER POSTS 버튼을 클릭했을 때 url을 통해 next 값을 넘겨주도록 수정하였다. 이제 넘어온 url에서 next 값을 조회해 보자. request.GET.get()를 함수를 사용하면 next 값을 조회할 수 있다. 1234def post_list(request, limit=20): # request url에서 next 파라미터값을 가져온다. start_entry_id = int(request.GET.get('next', '0')) 다음은 스팀잇 API 서버에서 글을 가져오는 코드를 수정한다. 이전에 `(USERNAME, 0, limit)` 로 넘겨주던 인자값을 `(USERNAME, start_entry_id, limit + 1)`로 수정하였다. 추가 설명하면, `start_entry_id` 인자값을 추가하고 `limit`를 +1를 하였다. `limit + 1`를 한 이유는 마지막 데이터에서 다음 페이지의 `entry_id`를 가져오기 위해서이다. 12345678# 스팀잇에서 게시글 가져오기data = '''｛ \"jsonrpc\": \"2.0\", \"method\": \"follow_api.get_blog\", \"params\": ｛\"account\": \"％s\", \"start_entry_id\": ％i, \"limit\": ％i｝, \"id\": 1｝''' ％ (USERNAME, start_entry_id, limit + 1)response = requests.post(URL, data=data) 그리고 `for blog in blogs:` 코드 바로 아래에 `entry_id` 값을 조회하는 코드를 추가한다. `entry_id` 값은 다음 페이지를 조회하기 위한 `next` 값으로 사용된다. 123for blog in blogs: entry_id = blog['entry_id'] blog = blog['comment'] 가져온 글의 수가 `limit`보다 작으면 `entry_id` 값을 0으로 초기화한다. 가져온 글의 수가 `limit`보다 작다는 것은 다음 페이지에서 가져올 수 있는 글이 없다는 의미이다. 12if len(posts) &lt; limit: entry_id = 0 마지막으로 `posts`를 `limit` 길이로 자른다. 왜냐하면 `posts`의 마지막 데이터는 페이징 처리를 위해 `entry_id` 값을 읽어오기 위한 데이터라서 필요 없기 때문이다. 그리고 템플릿 html 으로 전달하는 인자값에 `'next': entry_id` 를 추가한다. 12posts = posts[:limit]return render(request, 'blog/post_list.html', ｛'posts': posts, 'next': entry_id ｝) 아래에 `post_list` 함수의 전체 코드를 첨부하였으니 참고하자. 1234567891011121314151617181920212223242526272829303132333435def post_list(request, limit=20): start_entry_id = int(request.GET.get('next', '0')) data = '''｛ \"jsonrpc\": \"2.0\", \"method\": \"follow_api.get_blog\", \"params\": ｛\"account\": \"％s\", \"start_entry_id\": ％i, \"limit\": ％i｝, \"id\": 1 ｝''' ％ (USERNAME, start_entry_id, limit + 1) response = requests.post(URL, data=data) posts = [] # 게시글 목록 if response.status_code == 200: # 응답이 성공이라면 data = json.loads(response.text) # JSON 파싱 blogs = data['result']['blog'] for blog in blogs: # 리스트에서 필요한 데이터만 가져오기 entry_id = blog['entry_id'] blog = blog['comment'] html = md.convert(blog['body']) post = ｛ 'title': blog['title'], 'author': blog['author'], 'permlink': blog['permlink'], 'created': parse_time(blog['created']), 'body': html[:200], # 길이 200으로 자르기 ｝ posts.append(post) if len(posts) &lt; limit: entry_id = 0 posts = posts[:limit] return render(request, 'blog/post_list.html', ｛'posts': posts, 'next': entry_id ｝) 이번 시리즈는 구현하는 시간보다 스팀잇에 글 쓰는 시간이 더 오래 걸리는 것 같네요. ㅎㅎ 따라 하다가 모르는 부분이 있으면 댓글에 질문 남겨주세요. 그리고 kr-dev 태그에 개발관련 글을 올리면 제가 보팅해드립니다. 여기까지 읽어주셔서 감사합니다. https://media.giphy.com/media/h5AHEcNMhn7u8/giphy.gif 스팀잇에는 밥 로스 아저씨를 아는 분들이 많이 있을까요? 이 저작물은 크리에이티브 커먼즈 저작자표시-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬(python)","slug":"개발-이야기/파이썬-python","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://anpigon.github.io/tags/python/"},{"name":"Django","slug":"django","permalink":"https://anpigon.github.io/tags/django/"}],"author":"anpigon"},{"title":"[파이썬] 나만의 스팀잇 블로그 만들기 #2 - 글 목록","slug":"/kr/@anpigon/python-steemit-blog-2","date":"2018-10-02T12:34:54.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/python-steemit-blog-2/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/python-steemit-blog-2/","excerpt":"안녕하세요. @anpigon입니다.나만의 스팀잇 블로그 만들기 두 번째 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다. 이전 글 나만의 스팀잇 블로그 만들기 #1 blog url 추가하기내 블로그 주소(예: anpigon.pythonanywhere.com)로 접속하면 첫 페이지에 나의 스팀잇 글 목록이 보이게 만들어 보자.","text":"안녕하세요. @anpigon입니다.나만의 스팀잇 블로그 만들기 두 번째 강좌입니다. 이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있습니다. 이전 글 나만의 스팀잇 블로그 만들기 #1 blog url 추가하기내 블로그 주소(예: anpigon.pythonanywhere.com)로 접속하면 첫 페이지에 나의 스팀잇 글 목록이 보이게 만들어 보자. pythonanywhere에 접속하여 Files 페이지로 이동한다. 그리고 web/web 디렉토리로 이동한다. 만약 사용자명이 anpigon이고 프로젝트명이 web이면 전체 디렉토리 경로는 /home/anpigon/web/web/ 가 된다. 디렉토리를 정확하게 잘 찾아들어갔다면 아래와 같은 화면을 볼 수 있다. urls.py 파일을 클릭하여 편집화면으로 이동한다. 그리고 코드 내용을 아래와 같이 수정한다. 12345from django.urls import path, includeurlpatterns = [ path('', include('blog.urls'))] 여기서 path('', include('blog.urls')) 코드는 URL로 접속하는 모든 요청을 blog.urls 에서 처리하겠다는 의미이다. 실제 편집화면의 스크린 캡처을 바로 아래에 넣었다. 편집화면 상단에 있는 새로고침 버튼 을 클릭하면 수정된 내용이 서버에 바로 반영된다. Save 버튼을 클릭하여 저장한다. 그리고 새로고침 버튼을 클릭해보자. 그리고 블로그 주소(예: anpigon.pythonanywhere.com)로 접속하면 아래와 같은 화면을 볼 수 있다. 이렇게 화면에 오류 내용이 보이는 것이 정상이다. 왜냐하면 아직 blog를 구현하지 않았기 때문이다. 이제 본격 블로그를 개발해보자. 블로그 글 목록 URL 생성하기 방금 수정한 urls.py 파일이 있는 디렉토리에서 상위 디렉토리로 이동한다. 그리고 blog 디렉토리를 생성한다. blog가 생성된 전체 경로는 /home/anpigon/web/blog 이다. 아래 화면을 참고하여 생성된 디렉토리 경로를 확인하자. blog/ 디렉토리에 들어가서 urls.py 파일을 신규 생성한다. 생성된 blog/urls.py 파일을 클릭하여 편집화면으로 이동한다. 편집창에 아래 코드를 입력하고 저장한다. 123456from django.urls import re_pathfrom . import viewsurlpatterns = [ re_path('^$', views.post_list, name='post_list')] re_path('^$', views.post_list, name='post_list') 코드를 설명하면 ^$ URL에 글 목록을 보여줄 뷰(View) views.post_list를 맵핑하였다. 여기서 정규식 ^$은 아무 문자열이 없을 경우라는 의미이다. 아직은 정규식에 대해서 공부할 필요가 없다. 마지막으로 name='post_list'은 URL을 식별하기 위해 붙인 이름이다. 이 부분이 잘 이해가 안 되면 그냥 넘어가도 된다. 시간이 지난 뒤에 나중에 다시 보면 이해가 될 것이다. 블로그 글 목록 View 생성하기 여기서부터는 난이도가 조금 올라간다. 하지만 걱정할 필요가 없다. 천천히 따라하면 쉽게 할 수 있다. 참고로 이 글에서는 steemit에서 제공하는 파이썬 sdk를 사용하지 않았다. 방금 blog/urls.py 파일을 생성한 디렉토리에서 views.py 파일을 신규 생성한다. 그리고 views.py 파일을 클릭하여 편집화면으로 이동한다. 그리고 아래 설명서를 보면서 코드를 천천히 입력해보자. 코드 양을 보고 겁낼 필요가 없다. 우선 글 목록 뷰에 필요한 파이썬 모듈들을 임포트(import) 한다. 12345from django.shortcuts import render # 장고 View 렌더러 모듈from datetime import datetime # 날짜시간 모듈import markdown # 마크다운 HTML 변환 모듈import requests # 서버 API 요청 모듈import json # json 파싱 모듈 해당 모듈에 대한 설명은 간략하게 주석(#)을 달아놓았다. 마크다운 문서를 HTML로 변환하기 위한 모듈인 Markdown객체를 생성하여 md 변수에 담는다. 나는 마크다운 문서가 HTML로 잘 변환되길 바라면서 확장 기능 두개를 같이 포함하여 Markdown객체를 생성하였다. 1234md = markdown.Markdown([ 'markdown.extensions.extra', 'markdown.extensions.codehilite']) 여기서 사용한 Markdown의 확장 기능을 설명하면, 'markdown.extensions.extra'는 마크다운의 확장 문법을 파싱하는데 도움을 준다. 그리고 'markdown.extensions.codehilite' 는 Syntax highlighting를 적용하는데 매우 유용하다. Syntax highlighting가 궁금하신 분은 https://highlightjs.org를 방문해보면 무슨 뜻인지 이해될 것이다. 다음 라인에는 parse_time 함수를 구현한다. parse_time 함수는 날짜 텍스트를 파싱하는데 사용할 것이다. 참고로 파이썬에서 **def**로 시작하면 무조건 함수라고 보면 된다. 12def parse_time(date): return datetime.strptime(date, '％Y-％m-％dT％H:％M:％S') 스팀잇 API서버에서 글을 가져오기 위해 `URL`과 `USERNAME`를 변수를 정의하자. **`USERNAME`** 변수에는 본인의 스팀잇 아이디를 입력한다. 하지만 제 블로그를 만들어 주실 분은 **‘anpigon’**을 그대로 입력해도 좋다. 12URL = 'https://api.steemit.com' # 스팀잇 API URL 주소USERNAME = 'anpigon' # 본인의 스팀잇 아이디 이제 제일 중요한 메인 함수인 `post_list` 함수를 구현한다. `post_list` 함수는 **내 스팀잇 글을 가져와서 화면에 출력**할 것이다. 아래 코드 내용을 복사&붙여넣기 한다. 12345678910111213141516171819202122232425262728293031323334353637383940# 스팀잇 글 목록 가져오기def post_list(request, limit=20): # 스팀잇 API 요청하여 글을 가져온다. data = '''｛ \"jsonrpc\": \"2.0\", \"method\": \"follow_api.get_blog\", \"params\": ｛\"account\": \"％s\", \"start_entry_id\": ％i, \"limit\": ％i｝, \"id\": 1 ｝''' ％ (USERNAME, 0, limit) response = requests.post(URL, data=data) # 스팀잇 글 목록을 담을 변수 posts = [] # 응답이 성공이라면 다음 로직을 진행한다. if response.status_code == 200: # JSON 텍스트를 파싱한다. data = json.loads(response.text) # 파싱한 JSON 데이터에서 blog 정보를 꺼내온다. blogs = data['result']['blog'] # 반복문을 돌면서 필요한 정보를 받아오자. for blog in blogs: blog = blog['comment'] # 마크다운을 HTML로 변환 html = md.convert(blog['body']) post = ｛ 'title': blog['title'], # 제목 'author': blog['author'], # 작성자 'permlink': blog['permlink'], # 고유식별ID 'created': parse_time(blog['created']), # 작성일 'body': html[:200], # 본문내용 200글자로 자르기 ｝ posts.append(post) # 템플릿에 데이터 전달 return render(request, 'blog/post_list.html', ｛'posts': posts｝) 위 코드 내용을 설명하면 post_list 함수는 스팀잇 API 서버에서 게시글을 가져와 화면에 출력한다. 한 번에 가져와서 보여줄 글 수는 limit=20으로 설정했다. md.convert() 함수는 마크다운으로 작성된 텍스트를 HTML로 변환해준다. 그리고 목록 페이지에는 본문의 전체 내용이 필요 없기 때문에 html[:200]를 사용하여 본문 내용을 200 글자로 잘랐다. 마지막으로 작성일은 앞에서 구현한 parse_time 함수를 이용하여 날짜로 변환하였다. 참고로 위 코드 내용을 이해하지 못해서 괜찮다. 디자인 템플릿 적용하기 디자인 템플릿 파일을 사용하기 위해서는 템플릿 파일 경로를 설정해야 한다. web/web/settings.py 파일을 찾아서 편집한다. 57번 라인의 DIRS에 os.path.join(BASE_DIR, 'templates')를 추가한다. 아래 화면을 참고하자. 이렇게 설정하면 이제 템플릿 파일이 위치한 경로는 /home/anpigon/web/templates가 된다. web/ 디렉토리에 templates/blog 디렉토리를 생성한다. templates/blog 디렉토리에 디자인 템플릿 html 파일을 생성할 것이다. ## 기본 템플릿 html 생성 기본 템플릿은 모든 페이지에 확장되어 사용되는 템플릿이다. 앞으로 구현할 글 목록 페이지와 글 상세 페이지는 기본 템플릿을 베이스로 사용한다. web/templates/blog 디렉토리에 base.html 파일을 생성한다. 그리고 base.html 파일에 아래 내용을 복사&amp;붙여넣기 한다. 아래 코드는 Clean Blog 템플릿 파일을 장고에서 사용할 수 있게 수정하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788｛％ load static ％｝&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Clean Blog - Start Bootstrap Theme&lt;/title&gt; &lt;link href=\"｛％ static 'vendor/bootstrap/css/bootstrap.min.css' ％｝\" rel=\"stylesheet\"&gt; &lt;link href=\"｛％ static 'vendor/fontawesome-free/css/all.min.css' ％｝\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'&gt; &lt;link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'&gt; &lt;link href=\"｛％ static 'css/clean-blog.min.css' ％｝\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-light fixed-top\" id=\"mainNav\"&gt; &lt;div class=\"container\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Start Bootstrap&lt;/a&gt; &lt;button class=\"navbar-toggler navbar-toggler-right\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarResponsive\" aria-controls=\"navbarResponsive\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; Menu &lt;i class=\"fas fa-bars\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarResponsive\"&gt; &lt;ul class=\"navbar-nav ml-auto\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"/\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;About&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Sample Post&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Contact&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; ｛％ block content ％｝ ｛％ endblock ％｝ &lt;hr&gt; &lt;footer&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-8 col-md-10 mx-auto\"&gt; &lt;ul class=\"list-inline text-center\"&gt; &lt;li class=\"list-inline-item\"&gt; &lt;a href=\"#\"&gt; &lt;span class=\"fa-stack fa-lg\"&gt; &lt;i class=\"fas fa-circle fa-stack-2x\"&gt;&lt;/i&gt; &lt;i class=\"fab fa-twitter fa-stack-1x fa-inverse\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=\"list-inline-item\"&gt; &lt;a href=\"#\"&gt; &lt;span class=\"fa-stack fa-lg\"&gt; &lt;i class=\"fas fa-circle fa-stack-2x\"&gt;&lt;/i&gt; &lt;i class=\"fab fa-facebook-f fa-stack-1x fa-inverse\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=\"list-inline-item\"&gt; &lt;a href=\"#\"&gt; &lt;span class=\"fa-stack fa-lg\"&gt; &lt;i class=\"fas fa-circle fa-stack-2x\"&gt;&lt;/i&gt; &lt;i class=\"fab fa-github fa-stack-1x fa-inverse\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p class=\"copyright text-muted\"&gt;Copyright &amp;copy; Your Website 2018&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/footer&gt; &lt;script src=\"｛％ static 'vendor/jquery/jquery.min.js' ％｝\"&gt;&lt;/script&gt; &lt;script src=\"｛％ static 'vendor/bootstrap/js/bootstrap.bundle.min.js' ％｝\"&gt;&lt;/script&gt; &lt;script src=\"｛％ static 'js/clean-blog.min.js' ％｝\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 위 내용 중에서 중간쯤을 살펴보면 ｛％ block content ％｝ ｛％ endblock ％｝ 코드가 있다. 이 ｛％ block ％｝ 영역은 base.html을 확장하여 다른 템플릿에 사용할 수 있게 구멍을 뚫어 놓은 거라고 보면 된다. 참고로 ｛％ ％｝은 장고에서 사용할 수 있는 템플릿 태그라고 한다. ## 블로그 글 목록 템플릿 html 생성 이제 실제로 글 목록을 보여줄 템플릿 html를 만들자. 템플릿 디렉토리 templates/blog에 post_list.html 파일을 신규 생성한다. 그리고 post_list.html 파일에 아래 내용을 복사&amp;붙여넣기 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647｛％ extends 'blog/base.html' ％｝｛％ load static ％｝｛％ block content ％｝&lt;header class=\"masthead\" style=\"background-image: url(｛％ static 'img/home-bg.jpg' ％｝)\"&gt; &lt;div class=\"overlay\"&gt;&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-8 col-md-10 mx-auto\"&gt; &lt;div class=\"site-heading\"&gt; &lt;h1&gt;Clean Blog&lt;/h1&gt; &lt;span class=\"subheading\"&gt;A Blog Theme by Start Bootstrap&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/header&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-8 col-md-10 mx-auto\"&gt; ｛％ for post in posts ％｝ &lt;div class=\"post-preview\"&gt; &lt;a href=\"#\"&gt; &lt;h2 class=\"post-title\"&gt; ｛｛ post.title ｝｝ &lt;/h2&gt; &lt;h3 class=\"post-subtitle\"&gt; ｛｛ post.body|striptags|truncatechars:50 ｝｝ &lt;/h3&gt; &lt;/a&gt; &lt;p class=\"post-meta\"&gt;Posted by &lt;a href=\"#\"&gt;｛｛ post.author ｝｝&lt;/a&gt; on ｛｛ post.created ｝｝&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; ｛％ endfor ％｝ &lt;div class=\"clearfix\"&gt; &lt;a class=\"btn btn-primary float-right\" href=\"#\"&gt;Older Posts &amp;rarr;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;｛％ endblock ％｝ 위 코드에서 ｛％ extends 'blog/base.html' ％｝ 는 blog/base.html 템플릿을 확장해서 사용하겠다는 선언이다. 그리고 ｛％ block content ％｝와 ｛％ endblock ％｝ 사이에 있는 코드 내용이 위에서 설명한 기본 템플릿에 뚫어놓은 구멍인 ｛％ block content ％｝ ｛％ endblock ％｝ 영역에 들어갈 것이다. 그리고 ｛｛ post.body|striptags|truncatechars:50 ｝｝코드에서 사용한 striptags 필터는 HTML태그를 제거해준다. 그리고 truncatechars 필터는 문자열을 원하는 길이(50)로 잘라낸 다음 끝에 … 을 붙여준다. 내용이 너무 길어져서 이번 시간은 여기까지~~~ 이제 내 블로그 주소로 들어가면 아래와 비슷한 화면을 볼 수 있다. http://anpigon.pythonanywhere.com 여기까지 성공하셨다면 축하합니다. kr-dev에 개발 관련 글을 올리는 뉴비분들은 제가 보팅해드립니다. 저에게 보팅을 약 2000번 정도 받으면 원활한 활동에 필요하다는 100SP를 모을 수 있을 거예요. 그렇게 되려면 글을 2000개는 쓰셔야겠네요.🙊 여기까지 읽어주셔서 감사합니다. 이 저작물은 크리에이티브 커먼즈 저작자표시-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬(python)","slug":"개발-이야기/파이썬-python","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://anpigon.github.io/tags/python/"},{"name":"Django","slug":"django","permalink":"https://anpigon.github.io/tags/django/"}],"author":"anpigon"},{"title":"[파이썬] 나만의 스팀잇 블로그 만들기 #1","slug":"/kr/@anpigon/python-steemit-blog-1","date":"2018-10-01T12:48:12.000Z","updated":"2019-11-11T13:41:49.838Z","comments":true,"path":"/kr/@anpigon/python-steemit-blog-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/python-steemit-blog-1/","excerpt":"안녕하세요. @anpigon입니다.이번에는 장고(Django)를 사용하여 **나만의 스팀잇 블로그 만들기**를 진행해 볼까 합니다. 장고는 파이썬 웹 어플래케이션 프레임워크입니다. 이번 포스트를 작성하기 위해서 장고 걸스 튜토리얼을 보고 공부하였습니다.이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있도록 진행할게요. 그리고 Pythonanywhere에서 개발과 배포를 모두 진행하기 때문에 Pythonanywhere 회원가입이 필요합니다.","text":"안녕하세요. @anpigon입니다.이번에는 장고(Django)를 사용하여 **나만의 스팀잇 블로그 만들기**를 진행해 볼까 합니다. 장고는 파이썬 웹 어플래케이션 프레임워크입니다. 이번 포스트를 작성하기 위해서 장고 걸스 튜토리얼을 보고 공부하였습니다.이 시리즈는 개발 지식이 전혀 없는 분들도 쉽게 따라 할 수 있도록 진행할게요. 그리고 Pythonanywhere에서 개발과 배포를 모두 진행하기 때문에 Pythonanywhere 회원가입이 필요합니다. 그럼 이제 시작합니다~! Pythonanywhere 회원가입 하기 Pythonanywhere를 이용하면 파이썬으로 만든 웹사이트를 무료로 호스팅 할 수 있다. 단, 무료로 계속 사용하려면 3개월마다 로그인하여 연장 신청을 해야 한다. 사이트 주소 : www.pythonanywhere.com pythonanywhere에 들어가서 회원가입부터 하자. 메인 페이지 상단에 있는 Pricing &amp; signup 를 클릭하면 회원가입 페이지로 이동한다. 무료 계정인 Beginner을 사용하기 위해서 Create a Beginner account 를 선택한다. 그리고 회원 가입할 때 입력하는 username은 나중에 블로그 주소의 일부가 된다. 예를 들어 username이 anpigon이면 블로그 주소는 anpigon.pythonanywhere.com 이 된다. 아래 화면에서 Username에는 주소에 포함하고 싶은 이름을 입력한다. Web 생성하기 상단메뉴에서 Web 을 클릭하여 Web 생성 페이지로 이동한다. 그리고 페이지 왼쪽에 보이는 Add a new web app 을 클릭한다. 아래 화면에서 Project Name에 입력하는 값은 앱 디렉토리의 경로가 된다. 예를 들어 username이 anpigon이고 project name이 web이면 디렉토리 경로는 /home/anpigon/web/이 된다. 다음 화면에서 파이썬 버전 **Python 3.7 (Django 2.1)**을 선택한다. 그리고 웹 프레임워크는 Django를 선택한다. web 생성이 완료되면 아래 화면이 나타난다. 화면에 보이는 URL 주소를 클릭해보자. 브라우저에 아래 화면이 보인다면 web 생성에 성공한 것이다. 블로그 디자인 테마 업로드하기 여기서는 초보자가 다루기 쉬운 부트스트랩(bootstrap) UI 프레임워크를 사용하였다. 부트스트랩은 무료이며 부트스트랩 기반으로 제공되는 무료 테마가 많이 있다. 우리는 startbootstrap에서 제공하는 Clean Blog 테마를 사용할 것이다. 우선 Clean Blog 테마 파일을 다운로드한다. 다시 pythonanywhere로 돌아와서 Files 페이지로 이동하자. 그리고 방금 다운로드 받은 파일 startbootstrap-clean-blog-gh-pages.zip을 업로드 한다. 업로드 경로는 /home/anpigon/web/static이다. 참고로 디렉토리 경로는 사용자마다 다르므로, 자신이 생성한 앱 디렉토리를 확인하고 업로드해야한다. 업로드된 zip 파일의 압축을 풀기 위해 Console 페이지로 이동한다. 그리고 Start a new console에 보이는 Bash를 클릭하자. 그리고 나면 아래와 같은 콘솔창(console)의 검은 화면이 보일 것이다. 압축을 풀기 위해 콘솔창에 아래 명령어를 입력한다. 여기서는 프로젝트명이 web이라서 cd web/static를 입력하였다. 1234$ cd web/static$ unzip startbootstrap-clean-blog-gh-pages.zip$ mv startbootstrap-clean-blog-gh-pages/* ./$ rm -r startbootstrap-clean-blog-gh-pages* 압축을 풀고 나서 다시 Files 페이지로 가보면 zip 파일의 압축이 풀려있는 것을 확인 할 수 있다. 업로드한 테마를 확인하기 위해서 브라우저에 아래 URL을 입력해보자. 접속 URL은 사용자마다 다르므로, 본인의 URL로 접속하길 바란다. URL: http://anpigon.pythonanywhere.com/static/index.html 아래와 같은 화면이 보인다면 성공이다. 다음 시간에는 나의 스팀잇 글 목록을 보여주는 페이지를 개발할 예정입니다. 반응이 좋으면 빠른 시일내에 다음 강좌를 올리도록 하겠습니다. 그리고 kr-dev에 개발 관련 글을 올리는 뉴비분들은 제가 꾸준히 보팅해드리도록 하겠습니다. 저에게 보팅을 약 2000번 정도 받으면 원활한 활동에 필요하다는 100SP를 모을 수 있을 거에요.ㅋ 여기까지 읽어주셔서 감사합니다. 이 저작물은 크리에이티브 커먼즈 저작자표시-동일조건변경허락 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬(python)","slug":"개발-이야기/파이썬-python","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-python/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://anpigon.github.io/tags/python/"},{"name":"Django","slug":"django","permalink":"https://anpigon.github.io/tags/django/"}],"author":"anpigon"},{"title":"스팀잇 모바일앱 이야기 : eSteem을 수정해볼까?","slug":"/kr/@anpigon/esteem","date":"2018-09-28T11:16:36.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/kr/@anpigon/esteem/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/esteem/","excerpt":"안녕하세요. @anpigon입니다.저는 주로 모바일에서 스팀잇을 합니다. 하지만 스팀잇은 공식 모바일앱이 없습니다. 공식 모바일앱을 개발할 계획도 없어 보입니다. 그래서 저는 Partiko와 eSteem 모바일앱을 많이 사용합니다.Partiko는 네이티브앱이라서 속도가 빠릅니다. 하지만 기능면에서 많이 부족합니다. 예를 들면, Partiko 앱은 본문 내용을 제대로 표현해 내지 못합니다. 그리고 eSteem은 기능이 많지만 하이브리드 앱이라서 속도가 느립니다. 그리고 간간이 버그도 보입니다. 하지만 저는 북마크 기능과 저자 즐겨찾기 기능이 있는 eSteem을 가장 많이 사용합니다.","text":"안녕하세요. @anpigon입니다.저는 주로 모바일에서 스팀잇을 합니다. 하지만 스팀잇은 공식 모바일앱이 없습니다. 공식 모바일앱을 개발할 계획도 없어 보입니다. 그래서 저는 Partiko와 eSteem 모바일앱을 많이 사용합니다.Partiko는 네이티브앱이라서 속도가 빠릅니다. 하지만 기능면에서 많이 부족합니다. 예를 들면, Partiko 앱은 본문 내용을 제대로 표현해 내지 못합니다. 그리고 eSteem은 기능이 많지만 하이브리드 앱이라서 속도가 느립니다. 그리고 간간이 버그도 보입니다. 하지만 저는 북마크 기능과 저자 즐겨찾기 기능이 있는 eSteem을 가장 많이 사용합니다. 앱을 사용하지 않고 모바일 브라우저에서 steemit.com, steempeak.com, busy.org에 접속하면 스팀잇을 할 수 있지만, 많이 불편합니다. 참, Busy.org는 PWA로 설치하면 조금 쓸만합니다. 혹시 제가 모르고 있는 쓸만한 스팀잇 모바일앱이 있나요? ___ # eSteem 오픈소스 이야기 eSteem은 MIT 라이선스의 오픈소스입니다. 누구나 소스를 다운로드해 소스 내용을 볼 수 있습니다. GitHub: https://github.com/esteemapp/esteem https://imgur.com/kvyLspJ.png eSteem은 한참 동안 업데이트가 없었습니다. eSteem 깃허브를 보면 마지막 소스 커밋이 6개월 전입니다. https://imgur.com/6m2M2Qd.png 제 생각에는 아마도 eSteem팀은 데스크탑 버전을 개발하는라 바쁜것 같습니다. 깃허브에서 활동(activity) 그래프를 보면 esteem-surfer에 비해 esteem은 최근 활동 기록이 전혀 없습니다. 참고로 esteem-surfer은 esteem의 PC버전입니다. https://imgur.com/QsyXIHf.png eSteem Surfer 대해서는 @kimjaeh9님의 Busy말고 eSteem Surfer를 사용해보자!! 글에 설명이 잘되어 있습니다. eSteem 오픈소스 작업(?) 이야기 깃허브에서 eSteem 소스를 내려받아 약간 수정했습니다. 본문 글꼴을 노토산스체로 바꾸고 약간의 한글 번역을 수정 및 추가하였습니다. 그리고 보팅 정보 페이지를 아래와 같이 수정하였습니다. https://imgur.com/aDL2v29.png https://imgur.com/fR4tqZG.png 그리고 글목록에서 보이던 no-image(고래 이미지?)와 베네피셔리에 eSteem이 설정되어 있는 코드를 삭제하였습니다. 앱으로 빌드하는 방법을 몰라서 브라우저에서 접속할 수 있게 github.io에 업로드하였습니다. 하지만, 버그가 많아서 사용할만한 수준은 못됩니다. 접속 URL: https://anpigon.github.io/esteem/ 만약 eSteem앱을 사용한다면 로그인은 다음 방법을 권장합니다. 고급 설정을 켜고 포스팅키 또는 액티브키로 로그인하시기 바랍니다. 그러나 댓글 또는 보팅만 할 거면 액티브키는 입력할 필요가 없습니다. https://imgur.com/0acTf12.png https://imgur.com/kSXUzMc.png 주의 마스터키와 메인 패스워드는 노출되지 않게 조심하기시 바랍니다. 여기까지 읽어주셔서 감사합니다. 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #6 - 스팀잇에서 유사한 게시물 찾기","slug":"/kr/@anpigon/6","date":"2018-09-27T00:24:27.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/kr/@anpigon/6/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/6/","excerpt":"안녕하세요. @anpigon입니다.@nhj12311님의 “Node &amp; Steem #11 - 글 아카이브 … 포스팅 분류하기” 게시글을 보고 저도 비슷하게 구현해보았습니다. 시리즈 글을 찾아주는 기능은 @nhj12311님이 완벽하게 구현하였더군요. 그래서 저는 @nhj12311님과 다르게 시리즈 글이 아닌 유사도가 높은 게시글을 찾아내는데 초점을 맞추었습니다.","text":"안녕하세요. @anpigon입니다.@nhj12311님의 “Node &amp; Steem #11 - 글 아카이브 … 포스팅 분류하기” 게시글을 보고 저도 비슷하게 구현해보았습니다. 시리즈 글을 찾아주는 기능은 @nhj12311님이 완벽하게 구현하였더군요. 그래서 저는 @nhj12311님과 다르게 시리즈 글이 아닌 유사도가 높은 게시글을 찾아내는데 초점을 맞추었습니다. 구현에는 이전에 작성한 &quot;유사한 게시물 찾기&quot;과 조대협님의 &quot;NMF 알고리즘을 이용한 유사한 문서 검색과 구현&quot;를 참고하였습니다. 그리고 구현 과정과 결과물을 아래에 간략하게 정리하였습니다 스팀잇 게시글 가져오기 steem api를 이용하여 내가 작성한 게시글(posts)을 모두 가져온다. 그리고 가져온 Post에서 분석에 필요한 데이터(title, body, author, permlink)만 사용한다. 123456789101112131415161718from steem import Steem from steem.blog import Blog# 게시글(Post)에서 필요한 필드 정의filter_post = ['title', 'body', 'author', 'permlink']# 스팀잇 게시글 가져오는 함수def loadSteem(username): print('@％s님 글 가져오는 중...' ％ username) b = Blog(username) posts = b.all() # 게시글 모두 가져오기 # 필요한 데이터만 추려서 반환 return [｛k: v for k, v in p.export().items() if k in filter_post｝ for p in posts]# 스팀잇에서 글 가져오기posts = loadSteem('anpigon')posts # 결과 출력 형태소 분석 konlpy.Mecab를 이용하여 형태소 분석을 한다. 그리고 분석하는데 불필요한 품사는 모두 제거하였다. 품사 코드는 여기에서 참고하였다. 그리고 분석된 텍스트 데이터는 Pandas의 DataFrame 자료구조를 이용하여 처리하였다. 123456789101112131415161718192021222324252627import pandas as pdfrom konlpy.tag import Mecabpos_tagger = Mecab()# 분석에 필요한 품사 정의filter_pos = ['NNG', 'NNP', 'NNB', 'NR', 'NP', 'VV', 'VA', 'VX', 'AX', 'VCP', 'VCN', 'MM', 'MAG', 'MAJ']# 형태소 분석하는 함수 정의def morphs(text): tokens = pos_tagger.pos(text) # 형태소 분석하여 필요한 품사의 단어만 문장으로 구성하여 반환 return ' '.join([word for word, pos in filter(lambda x: (x[1] in filter_pos), tokens)])# DataFrame 객체 생성df = pd.DataFrame(columns=['title', 'body'])# 가져온 게시글(posts)을 DataFrame에 입력for i, post in enumerate(posts): key = post['author'] + '/' + post['permlink'] body = morphs(post['body']) # 형태소 분석 if len(body) &gt; 10: value = ｛ 'title': post['title'], 'body': body, ｝ df.loc[key] = value Pandas는 데이터 구조 및 데이터 분석 도구를 제공하는 파이썬 라이브러리이다. 그리고 오픈 소스 BSD 라이센스를 가지고 있다. pandas.DataFrame의 기능은 pandas 문서를 참고하면 된다. DataFrame의 head를 출력하면 아래와 같다. Tfidf 를 이용한 단어의 벡터화 구현 ​ tfidf 모델을 이용하여 단어를 벡터화한다. sklearn에서 제공하는 TfidfVectorizer를 이용하면 쉽게 구현할 수 있다. TfidfVectorizer 객체를 생성하고 fit_transform을 이용하여 body에 담겨있는 텍스트 데이터를 벡터화한다. 123456import numpy as npfrom sklearn.feature_extraction.text import TfidfVectorizervectorizer = TfidfVectorizer()vectors = vectorizer.fit_transform(df['body'].tolist())print(vectors.shape) NMF를 이용하여 게시글에서 특성 추출 NMF를 이용하여 각 게시글에서 특성을 추출한다. NMF에 넘겨주는 n_components=10값은 특성을 10개로 압축하여 추출한다는 의미이다. 123456from sklearn.decomposition import NMFvector_array = vectors.toarray()nmf = NMF(n_components=10)nmf.fit(vector_array)features = nmf.transform(vector_array) 피쳐 정규화 Normalizer를 이용하여 features를 0 ~ 1 로 스케일링을 한다. sklearn에서 제공하는 Normalizer를 이용하면 쉽게 구현할 수 있다. 1234from sklearn.preprocessing import Normalizernormalizer = Normalizer()norm_features = normalizer.fit_transform(features) https://imgur.com/hBNYqyu.png df_features에 게시글별 특징과 인덱스를 가지고 데이타 프레임을 만들어서 생성한다. 인덱스는 author/permlink의 형태이다. 그리고 0 ~ 9 컬럼은 각 게시글의 특징이다. 12df_features = pd.DataFrame(norm_features, index=df.index.tolist())df_features.head() 문서 유사도 계산 이제 기존에 작성한 게시글에서 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기 글과 유사한 게시글을 찾아보자. DataFrame.loc 함수를 이용하면 해당 게시글의 특성 행렬을 가져올 수 있다. 가져온 특성 행렬은 article에 저장한다. 12article = df_features.loc['anpigon/4']print(article[:10]) DataFrame.dot 함수를 이용하면, 한 게시글의 특성 행렬을 전체 게시글의 특성 행렬에 대해서 계산할 수 있다. 전체 게시글에서 각 게시글의 특성 행렬과 article의 특성 행렬을 곱한다. 그러면 article과 각 게시글에 대한 유사도가 계산된다. 이렇게 계산해서 나온 값이 큰 순으로 정렬해서 top에 저장한다. 그리고 유사도가 높은 순으로 게시글의 제목 10개를 출력해보자. 12345678similarities = df_features.dot(article)top = similarities.nlargest(10)texts = df.loc[top.index].valuesi = 0for title, body in texts: print('=== 유사도 ％.4f: ％s' ％ (top[i], title)) i += 1 파이썬 머신러닝 관련 글이 상위에 모두 있다. 그리고 유사도가 90％에 가깝게 나와서 만족한 결과가 나왔다. 이제 다른 사람이 작성한 게시글로 테스트해보자. 테스트 결과 @nhj12311님의 [개발] Node &amp; Steem #11 - 포스팅 아카이브 기능으로서의 첫 걸음. 포스팅 분류하기. 게시글과 유사한 게시글을 찾아보자. https://imgur.com/2y6QUOc.png 결과를 보면 @nhj12311님은 비슷한 글을 많이 작성해서 그런지 대부분의 개발 관련 글은 높은 유사도를 보인다. 마지막으로 @forhappywomen님의 임·준·출 19화 - 기형아검사?!!! 게시글도 테스트 해보았다. &quot;임·준·출&quot; 시리즈 글이 상위권에 포진해 있지 않다. 아마도 “임·준·출” 시리즈는 매 번 주제가 바뀌어서 그런 것 같다. @nhj12311님 말대로 머신러닝으로 시리즈 글을 묶어내는 건 매우 어려워 보인다. ___ 단어를 벡터화해서 벡트 간의 거리 계산으로 유사한 글을 찾는 방법은 내용에 같은 단어가 많으면 유사한 글로 분류될 가능성이 높습니다. 그리고 Word2Vector와 딥러닝을 이용하면 정확도를 더 높일 수 있다고 합니다. Word2Vector와 딥러닝을 공부하고 난 후에 다시 도전해 볼 생각입니다. 여기까지 읽어주셔서 감사합니다. 이전글 파이썬 머신러닝 #1 - 스팀잇 형태소 분석하기 파이썬 머신러닝 #2 - 스팀잇 형태소 분석해서 단어구름 만들기 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별 예측하기 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기 파이썬 머신러닝 #5 - 유사한 게시물 찾기 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리 4.0 국제 라이선스에 따라 이용할 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"}],"author":"anpigon"},{"title":"[Steem Project #2] 댓글 자동 답변봇","slug":"/kr/@anpigon/steem-project-2","date":"2018-09-21T06:37:45.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/kr/@anpigon/steem-project-2/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steem-project-2/","excerpt":"안녕하세요. @anpigon 입니다.추석 연휴 기간 동안 스팀잇을 대신 관리해주는 봇이 있으면 좋겠다는 생각을 했습니다. 그래서 “댓글에 자동으로 답변해주는 봇이 있으면 어떨까?” 하는 생각에 만들어 보았습니다. 우선 댓글 자동 답변 봇을 구현하기 전에 챗봇에 대해서 짧게 이야기하고 시작하겠습니다.","text":"안녕하세요. @anpigon 입니다.추석 연휴 기간 동안 스팀잇을 대신 관리해주는 봇이 있으면 좋겠다는 생각을 했습니다. 그래서 “댓글에 자동으로 답변해주는 봇이 있으면 어떨까?” 하는 생각에 만들어 보았습니다. 우선 댓글 자동 답변 봇을 구현하기 전에 챗봇에 대해서 짧게 이야기하고 시작하겠습니다. 챗봇(Chat Bot) 챗봇을 크게 두 종류로 구분하면 데이터를 직접 입력하여 구현하는 지도학습 방식과 스스로 학습하는 비지도학습 방식이 있다. 지도학습에는 대표적으로 심심이와 뱅킹 4대 챗봇(KB 리브똑똑, 신한 쏠 챗봇, 우리 위비톡, KEB 하나톡)이 있다. 그리고 비지도학습에는 대표적으로 2016년 큰이슈가 되었던 마이크로소프트의 테이와 현재는 일본 마이크로소프트에서 개발한 린나가 있다. 그리고 구현 방식에 따라서 더 세분화할 수도 있다. 최근 트렌드는 규칙 기반(Rule-base)과 딥러닝을 혼용하는 하이브리드방식을 많이 사용하는 것 같다. 우리는 챗봇 엔진을 직접 구현할 필요가 없다. 인공지능으로 유명한 기업에서 챗봇을 쉽게 개발할 수 있는 플랫폼을 서비스하고 있기 때문이다. 게다가 무료 서비스도 제공하고 있다. 대표적으로 타로챗봇으로 유명해진 Chatfuel과 구글의 Dialogflow, IBM의 왓슨 컨버세이션, 아마존의 알렉사, LG CNS의 단비 등등이 있다. 챗봇에 대해서 더 이야기하고 싶지만, 주제를 너무 벗어나는 것 같아서 아래 2가지 용어만 간단하게 설명하고 넘어가자. 인텐트(Intent): 사용자가 말하는 의도를 파악하고, 그에 알맞는 응답을 한다. 엔티티(Entity): 사용자가 입력한 문장에서 구성 요소를 식별한다. 이 글에서는 구글의 Dialogflow 플랫폼을 사용하여 간단한 챗봇을 만드는 방법을 설명한다. Dialogflow은 구글 계정을 가지고 있으면 회원가입 없이 바로 사용할 수 있다. Dialogflow Console: https://console.dialogflow.com Dialogflow에서 봇 생성하기 메뉴에서 Create new agent를 선택한다. 그리고 봇 이름(Agent name)을 입력한다. 기본 언어(Default Language)에서 원하는 언어를 선택한다. CREAET 버튼을 누르고 잠시 기다리면 봇 생성이 완료된다. 인텐트 등록하기 봇을 생성하고 인텐트(Intents) 메뉴에 들어가면 기본적으로 2개의 인텐트가 샘플로 등록되어있다. Default Fallback Intent는 사용자의 의도 분석에 실패한 경우 해당 인텐트에 정의된 응답을 반환한다. 그리고 Default Welcome Intent에 들어가보면 안녕, 반가워 처럼 인삿말이 정의되어있다. 인텐트를 추가하고 싶으면 CREATE INTENT 버튼을 누르면 된다. 저도 Dialogflow는 익숙하지 않아서 쉽게 설명하기가 어렵습니다. Dialogflow의 자세한 사용방법은 https://dialogflow.com/docs/ 문서를 참고하시기 바랍니다. 스팀잇 댓글 자동 응답봇 구현하기 이제 자바스크립트로 댓글 자동 응답봇을 구현해보자. Dialogflow API 연동하기 API연동에 필요한 Client Access Token 키는 Agent 설정 페이지에서 확인 할 수 있다. 아래와 같이 dialogflow() 함수를 구현한다. 123456789101112131415161718192021const axios = require('axios');function dialogflow(id, text) ｛ const url = 'https://api.dialogflow.com/v1/query?v=20150910'; const clientAccessToken = 'dialogflow 액세스키는 여기에'; const headers = ｛ 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer $｛clientAccessToken｝` ｝ const query = ｛ 'sessionId' : id, 'query' : text, 'lang': 'ko' ｝ return axios.post(url, query, ｛ headers: headers ｝).then((｛ data ｝) =&gt; ｛ if(data.status.code === 200) ｛ return data.result.fulfillment.speech; ｝ throw new Error(data); ｝);｝ dialogflow()함수에 **‘안녕’**을 입력하여 테스트 해보자. 그럼 Welcome 인텐트에 정의되어 있는 응답을 출력하는 것을 확인 할 수 있다. 12dialogflow('anpigon', '안녕').then(r =&gt; console.log(r))// 안녕! 댓글 모니터링 하기 steemjs는 오퍼레이션을 모니터링 할 수 있는 streamOperations() 함수를 제공하고 있다. streamOperations 함수는 발생하는 모든 오퍼레이션을 모니터링한다. 그 오퍼레이션 중에서 opcode가 comment이고 title가 빈 값이 면 댓글이라고 보면된다. 그러나 발생하는 댓글 중에서 내가 작성한 글(parent_author === username)에 등록된 댓글만 확인하도록 한다. 명심해야 할 것은 자동응답봇이 댓글달고 자기가 등록한 댓글에 또 댓글달고 또 댓글… 댓글… 이런 꼴을 보지 않으려면 author !== username 조건을 반드시 넣어줘야 한다. 12345678steem.api.streamOperations((err, [opcode, op]) =&gt; ｛ if(!err &amp;&amp; opcode === 'comment' &amp;&amp; op.title === '') ｛ const ｛ parent_author, parent_permlink, author, permlink, body｝ = op; if(parent_author === username &amp;&amp; author !== username) ｛ console.log(`댓글: $｛body｝ by @$｛author｝`); ｝ ｝ ｝); 최종 소스 자바스크립트로 구현된 최종 코드는 다음과 같다. 참고로 아래 코드는 이전에 설명했던 Dory앱에서도 동작합니다. 자동 응답봇 최종 소스 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const steem = require('steem');const axios = require('axios');const username = process.env.usernameconst wif = process.env.wif// dialogflowfunction dialogflow(id, text) ｛ const url = 'https://api.dialogflow.com/v1/query?v=20150910'; const ClientAccessToken = 'dialogflow 액세스키는 여기에'; const headers = ｛ 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer $｛ClientAccessToken｝` ｝ const query = ｛ 'sessionId' : id, 'query' : text, 'lang': 'ko' ｝ return axios.post(url, query, ｛ headers: headers ｝).then((｛ data ｝) =&gt; ｛ if(data.status.code === 200) ｛ return data.result.fulfillment.speech; ｝ throw new Error(data); ｝);｝ // 댓글 등록function reply(author, permlink, body) ｛ const title = ''; const jsonMetadata = ｛ \"tags\": [\"kr\"] ｝; const commentPermlink = steem.formatter.commentPermlink(author, permlink); return steem.broadcast.commentAsync(wif, author, permlink, username, commentPermlink, title, body, jsonMetadata); ｝// 봇 실행steem.api.streamOperations((err, [opcode, op]) =&gt; ｛ if(!err &amp;&amp; opcode === 'comment' &amp;&amp; op.title === '') ｛ const ｛ parent_author, parent_permlink, author, permlink, body｝ = op; if(parent_author === username &amp;&amp; author !== username) ｛ console.log(`댓글: $｛body｝ by @$｛author｝`); dialogflow(author, body.slice(0, 256).replace(/\\n/g, ' ')) .then(botsay =&gt; ｛ reply(author, permlink, `**[자동 응답]**\\n $｛botsay｝`) .then(() =&gt; ｛ console.log(`└─ 답변: $｛botsay｝`); ｝); ｝); ｝ ｝ ｝); 저는 가끔 제 스팀잇 활동 습관을 AI가 학습하여, 자동으로 보팅하고, 댓글 달아주는 봇을 상상해봅니다. 여기까지 읽어주셔서 감사합니다. 관련글 Steem Project #0 - 뉴비분들을 위한 보팅 계산기(소숫점 3자리) Steem Project #1 - 스팀잇 펫 연구소(펫이 보팅 해드려요) 안드로이드폰에서 보상 받기 자동화하기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"자동화","slug":"자동화","permalink":"https://anpigon.github.io/tags/자동화/"},{"name":"steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"},{"name":"챗봇","slug":"챗봇","permalink":"https://anpigon.github.io/tags/챗봇/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #5 - 유사한 게시물 찾기","slug":"/kr/@anpigon/5","date":"2018-09-20T04:17:45.000Z","updated":"2019-11-11T13:41:49.837Z","comments":true,"path":"/kr/@anpigon/5/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/5/","excerpt":"안녕하세요. @anpigon 입니다.이번에는 유사한 게시물을 찾아내는 방법을 공부하였습니다. 게시물을 벡터로 계산하고, 벡터 간의 거리를 구하는 방법으로 유사도를 분석합니다. 이 기술을 이용하면 인터레스팀 서비스처럼 관련 글을 찾아낼 수도 있습니다. 저는 이 기술을 사용해서 불펌러(어뷰징 계정)들을 찾아내고 싶네요.","text":"안녕하세요. @anpigon 입니다.이번에는 유사한 게시물을 찾아내는 방법을 공부하였습니다. 게시물을 벡터로 계산하고, 벡터 간의 거리를 구하는 방법으로 유사도를 분석합니다. 이 기술을 이용하면 인터레스팀 서비스처럼 관련 글을 찾아낼 수도 있습니다. 저는 이 기술을 사용해서 불펌러(어뷰징 계정)들을 찾아내고 싶네요. 이번 예제는 “Building Machine Learning Systems with Python - Second Edition” 서적을 참고하였습니다. 이 책의 54 페이지에 있는 내용입니다. scikit-learn **scikit-learn**는 데이터 마이닝 및 데이터 분석을 위한 파이썬 라이브러리이다. NumPy, SciPy 및 matplotlib를 기반으로 제작되었다. 그리고 상업적으로 사용 가능한 오픈 소스(BSD) 라이센스를 가지고 있다. scikit-learn 사용 환경은 다음과 같다. 아쉽게도 최신 버전인 파이썬3.7에서는 동작하지 않는다. 123Python (&gt;= 2.7 or &gt;= 3.3),NumPy (&gt;= 1.8.2),SciPy (&gt;= 0.13.3). 설치하기 1pip install -U scikit-learn 카운트 벡터 생성하기 게시물에 등장하는 단어를 세어 하나의 카운트 벡터로 생성한다. 그리고 해당 컨텐츠와 다른 컨텐츠 사이의 벡터 거리를 계산하여 컨텐츠 사이의 유사도를 파악한다. 하지만 우리는 단어를 세고 그 카운트를 벡터로 나타내는 코드를 작성할 필요가 없다. 그냥 SciKit의 “countVectorizer” 함수를 사용하면 된다. scikit-learn에서 텍스트를 벡터화할 수 있는 CountVectorizer 함수를 import한다. 12from sklearn.feature_extraction.text import CountVectorizervectorizer = CountVectorizer(min_df=1) CountVectorizer의 매개변수를 간단하게 설명하면, min_df의 값은 해당 값보다 낮은 빈도수의 단어는 모두 삭제된다. max_df도 비슷한 방식으로 작동한다. 아래와 같이 vectorizer를 출력하면 SciKit이 제공하는 다른 매개 변수와 기본값을 볼 수 있다. 다음 데이터 세트를 사용하여 벡터간 거리를 계산해보자. 1234567posts = [ \"이 글은 머신러닝에 관한 글이다. 사실은 재미없는 내용을 포함하고 있다.\", \"이미징 데이터베이스는 저장 기능을 제공한다.\", \"대부분의 이미징 데이터베이스는 이미지를 영구적으로 저장한다.\", \"이미징 데이터베이스는 데이터를 저장한다.\", \"이미징 데이터베이스는 데이터를 저장한다. 이미징 데이터베이스는 데이터를 저장한다. 이미징 데이터베이스는 데이터를 저장한다.\",] fit_transform() 함수를 사용하여 벡터화 작업을 수행한다. 결과를 확인해보면, 19개 단어로 구성된 5개의 게시물이 벡터화되었다. 123X_train = vectorizer.fit_transform(posts) num_sample, num_features = X_train.shapeprint(\"#sample: ％d, #fearutes: ％d\" ％ (num_sample, num_features)) feature_names을 출력해보자. vectorizer가 19개의 단어를 감지했다는 것을 확인할 수 있다. 그러나 **“글은”**과 “글이다” 처럼 동일한 단어가 따로 구분되어 잡힌게 찜찜하지만 일단은 그대로 진행해본다. 1print(vectorizer.get_feature_names()) 이제 새로운 게시물이 주어졌을때 해당 게시물이 어느 게시물과 거리가 가까운지 살펴보자. 거리가 가까운 게시물이 가장 유사한 게시물이라고 보면 된다. 새 게시물을 벡터화하고 카운터 벡터를 생성하자. 12new_post = \"이미징 데이터베이스는\"new_post_vec = vectorizer.transform([new_post]) 책 내용에 따르면 ‘transform’ 함수에 의해 반환되는 카운트 벡터는 희소(sparse)하다는 것에 주의해야 한다. 이것은 각 벡터가 각 단어에 대한 카운트 값을 가지고 있지 않기 때문에 대부분은 0에 가까운 값을 가진다는 것을 의미한다. 대신, 더 효율적인 메모리 구현체인 'coo_matrix’를 사용한다. 예를 들어 새 게시물에는 실제로 두가지 요소만 포함하고 있다. 사실 저는 이 내용을 이해하지 못했습니다. 영어를 제대로 번역한게 맞는지도 모르겠어요. 이 부분에 대해서는 쉽게 설명하지 못해서 죄송합니다.ㅠ 벡터화된 새 게시물의 new_post_vec를 출력해보자. 1print(new_post_vec) 출력 결과를 설명하면 새로운 게시물의 벡터가 7번째와 12번째에 위치하고 있다는 의미이다. toarry() 멤버를 통해 전체 ndarray를 출력해보자. 1print(new_post_vec.toarray()) 하지만 책이 설명하는 것과 동일한 결과가 나오지 않았다. 아마도 한글은 형태소 분석을 해야 원하는 결과가 나올 것 같다. 형태소 분석기를 사용하여 형태소를 분석하자. 그리고 형태소 분석된 게시물을 다시 벡터화를 해보자. 12345from konlpy.tag import Mecabpos_tagger = Mecab()posts_tokens = [' '.join(pos_tagger.morphs(sentence)) for sentence in posts]posts_tokens 형태소 분석된 게시물을 벡터화한다. 1X_train = vectorizer.fit_transform(posts_tokens) 그리고 새로운 게시물도 형태소 분석을 한다. 123new_post = \"이미징 데이터베이스는 저장한다.\"new_post_tokens = ' '.join(pos_tagger.morphs(new_post))new_post_tokens 새로운 게시물을 벡터화하고 new_post_vec를 출력해본다. 12new_post_vec = vectorizer.transform([new_post_tokens])print(new_post_vec) ndarray도 출력해본다. 새로운 게시물의 벡터가 5번째, 11번째, 14번째, 17번째에 위치한다는 예상했던 결과가 나왔다. 1print(new_post_vec.toarray()) 벡터 사이의 거리 구하기 이제 새로운 게시물(new_post_vec)과 기존 게시물(posts)들 각각에 대해 거리를 계산해보자. 두 벡터 사이의 유클리드 거리를 계산하여 유사성을 측정한다. 우선 거리를 구하는 dist_raw() 함수 정의한다. np.linalg.norm() 함수를 사용하면 최단 거리를 계산할 수 있다. 1234import numpy as npdef dist_raw(v1, v2): delta = v1 - v2 return np.linalg.norm(delta.toarray()) dist_raw() 함수를 사용하여 이전 게시물과 기존 게시물의 거리를 계산하여 출력한다. 그리고 유사도가 가장 높은 게시물을 찾아보자. 1234567891011121314import sysbest_dist = sys.maxsizebest_doc = Nonebest_i = None for i, post in enumerate(posts): post_vec = X_train.getrow(i) d = dist_raw(post_vec, new_post_vec) print(\"=== Post ％i with dist = ％.2f: ％s\" ％ (i, d, post)) if d &lt; best_dist: best_dist = d best_i = i print(\"Best post is ％i with dist=％.2f\" ％ (best_i, best_dist)) 3번 게시물이 새로운 게시물과 거리가 가장 가깝다는 결과가 나왔다. 그러나 3번, 4번 게시물을 보면 이상한 점이 있다. 4번 게시물은 3번 게시물을 복사&amp;붙여넣기 한 것이다. 따라서 3번 게시물처럼 4번 게시물도 새로운 게시물과도 유사하다는 결과가 나와야 한다. 해당 벡터의 feature를 출력해보면 그 이유를 알 수 있다. 이를 교정하기 위해서는 카운트 벡터를 정규화해야한다. 위에서 정의한 거리 구하는 함수 dist_raw()를 수정함으로써 문제를 간단히 해결할 수 있다. 카운터 벡터 정규화하기 원시 벡터(raw vectors)가 아닌 정규화된 벡터 거리를 계산하기 위한 함수 dist_norm()를 정의한다. 이 함수는 각 벡터의 norm을 나눈 후에 거리를 계산한다. 12345def dist_norm(v1, v2): v1_normalized = v1/np.linalg.norm(v1) v2_normalized = v2/np.linalg.norm(v2) delta = v1_normalized - v2_normalized return np.linalg.norm(delta) 이 함수를 사용하여 유사도를 측정한 결과를 출력해보자. 123456=== Post 0 with dist = 3.32: 이 글은 머신러닝에 관한 글이다. 사실은 재미없는 내용을 포함하고 있다.=== Post 1 with dist = 1.41: 이미징 데이터베이스는 저장 기능을 제공한다.=== Post 2 with dist = 2.00: 대부분의 이미징 데이터베이스는 이미지를 영구적으로 저장한다.=== Post 3 with dist = 1.00: 이미징 데이터베이스는 데이터를 저장한다.=== Post 4 with dist = 1.00: 이미징 데이터베이스는 데이터를 저장한다. 이미징 데이터베이스는 데이터를 저장한다. 이미징 데이터베이스는 데이터를 저장한다.Best post is 3 with dist=1.00 이제 원하는 결과가 나왔다. 3번 게시물과 4번 게시물도 동일한 결과가 나왔다. 여기까지 읽어주셔서 감사합니다. 이전글 파이썬으로 스팀잇 형태소 분석하기 #1 파이썬으로 스팀잇 형태소 분석하기 #2 - 단어구름 만들기 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별 예측하기 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #4 - 스팀잇 글 감정 분류하기","slug":"/kr/@anpigon/4","date":"2018-09-19T01:55:12.000Z","updated":"2019-11-11T13:41:49.836Z","comments":true,"path":"/kr/@anpigon/4/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/4/","excerpt":"안녕하세요. @anpigon 입니다.이번에는 간단한 텍스트 감정 분류기를 만들어 보겠습니다. 참고로 구글 검색하면 파이썬 머신러닝 관련 자료가 넘치도록 많습니다. 구글에서 마음에 드는 예제를 하나 가져왔습니다.아래 예제는 https://stevenloria.com/simple-text-classification/를 참고 했습니다.","text":"안녕하세요. @anpigon 입니다.이번에는 간단한 텍스트 감정 분류기를 만들어 보겠습니다. 참고로 구글 검색하면 파이썬 머신러닝 관련 자료가 넘치도록 많습니다. 구글에서 마음에 드는 예제를 하나 가져왔습니다.아래 예제는 https://stevenloria.com/simple-text-classification/를 참고 했습니다. TextBlob 라이브러리 설치 Textblob는 텍스트 정보를 처리하는 파이썬 라이브러리다. 품사 태깅, 명사구 추출, 감정 분석 및 분류, 번역 등과 같은 일반적인 자연 언어 처리(Natural Language Processing, NLP)를 위한 간단한 API를 제공한다. 설치하기 $ pip install -U textblob nltk TextBlob 라이브러리가 제공하는 기능 중에 어썸(Awesome)한 기능 하나를 소개한다. 나는 언어를 알아내는 기능과 번역기능이 정말 마음에 들었다. 아래 예제를 보자. 나머지 기능들은 [여기]에서 볼 수 있다. Detect Language(언어 알아내기) 어떤 국가의 언어로 작성된 텍스트인지 판단한다. 한글은 ko로 나온다. 언어 코드는 구글에서 제공하는 Adwords Api 문서에서 확인 가능하다. Translate(번역하기) 한글로 작성된 텍스트를 영어로 번역한다. 텍스트 감정 분류기 만들기 간단한 문장을 학습하여 긍정(pos)과 부정(neg)을 분류하는 단순한 분석기를 구현해보자. 먼저 textblob.classifiers를 임포트(import)하고 학습 데이터 세트과 테스트 데이터 세트를 만든다. 12345678910111213141516171819202122from textblob.classifiers import NaiveBayesClassifiertrain = [ ('I love this sandwich.', 'pos'), ('This is an amazing place!', 'pos'), ('I feel very good about these beers.', 'pos'), ('This is my best work.', 'pos'), (\"What an awesome view\", 'pos'), ('I do not like this restaurant', 'neg'), ('I am tired of this stuff.', 'neg'), (\"I can't deal with this\", 'neg'), ('He is my sworn enemy!', 'neg'), ('My boss is horrible.', 'neg')]test = [ ('The beer was good.', 'pos'), ('I do not enjoy my job', 'neg'), (\"I ain't feeling dandy today.\", 'neg'), (\"I feel amazing!\", 'pos'), ('Gary is a friend of mine.', 'pos'), (\"I can't believe I'm doing this.\", 'neg')] NaiveBayesClassifier 객체에 학습 데이터를 입력하고 분류기 cl를 생성한다. 1cl = NaiveBayesClassifier(train) 이제 학습된 분류기에서 classify(text) 함수를 사용하면 텍스트를 분류할 수 있다. 학습 데이터에 없는 텍스트를 입력하여 분류해보자. 12cl.classify(\"Their burgers are amazing\") # \"pos\"cl.classify(\"I don't like their pizza.\") # \"neg\" 아래와 같이 TextBlob 객체를 사용하여 여러 문장으로 구성된 텍스트도 분류할 수 있다. 12345from textblob import TextBlobblob = TextBlob(\"The beer was amazing. \" \"But the hangover was horrible. My boss was not happy.\", classifier=cl)blob.classify() # \"neg\" TextBlob에서 문장을 분리하여 각 문장을 개별적으로 분류 할 수도 있다. 1234for sentence in blob.sentences: print(sentence) print(sentence.classify())# \"pos\", \"neg\", \"neg\" 테스트 데이터 세트로 정확도를 확인해보자. 테스트 데이터의 정확도가 **83％**로 나왔다. 사실 테스트 데이터양이 적어서 높은 정확도가 나왔다. 12cl.accuracy(test)# 0.8333333333333334 show_informative_features를 실행하여 분류기가 어떤 기준으로 분류하는지 살펴보자. 1234567cl.show_informative_features(5)# Most Informative Features# contains(my) = True neg : pos = 1.7 : 1.0# contains(an) = False neg : pos = 1.6 : 1.0# contains(my) = False pos : neg = 1.3 : 1.0# contains(place) = False neg : pos = 1.2 : 1.0# contains(of) = False pos : neg = 1.2 : 1.0 텍스트에 “my” 단어를 포함(True)하고 있으면 부정(neg)일 확률이 1.7이다. 그리고 **“place”**라는 단어를 포함하지 않으면(False) 부정(neg)일 확률이 1.2이다. 한글 텍스트 감정 분류기 만들기 위에서 만든 분류기를 한글에도 적용해보자. TextBlob는 형태소 분석 기능을 포함하고 있지만, 한글 형태소 분석은 하지 못한다. 그래서 한글 형태소 분석을 위해 은전한닢(Mecab)을 사용하였다. 한글 형태소 분석기를 사용하지 않아도 분류기가 작동은 한다. 하지만 형태소 분석을 하지 않으면 조사, 명사, 동사 구분이 되지 않아 분류기의 정확도가 떨어진다. 아래와 같이 학습 데이터와 테스트 데이터를 준비한다. 123456789101112131415161718192021222324from konlpy.tag import Mecabpos_tagger = Mecab()train = [ ('나는 이 샌드위치를 정말 좋아해.', '긍정'), ('정말 멋진 곳이에요!', '긍정'), ('나는 이 맥주들이 아주 좋다고 생각해요.', '긍정'), ('이것은 나의 최고의 작품입니다.', '긍정'), (\"정말 멋진 광경이다\", \"긍정\"), ('난 이 식당 싫어', '부정'), ('난 이게 지겨워.', '부정'), (\"이 문제는 처리할 수 없습니다.\", \"부정\"), ('그는 나의 불구대천의 원수이다.', '부정'), ('내 상사는 끔찍해.', '부정')]test = [ ('맥주가 좋았습니다.', '긍정'), ('난 내 일을 즐기지 않는다', '부정'), ('오늘은 기분이 안 좋아요.', '부정'), ('놀라워요!', '긍정'), ('네드는 나의 친구입니다.', '긍정'), ('제가 이렇게 하고 있다니 믿을 수가 없어요.', '부정')] 우선 차이를 확인하기 위해서 형태소 분석없이 분류기를 사용해보자. 정확도를 확인해보자. 확률이 50％다. 거의 찍는 수준이다. 이제 형태소 분석기를 적용하고 다시 정확도를 확인해보자. train 데이터의 텍스트를 형태소를 분석하여 train_data를 생성한다. 한글 단어 뒤에 태그를 붙여줘야 분류기가 정확하게 분류할 수 있다. 12train_data = [(['/'.join(token) for token in pos_tagger.pos(sentence)], result) for [sentence, result] in train]train_data 결과 테스트 데이터를 사용하여 정확도를 다시 확인해보자. **66％**가 나왔다. 형태소 분석을 하고 나니 정확도가 높아졌다. 123test_data = [(['/'.join(token) for token in pos_tagger.pos(sentence)], result) for [sentence, result] in test]cl.accuracy(test_data) 결과 show_informative_features를 실행하여 분류 기준을 살펴보자. 1cl.show_informative_features() 결과 &quot;정말&quot;이라는 부사가 있으면 부정일 확률이 2.2이다. 그리고 “좋” 형용사가 있으면 긍정일 확률이 1.6이다. 스팀잇 감정 분류하기 마지막으로 스팀잇에 작성한 글 10개를 가져와서 긍정/부정을 분류해보자. 123456789101112131415161718from steem import Steem from steem.blog import Blog# 스팀잇에서 작성한 글 10개 가져오기username = 'anpigon'b = Blog(username)posts = b.take(10)for post in posts: if post.body != \"\": author = post.author permlink = post.permlink title = post.title body = post.body.replace('\\n', '') # 분류기로 분류하기 result = cl.classify(['/'.join(token) for token in pos_tagger.pos(body)]) print(\"(％s) ％s(/@％s/％s)\" ％ (result, title, author, permlink)); 결과 결과가 좋지 않다. 긍정보다는 부정으로 분류가 많이 되었다.ㅠㅠ 분류기에 학습 데이터를 추가로 더 입력하고 정확도를 계산해보자. 1234567891011121314151617new_train = [ ('나는 내 꿈을 믿는다', '긍정'), ('나는 매일 최선을 다하고 있다', '긍정'), ('나는 있는 그대로의 나를 사랑한다', '긍정'), ('나는 내 삶을 100％ 책임진다', '긍정'), ('가장 좋은 일은 아직 생기지 않았다', '긍정'), ('나는 매일 나의 삶에 감사한다', '긍정'), ('새로나온 휴대폰은 배터리 교체가 되지 않아 불편하다', '부정'), ('이번에 나온 영화 너무 재밌다. 주말에 또 보고 싶다.', '긍정'), ('나의 아버지는 이해가 안된다', '부정'), ('나는 어머니와 있을 때 퉁명해진다', '부정'), ('나는 어머니와 있을 때 불편할 때가 있다.', '부정')]new_train_data = [(['/'.join(token) for token in pos_tagger.pos(sentence)], result) for [sentence, result] in test]cl.update(new_train_data)cl.accuracy(test_data) 결과 정확도는 66％로 변함이 없다. 하지만 학습 데이터가 많아지면 정확도가 올라갈 것이다. 마지막으로 학습 데이터가 추가된 분류기로 스팀잇 글을 다시 분류해보자. 결과 긍정으로 분류된 글의 비율이 늘었다. 하지만 여전히 부정으로 분류된 글이 많다.ㅠ 여기까지 읽어주셔서 감사합니다. 이전글 파이썬으로 스팀잇 형태소 분석하기 #1 파이썬으로 스팀잇 형태소 분석하기 #2 - 단어구름 만들기 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별 예측하기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"나이브 베이즈 분류","slug":"나이브-베이즈-분류","permalink":"https://anpigon.github.io/tags/나이브-베이즈-분류/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬 머신러닝 #3 - 스팀잇 아이디로 성별  예측하기","slug":"/busy/@anpigon/3","date":"2018-09-15T13:43:24.000Z","updated":"2019-11-11T13:41:49.836Z","comments":true,"path":"/busy/@anpigon/3/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/3/","excerpt":"안녕하세요. @anpigon 입니다.이전에 **“파이썬 형태소 분석”**이란 제목으로 시리즈를 시작했는데, 시리즈 제목을 머신러닝으로 변경했습니다. 형태소 분석은 스팀잇에 작성한 글로 &quot;단어구름&quot;를 만들어보고 싶어서 시작했습니다. 하지만, 형태소 분석만 하고 끝내기엔 아쉬워 머신러닝을 공부해서 재미난 걸 만들어 보려고 합니다.","text":"안녕하세요. @anpigon 입니다.이전에 **“파이썬 형태소 분석”**이란 제목으로 시리즈를 시작했는데, 시리즈 제목을 머신러닝으로 변경했습니다. 형태소 분석은 스팀잇에 작성한 글로 &quot;단어구름&quot;를 만들어보고 싶어서 시작했습니다. 하지만, 형태소 분석만 하고 끝내기엔 아쉬워 머신러닝을 공부해서 재미난 걸 만들어 보려고 합니다. 이번에는 머신러닝을 사용하여 스팀잇 아이디의 성별을 예측해보겠습니다. 참고로, 단어구름 만들기 포스팅에 댓글을 남기시면 여러분이 스팀잇에 작성한 글을 분석하여 단어구름를 만들어 드립니다. 현재 봇이 돌고 있습니다. 하지만, 노트북에서 봇을 돌리고 있어서 분석 시간은 조금 걸립니다. 나이브 베이즈 분류 나이브 베이즈 분류(Naïve Bayes Classification)는 텍스트 분류에 사용됩니다. 대표적으로 스팸 메일을 필터링하는 데 사용되고 있습니다. 자세한 설명은 조대협님 블로그에 설명이 잘 되어있어 링크로 대신합니다. [조대협의 블로그] 나이브 베이즈 분류 (Naive Bayesian classification) #1 - 소개 아래 나이브 베이즈 분류 예제는 https://www.nltk.org/book/를 참고 했습니다. 이름 성별 분류하기 남성과 여성의 이름에는 몇 가지 독특한 특성이 있다. a, e, i 로 끝나면 여성이고 k, o, r, s, t 로 끝나면 남성일 가능성이 크다. 이러한 차이를 이용하여 데이터를 학습하는 머신러닝을 구현해 보자. 먼저 이름에서 맨 마지막 알파벳을 가져오는 함수를 구현한다. 이 함수는 feature set이라고 불리는 데이터를 반환한다. 1234import redef gender_features(word): return ｛'last_letter': re.sub('[0-9]', '', word)[-1].lower()｝ 구현된 gender_features() 함수를 실행하고 결과를 확인해보자. 학습 데이터 준비하기 머신러닝을 학습할 데이터를 준비하자. male.txt 파일과 female.txt 파일에서 머신러닝이 학습할 데이터를 가져온다. 해당 파일은 &lt;github.com/tomazas&gt;에서 가져왔다. 12345labeled_names = ([(name, 'male') for name in open('male.txt').read().split('\\n')] +[(name, 'female') for name in open('female.txt').read().split('\\n')])import randomrandom.shuffle(labeled_names) 결과 분류기 학습시키기 gender_features() 함수로 학습 데이터 처리하여 feature set를 만든다. 그리고 feature set에서 학습 세트(train set)와 테스트 세트(test set)로 나눈다. 학습 세트는 나이브 베이즈 분류 머신러닝을 학습시키는 데 사용된다. 그리고 테스트 세트는 학습된 머신러닝을 검증하는 데 사용한다. 123456import nltkfeaturesets = [(gender_features(n), gender) for (n, gender) in labeled_names]train_set, test_set = featuresets[500:], featuresets[:500]classifier = nltk.NaiveBayesClassifier.train(train_set) 머신러닝 테스트하기 학습 데이터에 없는 이름을 가지고 테스트해보자. Neo는 남성, Trinity는 여성이라는 결과가 나왔다. 테스트 세트를 이용하여 나이브 베이즈 분류기의 정확도를 확인해보자. 이 학습된 분류기의 정확도는 **74.2％**이다. 12nltk.classify.accuracy(classifier, test_set)0.742 마지막으로 show_most_informative_features() 함수를 사용하면 이름의 성별을 구별하는 기준을 확인할 수 있다. a로 끝나는 이름은 여성일 확률이 35.8％이다. 그리고 k로 끝나는 이름은 남성일 확률이 32.8％이다. 1classifier.show_most_informative_features() 스팀잇 아이디로 성별 알아내기 성별을 분류해주는 머신러닝 학습이 완료되었습니다. 이제 이 포스팅의 목적인 스팀잇 아이디로 성별을 예측해보겠습니다. 아래와 같이 성별을 예측하여 결과를 반환하는 함수를 구현합니다. 12def predict(usernames): return [｛u: classifier.classify(gender_features(u))｝ for u in usernames] 성별을 알고 싶은 스팀잇 아이디 데이터를 준비합니다. 아래 데이터는 나의 팔로우에서 무작위로 가져왔습니다. 익숙한 아이디가 많이 보이네요. 12345678910111213141516171819202122input_data = [ 'ned', 'etainclub', 'codingart', 'codingman', 'ksc', 'imrahelk', 'newbijohn', 'coinfarmer165', 'ponzipanda', 'blockchainstudio', 'jisoooh0202', 'jamieinthedark', 'xinnong', 'bbooaae', 'onehand', 'osyvv', 'bluengel', 'jungjunghoon', 'duplicate', 'lucky2', ] 앞에서 구현한 predict() 함수를 실행하니, 아래와 같은 결과가 나왔습니다. 머신러닝 학습 데이터가 스팀잇 아이디가 아니었고, 정확도가 74％인 것을 참작하면 만족한 결과가 나왔습니다. 성별이 반대로 나오신 분들께는 죄송합니다. 여기까지 읽어주셔서 감사합니다. 이전글 파이썬으로 스팀잇 형태소 분석하기 #1 파이썬으로 스팀잇 형태소 분석하기 #2 - 단어구름 만들기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"나이브 베이즈 분류","slug":"나이브-베이즈-분류","permalink":"https://anpigon.github.io/tags/나이브-베이즈-분류/"}],"author":"anpigon"},{"title":"안드로이드앱 소개 #1 - ISS HD 라이브","slug":"/busy/@anpigon/1-iss-hd","date":"2018-09-14T00:15:03.000Z","updated":"2019-11-11T13:41:49.853Z","comments":true,"path":"/busy/@anpigon/1-iss-hd/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/1-iss-hd/","excerpt":"안녕하세요. @anpigon입니다.제가 사용하고 있는 앱 중에서 하나를 간략하게 소개합니다. ISS HD 라이브https://play.google.com/store/apps/details?id=com.nicedayapps.iss_free 우주 비행사들처럼 국제 우주 정거장에서 지구를 본 적 있나요? 이제 365일 24시간 실시간 동영상 스트리밍을 통해 볼 수 있답니다!","text":"안녕하세요. @anpigon입니다.제가 사용하고 있는 앱 중에서 하나를 간략하게 소개합니다. ISS HD 라이브https://play.google.com/store/apps/details?id=com.nicedayapps.iss_free 우주 비행사들처럼 국제 우주 정거장에서 지구를 본 적 있나요? 이제 365일 24시간 실시간 동영상 스트리밍을 통해 볼 수 있답니다! NASA 국제우주정거장(International Space Station, ISS)의 움직임과 지구 영상을 볼 수 있습니다. 이 앱을 사용하면, 지구에 아픈 곳이 없는지 살펴볼 수 있습니다. 하지만, 가끔 ISS와 연결이 안돼서 못 볼때도 있습니다.😥 어제 찍은 사진입니다. 대형 허리케인 플로렌스가 보입니다. 허리케인 크기가 어마어마 합니다. 지구 위에서 보니 더 무섭습니다. 아래는 앱 사용자들과 채팅하는 화면입니다. 알림을 설정할 수도 있습니다. 저는 일출 알림이 오면 들어가서 감상합니다. 그리고 구글 스크리뷰 처럼 ISS 내부를 돌아 다닐 수 있습니다. 우주인이 된 것 같은 기분을 느낄 수 있습니다. 하지만 앱을 설치 하지 않아도 유투브에서 실시간 지구 영상을 볼 수 있습니다. NASA Live - Earth From Space (HDVR) ♥ ISS LIVE FEED #AstronomyDay2018 | Subscribe now! 지구🌍는 아름답습니다. 지구가 아프지 않게 일회용품 사용을 줄입시다~😁 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"안드로이드앱 소개","slug":"안드로이드앱-소개","permalink":"https://anpigon.github.io/tags/안드로이드앱-소개/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬으로 스팀잇 형태소 분석하기 #2 - 단어구름 만들기","slug":"/busy/@anpigon/2","date":"2018-09-13T15:21:51.000Z","updated":"2019-11-11T13:41:49.836Z","comments":true,"path":"/busy/@anpigon/2/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/2/","excerpt":"안녕하세요. @anpigon 입니다.이전 글에 이어서 이번에는 스팀잇에 작성한 글에서 단어를 추출하여 단어구름을 만들어 보겠습니다. 이전글 파이썬으로 스팀잇 형태소 분석하기 #1 워드클라우드 모듈 설치워드클라우드(wordcloud) 모듈을 설치한다.pip install wordcloud","text":"안녕하세요. @anpigon 입니다.이전 글에 이어서 이번에는 스팀잇에 작성한 글에서 단어를 추출하여 단어구름을 만들어 보겠습니다. 이전글 파이썬으로 스팀잇 형태소 분석하기 #1 워드클라우드 모듈 설치워드클라우드(wordcloud) 모듈을 설치한다.pip install wordcloud 워드클라우드 깃허브에서 사용방법 또는 예제 소스를 참고할 수 있다. https://github.com/amueller/word_cloud 스팀잇에 작성한 글 가져오기 스팀잇에서 내가 작성한 글을 가져온다. 작성한 글을 모두 가져오려면 오래 걸리니 우선 1건만 가져와서 테스트해본다. 1234567891011121314from steem import Steem from steem.blog import Blogusername = 'anpigon' # 사용자 아이디b = Blog(username)# posts = b.all()posts = b.take(1) # 1건만 가져온다texts = []for post in posts: if post.body != \"\": texts.append(post.body.replace('\\n', '')) print(texts) 결과 화면 형태소 분석으로 단어 추출 형태소 분석에는 은전한닢(Mecab) 분석기를 사용한다. 분석기 중에서 은전한닢이 가장 속도가 빠르고 분석결과가 만족스러웠다. 1234567from konlpy.tag import Mecabtagger = Mecab()tokens = []for text in texts: tokens += tagger.nouns(text)print(tokens) 결과 화면 단어구름 만들기 이제 스팀잇 글에서 뽑아낸 단어를 가지고 단어구름을 만들어 보자. 1234567import matplotlib.pyplot as pltfrom wordcloud import WordCloudwordcloud = WordCloud().generate(' '.join(tokens))plt.imshow(wordcloud, interpolation='bilinear')plt.axis(\"off\")plt.show() 결과 화면 위와 같은 이미지가 나타난다. wordcloud가 한글 폰트를 지원하지 않아서 그렇다. 한글 폰트가 설치된 경로를 설정한다. 폰트가 설치된 경로는 OS마다 다르기 때문에 이 부분은 각자 확인하고 설정해야한다. 그리고 흰색 배경이 좋아서 배경색을 흰색으로 변경하였다. 12345678910# Window의 경우 폰트 경로# font_path = 'C:/Windows/Fonts/malgun.ttf';wordcloud = WordCloud( font_path='/Library/Fonts/AppleGothic.ttf', background_color='white').generate(' '.join(tokens))plt.imshow(wordcloud, interpolation='bilinear')plt.axis(\"off\")plt.show() 결과 화면 스팀잇에서 작성한 모든글을 가져와서 단어구름 만들기 글 한건에 대해서 분석이 완료 되었다. 이제 내가 작성한 모든 글을 가져와서 분석해보자. 12345678910111213141516171819202122232425262728293031from steem import Steem from steem.blog import Blogimport matplotlib.pyplot as pltfrom wordcloud import WordCloudfrom konlpy.tag import Mecab# 1. 스팀잇에서 작성한 글 모두 가져오기username = 'anpigon'b = Blog(username)posts = b.all()texts = []for post in posts: if post.body != \"\": texts.append(post.body.replace('\\n', '')) # 2. 형태소 분석하여 명사 단어 추출하기 tagger = Mecab()tokens = []for text in texts: tokens += tagger.nouns(text)# 3. 단어구름 만들기wordcloud = WordCloud( font_path='/Library/Fonts/AppleGothic.ttf', background_color='white', max_words=2000,).generate(' '.join(tokens))plt.imshow(wordcloud, interpolation='bilinear')plt.axis(\"off\")plt.show() 결과 화면 내가 평소에 글을 작성할 때, 구현, 사용, 아래 단어를 많이 사용하는 것을 볼 수 있다. 해당 단어는 카운트에서 제외하고 다시 실행해보자. 12345678910111213141516from wordcloud import WordCloud, STOPWORDSstopwords = set(STOPWORDS)stopwords.add(\"사용\")stopwords.add(\"구현\")stopwords.add(\"아래\")wordcloud = WordCloud( font_path='/Library/Fonts/AppleGothic.ttf', stopwords=stopwords, background_color='white', max_words=2000,).generate(' '.join(tokens))plt.imshow(wordcloud, interpolation='bilinear')plt.axis(\"off\")plt.show() 결과 화면 아까와는 다른 결과가 나왔다. 이제 사각형 형태의 단어구름 모양을 이쁜 구름모양 ☁으로 바꿔보자. 참고로, 워드클라우드 깃허브 샘플소스에는 엘리스와 다스베이더 예제가 포함되어 있다. 나는 픽사베이(pixabay)에서 무료 구름 이미지를 가져와서 적용하였다. 12345678910111213141516171819from os import pathfrom PIL import Imageimport numpy as npimport osd = path.dirname(__file__) if \"__file__\" in locals() else os.getcwd()mask = np.array(Image.open(path.join(d, 'cloud.png')))wordcloud = WordCloud( font_path='/Library/Fonts/AppleGothic.ttf', background_color=\"white\", max_words=2000, stopwords=stopwords, mask=mask,).generate(' '.join(tokens))plt.imshow(wordcloud, interpolation='bilinear')plt.axis(\"off\")plt.show() 결과 화면 이미지 파일로 저장하고 싶으면 to_file()함수를 사용하면 된다. 1wordcloud.to_file(path.join(d, \"wordcloud.png\")) 단어 빈도수 계산 nltk와 plt모듈을 사용하면 단어 빈도수를 계산하여 그래프로 나타낼 수 있다. 123456import nltkplt.figure(figsize=(12,6))words = nltk.Text(tokens, name='단어 빈도수')words.plot(50) # 50개만plt.show() 결과 화면 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"형태소 분석","slug":"형태소-분석","permalink":"https://anpigon.github.io/tags/형태소-분석/"},{"name":"단어구름","slug":"단어구름","permalink":"https://anpigon.github.io/tags/단어구름/"}],"author":"anpigon"},{"title":"[Steemit] 스팀잇 보상받기 자동화 하기","slug":"/busy/@anpigon/2eez4w","date":"2018-09-12T16:36:39.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/busy/@anpigon/2eez4w/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/2eez4w/","excerpt":"안녕하세요. @anpigon입니다.매번 스팀잇 지갑에 들어가서 보상을 받는 것이 귀찮아서 만들었습니다.이 포스팅에서는 보상을 자동으로 받는 봇을 구현합니다. 그리고 안드로이드폰에서 봇을 실행 할 수 있는 방법을 설명합니다. 놀고 있는 안드로이드를 재활용해도 좋습니다. 안드로이드 마켓에서 도리앱 설치","text":"안녕하세요. @anpigon입니다.매번 스팀잇 지갑에 들어가서 보상을 받는 것이 귀찮아서 만들었습니다.이 포스팅에서는 보상을 자동으로 받는 봇을 구현합니다. 그리고 안드로이드폰에서 봇을 실행 할 수 있는 방법을 설명합니다. 놀고 있는 안드로이드를 재활용해도 좋습니다. 안드로이드 마켓에서 도리앱 설치 도리앱(Dory)은 안드로이드에서 Node.js로 구현된 코드를 실행할 수 있는 앱입니다. 구글 마켓에서 Dory - node.js을 찾아 설치합니다. https://play.google.com/store/apps/details?id=io.tempage.dorynode 설치가 완료되면 도리앱을 실행하고 Add New Temfile 버튼을 선택합니다. 그럼 아래와 같이 console.log('Hello World');가 입력되어 있는 검은 화면이 보입니다. 입력되어 있는 내용은 모두 지웁니다. npm 모듈 설치 필요한 모듈을 설치합니다. 오른쪽 상단 메뉴에서 npm install -g를 선택합니다. 그리고 steem와 node-cron를 각각 입력하여 설치합니다. ｝ 에디터에 아래 코드를 복사&amp;붙여넣기 합니다. 그리고 save버튼을 눌러 저장합니다. 코드 내용(복사&amp;붙여넣기) 1234567891011121314151617181920const steem = require('steem');const cron = require('node-cron');const username = process.env.username;const wif = process.env.wif;function reward() ｛ steem.api.getAccountsAsync([username]).then(function([account]) ｛ const ｛ name, reward_vesting_steem, reward_sbd_balance, reward_vesting_balance ｝ = account; console.log(`Pending Rewards: $｛reward_vesting_steem｝ / $｛reward_sbd_balance｝ / $｛reward_vesting_balance｝`); if(reward_vesting_balance !== \"0.000000 VESTS\") ｛ steem.broadcast.claimRewardBalanceAsync(wif, name, '0.000 STEEM', '0.000 SBD', reward_vesting_balance).then(function() ｛ console.log(\"Rewards Claimed!\"); ｝); ｝ ｝);｝// 1시간마다 실행cron.schedule('0 */1 * * *', reward); 뒤로가기 버튼을 눌러 이전 화면으로 이동합니다. 그리고 Setting버튼을 눌러 설정화면으로 이동합니다. 설정 화면의 하단의 environment1과 environment2에 각각 username 사용자아이디와 wif 포스팅키를 입력합니다. 그리고 부팅될때 봇이 자동으로 실행되도록 하고 싶으면 start on boot를 on합니다. START 버튼을 누르면 cron에 설정한 시간마다 실행됩니다. STD OUT버튼을 누르면 아래와 같이 실행 로그를 확인 할 수 있습니다. node-cron 추가 설명 코드 맨 아래에 있는 cron.schedule함수의 입력값* * * * *은 봇이 실행되는 시간을 설정함니다. 각 입력값은 순서대로 분, 시간, 일, 월, 요일을 의미합니다. 만약 매일 아침 7시에 동작하고 싶다. 하면 아래와 같이 입력합니다. 0 7 * * * : 매일 7시 0분에 실행. 몇 가지 예제를 더 나열 하겠습니다. 5 * * * * : 매 시간 5분에 실행. 0 5 1 * *: 매달 1일 새벽 5시에 실행. */5 * * * * : 5분 마다 실행. 0 */3 * * * : 3시간에 한 번씩 실행. 0 7,21 * * * : 새벽 5시와 21시에 실행. cronjob에 대해 더 자세히 알고 싶으면 인터넷에서 찾아보시기 바랍니다. 위 방법을 사용하면 필요한 자동화봇을 만들어 안드로이드폰에서 동작시킬 수 있습니다. 여기까지 읽어주셔셔 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"},{"name":"자동화","slug":"자동화","permalink":"https://anpigon.github.io/tags/자동화/"}],"author":"anpigon"},{"title":"크롬브라우저에서 이모지(emoji) 쉽게 입력하는 방법","slug":"/busy/@anpigon/emoji","date":"2018-09-11T00:22:39.000Z","updated":"2019-11-11T13:41:49.852Z","comments":true,"path":"/busy/@anpigon/emoji/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/emoji/","excerpt":"이모지 입력할때마다 매번 getemoji.com 사이트에서 복사&amp;붙여넣기 해서 사용했습니다. 너무 불편해서 크롬 확장프로그램을 찾아봤습니다.아래 설치 URL 통해서 크롬 브라우저에 설치가능합니다.https://chrome.google.com/webstore/detail/emoji-keyboard-by-emojion/ipdjnhgkpapgippgcgkfcbpdpcgifncb?utm_source=chrome-ntp-icon","text":"이모지 입력할때마다 매번 getemoji.com 사이트에서 복사&amp;붙여넣기 해서 사용했습니다. 너무 불편해서 크롬 확장프로그램을 찾아봤습니다.아래 설치 URL 통해서 크롬 브라우저에 설치가능합니다.https://chrome.google.com/webstore/detail/emoji-keyboard-by-emojion/ipdjnhgkpapgippgcgkfcbpdpcgifncb?utm_source=chrome-ntp-icon 설치가 완료되면 주소창 왼편 유니콘 아이콘을 클릭합니다. 이모지를 입력할 수 있는 팝업창이 나타납니다. 이제 이모지를 좀더 편하게 입력할 수 있겠어요.😄 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"꿀팁","slug":"꿀팁","permalink":"https://anpigon.github.io/tags/꿀팁/"},{"name":"크롬 브라우저","slug":"크롬-브라우저","permalink":"https://anpigon.github.io/tags/크롬-브라우저/"},{"name":"이모지","slug":"이모지","permalink":"https://anpigon.github.io/tags/이모지/"}],"author":"anpigon"},{"title":"[머신러닝] 파이썬으로 스팀잇 형태소 분석하기 #1","slug":"/busy/@anpigon/5s1aam","date":"2018-09-10T15:28:06.000Z","updated":"2019-11-11T13:41:49.836Z","comments":true,"path":"/busy/@anpigon/5s1aam/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/5s1aam/","excerpt":"안녕하세요. @anpigon 입니다.구글 Keynote (Google I/O '18) 발표 영상을 이제서야 봤습니다. 발표 내용은 구글 어시스턴트의 새로운 기능에 관한 내용입니다. 여기서 주목할 기능은 인공지능(AI)이 미용실이나 레스토랑에 전화를 걸어 예약을 해주는 기능입니다.","text":"안녕하세요. @anpigon 입니다.구글 Keynote (Google I/O '18) 발표 영상을 이제서야 봤습니다. 발표 내용은 구글 어시스턴트의 새로운 기능에 관한 내용입니다. 여기서 주목할 기능은 인공지능(AI)이 미용실이나 레스토랑에 전화를 걸어 예약을 해주는 기능입니다. 인공지능이 미용실에 직접 전화를 걸어 대화하면서 예약하는 장면은 소름 돋을 정도였습니다. 사람인지 인공지능인지 구분할 수 없을 정도입니다. 심지어 대화 중간에 망설이는 듯이 &quot;음…&quot;하는 소리까지 냅니다. 아래 유튜브 링크에서 해당 발표 영상을 볼 수 있습니다. 35분부터 해당 내용이 나옵니다. 한글 자막으로 설정하고 보세요. (라이센스 관련 내용을 찾지 못하여 영상을 포스트 내용에 포함시키지 않았습니다. 클릭해서 유튜브에서 감상하기실 바랍니다.) 이 영상을 보고 인공지능(AI)에 관심이 생겼습니다. 관심있는 기술부터 공부하면서 정리할 예정입니다. 관심 분야가 너무 많아서 큰일이네요.🤯 서론은 여기까지 하고 본론으로 들어가겠습니다. KoNLPy 모듈 설치 한글 형태소 분석을 위해서는 Lucy Park(박은정)님이 개발한 KoNLPy 모듈이 필수다. 아래는 제26회 한글 및 한국어 정보처리 학술대회 논문집(2014년)에 발표한 요약본이다. 너무 멋진 글이라고 생각하여 발췌하였다. 파이썬은 간결한 아름다움을 추구하는 동시에 강력한 스트링 연산이 가능한 언어다. KoNLPy는 그러한 특장점을 살려, 파이썬으로 한국어 정보처리를 할 수 있게 하는 패키지이다. 꼬꼬마, 한나눔, MeCab-ko 등 국내외에서 개발된 여러 형태소 분석기를 포함하고, 자연어처리에 필요한 각종 사전, 말뭉치, 도구 및 다양한 튜토리얼을 포함하여 누구나 손쉽게 한국어 분석을 할 수 있도록 만들었다. 출처: https://www.lucypark.kr/docs/2014-10-10-hclt.pdf 우선 파이썬과 자바는 설치가 되어있다고 가정한다. 설치방법에 대한 자세한 내용은 아래 홈페이지를 참고한다. http://konlpy.org/ko/latest/install/ 1$ sudo apt-get install g++ openjdk-7-jdk python-dev python3-dev 아래와 같이 KoNLPy 를 설치한다. 123456$ pip install konlpyCollecting konlpy Downloading https://files.pythonhosted.org/packages/b1/41/73127de031d710fa6fc640cc4d4d399977e7a96423131fcd180b9f69627c/konlpy-0.4.4-py2.py3-none-any.whl (22.5MB) 100％ |████████████████████████████████| 22.5MB 25kB/sInstalling collected packages: konlpySuccessfully installed konlpy-0.4.4 환경변수에 JAVA_HOME을 설정한다. 맥OS는 아래와 같이 입력한다. 1JAVA_HOME=$(/usr/libexec/java_home) 그리고 Jpype1-py3를 설치한다. 1$ pip install Jpype1-py3 그 다음에는 Python에서 아래와 같이 입력한다. 123$ python&gt;&gt;&gt; import nltk&gt;&gt;&gt; nltk.download() 아래와 같이 창이 뜨면 All Package 탭을 선택한 후 stopwords와 punkt를 더블 클릭하여 다운로드 한다. 필요한 모듈 설치가 모두 완료되었다. 한글 형태소 분석하기 KoNLPy를 사용하면 꼬꼬마, 한나눔 등의 형태소 분석기를 사용할 수 있다. 주피터 노트북에서 코드를 작성하면 테스트하기 편리하다. 다음과 같이 주피터 노트북을 설치하고 실행한다. 12$ pip install jupyter$ jupyter notebook 꼬꼬마 형태소 분석기 사용하기 꼬꼬마(Kkma) 형태소 분석기는 서울대학교 IDS (Intelligent Data Systems) 연구실에서 개발하였다. 꼬꼬마 모듈을 사용하기 위해 import 한다. 12from konlpy.tag import Kkmakkma = Kkma() 아래와 같이 문장(sentences)분석을 한다. 마침표가 없어도 2개의 문장으로 분석한다. 12kkma.sentences('이것은 형태소 분석기 입니다 아버지가방에들어가신다')[이것은 형태소 분석기 입니다', '아버지가방에 들어가신다']` 아래와 같이 명사(nouns) 분석도 한다. 12kkma.nouns('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '형태소', '분석기', '아버지', '아버지가방', '가방'] 형태소(pos) 분석을 한다. 한글은 영어와는 다르게 형태의 변화가 많다. 그래서 최소한의 의미 단위인 형태소로 분석한다. 12345678910111213kkma.pos('이것은 형태소 분석기 입니다 아버지가방에들어가신다')[('이것', 'NP'), ('은', 'JX'), ('형태소', 'NNG'), ('분석기', 'NNG'), ('이', 'VCP'), ('ㅂ니다', 'EFN'), ('아버지', 'NNG'), ('가방', 'NNG'), ('에', 'JKM'), ('들어가', 'VV'), ('시', 'EPH'),('ㄴ다', 'EFN')] 한나눔 형태소 분석기 사용하기 한나눔(Hannanum) 형태소 분석기 는 카이스트 SWRC 연구소에서 개발하였다. 12from konlpy.tag import Hannanumhannanum = Hannanum() 한나눔 명사 분석은 꼬꼬마와는 분석 결과가 다르다. 12hannanum.nouns('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '형태소', '분석기', '아버지가방에들어가'] 한나눔 형태소 분석 결과이다. 12hannanum.morphs('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '은', '형태소', '분석기', '일', 'ㅂ니다', '아버지가방에들어가', '이', '시ㄴ다'] 12345678910hannanum.pos('이것은 형태소 분석기 입니다 아버지가방에들어가신다'[('이것', 'N'), ('은', 'J'), ('형태소', 'N'), ('분석기', 'N'), ('일', 'P'), ('ㅂ니다', 'E'), ('아버지가방에들어가', 'N'), ('이', 'J'), ('시ㄴ다', 'E')] Open Korean Text 형태소 분석기 사용하기 이전에 트위터에서 만든 형태소 분석기가 Open Korean Text로 바뀌었다. 12from konlpy.tag import Oktokt = Okt() 12okt.nouns('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['것', '형태소', '분석', '기', '아버지', '가방'] 12okt.morphs('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이', '것', '은', '형태소', '분석', '기', '입니', '다', '아버지', '가방', '에', '들어가신', '다'] 1234567891011121314okt.pos('이것은 형태소 분석기 입니다 아버지가방에들어가신다')[('이', 'Determiner'), ('것', 'Noun'), ('은', 'Josa'), ('형태소', 'Noun'), ('분석', 'Noun'), ('기', 'Noun'), ('입니', 'Adjective'), ('다', 'Eomi'), ('아버지', 'Noun'), ('가방', 'Noun'), ('에', 'Josa'), ('들어가신', 'Verb'), ('다', 'Eomi')] 코모란 형태소 분석기 사용하기 코모란(Komoran) 형태소 분석기은 Shineware Soft에서 개발하였다. 12from konlpy.tag import Komorankomoran = Komoran() 12komoran.nouns('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['형태소', '분석기', '아버지가방에들어가신다'] 12komoran.morphs('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '은', '형태소', '분석기', '이', 'ㅂ니다', '아버지가방에들어가신다'] 12345678komoran.pos('이것은 형태소 분석기 입니다 아버지가방에들어가신다')[('이것', 'NP'), ('은', 'JX'), ('형태소', 'NNP'), ('분석기', 'NNG'), ('이', 'VV'), ('ㅂ니다', 'EC'), ('아버지가방에들어가신다', 'NNP')] 은전한닢 형태소 분석기 사용하기 은전한닢(Mecab) 형태소 분석기는 카카오에 근무중인 유영호, 이용운 개발자님이 개발하였다. 12from konlpy.tag import Mecabmecab = Mecab() 12mecab.nouns('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '형태소', '분석기', '아버지', '방'] 12mecab.morphs('이것은 형태소 분석기 입니다 아버지가방에들어가신다')['이것', '은', '형태소', '분석기', '입니다', '아버지', '가', '방', '에', '들어가', '신다'] 123456789101112mecab.pos('이것은 형태소 분석기 입니다 아버지가방에들어가신다')[('이것', 'NP'), ('은', 'JX'), ('형태소', 'NNG'), ('분석기', 'NNG'), ('입니다', 'VCP+EF'), ('아버지', 'NNG'), ('가', 'JKS'), ('방', 'NNG'), ('에', 'JKB'), ('들어가', 'VV'), ('신다', 'EP+EC')] 형태소 분석기 5개 중에서 어떤 것을 사용해야 좋을지 선택하기가 어려웠다. 그래서 내가 작성한 스팀잇 글 전체(26개)를 형태소 분석하는데 걸리는 시간을 체크해보았다. 꼬꼬마는 품사 분석 정확도가 매우 뛰어나지만, 분석 시간이 너무 오래 걸리는 단점이 있다. 빠른 형태소 분석이 필요하면 은전한닢을 사용하는 것이 좋다. 구분 꼬꼬마 오픈한국어 코모란 한나눔 은전한닢 소요시간(초) 30.779 7.050 5.499 9.607 1.187 아래는 각 형태소 분석기가 분석하는데 걸리는 시간을 체크하는데 사용한 코드 내용이다. 12345678910111213141516171819202122import timefrom konlpy.tag import Kkma, Okt, Komoran, Hannanum, Mecabfrom steem import Steem from steem.blog import Blogusername = 'anpigon'b = Blog(username)posts = b.all()# posts = b.take(10)texts = []for post in posts: if post.body != \"\": texts.append(post.body.replace('\\n', ''))pos_taggers = [('Kkma', Kkma()), ('Okt', Okt()), ('Komoran', Komoran()), ('Hannanum', Hannanum()), ('Mecab', Mecab())]for name, tagger in pos_taggers: process_time = time.time() for text in texts: tagger.pos(text) process_time = time.time() - process_time print('module = ％10s, ％.3f secs' ％ (name, process_time)) 여기까지 읽어주셔서 감사합니다. 추가: python steem SDK는 https://github.com/steemit/steem-python 에서 가이드를 보고 설치해주세요.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"파이썬 머신러닝","slug":"개발-이야기/파이썬-머신러닝","permalink":"https://anpigon.github.io/categories/개발-이야기/파이썬-머신러닝/"}],"tags":[{"name":"파이썬","slug":"파이썬","permalink":"https://anpigon.github.io/tags/파이썬/"},{"name":"머신러닝","slug":"머신러닝","permalink":"https://anpigon.github.io/tags/머신러닝/"},{"name":"형태소 분석","slug":"형태소-분석","permalink":"https://anpigon.github.io/tags/형태소-분석/"}],"author":"anpigon"},{"title":"[Steem Project #1] 스팀잇 펫 연구소","slug":"/busy/@anpigon/steem-project-1","date":"2018-09-07T10:20:54.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/busy/@anpigon/steem-project-1/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/steem-project-1/","excerpt":"안녕하세요. @anpigon입니다.최근에 블록체인과 Node.js를 공부하면서 머릿속에서 어느 정도 개념을 이해했습니다. 그리고 구현해보고 싶은 것들이 생겼습니다. 여유시간에 계획했던 것들을 하나씩 만들면서 과정이나 결과물을 공개하려고 합니다. 다양한 시도를 하면서 제가 가지고 있는 아이디어를 공유하고 싶습니다.","text":"안녕하세요. @anpigon입니다.최근에 블록체인과 Node.js를 공부하면서 머릿속에서 어느 정도 개념을 이해했습니다. 그리고 구현해보고 싶은 것들이 생겼습니다. 여유시간에 계획했던 것들을 하나씩 만들면서 과정이나 결과물을 공개하려고 합니다. 다양한 시도를 하면서 제가 가지고 있는 아이디어를 공유하고 싶습니다. 스팀잇에 펫이 있으면 어떨까?하고 생각해보았습니다. 구현하다보니 이런 결과물이 나왔네요. 아래는 **“스팀잇 펫 연구소”**입니다. 스팀잇 펫 연구소 ‧ 접속 주소: https://anpigon.github.io/pet 좌측상단의 입력칸에 **“사용자 아이디를 입력”**합니다. 입력한 사용자 아이디가 유효하면, 작성한 글 중에서 보팅 가능한 글을 자동으로 가져옵니다. 펫 아래쪽에 **“보팅받기 버튼”**을 누르면, 펫이 사용자가 작성한 글 중에 하나를 선택하여 보팅해줍니다. 펫은 하루에 한번만 보팅해줍니다. 2마리 펫으로 부터 보팅을 받았다면 내일 다시 보팅 받을 수 있습니다. 각 펫의 보팅금액은 약 $0.001입니다. 두 펫의 보팅을 모두 받으면 총 보팅금액이 $0.002 정도 되네요. 스팀잇 커뮤니티가 활성화되는데 도움이 되었으면 좋겠습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"}],"author":"anpigon"},{"title":"[블록체인] 이더리움(Ethereum) 공부 #3 - 트랜잭션과 서명","slug":"/busy/@anpigon/ethereum-3","date":"2018-09-07T00:46:06.000Z","updated":"2019-11-11T13:41:49.829Z","comments":true,"path":"/busy/@anpigon/ethereum-3/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/ethereum-3/","excerpt":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook","text":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook 자바스크립트에서는 web3.js를 사용하여 이더리움 네트워크와 연동한다. 아래와 같이 설치하여 사용한다. 1$ npm install web3 또는, 브라우저에서 동작하는 경우에는 CDN를 사용한다. 1&lt;script src=\"https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js\"&gt;&lt;/script&gt; 트랜잭션(Transactions) **트랜잭션(Transactions)**은 외부 소유 계정(EOA)에서 생성되어 이더리움 블록체인에 기록된 서명된 메시지다. 트랜잭션을 통해서만 이더(ether)를 전송하거나, 이더리움 가상 머신(EVM)에 있는 컨트랙트를 실행 할 수 있다. 트랜잭션의 구조 트랜잭션은 다음과 같은 필드로 구성된다. nonce: EOA에 발급되는 트랜잭션 일련번호. gas price: 가스 가격 gas limit: 가스의 최대 사용량 to: 수신자 주소 value: 수신자에게 보내는 이더(ether) 개수 data: 가변길이의 바이너리 데이터(payload) v, r, s: ECDSA 서명 구성 요소 트랜잭션에는 발신자 주소를 의미하는 from 필드를 포함하지 않는다. 발신자의 공개키는 ECDSA 서명의 구성요소(v,r,s)에서 계산 할 수 있기 때문이다. 그리고 공개키에서 주소를 계산할 수 있다. nonce nonce는 EOA가 생성하여 블록체인에 기록된 트랜잭션 개수이다. nonce는 트랜잭션의 중복 전송을 방지하는데 사용된다. 예를 들면, 10 ether를 가지고 있는 계정이 있다. 그리고 이 계정에서 6 ether를 소비하는 두 개의 트랜잭션 nonce 1과 트랜잭션 nonce 2에 서명하여 전송한다. 이더리움 노드는 트랜잭션을 수신한 순서가 아닌 nonce의 순서로 처리한다. 트랜잭션 nonce 1이 성공적으로 처리되면 계정의 잔액을 4 ether로 줄인다. 그리고 트랜잭션 nonce 2는 잔액이 부족하므로 유효하지 않은 것으로 간주한다. 그러나 트랜잭션 nonce 2가 먼저 수신되면 노드는 이를 유지하고 트랜잭션 nonce 1이 도착할 때 까지 트랜잭션의 유효성을 검사하지 않는다. 아래와 같이 web3를 사용하여 nonce를 조회 할 수 있다. 1234const address = \"0x57FC45cc929f84eC95cd6C6903bBcA8d1164d0B3\"web3.eth.getTransactionCount(address, function(error, result) ｛ console.log(result)｝) 새로운 트랜잭션을 생성할 때, 다음 nonce를 조회하여 트랜잭션에 포함해야 한다. 그러나 트랜잭션이 블록체인에 기록(채굴)되기 전까지는 getTransactionCount() 함수의 합계에 포함되지 않는다. 그래서 블록체인에 기록되기 전인 pending 상태의 트랜잭션은 프로그램상에서 계산하여 저장하고 있어야 한다. gas price 가스(gas)는 이더(ether)와는 별도의 가상 화폐다. 가스는 DDoS 공격이나 악의적으로 자원을 소모하게 하는 트랜잭션을 방지하기 위해 사용된다. 트랜잭션에 포함되는 gasPrice 필드는 트랜잭션 생성자가 가스 가격을 설정할 수 있다. 가스 가격은 GWei 단위를 사용한다. 현재 이더리움 네트워크의 가스 정보는 ethgasstation.info에서 확인 할 수 있다. 트랜잭션의 가스 가격을 높게 설정하면 블록체인에 더 빨리 기록된다. 설정할 수 있는 최소 가스 가격은 0이며, 이것은 수수료가 없는 트랜잭션을 의미한다. 채굴자 입장에서는 보상받을 수 있는 가스비가 높은 순으로 블록체인에 기록하기 때문에, 가스비가 낮은 트랜잭션은 우선순위가 낮을 수밖에 없다. 아래와 같이 web3을 사용하여 이더리움 네트워크 평균 가스 가격을 조회할 수 있다. 이것은 말 그대로 네트워크에서 소비된 가스의 평균 가격이다. 123web3.eth.getGasPrice(function(err, res) ｛ console.log(res.toNumber())｝) gas limit 가스와 관련된 두 번째 중요한 값은 gasLimit이다. gasLimit는 트랜잭션을 처리하는데 사용할 최대 가스 개수를 설정한다. 단순하게 하나의 EOA에서 다른 EOA로 이더(ether)를 전송하는 트랜잭션에 필요한 가스량은 21,000개로 고정되어 있다. 따라서 이더 전송에 소비되는 수수료를 계산하려면 가스 가격에 21,000를 곱하면 된다. 123web3.eth.getGasPrice(function(err, res) ｛ console.log(res * 21000)｝) 트랜잭션 목적지가 컨트랙트 주소인 경우에는 필요한 가스량을 추정할 수는 있지만 정확하게 계산할 수는 없다. 컨트랙트 호출에 필요한 가스량은 컨트랙트 실행이 완료된 후에 결정된다. 만약 gasLimit를 컨트랙트가 실행하는데 필요한 가스량보다 적게 설정한 경우, 컨트랙트는 실행되지 못하고 가스 비용만 소비하게 된다. 대부분은 gasLimit를 초과하여 설정한다. 왜냐하면 컨트랙트가 실행되면 실제로 사용된 가스 비용만 차감하기 때문이다. 그리고 gasLimit는 잘못된 컨트랙트 호출로 인해 예상치보다 많은 가스 비용을 사용하는 것을 방지해준다. to to 필드는 수신자(도착지) 주소를 의미한다. 수신자 주소는 EOA 또는 컨트랙트 주소이다. 이더리움 네트워크에서는 주소를 검증하지 않는다. 따라서 잘못된 주소로 전송된 이더는 영원히 사용할 수 없게 된다. value와 data 트랜잭션에서 가장 중요한 &quot;payload&quot;는 value와 data라는 두 개의 필드에 의해 사용된다. 트랜잭션은 다음과 같이 네 가지 조합이 가능하다. ‘value와 data 둘다 사용’, ‘value만 사용’, ‘data만 사용’, ‘value와 data 둘다 없음’. value만 있는 트랜잭션은 송금(payment) 이다. 그리고 데이터만 있는 트랜잭션은 **컨트랙트 호출(invocation)**이다. value도 data도 없는 트랜잭션은 그냥 가스 낭비다. value 전송 value을 포함하는 트랜잭션은 **송금(payment)**이라고 보면 된다. EOA 주소 또는 컨트랙트 주소로 value를 포함한 트랜잭션을 전송하면 해당 계정의 ether 잔액에 value가 추가된다. 하지만, 이 트랜잭션은 EOA 주소와 컨트랙트 주소에서는 다르게 작동한다. 대상 주소(to)가 컨트랙트 주소인 경우에는 EVM이 컨트랙트를 실행하고 트랜잭션의 data에 지정된 함수를 호출하려고 시도한다. 트랜잭션에 data가 없으면 EVM에서 대상 컨트랙트의 이름없는(fallback) 함수를 호출한다. 그리고 해당 함수가 송금가능(payable)인 경우에는 다음에 수행할 작업을 결정하기 위해 해당 함수를 실행한다. 송금가능(payable) 함수가 성공적으로 실행완료되면 컨트랙트의 ether 잔액에 송금된 금액을 반영하여 컨트랙트 상태가 업데이트된다. 만약 트랜잭션에 data가 포함되어 있으면 이 트랜잭션은 컨트랙트 주소로 처리될 가능성이 크다. 트랜잭션에 포함된 데이터는 EVM에 의해 함수 호출(function invocation) 로 해석되고 data에 지정된 함수가 호출된다. 디지털 서명(ECDSA, Elliptic Curve Digital Signature Algorithm) 이더리움은 디지털 서명에 ECDSA(Elliptic Curve Digital Signature Algorithm) 알고리즘을 사용한다. ECDSA는 타원 곡선 개인/공개키를 기반으로하는 디지털 서명에 사용하는 알고리즘이다. 디지털 서명은 이더 소유를 증명하고 부인 방지하는데 사용된다. ECDSA를 더 자세히 알고 싶으면 단계별로 설명해주는 가이드 문서를 참고하세요. http://bit.ly/2r0HhGB 이더리움의 서명된 메세지는 RLP로 인코딩된 트랜잭션 데이터의 Keccak256 해시이다. 코드로 나타내면 다음과 같다. 1Sig = sign(keccak256(rlp.encode(tx.raw)), privateKey) sign함수는 일반적으로 R과 S값으로 구성된 서명 Sig를 생성한다. 1Sig = (R, S) 이더리움 트랜잭션 서명은 다음 순서로 진핸된다. nonce, gasPrice, gasLimit, to, value, data, v, r, s의 9개 필드를 포함하는 트랜잭션 데이터 구조를 만든다. 트랜잭션을 RLP 인코딩하여 serialize한다. 이 serialize 메시지의 Keccak256 해시를 계산한다. EOA의 개인키로 해시를 ECDSA 서명한다. ECDSA 서명의 계산된 r과 s값을 트랜잭션에 삽입한다. raw 트랜잭션 생성하여 서명하기 이더리움 트랜잭션 생성에는 ethereumjs-tx를 사용한다. 이더리움 트랜잭션을 생성하여 서명하고 전송해 보자 123456789101112131415161718192021222324252627282930313233343536373839404142const Web3 = require('web3')const EthereumTx = require('ethereumjs-tx')let web3if (typeof web3 !== 'undefined') ｛ web3 = new Web3(web3.currentProvider)｝ else ｛ // Set the provider you want from Web3.providers web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"))｝// EOA 계정 주소const fromAddress = '0xf6d0B5f612dEecB00345D...'const toAddress = '0xDf6d0B5d345EecB00f612...'// 1. nonce 값 조회web3.eth.getTransactionCount(fromAddress, function(err, nonce) ｛ // 2. 트랙잭션 데이터 생성 const txParams = ｛ nonce: web3.toHex(nonce), to: toAddress, value: web3.toHex(web3.toWei(0.1, 'ether').toNumber()), // 0.1 이더 gasPrice: web3.toHex(web3.toWei(1, 'Gwei').toNumber()), // 가스 가격 gasLimit: web3.toHex(300000), // 가스 최대 사용량 // EIP 155 chainId - mainnet: 1, ropsten: 3 chainId: 3, //네트워크 ID(3=Ropsten Tesetnet) ｝ const tx = new EthereumTx(txParams) // 3. 트랜잭션 서명 const privateKey = Buffer.from('91c8360c4cb4b5fac45513a7213f31d4e4a7bfcb4630e9fbf074f42a203ac0b9', 'hex') tx.sign(privateKey) // 4. 트랜잭션 전송하기 const serializedTx = '0x' + tx.serialize().toString('hex') web3.eth.sendRawTransaction(serializedTx, function(err, txId) ｛ if (!err) ｛ console.log('txId: ', txId) // 트랜잭션ID값 ｝ ｝)｝) 서명 검증이나 공개키 계산은 ethereumjs-tx를 이용하면 아래와 같이 간단하게 처리할 수 있다. 트랜잭션 서명 검증하기 123if (tx.verifySignature()) ｛ console.log('서명 검증 완료!')｝ 서명에서 발신자 주소 계산하기 1console.log('발신자 주소: ' + tx.getSenderAddress().toString('hex')) 단순 반복 공격 방지(EIP-155) EIP-155은 **“단순 반복 공격 방지(Simple Replay Attack Protection)”**를 위한 제안이다. 서명하기 전 트랜잭션 데이터 내부에 체인ID(chain identifier)를 포함한다 . 이렇게하면 하나의 블록체인(메인넷)에서 생성된 트랜잭션이 다른 블록체인(이더리움 클래식 또는 테스트넷)에서 유효하지 않다. 하나의 네트워크에서 브로드 캐스트되는 트랜잭션을 다른 네트워크에서 반복하여 사용할 수 없기 때문에 &quot;반복 공격 보호(replay attack protection)&quot;라고 한다. EIP-155가 적용된 서명을 코드로 나타내면 아래와 같다. r, s, v 값 계산하기 12345678910111213141516const secp256k1 = require('secp256k1')// EIP 155 chainId - mainnet: 1, ropsten: 3const chainId = 1let v = chainIdv -= chainId * 2 + 8// Keccak256 hash of the RLP-encoded dataconst msgHash = keccak(rlp.encode(tx.raw))// sign a transaction with a given private keyconst sig = secp256k1.sign(msgHash, privateKey)sig.r = sig.signature.slice(0, 32)sig.s = sig.signature.slice(32, 64)sig.v = sig.recovery + 27sig.v += chainId * 2 + 8 r, s, v 값에서 발신자 공개키 계산하기 12345const signature = Buffer.concat([setLength(r, 32), setLength(s, 32)], 64)const recovery = v - 27const senderPubKey = secp256k1.recover(msgHash, signature, recovery)const senderPubKey = secp256k1.publicKeyConvert(senderPubKey, false).slice(1) ECDSA 서명은 너무 복잡하여 제 수학적 머리로는 이해하기 어려웠습니다. 그래서 서명에 관련된 내용은 설명이 많이 부족합니다. 😥 여기까지 읽어주셔서 감사합니다. 이전글 이더리움(Ethereum) 공부 #1 - 키와 주소 이더리움(Ethereum) 공부 #2 - HD 지갑과 니모닉 코드","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"블록체인 기반 은행 인증서비스 “뱅크사인” 사용후기","slug":"/busy/@anpigon/6sns8d","date":"2018-08-29T06:16:06.000Z","updated":"2019-11-11T13:41:49.852Z","comments":true,"path":"/busy/@anpigon/6sns8d/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/6sns8d/","excerpt":"블록체인 기반 은행 공동 인증서비스인 &quot;뱅크사인&quot;이 2018년 27일에 오픈하였다.뱅크사인은 기존의 공인인증서를 대체하기 위해 은행연합회에서 만든 통합 인증 서비스이다. 뱅크사인은 한 번만 발급받으면 여러 은행에서 이용할 수 있다. 현재는 은행 로그인 용도로만 사용된다.","text":"블록체인 기반 은행 공동 인증서비스인 &quot;뱅크사인&quot;이 2018년 27일에 오픈하였다.뱅크사인은 기존의 공인인증서를 대체하기 위해 은행연합회에서 만든 통합 인증 서비스이다. 뱅크사인은 한 번만 발급받으면 여러 은행에서 이용할 수 있다. 현재는 은행 로그인 용도로만 사용된다. https://imgur.com/FvjvMvm.png 뱅크사인 공용앱 설치 은행앱에서 뱅크사인 로그인을 이용하려면 전국은행연합회금융에서 만든 뱅크사인 공용앱이 설치되어 있어야 한다. https://imgur.com/oCs6xbg.png https://imgur.com/uecpJSU.png 뱅크사인 앱 설명에 따르면 인증서 유효기간은 3년이다. 그리고 농협은행, 신한은행, 우리은행, SC제일은행, KEB하나은행, 기업은행, 국민은행, 수협은행, 대구은행, 부산은행, 광주은행, 제주은행, 전북은행, 경남은행, 케이뱅크에서 이용 가능하다. 뱅크사인 인증서 발급 신한은행앱에서 뱅크사인 서비스를 이용 신청하고 인증서를 발급받아 이용해보았다. 신한은행앱 로그인 화면에서 ‘로그인 방식 선택’ 버튼을 누르면 뱅크사인 로그인 방식이 추가된 것을 확인할 수 있다. 뱅크사인 로그인 방식을 선택하면 로그인 화면이 뱅크사인 로그인 화면으로 바뀐다. https://imgur.com/kiYdrYj.png https://imgur.com/nUfzaCI.png 뱅크사인 로그인을 시도하면 발급된 인증서가 없다면서, 뱅크사인 이용신청 페이지로 이동한다. https://imgur.com/5L153nf.png https://imgur.com/ul0HQzP.png 뱅크사인 이용신청 페이지에서 약관동의, 휴대폰 본인인증, 계좌 인증, 보안매체 인증을 거치고 나면 뱅크사인 인증서 발급이 완료된다. https://imgur.com/m2G2maJ.png https://imgur.com/bhx96G1.png https://imgur.com/bWmaUzS.png 다음 버튼을 누르면 뱅크사인앱이 연동되어 실행된다. 이 단계에서 뱅크사인 인증서 비밀번호 6자리를 설정한다. 그리고 추가로 지문인증이나 패턴인증을 설정할 수 있다. https://imgur.com/AwexDT1.png https://imgur.com/K7AiYKy.png https://imgur.com/YeT8uvb.png 발급이 완료되고 나면 신한은행앱 로그인시 뱅크사인앱이 연동 실행되며, 뱅크사인앱에서 인증처리 후 신한은행앱에서 로그인이 완료된다. 타은행에서 뱅크사인 인증서 등록 한번만 발급받으면 여러 은행에서 이용할 수 있다고 하니, 국민은행앱에서도 이용해보았다. 현재 국민은행은 KB스타뱅킹 미니에만 뱅크사인 로그인이 업데이트되었다. 스타뱅킹과 리브는 9월 중에 업데이트 된다고 한다. KB스타뱅킹 미니앱에서 뱅크사인 로그인을 시도하면 타은행에서 발급받은 인증서를 등록하라는 메세지가 출력된다. https://imgur.com/UMLW2Ln.png https://imgur.com/mGa84ok.png https://imgur.com/ojA9DTe.png 앞에서 신한은행앱을 통해 뱅크사인 인증서를 발급받았기 때문에, 국민은행앱에서는 휴대폰 본인인증만 하면 뱅크사인 로그인을 이용할 수 있다. https://imgur.com/ijn0Itj.png https://imgur.com/8hFXK4x.png https://imgur.com/7TKJVvH.png ___ 공인인증서와 비교해서 뱅크사인의 이점을 아직은 잘 모르겠습니다. 뱅크사인 인증서 유효기간을 3년으로 한 것은 잘했다고 인정합니다. 그러나 뱅크사인앱을 추가로 설치해야하고, 로그인할 때마다 뱅크사인앱이 실행되는 점는 불편합니다. 하지만, 금융권에서 블록체인 기술을 도입하여 서비스 한다는 점에서 블록체인의 밝은 미래를 기대해봅니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"뱅크사인","slug":"뱅크사인","permalink":"https://anpigon.github.io/tags/뱅크사인/"}],"author":"anpigon"},{"title":"[블록체인] 이더리움(Ethereum) 공부 #2 - HD 지갑과 니모닉 코드","slug":"/busy/@anpigon/ethereum-2-hd","date":"2018-08-28T13:41:27.000Z","updated":"2019-11-11T13:41:49.829Z","comments":true,"path":"/busy/@anpigon/ethereum-2-hd/","link":"","permalink":"https://anpigon.github.io/busy/@anpigon/ethereum-2-hd/","excerpt":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook","text":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook 이더리움 지갑에는 이더(ether)나 토큰(token)이 들어있지 않다. 지갑에는 한 쌍의 공개키와 개인키만 있을 뿐이다. 이더나 토큰은 이더리움 블록체인에 기록되어 있다. 지갑의 유형은 크게 비결정적 지갑(Nondeterministic Wallet)과 결정적 지갑(Deterministic Wallets)으로 구분된다. 결정적 지갑 중에서 가장 많이 사용되는 HD 지갑에 대해서 알아본다. 계층 결정적 지갑(HD Wallets) 결정적 지갑(Deterministic Wallets)은 단일 **시드(seed)**에서 많은 키를 생성하기 위해 개발되었다. 결정적 지갑 중에서 가장 발전된 형태는 계층 결정적 지갑(Hierarchical Deterministic Wallets)이다. 계층 결정적 지갑은 HD 지갑(HD Wallet)이라고도 한다. HD 지갑은 비트코인의 BIP-32와 BIP-44 표준에 정의되어 있다. HD 지갑은 트리 구조로 생성된 키를 가지고 있다. 이 트리 구조는 부모키에서 자식키를 만들 수 있고, 그 자식키에서 손자키를 만들 수 있다. 이런 방법으로 키를 무한대로 생성한다. 이렇게 키를 여러 개 생성하여 관리하는 이유는 블록체인의 투명성과 관련된 보안 문제 때문이다. 이와 관련된 문제는 나중에 별도 포스팅으로 설명하겠다. https://steemitimages.com/400x0/https://imgur.com/hppMB4b.png 시드에서 HD 지갑 생성하기 HD 지갑은 루트 시드(Root Seed) 한 개로부터 많은 키와 주소가 생성된다. 따라서 루트 시드만 알고 있으면 수천 또는 수백만 개의 키를 가지고 있는 HD 지갑 전체를 복원할 수 있다. 루트 시드는 니모닉 단어 순서(Mnemonic Word Sequence)를 가장 많이 사용한다. 루트 시드를 HMAC-SHA512 알고리즘 함수를 사용하여 해시한 값에서 마스터 개인키(Mater Private Key)과 마스터 체인코드(Master Chain Code)를 생성한다. 512비트의 해시된 값에서 왼쪽 256비트를 마스터 개인키로 사용하고, 오른쪽 256비트를 체인코드로 사용한다. 그리고 마스터 공개키는 타원곡선 곱셈 함수를 사용하여 마스터 개인키로부터 계산된다. https://steemitimages.com/500x0/https://imgur.com/Vu0SpXy.png 계층 결정적 지갑은 자식키 유도 함수(CKD)를 사용하여 부모키로 부터 자식키를 파생한다. 자식키 생성에는 부모키, 체인코드, 인덱스 번호가 사용된다. 자식키를 생성하기 위해 부모키, 체인코드, 인덱스 번호를 결합하여 HMAC-SHA512로 해시한다. 해시된 값(512비트)을 반으로 나눠 개인키(256비트)와 체인코드(256비트)를 생성한다. 이 방법으로 자식키를 계속 생성할 수 있다. 위에서 보았듯이 체인코드는 자식키를 파생하는데 사용된다. 키와 체인코드를 포함하고 있는 키를 확장키(Extended Key)라고 한다. 대부분의 HD 지갑은 키 생성을 위해 비트코인의 BIP-32 표준을 사용한다. 그리고 확장 개인키는 xprv, 확장 공개키는 xpub라는 접두어를 사용하여 식별한다. 강화된 유도법(Hardened Derivation)으로 자식키 생성 만약 자식 확장 개인키가 유출되는 경우, 자식 확장 개인키가 포함하고 있는 키와 체인코드를 사용하면 다른 자식의 개인키 전부를 알아 낼 수 있다. 이러한 문제에 대응하기 위해 HD지갑은 강화된 유도(Hardened Derivation) 함수를 사용한다. 강화된 유도 함수는 부모 키와 자식 체인코드 관계를 끊어버린다. 이렇게 해서 부모키오 자식키 사이에 **방화벽(firewall)**을 만든다. HD 지갑 키 식별자(path) HD 지갑의 키는 명명 규칙인 'path’를 사용하여 식별한다. 그리고 트리의 각 레벨은 슬래시(/) 문자로 구분된다. 마스터 개인키에서 생성된 자식 개인키는 'm’으로 시작하고, 마스터 공개키에서 생성된 자식 공개키는 'M’으로 시작한다. 예를 들면, 마스터 개인키의 0번째 자식 개인키의 path는 m/0이다. 그리고 0번째 자식 공개키의 path는 M/0이다. 0번째 자식 개인키의 1번째 손자 개인키는 m/0/1이 된다. BIP-44 비트코인의 BIP-44 표준은 복잡한 키 생성에 대한 방법을 제공한다. BIP-44는 미리 정의된 5개의 레벨의 path로 구성된다. 1m / purpose' / coin_type' / account' / change / address_index 경로에 있는 아포스트로피(’) 문자는 BIP-32의 강화된 유도(hardened derivation)가 사용됨을 나타낸다. purpose는 44’를 사용한다. BIP-44 규격이 사용됨을 의미한다. coin_type은 가상화폐 코인 유형을 의미한다. 이더리움은 60’을 사용한다. 다른 코인 유형 코드는 SLIP0044 표준 문서에서 찾아 볼 수 있다. account은 회계나 조직 목적을 위해 지갑을 하위 계좌로 세분화할 때 사용한다. change은 이더리움에서 사용하지 않는다. 비트코인에서 수신 주소(receiving address)와 잔액 주소(change address)를 구분하기 위해 사용한다. address_index는 주소 번호를 의미한다. 순차적으로 증가한다. 이제 자바스크립트로 확장 개인키와 자식키를 생성해보자. 1234567891011var Bitcore = require('bitcore-lib');// 마스터 확장 개인키 생성var xPriKey = new Bitcore.HDPrivateKey();// 단절된 확장 자식 공개키 생성var xPubKey = xPriKey.deriveChild(\"m/44'/60'/0'\").hdPublicKey;// 0번째 자식 공개키 생성var pubKey = xPubKey.deriveChild(\"m/0/0\").publicKey;console.log(publicKey) 실행결과: https://imgur.com/dOI6JdD.png 니모닉 코드 단어(BIP-39) 니모닉 코드 단어(mnemonic code words)는 순서대로 나열된 영어 단어에서 시드(seed)를 만드는 방법이다. 니모닉 코드는 BIP-39 표준에 정의되어 있다. 니모닉 코드를 사용하면 HD 지갑을 쉽게 복원할 수 있다. 니모닉 코드 단어열은 12 ~ 24 단어로 구성된다 아래 두 시드를 비교해보면, 니모닉 시드가 쉽게 읽히고 종이에 적어서 백업하기 좋다. 16진수 시드 1FCCF1AB3329FD5DA3DA9577511F8F137 12개의 단어 니모닉 시드 1wolf juice proud gown wool unfair wall cliff insect more detail hub 자바스크립트를 사용하여 니모닉 시드에서 키를 생성해보자. 우선 bitcore-mnemonic 라이브러리를 설치한다. 1npm install bitcore-mnemonic --save 아래와 같이 니모닉 단어를 생성하고 니모닉으로 부터 개인키를 생성한다. 123456789var Mnemonic = require('bitcore-mnemonic');// 니모닉 코드 생성var code = new Mnemonic(Mnemonic.Words.ENGLISH);console.log(code.toString());// 니모닉 코드에서 개인키 생성var xPriKey = code.toHDPrivateKey();console.log(xPriKey); 실행 결과 https://imgur.com/NMCAnza.png 이제 앞에서 생성한 니모닉 단어로부터 개인키를 복원해보자. 123456// 복원용 니모니 단어var words = \"damage clog alert hurt fork purchase iron cotton apple buffalo survey vast\";// 니모닉 단어로 부터 개인키 복원var xPriKey = Mnemonic(words).toHDPrivateKey();console.log(xPriKey); 실행 결과 https://imgur.com/oQsOIRB.png 참고로 bip39 라이브러리를 사용하면 한글을 니모닉 단어로 사용 할 수 있다. 만약 이더리움 지갑을 개발한다면 BIP-32, BIP-39, BIP-43, BIP-44 표준에 따라 니모닉 코드를 시드로 사용하는 HD지갑으로 구현하자. 여기까지 읽어주셔서 감사합니다. 지갑과 니모닉을 공부하면서 생소한 용어들이 많이 등장하였습니다. 한글로 어떻게 표기할지 몰라 임의로 번역하거나 영어 발음 그대로 작성한 문장이 많습니다. 이 글을 읽으면서 용어에 대한 일관성이 없어라도 이해 부탁드립니다. 이전글 이더리움(Ethereum) 공부 #1 - 키와 주소","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[아티스팀] 서울 한강 야경","slug":"/artisteem/@anpigon/artisteem--anpigon--2143501942--artisteem-sky-busy-jjangjjangman-kr--2018-08-27-23-05-06--artwork--none","date":"2018-08-27T14:05:09.000Z","updated":"2019-11-11T13:41:49.852Z","comments":true,"path":"/artisteem/@anpigon/artisteem--anpigon--2143501942--artisteem-sky-busy-jjangjjangman-kr--2018-08-27-23-05-06--artwork--none/","link":"","permalink":"https://anpigon.github.io/artisteem/@anpigon/artisteem--anpigon--2143501942--artisteem-sky-busy-jjangjjangman-kr--2018-08-27-23-05-06--artwork--none/","excerpt":"","text":"한강 길을 걷다가 달빛이 강물에 반사된 영동대교가 이뻐서 찍었습니다.멀리 보이는 롯데타워가 구름에 가려졌어요.","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"아티스팀","slug":"아티스팀","permalink":"https://anpigon.github.io/tags/아티스팀/"},{"name":"야경","slug":"야경","permalink":"https://anpigon.github.io/tags/야경/"}],"author":"anpigon"},{"title":"[블록체인] 이더리움(Ethereum) 공부 #1 - 키와 주소","slug":"/kr/@anpigon/ethereum-1","date":"2018-08-25T15:49:36.000Z","updated":"2019-11-11T13:41:49.829Z","comments":true,"path":"/kr/@anpigon/ethereum-1/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/ethereum-1/","excerpt":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook","text":"안녕하세요. @anpigon입니다.마스터 이더리움(Mastering Ethereum) 책을 보면서 정리한 글입니다. 아직 전체 내용을 다 보지는 못하였습니다. 하지만 궁금한 사항을 댓글로 문의하면, 최대한 답변해드리도록 노력하겠습니다. 책 전체 내용은 깃허브에서 볼 수 있습니다. https://github.com/ethereumbook/ethereumbook 이더리움은 주소, 개인키, 디지털 서명 등을 통해 이더(ether)를 소유하고 통제한다. 그리고 키와 주소는 지갑 또는 웰렛이라고 부르는 소프트웨어에 의해 생성되고 관리된다. 이더리움에는 2가지 유형의 계정이 있다. 외부 소유 계정(EOA)과 컨트랙트 계정(CA)이다. EOA는 지갑에서 개인키로 생성한 계정이고, CA는 컨트랙트에서 생성된 계정이다. 개인키와 공개키 개인키는 이더를 지출하는 트랜잭션을 디지털 서명하는 데 사용된다. 그리고 공개키는 이더을 수신하는 주소로 사용된다. 이더리움은 정보를 보호하기 위해 타원 곡선 암호화(ECC, Elliptic Curve Cryptography) 방식을 사용하여 공개키를 암호화한다. 타원 곡선 암호는 타원 곡선을 구성하는 여러 점들 위에서 덧셈 및 곱셈으로 표현되는 **이산 로그 문제(discrete logarithm problem)**를 기반으로 한 비대칭 또는 공개키 암호화 방식이다. 그리고 이더리움은 비트코인처럼 미국립표준기술원(NIST)에서 개발한 secco256k1이라고 부르는 표준 타원 곡선을 사용한다. 그래서 이더리움은 비트코인에서 사용하는 라이브러리 및 도구를 재사용 할 수 있다. 이제 개인키와 공개키를 생성하는 방법을 알아보자. 개인키(Private key) 개인키는 단순히 무작위로 추출된 숫자이다. 좀 더 정확하게 말하면, 개인키는 0과 n - 1 사이의 임의의 수이다. 여기서 n은 타원곡선의 위수(order)로 정의된 상수(n = 1.1578 * 1077, 2256보다 약간 작은 값)이다. 다음은 난수에서 생성한 개인키(k)이다. 16진수 문자열로 표시하였다. 1a96580eb08a2a600911fa5b98a00fb6faf7417834131f81c070d804c45bc2729 개인키를 생성할 수 있는 범위(2256)를 10진수로 나타내면 약 1077이다. 비교를 위해 예를 들자면, 우주는 약 1080개의 원자로 구성되어 있다고 한다. 만약 개인키를 잃어버린다면 우주에서 바늘 찾기만큼 어렵다. 자바스크립트를 사용하여 개인키를 생성해보자. 이더리움 키 생성에는 bitcore-lib 라이브러리를 사용한다. 아래와 같이 bitcore-lib을 설치한다. 1$ npm install bitcore-lib --save 그리고 bitcore-lib 라이브러리를 사용하여 개인키를 생성한다. 1234var Bitcore = require('bitcore-lib');var priKey = Bitcore.PrivateKey();console.log(priKey); 실행결과: 공개키(Public key) 공개키는 타원곡선 곱셈 함수를 사용하여 개인키로부터 계산된다. 계산 공식은 다음과 같다. 1K = k * G k는 개인키이고 G는 생성지점이라고 하는 상수다. 그리고 K는 계산결과로 나온 공개키다. 개인키에서 공개키는 계산할 수 있지만, 반대로 공개키에서 개인키는 계산할 수는 없다. **이산 로그(discrete logarithm) 찾기**로도 알려져 있는 역계산법은 K값을 안다는 가정 하에 k값을 계산하는 것이다. 하지만, K값을 찾기 위해서는 가능한 k를 모두 대입하는 방법밖에 없기때문에 K값을 찾는 것은 거의 불가능에 가깝다. 파워포인트로 그린 것이기 때문에 실제 타원곡선과 다릅니다. 랜덤으로 생성된 숫자 개인키(k)를 시작하여 생성지점 G라고하는 곡선의 미리 결정된 점을 곱하여 곡선상의 다른 점, 즉 대응하는 공개키(K)를 계산한다. 1K = a96580eb08a2a600911fa5b98a00fb6faf7417834131f81c070d804c45bc2729 * G 공개키(K)는 타원 곡선의 한 점으로 타원 곡선 방정식을 만족하는 X와 Y 좌표이다. 그래서 K = (x, y)로 정의된다. 1234K = (x, y)x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341Ay = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 공개키는 x좌표를 알면 y좌표를 대략 알 수 있다. 그래서 보통 y좌표가 상단인지 하단인지 구분하는 단일 비트와 x좌표만 사용하여 압축된 공개키를 사용한다. 압축되지 않은 공개키와 압축된 공개키는 모두 secp256k1 문서에 설명되어 있다. 이제 자바스크립트를 사용하여 개인키로부터 공개키를 계산해보자. 12var pubKey = priKey.toPublicKey();console.log(pubKey); 실행결과: 이더리움 주소 이더리움 주소는 공개키 해시(Keccak-256)의 마지막 20바이트로 구성된다. Keccak-256는 단방향 해시 함수이다. 개인키(k): 1k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 공개키(K)는 X와 Y 좌표를 연결하고 16진수 문자열로 표시한다. 1K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0 Keccak-256을 사용하여 공개키의 해시를 계산한다. 1Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9 공개키 해시의 마지막 20 바이트만 유지한다. 1001d3f1ef827552ae1114027bd3ecf1f086ba0f9 마지막으로 맨 앞에 &quot;0x&quot;를 붙여 이더리움 주소임을 표시한다. 10x001d3f1ef827552ae1114027bd3ecf1f086ba0f9 이제 자바스크립트로 공개키에서 이더리움 주소를 생성해보자. 이더리움 주소 생성에는 ethereumjs-util 라이브러리를 사용한다. 아래와 같이 ethereumjs-util를 설치한다. 1$ npm install ethereumjs-util --save ethereumjs-util 라이브러리를 사용하면 이더리움 주소를 간단하게 생성 할 수 있다. 12345678910111213var Bitcore = require('bitcore-lib');var EthUtil = require('ethereumjs-util');// 키쌍 생성var priKey = Bitcore.PrivateKey();var pubKey = priKey.toPublicKey();// keccak 해시(20 바이트)var addressHash = EthUtil.pubToAddress(pubKey.toBuffer(), true); // 이더리움 주소 생성var etherAddress = '0x' + addressHash.toString('hex');console.log(etherAddress); 실행결과: 이더리움 주소 유효성 체크 이더리움 주소 유효성 체크는 **EIP-55(Ethereum Improvement Proposal 55)**에 제안된 내용이다. EIP-55는 이더리움 주소에 체크섬을 추가하여 주소의 무결성을 검증하고 오류로부터 보호한다. 이 제안은 EIP-55가 적용되지 않은 이전 지갑에서도 전혀 문제를 일으키지 않는다. 방법은 간단하다. 16진수 문자열로 구성된 이더리움 주소에서 소문자를 체크섬 형태의 대문자로 바꾸기만 하면 된다. 기존 이더리움 주소: 10x7f7625faa1ca985e9ad678656a9dcdf79620df6b EIP-55 체크섬이 적용된 이더리움 주소: 10x7f7625FAa1CA985E9Ad678656A9DcdF79620dF6B 두 주소의 차이를 살펴보면 일부 소문자가 대문자로 변경되었다. 자세히 살펴보지 않으면 차이점을 발견하기 어렵다. 이더리움 주소에서 접두어(0x)를 제거하고 주소를 해시(Keccak256)한다. 1Keccak256(\"7f7625faa1ca985e9ad678656a9dcdf79620df6b\") Keccak256 해시 결과: 13015b5c87eeb15cce85e3e48eefb50b400dd497c7b0bd41f16937ead349b3784 이더리움 주소와 해시를 비교한다. 그리고 주소와 매칭되는 해시의 16진수가 0x8 이상인 경우에 주소의 소문자를 대문자로 변경한다. 12Address: 7f7625faa1ca985e9ad678656a9dcdf79620df6bHash : 3015b5c87eeb15cce85e3e48eefb50b400dd497c... 이더리움 주소 7번째에 위치한 소문자 f를 보자. 해당 해시의 7번째에 위치한 16진수 c는 0x8보다 크다. 그러므로 소문자 f를 대문자 F로 변경한다. 이와 같은 방법으로 이더리움 주소의 모든 소문자를 변경한다. 아래의 변경된 결과를 확인해보자. 12Address: 7f7625FAa1CA985E9Ad678656A9DcdF79620dF6BHash : 3015b5c87eeb15cce85e3e48eefb50b400dd497c... EIP-55의 체크섬 주소를 사용하면 이더리움 주소의 오류를 감지할 수 있다. 자바스크립 코드로 나타내면 아래와 같다. 123456789101112// 체크섬 주소로 변환etherAddress = EthUtil.toChecksumAddress(etherAddress)// 이더리움 주소 유효성 체크if (EthUtil.isValidAddress(etherAddress) === false) ｛ console.log('올바른 이더리움 주소가 아닙니다.')｝// 이더리움 체크섬 주소 유효성 체크if (EthUtil.isValidChecksumAddress(etherAddress) === false) ｛ console.log('올바른 이더리움 체크섬 주소가 아닙니다.')｝ 만약 이더리움 지갑 소프트웨어를 개발한다면 EIP-55를 반드시 적용하자. 그러면 사용자가 이더리움 주소를 잘못 입력하여 송금하는 일을 사전에 방지할 수 있다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #8 - 보팅 내역 보여주기","slug":"/kr/@anpigon/steemit-8","date":"2018-08-23T13:29:30.000Z","updated":"2019-11-11T13:41:49.828Z","comments":true,"path":"/kr/@anpigon/steemit-8/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-8/","excerpt":"안녕하세요. @anpigon입니다.이 포스팅은 제가 스팀잇과 프론트엔드 기술을 공부하고 앱을 구현하는 과정을 정리한 글입니다. 그래서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번에는 아래와 같이 보팅 내역을 볼 수 있는 페이지를 구현하였습니다.","text":"안녕하세요. @anpigon입니다.이 포스팅은 제가 스팀잇과 프론트엔드 기술을 공부하고 앱을 구현하는 과정을 정리한 글입니다. 그래서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번에는 아래와 같이 보팅 내역을 볼 수 있는 페이지를 구현하였습니다. 구현된 앱은 steemlog.github.io에서 확인 할 수 있습니다. VoteHistory 컴포넌트 구현하기 보팅 내역을 표시하는 VoteHistory 컴포넌트를 구현하자. 아래와 같이 VoteHistory.vue 파일을 생성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export default ｛ // ... computed: ｛ // ... votes () ｛ let totalRshares = 0 let totalWeight = 0 this.active_votes.forEach(e =&gt; ｛ // 해당 포스트에 보팅된 총 리워드 합산 totalRshares += parseFloat(e.rshares) // 해당 포스트에 보팅된 총 가중치 합산 totalWeight += parseFloat(e.weight) ｝) return this.active_votes.map(e =&gt; ｛ let value, curation if (this.pending_payout_value &gt; 0) ｛ // 페이아웃 이전인 경우 value = (e.rshares * (this.global.rewardBalance / this.global.recentClaims) * this.global.price) curation = '≈$' + (e.weight / this.total_vote_weight * this.pending_payout_value * 0.25 / this.global.price).toFixed(3) ｝ else ｛ // 페이아웃 이후인 경우 const o = '$' + this.total_payout_value / (this.total_payout_value + this.curator_payout_value) value = e.rshares / totalRshares * parseFloat(this.total_payout_value / o) curation = (e.weight / totalWeight * this.curator_payout_value).toFixed(3) ｝ return ｛ voter: e.voter, reputation: steem.formatter.reputation(e.reputation), weight: e.percent / 100, value: value.toFixed(3), curation: curation, time: new Date(e.time + 'Z') ｝ ｝) ｝, ...mapState(｛ global: state =&gt; state.global ｝) ｝, beforeCreate () ｛ const author = this.$route.params.author const permlink = this.$route.params.permlink steem.api.getContentAsync(author, permlink) .then(n =&gt; ｛ this.title = n.title this.total_vote_weight = n.total_vote_weight this.pending_payout_value = parseFloat(n.pending_payout_value.split(' ')[0]) this.total_payout_value = parseFloat(n.total_payout_value.split(' ')[0]) this.curator_payout_value = parseFloat(n.curator_payout_value.split(' ')[0]) this.active_votes = n.active_votes this.author = n.author this.author_reputation = n.author_reputation this.created = n.created this.category = n.category this.net_votes = n.net_votes this.children = n.children this.cashout_time = n.cashout_time ｝) .catch(e =&gt; console.log(e)) .finally(() =&gt; (this.loading = false)) ｝, created () ｛ this.$store.dispatch('global/loadGlobalProperties') ｝ // ...｝ 코드량이 많아서 핵심 로직만 남기고 생략하였습니다. 전체 소스는 깃허브 소스를 참고하길 바랍니다. 그리고 Router에 VoteHistory 컴포넌트 경로를 추가한다. /@anpigon/steemit-7/vote 형태의 경로(path)는 VoteHistory 컴포넌트로 연결될 것이다. 1234567891011export default new Router(｛ routes: [ // ... ｛ path: '/@:author/:permlink/vote', name: 'VoteHistory', component: () =&gt; import('@/components/VoteHistory') ｝, // ... ]｝) VoteHistory 컴포넌트 링크 연결하기 포스트 하단의 좋아요 텍스트를 클릭하면 보팅 내역 페이지로 이동하게 만들자. VoteHistory 컴포넌트의 링크 연결에는 &lt;router-link&gt;를 사용한다. Main 컴포넌트와 PostView 컴포넌트에서 ‘좋아요’ 텍스트를 찾아서 아래와 같이 수정한다. 이제 **‘좋아요’**를 클릭하면 보팅 내역 페이지로 이동할 것이다. 1&lt;router-link :to=\"'/@' + author + '/' + permlink + '/vote'\" class='mr-1'&gt;좋아요 ｛｛ net_votes ｝｝명&lt;/router-link&gt; 추가 수정사항 다음은 VoteHistory 컴포넌트를 구현하면서 추가로 수정한 내용이다. 뒤로가기 버튼이 있는 상단바 구현하기 메인 컴포넌트 외에는 상단바에 뒤로가기 버튼만 보이도록 수정하였다. ![상단바](https://steemitimages.com/400x0/https://imgur.com/q6utSJN.png) 다음과 같이 Main 라우터에 메타(meta) 데이터를 추가한다. meta.main의 값으로 메인 컴포넌트인지 아닌지를 판단할 것이다. 1234567891011export default new Router(｛ routes: [ ｛ path: '/', name: 'Main', component: Main, meta: ｛ main: true ｝ ｝, // ... ]｝) 그 다음에 App.vue 파일을 수정한다. computed에 메인 컴포넌트를 판단하는 isMainComponent를 추가하였다. 12345678910export default ｛ // ... computed: ｛ // ... isMainComponent () ｛ return !!this.$route.meta.main ｝ ｝ // ...｝ 그리고 아래와 같이 뒤로가기 버튼만 있는 상단바 &lt;v-toolbar&gt;를 추가한다. 해당 상단바는 isMainComponent가 false인 경우에만 보여진다. 123456&lt;v-toolbar fixed app v-show='!isMainComponent'&gt; &lt;v-toolbar-side-icon @click.stop=\"$router.go(-1)\"&gt; &lt;v-icon&gt;arrow_back_ios&lt;/v-icon&gt; &lt;/v-toolbar-side-icon&gt; &lt;v-toolbar-title class=\"ml-0\"&gt;뒤로가기&lt;/v-toolbar-title&gt;&lt;/v-toolbar&gt; 피드, 최신글, 인기글, 대세글 메뉴 추가 아래 화면과 같이 피드, 최근글, 인기글, 대세글 메뉴를 상단바에 추가하였다. 각 메뉴를 선택했을 때 보여줄 컴포넌트를 구현하자. 우선 Main.vue 에서 글목록을 보여주는 코드를 분리하여 Discussions.vue 파일을 만들자. 피드(FeedPanel), 최신글(CreatedPanel), 인기글(HotPanel), 대세글(TrendingPanel) 컴포넌트는 Discussions.vue를 상속받아서 구현할 것이다. 생성할 컴포넌트 파일 구조는 다음과 같다. 123456789src└── components ├── panels │ ├── Discussions.vue # 상속받을 구현체 │ ├── FeedPanel.vue # 피드 │ ├── CreatedPanel.vue # 최신글 │ ├── HotPanel.vue # 인기글 │ └── TrendingPanel.vue # 대세글 └── ... Main.vue에서 글목록을 담당하는 코드를 분리하여 Discussions.vue 파일에 저장한다. Main.vue에서 분리되어 필요없는 코드를 지우고 아래와 같이 &lt;router-view&gt;로 대체한다. &lt;router-view&gt; 영역에는 피드, 최신글, 인기글, 대세글 컴포넌트를 렌더링하여 보여줄 것이다. 12345&lt;v-flex xs12 md9&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/v-flex&gt; 그 다음에 FeedPanel.vue, CreatedPanel.vue, HotPanel.vue, TrendingPanel.vue 파일을 생성한다. 각각 컴포넌트들은 Discussions.vue를 상속받아서 구현한다. 컴포넌트 상속을 구현하기 위해서 Vue에서 제공하는 기능인 믹스인(mixin)을 사용하였다. 그리고 Discussions.vue를 상속받아 구현된 FeedPanel.vue의 전체 코드는 아래와 같다. 1234567891011121314151617181920&lt;script&gt;import steem from 'steem'import Discussions from './Discussions'export default ｛ name: 'Feed', mixins: [ Discussions ], methods: ｛ getDiscussions () ｛ const query = ｛ tag: this.$route.params.username, limit: 11, start_permlink: this.next.permlink, start_author: this.next.author ｝ return steem.api.getDiscussionsByFeedAsync(query) ｝ ｝｝&lt;/script&gt; FeedPanel.vue는 Discussions.vue를 상속받았으므로 Discussions.vue의 기능을 그대로 사용할 수 있다. 그래서 글을 가져오는 로직이 달라져야 하는 getDiscussions() 함수만 재정의 하였다. CreatedPanel.vue, HotPanel.vue, TrendingPanel.vue도 Discussions.vue를 상속받아 구현한다. 마지막으로 Main 라우터를 수정한다. 각 컴포넌트들은 Main.vue 하위에 있어야 한다. 그래서 아래와 같이 Main 라우터 children에 Feed, Created, Hot, Trending 라우터를 등록하였다. 1234567891011121314151617export default new Router(｛ routes: [ ｛ path: '/', name: 'Main', component: Main, children: [ ｛ path: 'default', redirect: ｛ name: 'Created' ｝, alias: '' ｝, ｛ name: 'Feed', path: '@:username/feed', component: () =&gt; import('@/components/panels/FeedPanel'), meta: ｛ main: true ｝, props: true ｝, ｛ name: 'Created', path: 'created', component: () =&gt; import('@/components/panels/CreatedPanel'), meta: ｛ main: true ｝ ｝, ｛ name: 'Hot', path: 'hot', component: () =&gt; import('@/components/panels/HotPanel'), meta: ｛ main: true ｝ ｝, ｛ name: 'Trending', path: 'trending', component: () =&gt; import('@/components/panels/TrendingPanel'), meta: ｛ main: true ｝ ｝ ] ｝, // ... ]｝) 다음은 완성된 화면입니다. 아래 화면과 같이 메뉴를 클릭하면 피드, 최신글, 인기글, 대세글을 가져옵니다. 전체 소스 내용은 github에서 볼 수 있습니다. 그리고 구현된 앱은 steemlog.github.io에서 확인 할 수 있습니다. 여기까지 읽어주셔서 감사합니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 - 시작하기 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기 스팀잇(Steemit)기반 앱 만들기 #4 - 상세화면 구현하기 스팀잇(Steemit)기반 앱 만들기 #5 - 댓글 보여주기 스팀잇(Steemit)기반 앱 만들기 #6 - 로그인 기능 스팀잇(Steemit)기반 앱 만들기 #7 - 사용자 프로필 패널 구현하기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Steemit] 스팀잇에서 사용 가능한 HTML태그와 속성을 알아보자.","slug":"/kr/@anpigon/html","date":"2018-08-22T15:08:45.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/kr/@anpigon/html/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/html/","excerpt":"안녕하세요. @anpigon입니다.스팀잇은 허용한 HTML 태그와 속성만 입력할 수 있도록 되어있습니다. 그래서 스팀잇 소스를 분석하여 사용 가능한 HTML 태그와 속성을 파악하여 정리하였습니다.스팀잇에서 사용가능한 HTML 태그는 아래와 같다. 아래에 포함되지 않은 HTML 태그는 사용할 수 없다.","text":"안녕하세요. @anpigon입니다.스팀잇은 허용한 HTML 태그와 속성만 입력할 수 있도록 되어있습니다. 그래서 스팀잇 소스를 분석하여 사용 가능한 HTML 태그와 속성을 파악하여 정리하였습니다.스팀잇에서 사용가능한 HTML 태그는 아래와 같다. 아래에 포함되지 않은 HTML 태그는 사용할 수 없다. 123456&lt;div&gt;, &lt;iframe&gt;, &lt;a&gt;, &lt;p&gt;, &lt;br&gt;, &lt;img&gt;, &lt;hr&gt;&lt;ul&gt;, &lt;li&gt;, &lt;ol&gt;&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt;&lt;blockquote&gt;, &lt;pre&gt;, &lt;code&gt;, &lt;center&gt;&lt;table&gt;, &lt;thead&gt;, &lt;tbody&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt;&lt;strike&gt;, &lt;sup&gt;, &lt;sub&gt;, &lt;em&gt;, &lt;strong&gt;, &lt;del&gt;, &lt;b&gt;, &lt;i&gt;, &lt;q&gt; HTML태그에 허용되는 속성(Attribute)은 다음과 같다. 속성을 사용할 수 있는 태그만 표시하였다. 태그 속성 설명 &lt;iframe&gt; src src에 사용 가능한 도메인ㆍhttps://w.soundcloud.com/player/?url=…ㆍhttps://player.vimeo.com/video/28530912…ㆍhttps://www.youtube.com/embed/yUjlBfmkO6… &lt;div&gt; class class에 사용 가능한 스타일 pull-right, pull-left, text-justify, text-rtl, text-center, text-right, videoWrapper, phishy※ div.class 스타일에 대해서는 아래에서 다시 설명하겠다. &lt;td&gt; style style에 사용 가능한 스타일 text-align:right &lt;img&gt; src, alt &lt;a&gt; href href에 사용 가능한 스킴(Scheme)http://, https://, steem:// 각 태그에 대한 설명 각 HTML 태그에 대한 간략한 설명과 예제를 살펴보자. &lt;strike&gt;, &lt;del&gt; 태그 &lt;strike&gt;는 취소선, &lt;del&gt;은 삭제선을 의미한다. 그러나 HTML 렌더링 결과는 동일하다. 마크다운은 ~~를 사용한다. 123&lt;strike&gt;취소선&lt;/strike&gt;&lt;del&gt;삭제선&lt;/del&gt;~~마크다운 표현식~~ &lt;sup&gt;, &lt;sub&gt; 태그 &lt;sup&gt;는 윗첨자(super subscript), &lt;sub&gt;은 아랫첨자(subscript)를 의미한다. 스팀잇에서 작은 글자를 표현할때 많이 사용한다. 12윗첨자&lt;sup&gt;윗첨자&lt;/sup&gt;아랫첨자&lt;sub&gt;아랫첨자&lt;/sub&gt; &lt;i&gt;, &lt;em&gt; 태그 &lt;i&gt;는 Italic를 뜻하며 이탤릭체 또는 기울임체라고 한다. &lt;em&gt;은 Emphasize를 뜻한다. 그러나 HTML 렌더링 결과는 동일하다. 마크다운은 * 또는 _를 사용한다. 1234&lt;i&gt;Italic&lt;/i&gt;&lt;em&gt;Emphasize&lt;/em&gt;*마크다운 표현식*_마크다운 표현식_ &lt;strong&gt;, &lt;b&gt; 태그 &lt;strong&gt;, &lt;b&gt; 는 글자를 강조할때 사용한다. 마크다운은 ** 또는, __를 사용한다. 1234&lt;strong&gt;Strong&lt;/strong&gt;&lt;b&gt;Bold&lt;/b&gt;**마크다운 표현식**__마크다운 표현식__ &lt;q&gt;, &lt;blockquote&gt; 태그 &lt;q&gt;는 짧은 인용문, &lt;blockquote&gt;는 긴 인용문에 사용한다. 마크다운은 긴 인용문에 &gt;를 사용한다. 12345678&lt;q&gt;짧은 인용문&lt;/q&gt;&lt;blockquote&gt;추구할 수 있는 용기가 있다면 우리의 모든 꿈은 이뤄질 수 있다. &lt;br&gt;– 월트 디즈니&lt;/blockquote&gt;&gt; 마크다운 표현식에서는 인용문을 이렇게 사용한다.\\- 안피곤 &lt;iframe&gt; 태그 &lt;iframe&gt;은 동영상을 삽입할 때 사용한다. 하지만, 현재는 Soundcloud, vimeo, **Youtube**에 업로드한 동영상만 사용 가능하다. 아래와 같은 embed 코드는 동영상 제공 사이트에서 가져올 수 있다. 123&lt;iframe src=\"https://w.soundcloud.com/player/?url=…\"&gt;&lt;/iframe&gt;&lt;iframe src=\"https://player.vimeo.com/video/28530912…\"&gt;&lt;/iframe&gt;&lt;iframe src=\"https://www.youtube.com/embed/egGkViMDVF…\"&gt;&lt;/iframe&gt; 참고로 Youtube와 vimeo는 URL만 입력하면 &lt;iframe&gt;으로 자동 변환된다. &lt;img&gt; 태그 이미지를 삽입할 때 사용한다. 마크다운으로 표현하면 ![대체텍스트](이미지주소)이다. 1&lt;img src=\"https://imgur.com/a2cMI4Q.png\" alt=\"대체텍스트\"&gt; 이미지도 URL만 입력하면 &lt;img&gt;로 자동 변환된다. 단, &quot;https://imgur.com/a2cMI4Q.png&quot; 와 같이 URL이 jpg, jpeg, gif, png, svg, ico, tif, tiff 로 끝나는 경우에만 자동 변환된다. &lt;div&gt; 태그의 class 스타일 &lt;div&gt;에 사용가능한 스타일에 대해서 차례대로 살펴보자. pull-right div를 오른쪽으로 float한다. 123&lt;div class='pull-right'&gt;오른쪽에 출력&lt;/div&gt; pull-left div를 왼쪽으로 float한다. 123&lt;div class='pull-left'&gt;왼쪽에 출력&lt;/div&gt; text-justify 텍스트를 양쪽 정렬한다. 123&lt;div class='text-justify'&gt;텍스트 양쪽 정렬&lt;/div&gt; text-center 텍스트를 가운데 정렬한다. &lt;center&gt;와 동일하다. 123&lt;div class='text-center'&gt;텍스트 가운데 정렬&lt;/div&gt; text-right 텍스트를 오른쪽 정렬한다. 123&lt;div class='text-right'&gt;텍스트 오른쪽 정렬&lt;/div&gt; 결과만 봤을때는 text-right와 pull-right와 동일하다고 생각 할 수 있다. 하지만, 두 스타일의 용도와 정렬 방식은 다르다. text-right는 &lt;div&gt; 내부 항목들을 오른쪽으로 정렬한다. 그리고 pull-right는 &lt;div&gt; 영역을 오른쪽에 출력한다. text-rtl 글자 방향을 오른쪽에서 왼쪽으로 표시한다. 특수문자가 왼쪽으로 표시되는 것 말고는 text-right와 차이가 거의 없어 보인다. 123&lt;div class='text-rtl'&gt;글자 방향을 오른쪽에서 왼쪽으로...&lt;/div&gt; phishy phishy는 글자색을 빨간색으로 표시해준다. 123&lt;div class='phishy'&gt; 빨간색&lt;/div&gt; 응용해보기 위의 스타일을 응용하면 아래와 같은 표현도 가능하다. 이렇게 까지 사용할 일은 없다고 생각되지만, 재미를 위해서 만들어 보았다. 1234567891011&lt;div class='pull-left'&gt; 문장에서 가운데 글자를&lt;/div&gt;&lt;div class='pull-left'&gt; &lt;div class='phishy'&gt; 빨간색 &lt;/div&gt;&lt;/div&gt;&lt;div class='pull-left'&gt; 으로 강조하고 싶다.&lt;/div&gt; 또는, 1234567891011121314151617181920212223242526&lt;div class='pull-left'&gt; &lt;sup&gt;&lt;table&gt; &lt;tr&gt;&lt;th&gt;1 단계&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;눈을 감는다&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/sup&gt;&lt;/div&gt;&lt;div class='pull-left'&gt;&amp;#10132;&lt;/div&gt;&lt;div class='pull-left'&gt; &lt;sup&gt;&lt;table&gt; &lt;tr&gt;&lt;th&gt;2 단계&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;잡념을 없앤다&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/sup&gt;&lt;/div&gt;&lt;div class='pull-left'&gt;&amp;#10132;&lt;/div&gt;&lt;div class='pull-left'&gt; &lt;sup&gt;&lt;table&gt; &lt;tr&gt;&lt;th&gt;3단계&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;잠을 잔다&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/sup&gt;&lt;/div&gt;&lt;div class='pull-right'&gt; &lt;sup&gt;&lt;table&gt; &lt;tr&gt;&lt;th&gt;마지막 단계&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;꿈을 꾼다&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/sup&gt;&lt;/div&gt; 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"}],"author":"anpigon"},{"title":"[아티스팀] 자꾸만 눈이 가는 하늘","slug":"/artisteem/@anpigon/artisteem--anpigon--452460314--artisteem-jjangjjangman-busy-kr-newbie-kr--2018-08-22-19-35-16--artwork--none","date":"2018-08-22T10:35:18.000Z","updated":"2019-11-11T13:41:49.852Z","comments":true,"path":"/artisteem/@anpigon/artisteem--anpigon--452460314--artisteem-jjangjjangman-busy-kr-newbie-kr--2018-08-22-19-35-16--artwork--none/","link":"","permalink":"https://anpigon.github.io/artisteem/@anpigon/artisteem--anpigon--452460314--artisteem-jjangjjangman-busy-kr-newbie-kr--2018-08-22-19-35-16--artwork--none/","excerpt":"","text":"한강 공원에서 기분 좋은 하늘 구름~","categories":[{"name":"일상 이야기","slug":"일상-이야기","permalink":"https://anpigon.github.io/categories/일상-이야기/"}],"tags":[{"name":"아티스팀","slug":"아티스팀","permalink":"https://anpigon.github.io/tags/아티스팀/"},{"name":"하늘","slug":"하늘","permalink":"https://anpigon.github.io/tags/하늘/"}],"author":"anpigon"},{"title":"《최고의 휴식》 마인드풀니스(뇌를 위한 휴식)","slug":"/kr/@anpigon/5jnndd","date":"2018-08-21T15:01:03.000Z","updated":"2019-11-11T13:41:49.861Z","comments":true,"path":"/kr/@anpigon/5jnndd/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/5jnndd/","excerpt":"마인드풀니스 소개피곤을 해소하는 방법 중 하나인 마인드풀니스를 소개합니다. 마인드풀니스는 뇌를 휴식하는 방법입니다. 마음 챙김 명상이라고도 합니다.2007년 구글에서 SIY(Search Inside Yourself) 프로그램을 도입했는데, 이것이 마인드풀니스(Mindfuless) 의 시작이다. 지금은 구글뿐만 아니라 애플, 페이스북, 인텔 등 유명한 기업에서도 마인드풀니스를 운영하고 있다.","text":"마인드풀니스 소개피곤을 해소하는 방법 중 하나인 마인드풀니스를 소개합니다. 마인드풀니스는 뇌를 휴식하는 방법입니다. 마음 챙김 명상이라고도 합니다.2007년 구글에서 SIY(Search Inside Yourself) 프로그램을 도입했는데, 이것이 마인드풀니스(Mindfuless) 의 시작이다. 지금은 구글뿐만 아니라 애플, 페이스북, 인텔 등 유명한 기업에서도 마인드풀니스를 운영하고 있다. 우리가 아무것도 하지 않을 때 활성화되는 뇌의 부위를 디폴트 모드 네트워크(DMN, Default Mode Network) 라고 한다. 우리의 뇌는 신체가 소비하는 전체 에너지 중에서 20％를 사용한다. 그리고 뇌가 소비하는 에너지의 60 ~ 80％는 디폴트 모드 네트워크라고 불리는 뇌의 회로에 사용된다. 디폴트 모드 네트워크 가만히 있을때 활성화 되는 뇌의 부위 디폴트 모드 네트워크가 과도하게 활성화되어 에너지를 낭비하는 경우, 아무것도 하지 않아도 우리는 피곤함을 느끼게 된다. 디폴트 모드 네트워크를 스스로 통제할 수 있는 뇌 구조를 만드는 것이 마인드풀니스의 핵심이라고 할 수 있다. 힘들고 고통스러웠던 과거나 불안한 미래를 떠올린다면 디폴트 모드 네트워크가 과도하게 활성화된다. 마인드풀니스 호흡 방법 다음은 구가야 아키라의 《최고의 휴식》에 나온 마인드풀니스 호흡 방법입니다. 기본자세를 취한다. 눈을 감고 자세를 편하게 앉는다. 감각을 의식한다. 몸 전체의 감각에 집중한다. 중력의 감각을 의식한다. 호흡을 의식한다. 자연스러운 호흡에 집중한다. 호흡에 &quot;하나, 둘, 셋, …&quot;하고 세는 것도 효과적이다. 잡념이 떠오를 때 잡념이 떠오르면 잡념을 떨치고 호흡에 집중한다. 하루에 5분에서 10분 정도 매일 지속하는 것이 중요하다. 그리고 매일 같은 시간, 같은 장소에서 하는 습관을 들이는 것이 좋다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"마인드풀니스","slug":"마인드풀니스","permalink":"https://anpigon.github.io/tags/마인드풀니스/"},{"name":"구가야 아키라","slug":"구가야-아키라","permalink":"https://anpigon.github.io/tags/구가야-아키라/"},{"name":"최고의 휴식","slug":"최고의-휴식","permalink":"https://anpigon.github.io/tags/최고의-휴식/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #7 - 사용자 프로필 패널 구현하기","slug":"/kr/@anpigon/steemit-7","date":"2018-08-19T11:10:33.000Z","updated":"2019-11-11T13:41:49.828Z","comments":true,"path":"/kr/@anpigon/steemit-7/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-7/","excerpt":"안녕하세요. @anpigon입니다.이 포스팅은 제가 스팀잇과 프론트엔드 기술을 공부면서 앱을 구현하는 과정을 정리한 글입니다. 그래서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번에는 사용자 프로필을 보여주는 패널을 구현하였습니다. 아래 화면을 보시면 왼쪽 상단에 사용자 프로필을 보여주는 영역이 추가되었습니다.","text":"안녕하세요. @anpigon입니다.이 포스팅은 제가 스팀잇과 프론트엔드 기술을 공부면서 앱을 구현하는 과정을 정리한 글입니다. 그래서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번에는 사용자 프로필을 보여주는 패널을 구현하였습니다. 아래 화면을 보시면 왼쪽 상단에 사용자 프로필을 보여주는 영역이 추가되었습니다. 구현된 앱은 steemlog.github.io에서 확인 할 수 있습니다. 사용자 정보 패널 구현하기 이번에 구현할 파일 구조는 아래와 같다. 1234567891011src├── components│ ├── panels # 패널 컴포넌트들│ │ └── UserProfilePanel.vue # 사용자 프로필 패널│ └── ...└── store ├── ... └── modules ├── account # 계정을 관리 ├── global.js # 글로벌 속성 관리 └── ... ___ UserProfilePanel.vue 파일 생성하기 사용자 프로필을 보여주는 영역은 별도의 컴포넌트로 구현한다. 아래와 같이 components/panels/UserProfilePanel.vue 파일을 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;v-card&gt; &lt;v-card-media&gt; &lt;img src='https://steemitimages.com/0x100/https://steemitimages.com/DQmbbsXGpDwSwwxoUXurjFUvxcm2vFVYpVJG53ZNKPVmUDR/0b1e69ca63199afcb690ecf29ad6bcb9.jpg'&gt; &lt;/v-card-media&gt; &lt;v-avatar size=\"64\"&gt; &lt;img src='https://steemitimages.com/u/anpigon/avatar'&gt; &lt;/v-avatar&gt; &lt;v-card-title class='pt-0'&gt; &lt;div class='username'&gt; &lt;span&gt;안피곤&lt;/span&gt; &lt;span&gt;(45)&lt;/span&gt; &lt;div&gt;@anpigon&lt;/div&gt; &lt;/div&gt; &lt;div&gt;수면의 과학&lt;/div&gt; &lt;/v-card-title&gt; &lt;v-card-text class='pt-0'&gt; &lt;div&gt;&lt;v-icon small&gt;power&lt;/v-icon&gt; 보팅 파워: 70％&lt;/div&gt; &lt;div&gt;&lt;v-icon label small&gt;attach_money&lt;/v-icon&gt; 보팅 금액: $0.001&lt;/div&gt; &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default ｛ name: 'UserProfilePanel' ｝&lt;/script&gt;&lt;style scoped&gt;.v-avatar ｛ margin: -120px 0px 0px 15px;｝.v-avatar img ｛ border: 2px solid #fff｝.username ｛ position: absolute; top: 26px; left: 95px; color: white; line-height: 160％; font-weight:bold; text-shadow: 0 0 4px rgba(0,0,0,.8);｝.username &gt; span:first-child ｛ font-size: 32px;｝&lt;/style&gt; 그리고 store/modules/auth.js를 수정한다. 아래와 같이 로그인 여부를 조회하는 isLogin를 getters에 추가한다. isLogin은 state.username에 값이 있으면 true를 없으면 false를 반환한다. 1234567const getters = ｛ // 로그인 여부 조회 isLogin: state =&gt; ｛ // username 값이 있으면 로그인 상태이다. return !! ｝｝ 이제 Main 화면에서 사용자 정보를 보여주기 위해 Main.vue를 수정한다. 아래와 같이 computed 속성을 사용하여 로그인 상태일때만 사용자 프로필 컴포넌트를 불러와서 보여주도록 한다. computed는 계산된 속성이라고 한다. 그래서 값이 변경되면 다시 계산된 값을 반환해준다. 12345678910111213export default ｛ // ... computed: ｛ UserProfilePanel () ｛ if (this.$store.getters['auth/isLogin']) ｛ return () =&gt; import('@/components/panels/UserProfilePanel') ｝ else ｛ return '' ｝ ｝ ｝, // ...｝ 그러고 나서 Main.vue의 &lt;template&gt; 에 &lt;component :is='UserProfilePanel'&gt;&lt;/component&gt; 코드를 삽입한다. 12345678910&lt;template&gt; &lt;v-container fill-height grid-list-md&gt; &lt;v-layout row wrap&gt; &lt;v-flex xs12 md3&gt; &lt;component :is='UserProfilePanel'&gt;&lt;/component&gt; &lt;/v-flex&gt; &lt;v-flex xs12 md9&gt; &lt;div v-infinite-scroll=\"loadMore\" infinite-scroll-disabled=\"busy\" infinite-scroll-distance=\"30\"&gt; 우리는 computed 속성을 사용하여 로그인한 상태인 경우에만 UserProfilePanel 컴포넌트를 임포트하여 사용하고 있다. 그래서 UserProfilePanel 컴포넌트를 사용하기 위해서는 &lt;component&gt;의 is옵션을 사용하여 컴포넌트를 렌더링해야 에러없이 해당 컴포넌트를 보여줄 수 있다. 여기까지 구현된 화면이다. 사용자 정보 저장소 구현하기 이제 사용자 정보를 관리할 account 저장소를 구현한다. 아래와 같이 store/modules/account.js 파일을 생성한다. 12345678910111213const state = ｛ name: '', profileImage: '', coverImage: '', about: '', reputation: 0, postCount: 0, lastVoteTime: 0, votingPower: 0, vestingShares: 0, delegatedVestingShares: 0, receivedVestingShares: 0｝ 그리고 사용자 정보를 저장소의 상태(state)에 커밋(commit)할 수 있는 setAccount 변이(mutations)을 구현한다. 액션에서 가져온 사용자 정보를 상태에 저장할 때 사용 할 것이다. 123456789const mutations = ｛ // ... setAccount (state, account) ｛ // state에 account 정보 저장 for (const key in account) ｛ state[key] = account[key] ｝ ｝｝ 스팀잇 네트워크에서 사용자 정보를 가져오는 loadAccount 액션을 구현한다. 123456789101112131415161718192021222324252627282930import steem from 'steem'const actions = ｛ // ... async loadAccount (｛ commit, state ｝) ｛ // 스팀잇 네트워크에서 사용자 정보 조회 const [ account ] = await steem.api.getAccountsAsync([state.username]) // 메타 정보 파싱 const ｛ profile ｝ = JSON.parse(account.json_metadata) const data = ｛ name: profile.name, // 이름 coverImage: profile.cover_image, // 커버 이미지 profileImage: profile.profile_image, // 프로필 이미지 about: profile.about, // 자기 소개 reputation: steem.formatter.reputation(account.reputation), // 명성도 postCount: account.post_count, // 포스트 갯수 lastVoteTime: account.last_vote_time, // 마지막 보팅 시간 votingPower: account.voting_power, // 남은 보팅 파워 vestingShares: parseFloat(account.vesting_shares.split(' ')[0]), // 스팀 파워(VEST) delegatedVestingShares: parseFloat(account.delegated_vesting_shares.split(' ')[0]), receivedVestingShares: parseFloat(account.received_vesting_shares.split(' ')[0]) ｝ // setAccount 뮤테이션 커밋 commit('setAccount', data) ｝｝ 글로벌 프로퍼티 저장소 구현하기 스팀파워와 보팅금액을 계산하는데 글로벌 프로퍼티값이 필요하다. 그래서 글로벌 프로퍼티값을 관리할 global 저장소를 구현한다. 아래와 같이 store/modules/global.js 파일을 생성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import steem from 'steem'const state = ｛ totalVestingFundSteem: 0, totalVestingShares: 0, rewardBalance: 0, recentClaims: 0, price: 0｝const getters = ｛｝const actions = ｛ loadGlobalProperties (｛ commit ｝) ｛ Promise.all([ steem.api.getDynamicGlobalPropertiesAsync(), steem.api.getRewardFundAsync('post'), steem.api.getCurrentMedianHistoryPriceAsync() ]).then(function ([ global, rewardFund, price ]) ｛ const base = parseFloat(price.base.split(' ')[0]) const quote = parseFloat(price.quote.split(' ')[0]) commit('setGlobalProperties', ｛ totalVestingFundSteem: parseFloat(global.total_vesting_fund_steem.split(' ')[0]), totalVestingShares: parseFloat(global.total_vesting_shares.split(' ')[0]), rewardBalance: parseFloat(rewardFund.reward_balance.split(' ')[0]), recentClaims: rewardFund.recent_claims, price: (base / quote) ｝) ｝) ｝｝const mutations = ｛ setGlobalProperties (state, global) ｛ for (const key in global) ｛ state[key] = global[key] ｝ ｝｝export default ｛ namespaced: true, state, getters, actions, mutations｝ ___ store/index.js 수정 앞서 구현한 account.js와 global.js를 루트 저장소에 추가한다. 12345678910import global from './modules/global'import account from './modules/account'export default new Vuex.Store(｛ modules: ｛ global, account, // ... ｝｝) UserProfilePanel.vue 수정 스팃잇 네트워크에서 가져온 실제 사용자 정보를 보여주기 위해서 UserProfilePanel.vue 컴포넌트를 수정한다. computed에 global 저장소와 account 저장소의 state를 추가한다. 1234567891011export default ｛ computed: ｛ ...mapState('auth', ['username']), // this.$store.state.auth.username ...mapState(｛ global: state =&gt; state.global // 글로벌 프로퍼티 ｝), ...mapState(｛ account: state =&gt; state.account // 사용자 정보 ｝) ｝｝ vestingShares를 스팀파워로 변환하는 formatterVestingSteem() 함수를 구현한다. 12345methods: ｛ formatterVestingSteem (vestingShares) ｛ return this.global.totalVestingFundSteem * (vestingShares / this.global.totalVestingShares) ｝｝ computed에 아래와 같이 계산된 속성을 추가한다. 1234567891011121314151617181920212223242526272829303132333435computed: ｛ // 스팀파워 vestingSteem () ｛ return this.formatterVestingSteem(this.account.vestingShares) ｝, // 위임한 스팀파워 delegatedVestingSteem () ｛ return this.formatterVestingSteem(this.account.delegatedVestingShares) ｝, // 임대받은 스팀파워 receivedVestingSteem () ｛ return this.formatterVestingSteem(this.account.receivedVestingShares) ｝, // 총 스팀파워 totalSteemPower () ｛ return this.vestingSteem + this.delegatedVestingSteem + this.receivedVestingSteem ｝, // 보팅파워 votePower () ｛ const elapsedSeconds = (new Date() - new Date(this.account.lastVoteTime + 'Z')) / 1000 // 마지막 보팅 후 경과 시간 const regeneratedPower = (10000 * elapsedSeconds) / (60 * 60 * 24 * 5) // 재생된 보팅파워 const currentPower = Math.round(Math.min(this.account.votingPower + regeneratedPower, 10000)) // 현재 보팅파워 return (currentPower / 100) || 0 ｝, // 남은 보팅파워 재생시간 remainHours () ｛ return (10000 - this.votePower) * (5 * 60 * 60 * 24) / (60 * 60 * 10000) ｝, // 보팅 금액 upvoteValue () ｛ const rate = parseInt((this.votePower * 100 + 49) / 50) * 100 const upvoteValue = (this.totalSteemPower / (this.global.totalVestingFundSteem / this.global.totalVestingShares) * rate * (this.global.rewardBalance / this.global.recentClaims)) * this.global.price return upvoteValue || 0 ｝｝ created() 함수를 사용하여 UserProfilePanel.vue 컴포넌트가 생성되었을때 사용자 정보와 글로벌 프로퍼티값을 가져오게하자. 아래와 같이 global 저장소와 account 저장소의 액션을 호출한다. 1234567891011import ｛ mapState ｝ from 'vuex'export default ｛ // 컴포넌트 생성될떄 created () ｛ // 글로벌 프로퍼티 가져오기 this.$store.dispatch('global/loadGlobalProperties') // 사용자 프로필 가져오기 this.$store.dispatch('account/loadAccount', this.username) ｝｝ 아래는 이번에 구현된 컴포넌트 구조와 컴포넌트에 포함된 속성 및 데이터이다. 하다보니 코드가 많이 복잡해졌네요. 여기까지 읽어주셔서 감사합니다. 전체 소스 내용은 github에서 볼 수 있습니다. 그리고 구현된 앱은 steemlog.github.io에서 확인 할 수 있습니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 - 시작하기 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기 스팀잇(Steemit)기반 앱 만들기 #4 - 상세화면 구현하기 스팀잇(Steemit)기반 앱 만들기 #5 - 댓글 보여주기 스팀잇(Steemit)기반 앱 만들기 #6 - 로그인 기능","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Steemit] 크롬 브라우저에서 스팀잇 UI를 바꿔보자.","slug":"/kr/@anpigon/ui","date":"2018-08-17T06:05:21.000Z","updated":"2019-11-11T13:41:49.832Z","comments":true,"path":"/kr/@anpigon/ui/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/ui/","excerpt":"안녕하세요. @anpigon입니다.스팀잇은 UI 디자인이나 기능에서 불편한 점이 있습니다. 그래서 @armandocat님이 만든 Steemit More Info(한글 소개자료)와 @kyunga님, @yjiq150님, @bramd님이 만든 Steemit.com Enhancer을 사용합니다. 둘 다 크롬브라우저에서 작동하는 확장 프로그램입니다.","text":"안녕하세요. @anpigon입니다.스팀잇은 UI 디자인이나 기능에서 불편한 점이 있습니다. 그래서 @armandocat님이 만든 Steemit More Info(한글 소개자료)와 @kyunga님, @yjiq150님, @bramd님이 만든 Steemit.com Enhancer을 사용합니다. 둘 다 크롬브라우저에서 작동하는 확장 프로그램입니다. 두 프로그램을 사용하면 부족한 기능은 어느 정도 커버 됩니다. 하지만 스팀잇의 UI 디자인은 여전히 성에 차지 않습니다. 그래서 User JavaScript and CSS을 사용하여 스팀잇 UI를 결정하는 CSS를 수정하였습니다. 아래에서 적용된 화면의 스샷을 볼 수 있습니다. 피드 화면 포스트 화면 기타 수정된 요소들 나눔고딕 폰트를 적용하고 줄 간격을 조정하여 가독성을 높였습니다. 아래에서 적용 전과 적용 후 화면을 비교해보세요. 적용 전 적용 후 인용문(Blockquote) 스타일은 아래와 같이 변경됩니다. 이미지(img) 스타일은 흰색 테두리와 우측하단에 그림자가 들어가고 가운데 정렬됩니다. 그리고 상단바 우측에 보팅파워와 보팅금액이 표시됩니다. ___ 적용 방법 적용하기 위해서는 크롬 브라우저에 User JavaScript and CSS 확장 프로그램을 설치해야합니다. 아래 경로를 통해 설치합니다. https://chrome.google.com/webstore/detail/user-javascript-and-css/nbhcbdghjpllgmfilhnhkllmkecfmpld?utm_source=chrome-ntp-icon 설치가 완료되면 앱을 실행하여 다음과 같이 수정된 CSS 를 적용합니다. 아래 코드는 **JS영역(왼쪽)**에 복사&amp;붙여넣기 하세요. 보팅파워와 보팅금액을 표시하는 로직입니다. 123456789(()=&gt;｛const username=document.querySelector('header li.Header__userpic &gt; span')if(username)｛function f(a,b,p)｛p=｛method:'POST',headers:｛'Content-Type':'application/json'｝,body:JSON.stringify(｛jsonrpc:\"2.0\",method:\"call\",params:[\"database_api\",a,b?[b]:[]]｝)｝;return fetch('//api.steemit.com',p).then(r=&gt;r.json()).then(d=&gt;d.result)｝function i(a)｛return parseFloat((a||'0').split(' ')[0])｝function v(t,e)｛return i(e.total_vesting_fund_steem)*(i(t)/i(e.total_vesting_shares))｝const id='ap_'+String(Math.round(Math.random()*new Date().getTime()));(function load()｛Promise.all([f('get_reward_fund','post'),f('get_dynamic_global_properties'),f('get_current_median_history_price'),f('get_accounts',[username.title])]).then(r=&gt;｛const[a,g,c,[d]]=r;const es=((new Date()-new Date(d.last_vote_time+\"Z\"))/1e3);const vp=Math.round(Math.min(d.voting_power+(1e4*es/432000),1e4));const totalVestingSteem=v(d.vesting_shares,g)+v(d.delegated_vesting_shares,g)+v(d.received_vesting_shares,g)const rate=parseInt((vp+49)/50)*100const vv=(totalVestingSteem/(i(g.total_vesting_fund_steem)/i(g.total_vesting_shares))*rate*(i(a.reward_balance)/i(a.recent_claims))*(i(c.base)/i(c.quote)));let span=document.getElementById(id)if(!span)｛const header=document.querySelector('header .Header__buttons');span=document.createElement('span');span.id=id;span.style.color='rgba(0,0,0,.65)';span.style.border='1px solid #eee';span.style.margin='1rem';span.style.padding='0 10px';header.insertBefore(span,header.childNodes[0])｝span.innerHTML=`&lt;small&gt;· 보팅파워: $｛vp/100｝％&lt;br&gt;· 보팅금액: \\$$｛vv.toFixed(3)｝&lt;/small&gt;`;window.setTimeout(function()｛load()｝,1000)｝)｝)()｝｝)() ___ 아래 코드는 **CSS영역(오른쪽)**에 복사&amp;붙여넣기 하세요. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@import url('//fonts.googleapis.com/css?family=Nanum+Gothic:400,700,800');/* 폰트 변경 */body,h1,h2,h3,h4,h5,h6,.Markdown,.Markdown h1, .Markdown h2, .Markdown h3, .Markdown h4, .Markdown h5, .Markdown h6, .ReplyEditor__body.rte h1, .ReplyEditor__body.rte h2, .ReplyEditor__body.rte h3, .ReplyEditor__body.rte h4, .ReplyEditor__body.rte h5, .ReplyEditor__body.rte h6,.PostFull__header &gt; h1 /* 포스트 제목 */｛ font-family: \"Nanum Gothic\", \"Source Sans Pro\" !important; font-smoothing: antialiased; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;｝/* 줄간격 조정 */.Markdown p, .ReplyEditor__body.rte p ｛ line-height: 180％ !important; ｝/* 인용문(Blockquote) */.Markdown blockquote ｛ border-left: 0 !important; padding-left: 35px;｝.Markdown blockquote:before ｛ content: \"\\201C\"; font-size: 3em; font-family: Georgia; color: #bcbcbc; float: left; margin: -15px 0 0 -35px;｝/* 이미지 꾸미기 */.Markdown img ｛ margin: 0 auto; display: -webkit-box; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); margin-bottom: 1rem; border: solid 4px #fefefe; border-radius: 3px; line-height: 0; max-width: calc(100％ - 10px);｝/* UI 변경 */.theme-light, .theme-light .Post ｛ background-color: hsla(0, 0％, 95％, .97) !important;｝.theme-light .PostFull ｛ position: relative; background-color: #fff; border: 0; border-radius: 4px; background-clip: padding-box; -webkit-box-shadow: 0 4px 12px rgba(0,0,0,.15); box-shadow: 0 4px 12px rgba(0,0,0,.15); padding: 32px!important; overflow-x: inherit;｝.theme-light .c-sidebar__module, .theme-light .articles__summary ｛ position: relative; border: 1px solid #dddfe2; border-radius: 3px; margin-bottom: 10px;｝.theme-light .articles__summary:hover ｛ background-color: #f5f8fa;｝.theme-light .articles ｛ border: initial !important; box-shadow: initial !important; background-color: initial !important;｝.theme-light .articles:hover ｛ box-shadow: initial !important;｝.articles ｛ padding: 0.5em 0 !important;｝@media only screen and (min-width: 75em) ｛ .PostsIndex.row ｛ width: 1190px !important; ｝ .PostsIndex.row.layout-list ｛ width: 1600px !important; ｝｝.PostFull__reply a:first-child ｛ display: inline-flex; max-width: 30px; overflow: hidden; white-space: nowrap;｝.articles__hr ｛ display: none !important;｝@media print, screen and (min-width: 64em) ｛ .PostFull__footer.row .large-5 ｛ max-width: 46.66667％ !important; flex: 0 0 46.66667％ !important; ｝ .PostFull__footer.row .large-5:first-child ｛ max-width: 36.66667％ !important; flex: 0 0 36.66667％ !important; ｝ .articles__feature-img-container ｛ max-height: 200px; overflow: hidden; display: block; vertical-align: middle; ｝ .articles__feature-img-container &gt; img ｛ width: 100％; ｝｝@media only screen and (min-width: 47.5em) ｛ .theme-light .layout-list .articles__summary, .theme-light .layout-compressed .articles__summary ｛ padding: .5rem 1rem; border-bottom: initial !important; ｝｝ 복사&amp;붙여넣기를 다 하셨으면 저장 버튼을 눌러 저장합니다. 아래 화면에서 보면 브라우저 툴바에서 프로그램이 실행 중인 것을 확인 할 수 있습니다. 그리고 on/off 버튼으로 프로그램 중지도 가능합니다. 나눔 고딕 외 다른 폰트 적용방법 다른 폰트를 사용하고 싶으면 구글 폰트 사이트에서 찾아볼 수 있습니다. **fonts.google.com**에 접속하면 나눔 고딕, 나눔 명조 등 공개된 무료 웹폰트 들이 있습니다. 원하는 폰트를 선택하면 아래와 같이 CSS 경로와 적용방법을 알 수 있습니다. CSS에 능숙하다면 스팀잇을 더 멋진 UI로 바꿔보시기 바랍니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"}],"author":"anpigon"},{"title":"[소설] 더글라스 케네디 ⟪템테이션(Temptation)⟫","slug":"책 이야기/2018-08-16---temptation","date":"2018-08-16T02:07:51.000Z","updated":"2019-11-11T13:41:49.860Z","comments":true,"path":"책 이야기/2018-08-16---temptation/","link":"","permalink":"https://anpigon.github.io/책 이야기/2018-08-16---temptation/","excerpt":"&quot;한 번의 성공이 반드시 ‘영원한 성공’으로 귀결되지는 않는다!&quot; 더글라스 케네디의 소설 《빅 픽처》를 시작으로 《파리5구의 여인》, 《모멘트》 다음으로 읽은 소설 《템테이션》이다. 초반에 약간 지루했지만, 중반을 이후에는 완전 몰입해서 읽었다. 이 책은 로스앤젤레스 할리우드를 배경으로 한 시나리오 작가의 파란만장한 삶을 그리고 있다. 그리고 그 과정에서 인생의 가치를 다시 생각하게 만든다.","text":"&quot;한 번의 성공이 반드시 ‘영원한 성공’으로 귀결되지는 않는다!&quot; 더글라스 케네디의 소설 《빅 픽처》를 시작으로 《파리5구의 여인》, 《모멘트》 다음으로 읽은 소설 《템테이션》이다. 초반에 약간 지루했지만, 중반을 이후에는 완전 몰입해서 읽었다. 이 책은 로스앤젤레스 할리우드를 배경으로 한 시나리오 작가의 파란만장한 삶을 그리고 있다. 그리고 그 과정에서 인생의 가치를 다시 생각하게 만든다. 줄거리 이 책의 주인공 데이비드 아미티지는 11년째 무명작가이다. 어느 날 시티콤 대본 “셀링 유”가 FRT 방송국에 팔리면서 그의 삶은 하루아침에 달라진다. 그리고 “셀링 유”가 최고의 시청률을 기록하면서 데이비드는 할리우드 최고의 작가로 급부상한다. 성공 가도를 달리고 있는 데이비드에게 갑자기 억만장자 필립 플렉이 영화 시나리오 공동 작업을 제안해온다. 그 후부터 데이비드에게 뜻하지 않은 위기가 찾아오는데… 본문에서 발췌 사람들은 흔히 성공하면 삶이 편해질 것이라 여긴다. 하지만 성공하면 삶은 어쩔 수 없이 더 복잡해진다. 아니, 더 복잡해지기를 바라는지도 모른다. 더 큰 성공을 거두기 위한 갈증에 자극을 받으며 더욱 매달려야 하기 때문이다. 바라던 걸 성취하면 또 다른 바람이 홀연히 나타난다. 그 바람을 충족시키지 못하면 우린 또 다시 결핍감을 느낄 수밖에 없다. 그러면 다시 완벽한 만족감을 얻기 위해 모든 걸 걸고 달려든다. 그때껏 이룬 것들을 모두 뒤엎더라도 새로운 성취와 변화를 찾아 매진한다. (p.121) 인생은 그런 겁니다. 누구나 선택을 하죠. 자신의 선택에 따라 상홍이 바뀌고요. 그게 바로 ‘인과율’입니다. 우리는 스스로 내린 결정 때문에 나쁜 일이 생기면 늘 남 탓을 하는 버릇이 있어요. 상황이 안 좋았다거나 사악한 사람때문에 일을 그르쳤다고 생각하죠. 하지만 근본적으로 조목조목 따져보면 진정 탓할 사람은 자기 자신뿐이라는걸 알게 되죠. (p.426) 우리 모두가 필사적으로 추구하는 건 자기 존재에 대한 확인이다. 그러나 그 확인은 자신을 사랑해 주는 사람, 자신이 사랑하는 사람을 통해서만 얻어질 수 있다. (p.446) “아가야, 미안. 나쁜 늑대가 없으면 이야기 자체가 되지 않아.“ 왜 그럴까? 어떤 이야기라도 이야기에는 위기가 있어야 하기 때문이다. … 세상 모든 일은 결국 이야기다. 그리고 그 모든 이야기에는 필수적으로 위기가 포함된다. 분노, 갈망, 기대, 실패에 대한 두려움. 지금 자신이 살고 있는 삶에 대한 실망. 자신이 원하는 삶이라고 상상하는 삶에 가까이 다가가지 못하는 절망. 이런 위기는 누구에게나 필요하다. (p.450 “아기 돼지 삼형제 이야기에서”) 우리는 위기를 통해 믿게 된다. 자신이 중요한 존재라는 걸 믿게 되고, 모든 게 그저 순간에 불과한 거라 믿게 되고, 자신이 하찮은 존재에서 벗어나 더 나은 존재가 될 수 있다고 믿게 된다. 무엇보다 우리는 위기를 통해 깨닫게 된다. 싫든 좋든 우리는 누구나 나쁜 늑대의 그림자 아래 있음을, 어디에나 도사리고 있는 위험 아래에 있음을, 우리 스스로가 자신에게 행하는 위험 아래에 있음을 깨닫게 된다. (p.451) 누구에게나 한 번의 성공은 있을 수 있다. 그러나 그것이 영원한 성공이라고 말할 수는 없다. 그리고 인생의 갈림길에서 어떤 선택을 할지는 각자 본인이 판단하고 책임져야 할 몫이다.","categories":[{"name":"책 이야기","slug":"책-이야기","permalink":"https://anpigon.github.io/categories/책-이야기/"}],"tags":[{"name":"독서 후기","slug":"독서-후기","permalink":"https://anpigon.github.io/tags/독서-후기/"},{"name":"더글라스 케네디","slug":"더글라스-케네디","permalink":"https://anpigon.github.io/tags/더글라스-케네디/"}],"author":"anpigon"},{"title":"[Steem Project]뉴비분들을 위한 보팅 계산기","slug":"/kr/@anpigon/6gxjap","date":"2018-08-13T11:53:00.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/6gxjap/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/6gxjap/","excerpt":"안녕하세요. @anpigon 입니다.뉴비분들을 위한 보팅 금액 계산기를 만들었습니다.이 계산기는 보팅 금액을 소숫점 3자리까지 표시해줍니다.https://anpigon.github.io/steemit/아래는 보팅 계산기를 만들게 된 계기(?)입니다.자신의 보팅 금액은 steemnow에서 제공하는 보팅 계산기로 계산 할 수 있습니다. 하지만 스팀 파워가 낮아서 보팅 금액이 $0.01 이하면 $0으로 표시됩니다.","text":"안녕하세요. @anpigon 입니다.뉴비분들을 위한 보팅 금액 계산기를 만들었습니다.이 계산기는 보팅 금액을 소숫점 3자리까지 표시해줍니다.https://anpigon.github.io/steemit/아래는 보팅 계산기를 만들게 된 계기(?)입니다.자신의 보팅 금액은 steemnow에서 제공하는 보팅 계산기로 계산 할 수 있습니다. 하지만 스팀 파워가 낮아서 보팅 금액이 $0.01 이하면 $0으로 표시됩니다. 그래서 저를 포함하여 몇몇 뉴비분들은 자신의 보팅 금액을 $0으로 알고 있을 거라고 생각했습니다. 설마 저만 그렇게 생각하고 있었던 것은 아니겠죠? 저의 보팅 기록을 살펴보기 위해 스텔라 블록 탐색기를 이용하였습니다. 아래 캡쳐한 이미지를 보면 최소 보팅 금액이 $0.001인 것을 확인 할 수 있습니다. 이제 알았습니다. 저는 보팅 금액이 $0.001입니다. anpigon의 보팅 기록을 보면 $0.001 금액을 보팅했고, 큐레이션 보상으로는 0 스팀파워를 받았습니다. ^^ 보팅 금액이 $0.002가 되기 위해서는 어느 정도의 스팀 파워를 가져야하는지 계산하고 싶었습니다. 그래서 계산기를 만들었습니다. 지금 제 보팅 가치는 $0.001이지만, 마음은 보팅 가치 이상으로 전해졌으면 좋겠습니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #6 - 로그인 기능","slug":"/kr/@anpigon/steemit-6","date":"2018-08-12T15:12:00.000Z","updated":"2019-11-11T13:41:49.828Z","comments":true,"path":"/kr/@anpigon/steemit-6/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-6/","excerpt":"이번 시간에는 스팀잇 로그인 기능을 구현해봅니다. 현재까지 구현된 전체 소스는 깃허브에서 확인 가능합니다.저도 공부하면서 구현하는 중이라서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번 시간에는 vuex를 사용하여 로그인 기능을 구현합니다. Vuex의 중심에는 **저장소(store)**가 있습니다. 그리고 저장소는 애플리케이션 상태를 저장하고 있습니다. Vuex에 대한 자세한 설명은 가이드 문서의 링크로 대신합니다.","text":"이번 시간에는 스팀잇 로그인 기능을 구현해봅니다. 현재까지 구현된 전체 소스는 깃허브에서 확인 가능합니다.저도 공부하면서 구현하는 중이라서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변해드리도록 노력하겠습니다.이번 시간에는 vuex를 사용하여 로그인 기능을 구현합니다. Vuex의 중심에는 **저장소(store)**가 있습니다. 그리고 저장소는 애플리케이션 상태를 저장하고 있습니다. Vuex에 대한 자세한 설명은 가이드 문서의 링크로 대신합니다. 저의 경우에는 Vuex를 이해하는데 어려웠습니다. 그래서 학습하는 데 시간이 많이 소요되었네요. 아직도 Vuex는 여전히 어렵습니다. ㅠㅠ 그리고 이제부터 앱 구현에 관련된 설명은 평어체를 사용하겠습니다. Vuex 설치 Vuex를 사용하기 위해 아래와 같이 설치한다. 1$ npm install vuex --save 로그인 기능 구현하기 이번에 구현할 파일 구조는 아래와 같다. 로그인 컴포넌트와 로그인 액션과 인증 정보를 저장할 저장소를 구현하게 될 것이다. src ├── components │ ├── Login.vue # 로그인 컴포넌트 │ └── ... └── store ├── index.js # 모듈을 조합하고 저장소를 내보내는 곳 입니다. └── modules └── auth.js # 로그인/인증 모듈 로그인 컴포넌트(Login.vue) 생성하기 로그인 화면에서는 username와 password를 입력받는다. username은 스팀잇 아이디를 입력받고, password는 포스팅키를 입력받는다. 로그인 화면을 렌더링할 컴포넌트 components/Login.vue 파일을 아래와 같이 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;template&gt; &lt;v-container _fluid fill-height grid-list-md&gt; &lt;v-layout&gt; &lt;v-flex xs12 sm8 offset-sm2 lg6 offset-lg3&gt; &lt;v-card&gt; &lt;v-card-text&gt; &lt;v-layout row&gt; &lt;v-flex xs10 offset-xs1 md8 offset-md2&gt; &lt;v-card flat&gt; &lt;v-card-title&gt; &lt;h1 class=\"headline\"&gt;로그인하기&lt;/h1&gt; &lt;/v-card-title&gt; &lt;v-card-text&gt; &lt;v-form ref=\"form\" v-model=\"valid\" lazy-validation&gt; &lt;v-text-field prepend-icon=\"person\" autofocus v-model=\"username\" label=\"Username\" :rules=\"usernameRules\" persistent-hint required&gt;&lt;/v-text-field&gt; &lt;v-text-field prepend-icon=\"lock\" v-model=\"password\" type=\"password\" label=\"Password\" :rules=\"passwordRules\" persistent-hint hint=\"로그인에는 항상 포스팅키를 사용하시기를 권장합니다.\" &gt;&lt;/v-text-field&gt; &lt;/v-form&gt; &lt;/v-card-text&gt; &lt;v-card-actions class='pt-0'&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-btn color=\"primary\" :loading=\"busy\" :disabled=\"busy\" @click.prevent=\"login\"&gt;로그인&lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/v-container&gt;&lt;/template&gt;&lt;script&gt;import steem from 'steem'export default ｛ name: 'login', // 컴포넌트 이름 data () ｛ return ｛ valid: false, // 유효성 체크 플래그값 username: '', // username password: '', // 비밀번호 usernameRules: [ // username 유효성 검사 로직 v =&gt; !!v || 'Username is required' ], passwordRules: [ // 비밀번호 유효성 검사 로직 v =&gt; (!v || steem.auth.isWif(v)) || 'Password is invalid' ], busy: false // 로그인 요청 여부 플래그값 ｝ ｝, deactivated () ｛ this.$destroy() ｝, methods: ｛ login () ｛ if (this.$refs.form.validate()) ｛ // 유효성 체크 // 로그인 로직 ｝ ｝ ｝｝&lt;/script&gt; 참고로 password는 필수입력값에서 제외하였습니다. 포스팅키가 유출되지 않도록 관리에 유의하시기 바랍니다. 그리고 라우터에 로그인 컴포넌트 경로(path)를 추가한다. router/index.js 파일을 아래와 같이 수정한다. 123456789101112import Login from '@/components/Login'export default new Router(｛ routes: [ // ... ｛ path: '/login', name: 'Login', component: Login ｝ ]｝) 여기까지 구현하고 앱을 실행하면 아래 화면을 볼 수 있다. 브라우저 주소창에 http://localhost:3000/#/login를 입력하면 볼 수 있다. 사용자 로그인과 인증 정보을 관리할 저장소(Store) 구현하기 이제부터 vuex를 사용하여 로그인 액션과 인증 정보를 관리할 저장소(Store)를 구현한다. 아래는 Vuex 가이드 문서에 나온 샘플 예제의 코드 구조를 보고 구현하였다. 실제로 Vuex는 코드 구조를 제한하지 않는다. ./store/modules/auth.js 파일을 아래와 같이 생성한다. 12345678910111213141516171819202122232425262728const state = ｛ username: '', password: ''｝const getters = ｛｝const actions = ｛ login (｛ commit ｝, auth) ｛ commit('login', auth) ｝｝const mutations = ｛ login (state, ｛ username, password ｝) ｛ state.username = username state.password = password ｝｝export default ｛ namespaced: true, state, getters, actions, mutations｝ 위의 코드 내용을 간단하게 설명하면 다음과 같다. state: 애플리케이션의 로그인 상태 정보(username, password)를 포함한다. getters: 저장소 상태 정보를 계산하여 조회할 필요가 있을때 사용한다. actions: 로그인 작업을 실행한다. mutations: 로그인 상태 정보를 저장한다. 각 저장소 모듈을 관리할 index.js 파일 생성하기 저장소 모듈을 관리할 ./store/index.js 파일을 생성한다. 그리고 방금 만든 auth 저장소 모듈을 export 한다. 지금은 auth 모듈 하나만 존재하지만, 나중에 구현될 모듈들은 모두 여기서 관리될 것이다. 1234567891011import Vue from 'vue'import Vuex from 'vuex'import auth from './modules/auth'Vue.use(Vuex)export default new Vuex.Store(｛ modules: ｛ auth ｝｝) 그리고 저장소(store)를 컴포넌트 전역에서 사용하기 위해서는 루트 컴포넌트의 모든 자식 컴포넌트에 저장소(store)를 주입해야 한다. 아래와 같이 루트 저장소 store를 임포트하고 new Vue(｛｝) 객체에 주입한다. main.js 파일을 아래와 같이 수정한다. 123456789import store from './store'new Vue(｛ el: '#app', router, store, template: '&lt;App/&gt;', components: ｛ App ｝｝) 로그인 컴포넌트에서 로그인 액션 호출하기 로그인 기능을 구현하기 전에 먼저 **“vuex 액션(action)을 호출하는 방법”**에 대해 간단히 알아보자. 저장소에 등록된 액션은 다음과 같은 방법으로 호출 할 수 있다. 가장 간단한 방법은 this.$store.dispatch('auth/login')를 사용하여 컴포넌트에서 액션을 디스패치한다. 1234567891011import ｛ mapActions ｝ from 'vuex'export default ｛ // ... methods: ｛ login () ｛ console.log(this.$store) this.$store.dispatch('auth/login') ｝ ｝｝ 또는 mapActions 헬퍼를 사용하여 store.dispatch 호출에 매핑하여 사용 할 수 있다. 1234567891011121314151617181920import ｛ mapActions ｝ from 'vuex' // mapActions 헬퍼 임포트methods: ｛ // this.login()을 this.$store.dispatch('auth/login')에 매핑 ...mapActions(｛ login: 'auth/login' ｝), // 함수명이 같으면 아래와 같이 생략가능하다. // this.login()을 this.$store.dispatch('auth/login')에 매핑 ...mapActions([ 'auth/login' ]), // 모듈의 네임스페이스 문자열을 헬퍼의 첫 번째 인수로 전달하여 아래와 같이 단순화 할 수 있다. // this.login()을 this.$store.dispatch('auth/login')에 매핑 ...mapActions('auth', [ 'login' ])｝ 또한 createNamespacedHelpers를 사용하여 네임스페이스 헬퍼를 생성할 수 있다. 전달된 네임스페이스 값으로 바인딩된 새로운 컴포넌트 바인딩 헬퍼를 가진 객체를 반환한다. 123456789101112import ｛ createNamespacedHelpers ｝ from 'vuex'const ｛ mapActions ｝ = createNamespacedHelpers('auth')export default ｛ methods: ｛ // `auth`에서 찾음 ...mapActions([ 'login' ]) ｝｝ 이제 위의 방법 중 하나를 사용하여 다음과 같이 로그인 기능을 구현해보자. 사용자가 입력한 username이 스팀잇 네트워크에 존재하는지 steem.api.lookupAccountNamesAsync() 함수를 사용하여 체크한다. 그리고 auth 저장소의 로그인 액션을 디스패치한다. 모든 작업이 완료되면 this.$router.go(-1)를 사용하여 메인 컴포넌트로 이동한다. 로그인 컴포넌트 components/Loing.vue의 수정된 내용은 아래와 같다. 1234567891011121314151617181920212223methods: ｛ login () ｛ if (this.$refs.form.validate()) ｛ // 유효성 체크 this.busy = true // 스팀잇 네트워크에서 username 조회 steem.api.lookupAccountNamesAsync([this.username]) .then(usernames =&gt; ｛ if (!usernames || !usernames[0]) return alert(`\"$｛this.username｝\" 사용자를 찾을 수 없습니다.`) // 저장소의 로그인 액션 디스패치~ this.$store.dispatch('auth/login', ｛ username: this.username, password: this.password ｝) // 메인 페이지로 이동 this.$router.go(-1) ｝) .finally(() =&gt; (this.busy = false)) ｝ ｝｝ 로그인 상태에 따라 상단바 모양 바꾸기 로그인 상태에 따라 로그인 전 상단바와 로그인 후 상단바가 아래와 같이 다르게 보이도록 구현한다. 로그인 전 로그인 후 아래와 같이 App.vue 컴포넌트의 computed 옵션에서 auth 저장소가 가지고 있는 상태(state)의 username를 참조한다. 12345computed: ｛ username () ｛ return this.$store.state.auth.username ｝｝ 다른 방법으로는 아래와 같이 mapState 헬퍼를 사용할 수 있다. 12345678910import ｛ mapState ｝ from 'vuex'export default ｛ //... computed: ｛ ...mapState(｛ username: state =&gt; state.auth.username ｝) ｝｝ 또는 모듈의 네임스페이스 문자열을 헬퍼의 첫 번째 인수로 전달하여 해당 모듈을 컨텍스트로 사용할 수 있다. 123...mapState('auth', ｛ username: state =&gt; state.username｝) 또한 저장소의 속성 이름과 computed에 맵핑된 속성 이름이 같으면 아래와 같이 단순화 할 수 있다. 1234...mapState('auth', [ // this.username를 store.state.auth.username에 매핑 합니다. 'username']) this.$store.state.auth.username 값이 없으면 상단바에 로그인 버튼을 보여주고, 값이 있으면 상단바에 프로필 이미지를 보여주도록 해보자. App.vue 컴포넌트의 템플릿을 아래와 같이 수정한다. 12345678910111213&lt;v-toolbar color=\"teal accent-4\" dark fixed app&gt; &lt;v-toolbar-side-icon @click.stop=\"drawer = !drawer\"&gt;&lt;/v-toolbar-side-icon&gt; &lt;v-toolbar-title&gt;Steemlog&lt;/v-toolbar-title&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-toolbar-items v-if='!username'&gt; &lt;v-btn flat small to='/login'&gt;로그인&lt;/v-btn&gt; &lt;/v-toolbar-items&gt; &lt;v-btn v-if='username' icon&gt; &lt;v-avatar color=\"white\" size='36'&gt; &lt;img :src=\"'https://steemitimages.com/u/' + username + '/avatar'\" alt=\"avatar\" onerror=\"this.src='https://steemitimages.com/u/monawoo/avatar/small'\"&gt; &lt;/v-avatar&gt; &lt;/v-btn&gt;&lt;/v-toolbar&gt; 세션 스토리지를 사용하여 로그인 유지하기 지금 구현한 앱은 브라우저의 새로고침 버튼을 클릭하면 로그인이 풀리는 문제가 있다. 새로고침을 해도 로그인이 유지되도록 바꿔보자. auth 모듈 state 오브젝트의 username과 password 값을 **세션 스토리지(sessionStorage)**에서 가져온다. 그리고 login 액션에서는 커밋(commit)이 끝나면 세션 스토리지에 username과 password 값을 저장한다. ./store/modules/auth.js 파일을 아래와 같이 수정한다. 123456789101112const state = ｛ username: window.sessionStorage.getItem('username') || '', password: window.sessionStorage.getItem('password') || ''｝const actions = ｛ login (｛ commit ｝, auth) ｛ commit('login', auth) window.sessionStorage.setItem('username', auth.username) window.sessionStorage.setItem('password', auth.password) ｝｝ 세션 스토리지에 저장한 데이터는 브라우저의 세션 스토리지 영역에 저장되어 있다. 크롬 브라우저에서 개발자 도구(단축키: Ctrl + Shift + i)의 Application 탭에서 확인 가능하다. 참고로 로그아웃을 구현하지 않았으므로, 로그아웃을 하려면 세션 스토리지의 데이터를 삭제해야 한다. 다음 시간에는 사용자 프로필 정보를 가져오는 기능을 구현할 예정입니다. 여기까지 읽어주셔서 감사합니다. 구현된 앱은 steemlog.github.io에서 확인 해 볼 수 있습니다. 전체 소스 내용은 github에서 볼 수 있습니다. https://github.com/anpigon/steemit-app 이전글 스팀잇(Steemit)기반 앱 만들기 #1 - 시작하기 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기 스팀잇(Steemit)기반 앱 만들기 #4 - 상세화면 구현하기 스팀잇(Steemit)기반 앱 만들기 #5 - 댓글 보여주기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #5 - 댓글 보여주기","slug":"/kr/@anpigon/steemit-5","date":"2018-08-08T15:40:18.000Z","updated":"2019-11-11T13:41:49.827Z","comments":true,"path":"/kr/@anpigon/steemit-5/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-5/","excerpt":"이번 시간에는 스팀잇 본문의 댓글을 가져와서 하단에 보여주는 기능을 구현해봅니다. 현재까지 구현된 전체 소스 내용은 깃허브(PostView.vue)에서 확인 가능합니다.저도 공부하면서 구현하는 중이라서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변 해드리도록 노력하겠습니다.","text":"이번 시간에는 스팀잇 본문의 댓글을 가져와서 하단에 보여주는 기능을 구현해봅니다. 현재까지 구현된 전체 소스 내용은 깃허브(PostView.vue)에서 확인 가능합니다.저도 공부하면서 구현하는 중이라서 설명이 많이 부족할 수 있습니다. 궁금한 사항은 댓글로 문의하시면, 최대한 답변 해드리도록 노력하겠습니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기 스팀잇(Steemit)기반 앱 만들기 #4 - 상세화면 구현하기 강좌를 연재하면서 허전한 것 같아 로고를 한번 만들어 보았습니다. 본문 하단에 댓글 보여주기 본문 하단에 댓글을 보여주기 위해서 components/PostView.vue 파일을 수정합니다. data()에 댓글들을 저장할 comments와 플래그 값을 저장할 loadedComments를 추가합니다. loadedComments는 댓글을 가져오는 요청이 완료되었는지를 판단할 것입니다. 12345data () ｛ ... 생략 ... comments: [], loadedComments: false｝ 그리고 PostView.vue 컴포넌트 아랫부분에 댓글을 출력할 영역을 추가합니다. 이 댓글 영역은 loadedComments 플래그 값에 따라 로딩 이미지가 보이거나, 또는 댓글 목록이 보일 것입니다. 12345678910111213&lt;v-flex xs12&gt; &lt;v-subheader class='pl-0'&gt;댓글 (｛｛children｝｝)&lt;/v-subheader&gt; &lt;v-card ref='comments'&gt; &lt;v-container grid-list-md v-if='!loadedComments'&gt; &lt;v-layout align-center justify-center&gt; &lt;v-progress-circular color=\"primary\" indeterminate&gt;&lt;/v-progress-circular&gt; &lt;/v-layout&gt; &lt;/v-container&gt; &lt;v-card-text v-if='loadedComments'&gt; 여기는 댓글 영역입니다. &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-flex&gt; 나중에 스크롤 된 페이지에서 댓글 컴포넌트의 위치를 참조하기 위해 &lt;v-card&gt; 컴포넌트에 ref 옵션을 사용하였습니다. ref에는 “comments” 값을 입력합니다. 이번에 구현할 댓글 가져오기 기능은 PostVirw.vue 컴포넌트가 생성되었을 때는 동작하지 않습니다. 페이지를 스크롤 하다가 하단의 댓글 영역이 화면에 보이면, 이때 서버에서 댓글을 가져와서 보여주도록 하겠습니다. 이렇게 동작하기 위해서는 댓글 영역이 화면에 보이는지를 계산해야 합니다. 쉽게 구현하기 위해서 Vuerify.js의 스크롤 디렉티브(Scrolling Directive)를 사용합니다. 아래와 같이 컨텐츠을 감싸고 있는 &lt;v-layout&gt; 컴포넌트에 v-scroll 옵션을 추가합니다. 그리고 **“onScroll”**값을 입력합니다. 이제 페이지를 스크롤 하는 경우에 v-scroll() 함수가 호출 될 것입니다. 1&lt;v-layout justify-start column fill-height v-scroll=\"onScroll\"&gt; 전체 소스는 여기에서 확인 가능합니다. 그리고 스크롤할때 호출되는 onScroll() 함수를 다음과 같이 구현합니다. 1234567methods: ｛ onScroll () ｛ const windowOffsetTop = window.pageYOffset || document.documentElement.scrollTop const windowOffsetBottom = windowOffsetTop + window.innerHeight console.log('현재 스크롤된 화면의 Bottom 위치:', windowOffsetBottom) ｝｝ 브라우저 내장 함수를 사용하여 스크롤된 화면의 맨하단 위치값을 계산합니다. 이제 댓글 영역이 화면에 보이는지 아닌지를 계산해보겠습니다. 댓글 영역의 위치 값을 알기 위해서 computed에 댓글 영역의 offsetTop값을 가져오는 commentsOffsetTop() 함수를 추가합니다. 바로 전에 우리가 ref를 사용하여 **“comments”**값을 입력했던 것을 기억하나요? this.$refs를 사용하면 해당 컴포넌트를 참조 할 수 있습니다. 다음과 같이 this.$refs.comments.$el.offsetTop를 사용하여 댓글 영역의 offsetTop 값을 가져옵니다. 12345computed: ｛ commentsOffsetTop () ｛ return this.$refs.comments.$el.offsetTop ｝｝ 그리고 화면의 위치값을 계산하기 위해 스크롤할때 호출되는 onScroll() 함수를 수정하겠습니다. windowOffsetBottom와 commentsOffsetTop 값을 사용하여 페이지 스크롤이 댓글 영역에 도달하였는지 계산합니다. 1234567onScroll () ｛ const windowOffsetTop = window.pageYOffset || document.documentElement.scrollTop const windowOffsetBottom = windowOffsetTop + window.innerHeight if (!this.loadedComments &amp;&amp; windowOffsetBottom &gt; this.commentsOffsetTop) ｛ console.log('댓글 영역 도달!!!') ｝｝ 하지만, 스크롤 할 때마다 계속해서 서버에서 댓글을 가져오는 요청이 발생되어서는 안되겠죠? lodash 의 debounce() 함수를 사용하여 서버요청이 매번 발생되지 않도록 합니다. 아래와 같이 npm을 사용하여 lodash 를 설치합니다. 1$ npm install lodash --save debounce() 함수를 사용하면 한번 호출 한 이후에는 지연된 호출을 하도록 설정 할 수 있습니다. 다음과 같이 lodash를 임포트합니다. 1import _ from 'lodash' 그리고 lodash의 debounce() 함수를 사용하여 서버에서 댓글을 가져오는 getComments() 함수를 구현해보도록 하겠습니다. 12345678910111213methods: ｛ ... 생략... getComments: _.debounce(function () ｛ const path = `/$｛this.category｝/@$｛this.author｝/$｛this.permlink｝` // 댓글을 가져올 글의 path steem.api.getStateAsync(path) .then(r =&gt; ｛ console.log(r) this.loadedComments = true ｝) ｝, 1000)｝ 참고로 위와 같이 debounce() 함수의 2번째 인자값에 1000을 넣게 되면, 페이지 스크롤이 발생해도 1초가 지나기 전까지는 getComments()가 실행 되지 않습니다. 콘솔에서 steem.api.getStateAsync() 함수를 호출해보면 아래와 같은 구조의 데이터를 가져옵니다. 여기에서 댓글 데이터만 추출해야합니다. 아래 데이터를 보시면 content에 본문과 댓글이 배열 형태로 포함되어 있습니다. depth값이 0이면 본문이고, 그외에는 댓글이라고 보면 됩니다. 우리는 계층형 구조로된 댓글 데이터가 필요하기 때문에, 가져온 데이터의 content에서 본문을 제외한 댓글을 계층 형태의 배열로 만들어주는 함수를 구현합니다. 간단하게 구현하기 위해 재귀함수 형태로 구현합니다. 참고로 성능은 고려되지 않았습니다. 데이터량이 많으면 느려질 수 있습니다. 12345678910function addComments (contents, root) ｛ if (root.children &gt; 0) ｛ // root가 children를 가지고 있으면 실행 if (!root.comments) root.comments = [] // root의 댓글을 담을 comments 변수 초기화 root.replies.forEach(key =&gt; ｛ // 댓글key를 가지고 있는 root.replies 배열을 반복하여 contents에서 key와 매칭되는 댓글 데이터 가져옴 const comment = _.pick(contents[key], ['id', 'author', 'author_reputation', 'body', 'created', 'net_votes', 'permlink', 'parent_author', 'parent_permlink', 'url', 'children', 'depth', 'replies']) root.comments.push(comment) // root의 댓글목록에 추가 addComments(contents, comment) // 현재 댓글에 자식 댓글이 있는지 찾기 위해 재귀함수 호출 ｝) ｝｝ 코드 내용에 대한 설명은 주석으로 대신합니다. 그리고 댓글을 가져오는 getComments() 함수를 아래와 같이 수정합니다. 앞서 만든 재귀함수 addComments()를 사용하여 댓글을 계층형 배열로 만들어 줍니다. 123456789steem.api.getStateAsync(path) .then((｛ content ｝) =&gt; ｛ this.loadedComments = true // 댓글 목록 조회 const root = _.find(content, ｛ depth: 0 ｝) // content에서 본문만 가져오기 addComments(content, root) // 재귀함수 호출 this.comments = root.comments｝) 이제 마지막으로 댓글 컴포넌트도 재귀적으로 호출되도록 구현하겠습니다. 댓글 컴포넌트로 사용될 components/Component.vue 파일를 생성합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;template v-for=\"c in comments\"&gt; &lt;v-layout :key=\"c.id\"&gt; &lt;v-flex v-if=\"c.depth &gt; 1\" xs1&gt; &lt;span class='depth'&gt;&lt;/span&gt; &lt;/v-flex&gt; &lt;v-flex&gt; &lt;v-card flat style='padding:0' class='comments'&gt; &lt;v-card-title class=\"grey--text pb-1\"&gt; ｛｛ c.author ｝｝ &lt;span class='reputation pl-1 pr-1'&gt;(｛｛c.author_reputation | filterReputation｝｝)&lt;/span&gt; · ｛｛c.created | filterCreated｝｝ &lt;/v-card-title&gt; &lt;v-card-text class='pt-0 pb-0 overflow-hidden' v-html='c.body'&gt;&lt;/v-card-text&gt; &lt;v-card-actions class='pr-3'&gt; &lt;v-btn small flat&gt;&lt;v-icon left dark class='mr-2'&gt;favorite_border&lt;/v-icon&gt; 좋아요 (｛｛c.net_votes｝｝)&lt;/v-btn&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;strong&gt;$｛｛ c.payout_value ｝｝&lt;/strong&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;v-divider&gt;&lt;/v-divider&gt; &lt;Comments :comments='c.comments'&gt;&lt;/Comments&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default ｛ name: 'Comments', props: ['comments']｝&lt;/script&gt;&lt;style&gt;.overflow-hidden ｛ overflow: hidden; word-wrap: break-word;｝.depth ｛ border-left: 5px solid #eee; height: calc(100％ - 20px); display: block; margin: 10px 0 10px 10px;｝&lt;/style&gt; 방금 만든 Component.vue 컴포넌트를 사용하기 위해서 다음과 같이 PostView.vue 컴포넌트를 수정합니다. &lt;v-card-text v-if='loadedComments'&gt;&lt;/v-card-text&gt;에 Component.vue 컴포넌트를 사용하도록 아래와 같이 수정합니다. 123&lt;template v-if='loadedComments'&gt; &lt;Comments :comments='comments'&gt;&lt;/Comments&gt;&lt;/template&gt; 아래는 댓글을 가져와서 보여주는 화면입니다. 여기까지 읽어주셔서 감사합니다. 전체 소스 내용은 github에서 볼 수 있습니다. github: https://github.com/anpigon/steemit-app","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #4 - 상세화면 구현하기","slug":"/kr/@anpigon/steemit-4","date":"2018-08-07T01:40:24.000Z","updated":"2019-11-11T13:41:49.827Z","comments":true,"path":"/kr/@anpigon/steemit-4/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-4/","excerpt":"이번 시간에는 아래 화면과 같이 글 상세 내용을 볼 수 있는 화면을 구현해보도록 하겠습니다.그리고 구현하고 있는 앱 이름을 Steemit 과 Blog를 합쳐서 Steemlog 라고 지었습니다.^^ “Steemit + Blog = Steemlog” 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기","text":"이번 시간에는 아래 화면과 같이 글 상세 내용을 볼 수 있는 화면을 구현해보도록 하겠습니다.그리고 구현하고 있는 앱 이름을 Steemit 과 Blog를 합쳐서 Steemlog 라고 지었습니다.^^ “Steemit + Blog = Steemlog” 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기 시작하기전 글 상세화면을 구현하기 전에 무한 스크롤과 관련하여 오류가 있어서 Main.vue를 수정하였습니다. 오류를 설명하자면 상세화면 컴포넌트에서 페이지를 스크롤하는 경우에도 Main.vue에 구현되어 있는 무한 스크롤 기능이 동작하여 글을 계속 가져오는 문제가 있습니다. 해당 오류는 아래와 같은 방법으로 해결하였습니다. Main.vue 컴포넌트가 비활성화가 되는 경우에는 무한 스크롤 기능이 동작하지 않도록 합니다. Main.vue 컴포넌트의 deactivated 함수에서 busy 플래그를 true로 변경합니다. 그리고 Main.vue 컴포넌트가 활성화 되면 무한 스크롤 기능이 다시 동작하도록 activated 함수에서 busy 플래그를 false로 변경합니다. 123456deactivated () ｛ this.busy = true｝,activated () ｛ this.busy = false｝ 위의 설명이 잘 이해가 되지 않으면 Main.vue 파일의 전체 내용을 여기에서 확인하시기 바랍니다. 라우터에 PostView.vue 컴포넌트 추가하기 이번에 구현할 상세화면 컴포넌트 정보를 라우터(Router)에 추가하도록 하겠습니다. router/index.js 파일에 PostView 컴포넌트를 임포트합니다. 참고로 우리는 아직 PostView 컴포넌트를 구현하지 않았기 때문에 오류가 발생할 수 있습니다. 그리고 아래와 같이 Router 오브젝트에 PostView 컴포넌트의 path와 component 정보를 추가합니다. path에는 PostView 컴포넌트에서 사용할 author와 permlink값을 파라미터로 받을 수 있도록 /detail/@:author/:permlink 와 같은 형태로 입력합니다. 구현된 소스 내용은 여기 참고하세요. 12345678910111213... 생략 ...import PostView from '@/components/PostView' // PostView 컴포넌트 임포트... 생략 ...export default new Router(｛ routes: [ ｛ name: 'PostView', component: PostView, path: '/@:author/:permlink' ｝ ... 생략 ... 그러고 나서 Main.vue 컴포넌트에서 글목록을 클릭하면 PostView 컴포넌트으로 이동할 수 있도록 components/Main.vue 파일을 아래와 같이 수정합니다. 글제목과 내용을 표시하는 &lt;v-list-tile&gt; 태그에 to 옵션을 추가합니다. to 옵션은 우리가 라우터에 추가한 path정보와 맵핑되어 해당 컴포넌트가 렌더링됩니다. 아래 소스 내용에서 &quot;'/@' + d.author + '/' + d.permlink&quot; 코드에 실제 값이 매핑되면 &quot;/@anpigon/steemit-3&quot; 와 같은 형태가 됩니다. 12345678910... 생략 ...&lt;v-list three-line&gt; &lt;v-list-tile :to=\"'/@' + d.author + '/' + d.permlink\"&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;｛｛ d.title ｝｝&lt;/v-list-tile-title&gt; &lt;v-list-tile-sub-title class='ellipsis'&gt;｛｛ d.body ｝｝&lt;/v-list-tile-sub-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt;&lt;/v-list&gt;... 생략 ... 상세화면(PostView) 컴포넌트 생성 이제 components/PostView.vue 파일을 생성합니다. 파일 내용은 아래와 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt;&lt;v-container fill-height fluid grid-list-md&gt; &lt;v-layout v-if=\"loading\" align-center justify-center&gt; &lt;v-progress-circular size=\"50\" color=\"primary\" indeterminate&gt;&lt;/v-progress-circular&gt; &lt;/v-layout&gt; &lt;v-layout v-if=\"!loading\"&gt; &lt;v-flex xs12 md8 offset-md2&gt; &lt;v-card&gt; &lt;v-card-title class=\"headline pb-0\"&gt; ｛｛ title ｝｝ &lt;/v-card-title&gt; &lt;v-layout&gt; &lt;v-flex xs6&gt; &lt;v-list class='pt-0'&gt; &lt;v-list-tile avatar&gt; &lt;v-list-tile-avatar&gt; &lt;img :src=\"'https://steemitimages.com/u/' + author + '/avatar'\" alt=\"avatar\"&gt; &lt;/v-list-tile-avatar&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;｛｛ author ｝｝ (｛｛author_reputation｝｝)&lt;/v-list-tile-title&gt; &lt;v-list-tile-sub-title&gt;｛｛created｝｝ · ｛｛category｝｝&lt;/v-list-tile-sub-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;/v-list&gt; &lt;/v-flex&gt; &lt;v-flex text-xs-right class='pr-4 pt-3'&gt; &lt;div&gt;좋아요 ｛｛ net_votes ｝｝명 · 댓글 ｛｛ children ｝｝명&lt;/div&gt; &lt;strong&gt;$｛｛ payout_value ｝｝&lt;/strong&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;v-divider&gt;&lt;/v-divider&gt; &lt;v-card-text&gt; &lt;article v-html=\"body\"&gt;&lt;/article&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-flex&gt; &lt;/v-layout&gt;&lt;/v-container&gt;&lt;/template&gt;&lt;script&gt;import steem from 'steem'export default ｛ data () ｛ return ｛ loading: true, title: '', body: '', author: '', author_reputation: 0, category: '', children: 0, net_votes: 0, created: '', payout_value: 0 ｝ ｝, deactivated () ｛ // 해당 컴포넌트가 비활성화 되었을때, 컴포넌트를 메모리에서 제거한다. this.$destroy() ｝, beforeCreate () ｛ const author = this.$route.params.author // path에서 author값 const permlink = this.$route.params.permlink // path에서 permlink값 // 스팀 네트워크에서 글을 가져온다. steem.api.getContentAsync(author, permlink) .then(r =&gt; ｛ this.title = r.title this.body = r.body this.category = r.category this.children = r.children this.net_votes = r.net_votes this.author = r.author this.created = r.created this.author_reputation = r.author_reputation ｝) .catch(e =&gt; console.log(e)) // 에러가 발생하는 경우 콘솔에 출력 .finally(() =&gt; (this.loading = false)) // 로딩 이미지 비활성화 ｝｝&lt;/script&gt; 위 소스 내용에 대한 설명은 일부 주석으로 대신하였습니다. PostView.vue 컴포넌트에서는 beforeCreate 함수를 사용하여, 컴포넌트가 생성되기 전에 글 내용을 가져오도록 구현하겠습니다. beforeCreate 함수에서 스팀잇 글 내용을 가져오는 steem.api.getContentAsync 함수를 호출합니다. 참고로 data에서 loading 플래그는 글을 가져오기 전에 로딩 이미지 &lt;v-progress-circular&gt;를 보여주거나 또는 숨겨주는 용도입니다. 참고로 steem.api.getContentAsync 와 steem.api.getContent 는 동일한 기능의 함수입니다. 두 함수의 차이점을 설명하자면 Async가 붙은 함수는 ES6 표준 Promise를 사용하고, 그렇지 않은 함수는 콜백을 사용하여 구현합니다. 그리고 Async함수는 ES7부터 지원하는 Async / Await 문법을 사용하여 더 간결하게 코딩할 수 있습니다. 이 부분은 기회가 되면 나중에 보여주도록 하겠습니다. 여기까지 구현한 다음 목록에서 글을 클릭하면 아래와 같은 화면이 보입니다. 이쁘게 출력되진 않네요. 수정해야 할 부분들이 보입니다. 위 화면을 보시면 글 등록시간이 2018-08-03T15:28:45와 같이 표시되고 있습니다. Main.vue 컴포넌트에서 구현했던 방식을 사용하여 시간을 표시하도록 하겠습니다. 하지만 Main.vue 컴포넌트와 PostView.vue 컴포넌트에서 시간을 변환하는 동일한 코드가 있으면, 소스 내용도 길어지고 보기에 좋지 않습니다. 그래서 이번에는 vue가 제공하는 옵션 중 **필터(filter)**를 사용하여 모든 컴포넌트에서 사용할 수 있도록 구현해보겠습니다. main.js 에 아래와 같이 등록시간을 변환해주는 필터(filter)를 구현합니다. 12345678910111213141516171819Vue.filter('filterCreated', function (value) ｛ if (!value) return '' const now = new Date() const created = new Date(value.toString() + 'Z') const elapsedSeconds = (now - created) / 1000 // 경과 시간(초) if (elapsedSeconds &lt; 60) ｛ return Math.round(elapsedSeconds) + '초 전' ｝ else if (elapsedSeconds &lt; 360) ｛ return Math.round(elapsedSeconds / 60) + '분 전' ｝ else if (elapsedSeconds &lt; 8640) ｛ return Math.round(elapsedSeconds / 60) + '시간 전' ｝ else if (elapsedSeconds &lt; 207360) ｛ return '어제' ｝ else ｛ return (now.getFullYear() !== created.getFullYear() ? created.getFullYear() + '년 ' : '') + (created.getMonth() + 1) + '월 ' + created.getDate() + '일' ｝｝) 이제 PostView.vue 컴포넌트에서 등록시간 바인딩 해주는 부분에 필터를 적용하겠습니다. ｛｛｝｝ 형태의 데이터 바인딩 방법을 중괄호 보간법(mustache interpolations)이라고 합니다. 필터 적용방법은 보간자 내에 파이프 심볼과 함께 필터를 추가 해주면 됩니다. ｛｛ created ｝｝ 를 ｛｛ created | filterCreated ｝｝로 수정합니다. 같은 방법으로 명성(reputation)을 계산하는 것도 필터로 만들어봅니다. 123456789101112131415161718192021// 명성 계산Vue.filter('filterReputation', function (t) ｛ if (!t) return t t = parseInt(t) let e = String(t) let r = e.charAt(0) === '-' e = r ? e.substring(1) : e let n = e let i = parseInt(n.substring(0, 4)) let o = Math.log(i) / Math.log(10) let s = n.length - 1 let a = s + (o - parseInt(o)) if (isNaN(a)) a = 0 else ｛ a = Math.max(a - 9, 0) a *= r ? -1 : 1 a = 9 * a + 25 a = parseInt(a) ｝ return a｝) 작성자 명성을 표시하는 부분에 필터를 ｛｛author_reputation | filterReputation｝｝ 와 같이 적용합니다. 이번에는 computed 함수를 사용하여 보상금액(payout_value)을 계산해보도록 하겠습니다. vue에서는 이것을 **계산된 속성(computed property)**이라고 부릅니다. 123456789101112131415161718192021222324252627282930313233343536... 생략 ...data () ｛ ... 생략 ... // data에 payout_value 관련 값들을 저장 total_payout_value: 0, curator_payout_value: 0, pending_payout_value: 0｝, // computed 기능 구현computed: ｛ // payout_value 금액 계산 payout_value () ｛ return (this.total_payout_value + this.curator_payout_value + this.pending_payout_value).toFixed(2) ｝｝, beforeCreate () ｛ ... 생략 ... steem.api.getContentAsync(author, permlink) .then(r =&gt; ｛ ... 생략 ... this.total_payout_value = parseFloat(r.total_payout_value.split(' ')[0]) this.curator_payout_value = parseFloat(r.curator_payout_value.split(' ')[0]) this.pending_payout_value = parseFloat(r.pending_payout_value.split(' ')[0]) ｝) ... 생략 ...｝ 소스 내용에서 생략된 부분이 많아 보기 힘드실 수 있습니다. 소스 전체 내용은 여기를 참고하세요. 이제 마크다운으로 표시되고 있는 글내용을 html로 변환하여 보여주도록 해보겠습니다. 아래와 같이 Remarkable 객체를 생성합니다. 123import Remarkable from 'remarkable'const md = new Remarkable(｛ html: true, linkify: true ｝) 그리고 글을 가져오는 함수에서 마크다운 형태로 된 글내용을 html로 변환합니다. this.body = r.body를 this.body = md.render(r.body)로 수정합니다. 여기까지 구현하면 아직 스타일이 적용되지 않아 글내용을 보여주는 페이지의 디자인이 너무 투박하게 보일 것입니다. 우리는 스팀잇과 비슷한 디자인으로 보여주기 위해 아래와 같이 스타일을 추가합니다. 1234567891011121314&lt;style&gt;article img ｛ width: auto; max-width: 100％; height: auto; max-height: none; display: inline-block; vertical-align: middle; border-style: none;｝... 생략...&lt;/style&gt; 스타일은 내용이 너무 길어 생략하였습니다. 전체 내용은 여기를 참고하세요. 코드 하이라이트 적용하기 저는 스팀잇에 글을 작성할 때 주로 소스코드가 포함된 글을 올리기 때문에 코드 하이라이트 기능을 추가로 구현하였습니다. 아래와 같이 highlight.js 모듈을 설치합니다. 1$ npm install highlight.js --save 그리고 아래와 같이 index.html 파일의 헤더 부분에 css를 추가합니다. 1&lt;link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css' rel=\"stylesheet\"&gt; highlight.js에서 제공하는 테마는 종류가 많습니다. 제공하는 테마는 종류가 궁금하신 분들은 여기에서 찾아 볼 수 있습니다. 테마 적용방법은 css경로에서 default.min.css을 해당 테마의 파일명으로 변경하면 됩니다. 저는 vs2015 테마를 적용하였습니다. 저와 같은 테마를 적용하려면 vs2015.min.css를 사용하면 됩니다. 마지막으로 글내용중에 코드블럭을 찾아 highlight를 적용합니다. PostView.vue 컴포넌트가 업데이트(updated)되었을때 코드블럭을 찾아 highlight를 적용합니다. 코드 내용은 아래와 같습니다. 1234567891011121314import hljs from 'highlight.js'export default ｛ ... 생략 ... updated () ｛ Array.prototype.forEach.call(document.querySelectorAll('article pre code'), function (block) ｛ hljs.highlightBlock(block) ｝) ｝ ... 생략 ... 참고로 Remarkable 모듈에서도 highlight 옵션을 제공하고 있습니다. 하지만 highlight 테마의 배경색상이 나오지 않아서 저는 위와 같은 방법으로 적용하였습니다. Remarkable 모듈에서 제공하는 옵션이 궁금하신 분은 여기를 참고하세요. 아래는 지금까지 구현한 화면입니다. 여기까지 읽어주셔서 감사합니다. 전체 소스 내용은 github에서 볼 수 있습니다. github: https://github.com/anpigon/steemit-app","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #3 - 무한 스크롤 구현하기","slug":"/kr/@anpigon/steemit-3","date":"2018-08-03T15:28:45.000Z","updated":"2019-11-11T13:41:49.827Z","comments":true,"path":"/kr/@anpigon/steemit-3/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-3/","excerpt":"이번 시간에는 스크롤을 내렸을때 글 목록을 자동으로 가져오는 기능을 구현해보도록 하겠습니다. 이런 기능을 인피니티 스크롤(Infinite Scroll) 또는 무한 스크롤이라고 합니다.아래는 무한 스크롤이 구현된 화면입니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기","text":"이번 시간에는 스크롤을 내렸을때 글 목록을 자동으로 가져오는 기능을 구현해보도록 하겠습니다. 이런 기능을 인피니티 스크롤(Infinite Scroll) 또는 무한 스크롤이라고 합니다.아래는 무한 스크롤이 구현된 화면입니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기 무한 스크롤(Infinite Scroll) 모듈 설치하기 무한 스크롤 기능을 직접 구현해도 되지만, 이 글에서는 vue-infinite-scroll 모듈을 사용하여 구현하겠습니다. 아래와 같이 설치합니다. 1$ npm install vue-infinite-scroll --save 글 목록 화면에 무한 스크롤 적용하기 무한 스크롤을 적용하기 위해 Main.vue 파일을 수정합니다. 글목록을 보여주는 영역을 &lt;div&gt;태그로 감쌉니다. 그리고 v-infinite-scroll, infinite-scroll-disabled, infinite-scroll-distance 속성을 추가합니다. 각 속성에 대한 내용은 아래쪽에서 다시 설명하겠습니다. 수정된 코드는 다음과 같습니다. 참고로 코드량이 많아 일부 생략하였습니다. 123456789101112131415&lt;v-flex xs12 md9 offset-md3&gt; &lt;div v-infinite-scroll=\"loadMore\" infinite-scroll-disabled=\"busy\" infinite-scroll-distance=\"10\"&gt; &lt;v-layout row wrap&gt; &lt;v-flex xs12 md6 xl4 v-for=\"d in discussions\" :key=\"d.id\"&gt; ... 생략 ... &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/div&gt;&lt;/v-flex&gt; vue-infinite-scroll 모듈에서 사용가능한 옵션은 아래와 같습니다. Option Description infinite-scroll-disabled 이 속성의 값이 TURE 이면 스크롤이 비활성화됩니다. infinite-scroll-distance v-infinite-scroll 함수가 실행되기 전, 요소 하단과 뷰 포트 하단 사이의 최소 거리입니다. 기본값은 0입니다. infinite-scroll-immediate-check 바인딩 되자마자 즉시 directive을 확인해야 함을 의미합니다. 내용이 스크롤 가능한 컨테이너를 채울만큼 많지 않을 때 유용합니다. 기본값은 true 입니다. infinite-scroll-listen-for-event Vue 인스턴스에서 이벤트가 생성되면 스크롤을 다시 검사합니다. infinite-scroll-throttle-delay 이번 확인 시간과 다음 확인 시간 사이의 간격(밀리 초). 기본값은 200입니다. 이제 data 오브젝트에 무한 스크롤 기능 활성화 여부를 저장할 busy 변수를 추가합니다. 그리고 무한 스크롤 기능 작동시 호출되는 loadMore 함수를 구현합니다. loadMore함수에는 앞서 구현하였던, 최근글을 가져오는 getDiscussions 함수를 호출하도록 하겠습니다. getDiscussions 함수 호출 전에 busy값을 true로 변경하여 무한 스크롤이 중복하여 작동 하지 않도록 합니다. 12345678910111213export default ｛ data: () =&gt; (｛ discussions: [], busy: false ｝), ... 생략 ... methods: ｛ loadMore: function () ｛ this.busy = true // 무한 스크롤 기능 비활성화 this.getDiscussions() ｝, 글을 가져온 후에는 무한 스크롤 기능을 다시 활성화 해주어야 합니다. 그래서 getDiscussions 함수를 다음과 같이 수정합니다. getDiscussionsByCreated함수의 콜백에서 busy값을 다시 false 로 변경합니다. 그리고 새로 가져온 데이터가 기존 데이터를 유지하면서 추가될 수 있도록 discussions 변수에 담아주는 코드를 아래와 같이 수정합니다. 123456789101112131415161718192021// 스팀잇 최근글 가져오기steem.api.getDiscussionsByCreated(query, (err, result) =&gt; ｛ if (!err) ｛ // 무한 스크롤 활성화 // 가져온 글갯수가 10개 이상인 경우만 작동 if (result.length &gt; 10) ｛ this.busy = false ｝ // 가져온 데이터를 items에 담는다. const items = result.map(item =&gt; ｛ // # 수정됨 ... 생략 ... ｝) // items 배열을 기존 discussions 배열과 합친다. this.discussions = this.discussions.concat(items) ｝｝) 그리고 우리는 loadMore함수에서 스팀잇 글을 가져오도록 수정했기 때문에, created 함수에서는 스팀잇 글을 가져오는 getDiscussions 함수를 더 이상 호출하지 않도록 제거합니다. 123created () ｛ // this.getDiscussions() // # 제거됨｝ 위의 코드를 실행해보면 계속 동일한 글 목록만 가져오는 것을 볼 수 있습니다. 왜냐하면 우리는 같은 페이지의 글목록을 가져오고 있기 때문입니다. 다음 페이지의 글을 가져오기 위해서는 steem.api.getDiscussionsByCreated 함수를 호출할 때 permlink와 author 값을 넘겨줘야합니다. 다음 글을 가져오기 위해 이 두 값을 사용하려면, 글을 가져올때마다 마지막 값을 기억하고 있어야합니다. 아래와 같이 data 오브젝트에 next 오브젝트를 추가합니다. next 오브젝트는 permlink 와 author 를 가집니다. 12345678data: () =&gt; (｛ discussions: [], busy: false, next: ｛ permlink: null, author: null ｝｝) 그리고 methods 에 있는 getDiscussions 함수를 다음과 같이 수정합니다. 스팀잇 최근글을 가져오는 함수를 호출할때 넘겨주는 query 오브젝트에 start_permlink 와 start_author 추가하고, next.permlink 와 next.author 값을 넘겨줍니다. 마지막으로getDiscussionsByCreated 함수 콜백에서 가져온 글목록에서 마지막 데이터의 permlink 와 author 값을 각각 next.permlink 와 next.author 에 저장합니다. 1234567891011121314151617181920212223242526272829303132getDiscussions () ｛ let query = ｛ tag: 'kr', limit: 10, start_permlink: this.next.permlink, start_author: this.next.author ｝ // 스팀잇 최근글 가져오기 steem.api.getDiscussionsByCreated(query, (err, result) =&gt; ｛ ... 생략 ... this.next.permlink = item.permlink // 마지막 permlink 값 저장 this.next.author = item.author // 마지막 author 값 저장 return ｛ id: item.id, // # 추가됨 image: image, author: item.author, author_reputation: item.author_reputation, title: item.title, created: item.created, body: item.body.substr(0, 200), category: item.category, permlink: item.permlink, url: item.url, payout_value: item.payout_value, net_votes: item.net_votes, children: item.children ｝ ｝) 지금까지 작업한 코드를 실행해보면, 다음에 가져온 글 목록의 첫번째 글이 이전에 가져온 글 목록의 마지막 글이랑 동일하다는 것을 확인할 수 있습니다. 일부러 이렇게 의도한 것인지는 잘 모르겠습니다. 가져온 글목록의 글ID를 체크하여 글ID가 서로 동일하면 기존 글목록에 추가하지 않도록 합니다. 그래서 추가로 가져온 글 목록에서 첫번째 항목을 제거하도록 하겠습니다. 1234567891011// 스팀잇 최근글 가져오기steem.api.getDiscussionsByCreated(query, (err, result) =&gt; ｛ this.busy = false if (!err) ｛ // 가져온 글의 첫번쨰 항목 제거 if (this.discussions.length &gt; 0) ｛ result = result.slice(1) ｝ ... 생략 ... 글을 가져올때 아무런 변화가 없다가 화면에 글들이 갑자기 나타나면 아무래도 심심하기 때문에, 글을 가져올 때 화면에 로딩 이미지를 보여주도록 하겠습니다. 다음과 같이 &lt;v-progress-circular&gt; 태그를 글목록을 출력하는 부분 아래에 삽입합니다. 그리고 v-show=&quot;busy&quot; 옵션을 사용하여 무한 스크롤 기능이 작동 중일때만 로딩 이미지가 보이도록 합니다. 123456789 ... 생략 ... &lt;/v-flex&gt;&lt;!-- // v-for END --&gt;&lt;/v-layout&gt;&lt;div class=\"text-xs-center mt-3\" v-show=\"busy\"&gt; &lt;v-progress-circular indeterminate color=\"primary\"&gt; &lt;/v-progress-circular&gt;&lt;/div&gt; 오늘 작업은 여기까지입니다. 여기까지 읽어주셔서 감사합니다. 전체 소스 내용은 github에서 볼 수 있습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Steemit] 내 보팅 가치(Vote Value)를 JavaScript로 계산하기","slug":"/kr/@anpigon/vote-value-javascript","date":"2018-08-02T08:39:45.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/vote-value-javascript/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/vote-value-javascript/","excerpt":"내 보팅 가치를 계산하는 공식이 궁금하여 자료를 찾아보았습니다.다행히 @yoonsg님이 계산 공식을 잘 정리해 놓은 글이 있어서 참고하였습니다. [스팀잇 이야기] #2. 보팅의 가치는 어떻게 산출될까? 계산 공식을 100％ 이해하기는 어려웠습니다. 자바스크립트로 구현하면서 정리한 내용을 공유합니다.","text":"내 보팅 가치를 계산하는 공식이 궁금하여 자료를 찾아보았습니다.다행히 @yoonsg님이 계산 공식을 잘 정리해 놓은 글이 있어서 참고하였습니다. [스팀잇 이야기] #2. 보팅의 가치는 어떻게 산출될까? 계산 공식을 100％ 이해하기는 어려웠습니다. 자바스크립트로 구현하면서 정리한 내용을 공유합니다. Steem-js 라이브러리 사용 계산에 필요한 값들은 모두 steem-js 라이브러리를 사용하여 스텔라 네트워크에서 가져왔습니다. 123&lt;html&gt; &lt;script src=\"//cdn.steemjs.com/lib/latest/steem.min.js\"&gt;&lt;/script&gt;&lt;/html&gt; Reward Fund 가져오기 계산 공식에 의하면, reward_balance 와 recent_claims 값이 필요합니다. steem.api.getRewardFundAsync함수를 사용해서 필요한 값들을 가져옵니다. 12345678// Reward Fund 가져오기var rewardFund = await steem.api.getRewardFundAsync('post')// reward balance var rewardBalance = rewardFund.reward_balance.split(' ')[0]// recent claimsvar recentClaims = rewardFund.recent_claims SDB 가격 가져오기 steem.api.getCurrentMedianHistoryPriceAsync 함수를 사용해서 base와 quote값을 가져옵니다. 그리고 quote에 따른 STEEM 가격을 계산합니다. 1234567// Current Median History Price 가져오기var price = await steem.api.getCurrentMedianHistoryPriceAsync()var base = price.base.split(' ')[0]var quote = price.quote.split(' ')[0]// SBD / STEEM의 가격 비율var steemPrice = base /quote Global Properties 가져오기 steem.api.getDynamicGlobalPropertiesAsync 함수를 사용하여 total_vesting_fund_steem와 total_vesting_shares값을 가져옵니다. 참고로 이 두 값은 조회 할 때마다 계속 바뀝니다. 12345678// Global Properties 가져오기var global = await steem.api.getDynamicGlobalPropertiesAsync()// total Vesting Fund Steemvar totalVestingFundSteem = global.total_vesting_fund_steem.split(' ')[0]// total Vesting Sharesvar totalVestingShares = global.total_vesting_shares.split(' ')[0] 계정 정보 가져오기 마지막으로 steem.api.getAccountsAsync 함수를 사용하여, 계정 정보를 가져옵니다. username 변수의 값은 본인의 ID로 수정해야 합니다. 아래 코드에서는 ‘anpigon’ 이 사용되었습니다. 계정이 보유하고 있는 **스팀파워(steemPower)**와 **보팅파워(votingPower)**를 계산합니다. **보팅가중치(voteWeight)**는 *100％*라고 가정합니다. 123456789101112131415161718// 계정 정보 가져오기var username = 'anpigon' // 조회할 유저IDvar account = (await steem.api.getAccountsAsync([username]))[0]// 나의 Steem 계산하기var vestingSteem = steem.formatter.vestingSteem(account, global)// 대여받은 Steem 계산하기var receivedVestingShares = account.received_vesting_shares.split(\" \")[0]var receivedVestingSteem = totalVestingFundSteem * (receivedVestingShares / totalVestingShares)// 보유한 총 Steem(나의 Steem + 대여받은 Steem)var steemPower = vestingSteem + receivedVestingSteemvar votingPower = account.voting_power // 현재 보팅 파워var voteWeight = 1e4 // 보팅 가중치(100％)console.log(`나의 보팅파워: $｛votingpower/100｝％\\n나의 스팀파워: $｛steempower｝ [$｛vestingSteem｝ (+$｛receivedVestingSteem｝)]`) 보팅 가치 계산하기 이제 가져온 값들을 공식에 넣어 계산합니다. 12345678// 보팅파워 * 보팅가중치에 따른 비율 계산var rate = parseInt(votingPower * voteWeight / 1e4)rate = parseInt((rate + 49) / 50) * 100 // 변환식(?)// 나의 보팅 가치 계산var voteValue = steemPower / (totalVestingFundSteem / totalVestingShares) * rate * (rewardBalance / recentClaims) * steemPriceconsole.log(`나의 보팅 가치: \\$$｛voteValue｝`) 현재 저의 보팅 가치 금액은 약 $0.001 로 나옵니다.ㅠㅠ 참고로 위의 코드는 모두 크롬 브라우저 콘솔창에서 실행되었습니다. 마무리 계산 공식에 의하면 보팅 가치를 $0.01 를 올리기 위해서는 약 128 SP 이 필요합니다. 원화로 계산했을때, 업비트 거래소 현재가 기준으로 약 16만원이 필요합니다. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #2 - 최근글 가져오기","slug":"/kr/@anpigon/steemit-2","date":"2018-08-01T04:40:00.000Z","updated":"2019-11-11T13:41:49.827Z","comments":true,"path":"/kr/@anpigon/steemit-2/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-2/","excerpt":"이번 시간에는 스팀잇에 등록된 글을 가져와서 출력하는 화면을 구현하겠습니다. 저도 학습하면서 구현하는 중이기 때문에 설명이 부족할 수 있습니다. 양해부탁드립니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇 최신글을 가져와서 출력하는 화면 만들기앱을 실행했을 때 처음에 보여질 메인화면를 생성하고 라우터(router)에 추가할 것입니다. 라우터에 대한 설명은 여기를 참고하세요.","text":"이번 시간에는 스팀잇에 등록된 글을 가져와서 출력하는 화면을 구현하겠습니다. 저도 학습하면서 구현하는 중이기 때문에 설명이 부족할 수 있습니다. 양해부탁드립니다. 이전글 스팀잇(Steemit)기반 앱 만들기 #1 스팀잇 최신글을 가져와서 출력하는 화면 만들기앱을 실행했을 때 처음에 보여질 메인화면를 생성하고 라우터(router)에 추가할 것입니다. 라우터에 대한 설명은 여기를 참고하세요. App.vue 파일에서 &lt;v-content&gt; 부분을 아래와 같이 수정합니다. 1234567...&lt;v-content&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/v-content&gt;... &lt;router-view&gt; 태그는 라우터에 의해 해당하는 컴포넌트를 렌더링하여 보여주는 영역입니다. 그리고 router/index.js 파일에서 routers 부분을 아래와 같이 수정합니다. 1234567891011import Main from '@/components/Main' // Main 컴포넌트 임포트export default new Router(｛ routes: [ ｛ path: '/', name: 'Main', component: Main ｝ ]｝) /경로로 접근하게 되었을때, &lt;router-view&gt; 영역에 Main 컴포넌트가 렌더링된 화면이 보여질 것입니다. 마지막으로 최근글을 가져와서 출력할 화면인 components/Main.vue 파일을 생성합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;v-container fill-height fluid grid-list-md&gt; &lt;v-layout&gt; &lt;v-flex xs12 md9 offset-md3&gt; &lt;v-layout row wrap&gt; &lt;v-flex xs12 md6 xl4 v-for=\"idx in 3\" :key=\"idx\"&gt; &lt;v-card&gt; &lt;v-list&gt; &lt;v-list-tile&gt; &lt;v-list-tile-avatar&gt; &lt;img src=\"https://steemitimages.com/u/anpigon/avatar\" alt=\"avatar\"&gt; &lt;/v-list-tile-avatar&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;anpigon (55)&lt;/v-list-tile-title&gt; &lt;v-list-tile-sub-title&gt;11시간 · KR&lt;/v-list-tile-sub-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;/v-list&gt; &lt;v-card-media src=\"https://cdn.vuetifyjs.com/images/cards/desert.jpg\" height=\"200px\"&gt;&lt;/v-card-media&gt; &lt;v-card-title primary-title&gt; &lt;div&gt; &lt;h3 class=\"headline mb-0\"&gt;Kangaroo Valley Safari&lt;/h3&gt; &lt;div&gt;Located two hours south of Sydney in the Southern Highlands of New South Wales, ...&lt;/div&gt; &lt;/div&gt; &lt;/v-card-title&gt; &lt;v-card-title&gt; 좋아요 5명 · 댓글 5명 &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;strong&gt;$774.32&lt;/strong&gt; &lt;/v-card-title&gt; &lt;v-divider&gt;&lt;/v-divider&gt; &lt;v-card-actions&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;favorite_border&lt;/v-icon&gt; 좋아요&lt;/v-btn&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;comment&lt;/v-icon&gt; 댓글달기&lt;/v-btn&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;reply&lt;/v-icon&gt; 공유하기&lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/v-container&gt;&lt;/template&gt; 그럼 아래와 같은 화면이 보일 것입니다. 우리는 스팀잇의 최근글을 가져와서 카드형태의 목록으로 보여줄 것입니다. 스팀잇에서 최신글 가져오기 이제 스팀잇 라이브러리(steem.js)를 사용해서 스팀잇에서 최근글을 가져오겠습니다. steem.js에 대한 자세한 사용방법은 github에서 doc와 examples를 참고하세요. 아래와 같이 터미널을 열어 steem.js을 설치합니다. 1$ npm install steem --save 설치하는데 시간이 좀 걸리네요. 설치가 완료될때 까지 기다립니다. 저의 경우에는 아래와 같은 오류가 발생하였는데, 다시 설치를 시도하니 설치가 잘 되었습니다. 😃 12345678...npm WARN gentlyRm not removing C:\\workspace\\steemit-app\\node_modules\\@babel\\template\\node_modules\\.bin\\babylon as it wasn't installed by C:\\workspace\\steemit-app\\node_modules\\@babel\\template\\node_modules\\babylonnpm ERR! path C:\\workspace\\steemit-app\\node_modules\\glob-parent\\package.json.1597626054npm ERR! code EPERMnpm ERR! errno -4048npm ERR! syscall renamenpm ERR! Error: EPERM: operation not permitted, rename 'C:\\workspace\\steemit-app\\node_modules\\glob-parent\\package.json.1597626054' -&gt; 'C:\\workspace\\steemit-app\\node_modules\\glob-parent\\package.json'... Main.vue 파일을 열어서 아래와 같이 script 코드를 추가합니다. 1234567891011121314151617181920212223242526&lt;script&gt;import steem from 'steem' // 스팀잇 라이브러리 임포트 export default ｛ data () ｛ return ｛ discussions: [] ｝ ｝, methods: ｛ getDiscussions () ｛ let query = ｛ tag: 'kr', limit: 10 ｝ // 스팀잇 최근글 가져오기 steem.api.getDiscussionsByCreated(query, (err, result) =&gt; ｛ console.log(err, result) ｝) ｝ ｝, created () ｛ this.getDiscussions() ｝｝&lt;/script&gt; data에는 글을 가져와서 저장할 discussions 변수를 선언합니다. methods에는 스팀잇에서 글을 가져오는 getDiscussions 함수를 구현합니다. created 함수에는 컴포넌트가 생성되면, getDiscussions 함수를 호출하도록 하겠습니다. 콘솔창(Console)을 보면 아래와 같이 스팀잇에서 최근글을 가져와서 출력한 것을 볼 수 있습니다. 크롬 브라우저에서 콘솔창을 보려면 개발자 도구를 열어서(단축키: Ctrl + Shift + i), Console 탭을 선택하면 됩니다. 화면에 데이터 출력하기 이번 다음 단계에서는 가져온 데이터를 화면에 출력 해보겠습니다. 우리가 가져온 discussion데이터의 구조는 아래와 같습니다. 1234567891011｛ \"id\": 58212397, \"author\": \"anpigon\", \"permlink\": \"steemit-1-10f53977c621e\", \"category\": \"kr\", \"parent_author\": \"\", \"parent_permlink\": \"kr\", \"title\": \"스팀잇(Steemit)기반 앱 만들기 #1\", \"body\": \"스터디 목적으로 스팀잇 기반...\", ...｝ root_, parent_ 와 같은 prefix가 있는 데이터가 여러군데 보입니다. author, permlink와 parent_author, parent_permlink, root_author, root_permlink, root_title 의 차이점은 저도 잘모르겠습니다.ㅠㅠ 위의 데이터 구조에 맞추어 화면에 출력 할 수 있도록 Main.vue 파일을 수정합니다. 123456789101112131415161718192021222324252627282930313233343536&lt;v-flex xs12 md6 xl4 v-for=\"d in discussions\" :key=\"d.id\"&gt; &lt;v-card&gt; &lt;v-list&gt; &lt;v-list-tile avatar&gt; &lt;v-list-tile-avatar&gt; &lt;img :src=\"'https://steemitimages.com/u/' + d.author + '/avatar'\" alt=\"avatar\"&gt; &lt;/v-list-tile-avatar&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;｛｛ d.author ｝｝ (｛｛ d.author_reputation ｝｝)&lt;/v-list-tile-title&gt; &lt;v-list-tile-sub-title&gt;｛｛ d.created ｝｝ · ｛｛ d.category ｝｝&lt;/v-list-tile-sub-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;/v-list&gt; &lt;v-card-media src=\"https://cdn.vuetifyjs.com/images/cards/desert.jpg\" height=\"200px\"&gt;&lt;/v-card-media&gt; &lt;v-card-title primary-title&gt; &lt;div&gt; &lt;h3 class=\"headline\"&gt;｛｛ d.title ｝｝&lt;/h3&gt; ｛｛ d.body.substr(0, 100) ｝｝... &lt;/div&gt; &lt;/v-card-title&gt; &lt;v-card-title&gt; 좋아요 ｛｛ d.net_votes ｝｝명 · 댓글 ｛｛ d.children ｝｝명 &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;strong&gt;$｛｛ d.payout_value ｝｝&lt;/strong&gt; &lt;/v-card-title&gt; &lt;v-divider&gt;&lt;/v-divider&gt; &lt;v-card-actions&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;favorite_border&lt;/v-icon&gt; 좋아요&lt;/v-btn&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;comment&lt;/v-icon&gt; 댓글달기&lt;/v-btn&gt; &lt;v-spacer&gt;&lt;/v-spacer&gt; &lt;v-btn flat&gt;&lt;v-icon left dark&gt;reply&lt;/v-icon&gt; 공유하기&lt;/v-btn&gt; &lt;/v-card-actions&gt; &lt;/v-card&gt;&lt;/v-flex&gt; 그리고 getDiscussions 함수를 아래와 같이 수정합니다. 1234steem.api.getDiscussionsByCreated(query, (err, result) =&gt; ｛ console.log(err, result) if (!err) this.discussions = result｝) steem.api.getDiscussionsByCreated 함수로 가져온 result 데이터를 this.discussions에 넣어주고 있습니다. 아래와 같이 출력됩니다. 하지만 못생기게 출력되었어요.ㅠㅠ 그래서 제목과 내용을 출력하는 부분에 style를 추가하고 아래와 같이 수정하였습니다. 123456789101112131415161718192021222324252627&lt;template&gt; ... &lt;v-list three-line&gt; &lt;v-list-tile&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;｛｛ d.title ｝｝&lt;/v-list-tile-title&gt; &lt;v-list-tile-sub-title class='text-ellipsis'&gt;｛｛ d.body ｝｝&lt;/v-list-tile-sub-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;/v-list&gt;...&lt;/template&gt;&lt;style&gt;.text-ellipsis ｛ overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 3; display: -moz-box; display: -webkit-box; display: box; /*! autoprefixer: off */ -moz-box-orient: vertical; -webkit-box-orient: vertical; /*! autoprefixer: on */｝&lt;/style&gt; 수정하고 나면 아래와 같이 나타납니다. 짠~ 이미지 출력하기 이미지가 포함되어 있는 글인 경우에 이미지를 출력해보도록 하겠습니다. getDiscussions 함수에서 result 데이터 가져오는 부분을 아래와 같이 수정합니다. 그리고 discussions변수에는 필요한 데이터만 가지고 있도록 정리하였습니다. 123456789101112131415161718this.discussions = result.map((item) =&gt; ｛ const metadata = JSON.parse(item.json_metadata) // 메타데이터 JSON 파싱 const image = metadata.image ? metadata.image[0] : '' // 이미지 URL return ｛ image: image, author: item.author, author_reputation: item.author_reputation, title: item.title, created: item.created, body: item.body.substr(0, 200), category: item.category, permlink: item.permlink, url: item.url, payout_value: item.payout_value, net_votes: item.net_votes, children: item.children ｝｝) 이미지를 출력하는 &lt;v-card-media&gt; HMLT 태그를 아래와 같이 수정합니다. 123&lt;v-card-media v-if=\"d.image\" :src=\"d.image\" height=\"200px\"&gt;&lt;/v-card-media&gt; 보상금액(payout) 계산하기 글에 보상된 페이금액은 아래와 같이 계산합니다. 1234const totalPayoutValue = parseFloat(item.total_payout_value.split(' ')[0])const curatorPayoutValue = parseFloat(item.curator_payout_value.split(' ')[0])const pendingPayoutCalue = parseFloat(item.pending_payout_value.split(' ')[0])item.payout_value = (totalPayoutValue + curatorPayoutValue + pendingPayoutCalue).toFixed(2) 저자 명성(author reputation) 계산하기 저자 명성은 아래와 같이 계산합니다. 1item.author_reputation = steem.formatter.reputation(item.author_reputation) // 저자 명성 글 등록시간을 경과 시간으로 보여주기 글 등록시간을 “2초 전”, “5분 전”, “1시간 전” 과 같은 형태로 보여줍니다. 12345678910111213141516const now = new Date()const created = new Date(item.created + 'Z')const elapsedSeconds = (now - created) / 1000 // 경과 시간(초)if (elapsedSeconds &lt; 60) ｛ item.created = Math.round(elapsedSeconds) + '초 전'｝ else if (elapsedSeconds &lt; 360) ｛ item.created = Math.round(elapsedSeconds / 60) + '분 전'｝ else if (elapsedSeconds &lt; 8640) ｛ item.created = Math.round(elapsedSeconds / 60) + '시간 전'｝ else if (elapsedSeconds &lt; 207360) ｛ item.created = '어제'｝ else ｛ item.created = (now.getFullYear() !== created.getFullYear() ? created.getFullYear() + '년 ' : '') + (created.getMonth() + 1) + '월 ' + created.getDate() + '일'｝ 글 내용에서 HTML 제거하기 스팀잇 글 내용은 HTML과 마크다운을 혼용해서 사용하기 때문에, 마크다운을 HTML로 변환해줄 필요가 있습니다. 터미널에서 아래 명령어를 실행하여 remarkable 를 설치합니다. 1$ npm install remarkable --save 사용방법은 아래와 같습니다. 123import Remarkable from 'remarkable'const md = new Remarkable(｛ html: true, linkify: true ｝) 이제 글 내용에서 HTML 코드를 제거하겠습니다. 1item.body = md.render(item.body).replace(/&lt;\\/?[^&gt;]+(&gt;|$)/g, '') 아래 화면은 지금까지 작업한 결과물입니다. 모바일에서는 아래와 같이 보입니다. 전체 소스 내용은 github에서 볼 수 있습니다. github: https://github.com/anpigon/steemit-app 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Vue.js] 스팀잇(Steemit)기반 앱 만들기 #1","slug":"/kr/@anpigon/steemit-1-10f53977c621e","date":"2018-07-30T14:08:09.000Z","updated":"2019-11-11T13:41:49.827Z","comments":true,"path":"/kr/@anpigon/steemit-1-10f53977c621e/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/steemit-1-10f53977c621e/","excerpt":"스터디 목적으로 스팀잇 기반 서비스 앱을 자바스크립트(JS)로 구현해보려고 합니다. 그리고 모든 개발 과정들을 일지 쓰듯이 스팀잇에 남겨보려고 합니다.구현하기 위해서는 HTML과 자바스크립트에 대한 기본적인 지식이 필요합니다. 그리고 다음 준비물이 필요합니다. NodeJS Visual Studio Code vuetifyjs vue.js steem-js","text":"스터디 목적으로 스팀잇 기반 서비스 앱을 자바스크립트(JS)로 구현해보려고 합니다. 그리고 모든 개발 과정들을 일지 쓰듯이 스팀잇에 남겨보려고 합니다.구현하기 위해서는 HTML과 자바스크립트에 대한 기본적인 지식이 필요합니다. 그리고 다음 준비물이 필요합니다. NodeJS Visual Studio Code vuetifyjs vue.js steem-js &lt;개발환경 구성하기&gt; NodeJS 설치 : 개발SDK 저는 JAVA가 편하지만, 요즘 대세인 노드(Node)JS를 사용하여 구현합니다. 노드JS 홈페이지에 접속하여 8.11.3 LTS를 설치합니다. 다운로드: https://nodejs.org/ko/ Visual Studio Code 설치 : 개발도구 개발도구는 본인이 편한 것 아무거나 사용해도 상관없습니다. 저는 이클립스가 편하지만 대세에 따라 Visual Studio Code를 설치하였습니다. 다운로드: https://code.visualstudio.com/ Visual Studio Code(VSC)를 실행한 화면은 아래와 같습니다. 이후부터는 VSC 라고 명칭하겠습니다. Vuejs 설치 : JS프레임워크 자바스크립트 프레임워크에는 Angular, React.js, Vue.js 등 종류가 많아서 몇일을 고민했습니다. 하지만 대세에 따라 Vue.js를 설치합니다. 참고로 학습하는데 Vue.js가 가장 쉬웠습니다. 그리고 Vue.js 에서 제공해주는 vue-cli를 사용하여 개발환경을 구성합니다. vue-cli를 사용하면 복잡한 개발환경을 쉽게 구축할 수 있습니다. 차후 모바일도 할 것이라서 이왕 할거 개발환경을 pwa로 구성하기로 결정하였습니다. 참고로 pwa는 **프로그레시브 웹앱(Progressive Web App)**로 자세한 내용은 아래 링크로 대신합니다. 여러분의 첫 Progressive Web App - Google Developers VSC에서 통합 터미널(메뉴 &gt; 보기 &gt; 통합 터미널)을 열어줍니다. 그리고 아래와 같이 명령어를 입력하여 vue-cli를 설치하고 pwa개발환경을 구성합니다. [참고] 12345$ npm install -g vue-cli$ vue init pwa my-project$ cd my-project$ npm install$ npm run dev 아래는 설치중인 터미널 화면입니다. 설치가 모두 끝나고 나서 터미널에서 npm run dev 명령어를 실행하면, 브라우저에 아래 화면이 짠하고 나타납니다. 이 화면을 보았을때 감동이었습니다. 하지만 이제 시작입니다. Vuetify.js 설치 : UI프레임워크 UI프레임워크 종류가 많으니 마음에 드는 프레임워크를 선택하면 됩니다. 저는 vuetifyjs와 vuematerial 중에서 고민하였습니다. 하지만 대세에 따라 Vuetifyjs를 선택하였습니다. Vuetifyjs가 한글 메뉴얼이 매우 잘 되어있습니다. 터미널에서 아래와 같이 설치합니다. 1$ npm install vuetify --save Vuetify가 설치되었다면, VSC 파일탐색기에서 /src/main.js 파일을 열어서 수정합니다. main.js 파일에 Vuetify를 임포트(import)하고 Vue에게 Vuetify를 사용하도록 지시해야합니다. main.js 파일을 아래와 같이 수정합니다. 123456789101112131415import Vue from 'vue'import App from './App'import router from './router'import Vuetify from 'vuetify' // vuetify 임포트(import)import 'vuetify/dist/vuetify.min.css' // Vuetify.css 임포트(import)Vue.use(Vuetify) // Vuetify를 사용하도록 지시Vue.config.productionTip = falsenew Vue(｛ el: '#app', router, template: '&lt;App/&gt;', components: ｛ App ｝｝) 머티리얼 디자인 아이콘을 표시하기 위해 index.html 파일 &lt;head&gt;부분에 아래 태그를 추가합니다. 123&lt;head&gt; &lt;link href='https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons' rel=\"stylesheet\"&gt;&lt;/head&gt; 마지막으로 /src/App.vue 파일을 열어서 아래와 같이 수정합니다. 아래 소스는 [http://github.com/vuetifyjs]에서 가져왔습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;v-app id=\"inspire\"&gt; &lt;v-navigation-drawer v-model=\"drawer\" fixed app &gt; &lt;v-list dense&gt; &lt;v-list-tile @click=\"\"&gt; &lt;v-list-tile-action&gt; &lt;v-icon&gt;home&lt;/v-icon&gt; &lt;/v-list-tile-action&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;Home&lt;/v-list-tile-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;v-list-tile @click=\"\"&gt; &lt;v-list-tile-action&gt; &lt;v-icon&gt;contact_mail&lt;/v-icon&gt; &lt;/v-list-tile-action&gt; &lt;v-list-tile-content&gt; &lt;v-list-tile-title&gt;Contact&lt;/v-list-tile-title&gt; &lt;/v-list-tile-content&gt; &lt;/v-list-tile&gt; &lt;/v-list&gt; &lt;/v-navigation-drawer&gt; &lt;v-toolbar color=\"indigo\" dark fixed app&gt; &lt;v-toolbar-side-icon @click.stop=\"drawer = !drawer\"&gt;&lt;/v-toolbar-side-icon&gt; &lt;v-toolbar-title&gt;Application&lt;/v-toolbar-title&gt; &lt;/v-toolbar&gt; &lt;v-content&gt; &lt;v-container fluid fill-height&gt; &lt;v-layout justify-center align-center &gt; &lt;v-flex text-xs-center&gt; &lt;v-tooltip left&gt; &lt;v-btn slot=\"activator\" :href=\"source\" icon large target=\"_blank\"&gt; &lt;v-icon large&gt;code&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;span&gt;Source&lt;/span&gt; &lt;/v-tooltip&gt; &lt;v-tooltip right&gt; &lt;v-btn slot=\"activator\" icon large href=\"https://codepen.io/johnjleider/pen/rJdVMq\" target=\"_blank\"&gt; &lt;v-icon large&gt;mdi-codepen&lt;/v-icon&gt; &lt;/v-btn&gt; &lt;span&gt;Codepen&lt;/span&gt; &lt;/v-tooltip&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;/v-container&gt; &lt;/v-content&gt; &lt;v-footer color=\"indigo\" app&gt; &lt;span class=\"white--text\"&gt;&amp;copy; 2017&lt;/span&gt; &lt;/v-footer&gt; &lt;/v-app&gt;&lt;/template&gt;&lt;script&gt; export default ｛ data: () =&gt; (｛ drawer: null ｝), props: ｛ source: String ｝ ｝&lt;/script&gt; 다시 터미널에서 npm run dev 명령어를 실행하면 아래와 같은 화면이 나타납니다. 위 화면을 보기까지 많은 시행착오를 겪었지만 이 글에는 기술하지 않았습니다. 띄어쓰기나 빈문자열, 따옴표 등등 사소한 것에 에러를 뿜어대서 많이 당황스러웠네요. 여기까지 읽어주셔서 감사합니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"Vue","slug":"개발-이야기/vue","permalink":"https://anpigon.github.io/categories/개발-이야기/vue/"}],"tags":[{"name":"Vue","slug":"vue","permalink":"https://anpigon.github.io/tags/vue/"}],"author":"anpigon"},{"title":"[Steemit] 보팅 시간에 따른 큐레이션 보상 비율 분석하기","slug":"/kr/@anpigon/6dxsv6","date":"2018-07-25T05:21:15.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/6dxsv6/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/6dxsv6/","excerpt":"스팀잇을 공부하고 있는 스팀잇 초보입니다. 보상에 대해서는 많은 분들이 아는 내용이지만, 제가 이해한 방식으로 다시 정리하였습니다.포스트post을 작성하는 사람을 저자author라고 하며, 포스트에 대해 보팅voting하고 댓글comment을 다는 사람들을 큐레이터curator라고 합니다. 포스트에 대한 총 보상금rewards 중 75％는 저자에게 전달되고, 25％는 큐레이터들에게 분배됩니다.","text":"스팀잇을 공부하고 있는 스팀잇 초보입니다. 보상에 대해서는 많은 분들이 아는 내용이지만, 제가 이해한 방식으로 다시 정리하였습니다.포스트post을 작성하는 사람을 저자author라고 하며, 포스트에 대해 보팅voting하고 댓글comment을 다는 사람들을 큐레이터curator라고 합니다. 포스트에 대한 총 보상금rewards 중 75％는 저자에게 전달되고, 25％는 큐레이터들에게 분배됩니다. 큐레이터들의 보상 비율 큐레이션 보상금(총 보상금의 25％)이 각 큐레이터들에게 배분되는 비율 계산 공식은 아래와 같습니다. [이미지 출처: http://www.steem.center] 위의 공식에서 사용된 값의 의미는 다음과 같습니다. rs : 큐레이터가 보팅하여 발생한 rshares RS0 : 큐레이터가 보팅하기 전까지 누적된 rshares RS1 : 큐레이터가 보팅한 후 누적된 rshares RST : 총 누적된 rshares 여기서 rshare는 **보상(Reward Share)**를 의미합니다. 그리고 큐레이터가 보팅하여 발생하는 rshares는 큐레이터의 **스팀파워Steem Power**와 보팅파워Voting Power, **가중치weight**로 계산됩니다. 위의 공식을 다시 쉽게 표현하면 아래와 같습니다. 수학기호(√￣)는 한글로 &quot;루트&quot;라고 표현하였습니다. 1큐레이터 보상 비율％ = 루트(큐레이터가 보팅한 후 누적된 보상) - 루트(큐레이터가 보팅하기 전까지 누적된 보상) / 루트(총 누적된 보상) 따라서 위 계산 공식에 때르면 큐레이션 보상을 많이 받기 위한 조건은 아래와 같습니다. 내가 보팅하기 전까지는 포스트에 누적된 보상이 작다. 내가 보팅한 이후에 누적된 보상이 많아졌다. 보팅파워가 100％일떄 가중치 100％로 보팅했다. 나의 스팀파워가 크다. 결과적으로 스팀파워가 크고 보팅을 빨리 할 수록 받을 수 있는 큐레이션 보상 비율이 올라갑니다. 보팅 시간에 따른 큐레이션 보상 비율 포스팅 30분 이후에 보팅한 경우에는 큐레이션 보상을 100％ 가져오지만, 30분 이전에 보팅한 경우에는 시간에 따른 비율로 가져옵니다. 그리고 큐레이터가 가져오지 못한 보상의 나머지는 저자에게 갑니다. 30분 이전에 보팅한 경우, 큐레이션 보상 비율에 대한 계산 공식은 아래와 같습니다. 1△t = 포스팅 후 경과 시간(분) / 30분 예를들면 포스팅 1분 후 보팅한 경우, 1분 / 30분으로 계산하면 0.03이 나옵니다. 백분율로 환산하면 큐레이션 수익의 3％를 가져옵니다. 15분 후 보팅한 경우에는 15분 / 30분로 계산하면 50％를 가져옵니다. 보팅 시간에 따른 보상 비율을 표로 나타내면 아래와 같습니다. 포스팅 후 경과 시간(분) 큐레이션 보상 비율 0분 0％ 5분 16.66％ 10분 33.33％ 15분 50％ 20분 66.66％ 25분 83.33％ 30분 100％ 포스팅 되자마자 보팅하는 경우에는 내가 받을 큐레이션 보상이 0％가 되므로 전부 저자에게 가게 됩니다. 앞에서 계산한 큐레이터들의 보상 비율과 보팅 시간에 따른 비율을 계산하면 내가 받을 수 있는 큐레이션 최종 보상 비율을 구할 수 있습니다. 여기까지 읽어주셔서 감사합니다. 이전글 보팅파워와 재생시간 분석하기","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"}],"author":"anpigon"},{"title":"[Steemit] 보팅파워와 재생시간 분석하기","slug":"/kr/@anpigon/hrmjw","date":"2018-07-23T14:50:45.000Z","updated":"2019-11-11T13:41:49.831Z","comments":true,"path":"/kr/@anpigon/hrmjw/","link":"","permalink":"https://anpigon.github.io/kr/@anpigon/hrmjw/","excerpt":"최근에 스팀잇에 관심을 가지고 스터디하고 있는 뉴비입니다.하나 하나 차근 차근 공부하면서 블로그에 정리할 계획입니다. 보팅파워과 재생시간보팅파워Voting Power와 재생시간이 어떤 공식으로 계산 되는지 궁금하여 분석하여 보았습니다.https://steemd.com/@아이디 에 접속하면 자신의 보팅파워를 쉽게 확인 할 수 있습니다.","text":"최근에 스팀잇에 관심을 가지고 스터디하고 있는 뉴비입니다.하나 하나 차근 차근 공부하면서 블로그에 정리할 계획입니다. 보팅파워과 재생시간보팅파워Voting Power와 재생시간이 어떤 공식으로 계산 되는지 궁금하여 분석하여 보았습니다.https://steemd.com/@아이디 에 접속하면 자신의 보팅파워를 쉽게 확인 할 수 있습니다. 하지만 우리는 계산 공식을 구해서 직접 계산해보도록 하겠습니다. 계산하기 전에 우리는 사용자 프로필 정보에서 마지막 보팅 시간last vote time 과 보팅파워voting power를 조회해야 합니다. 사용자 프로필 정보 조회하기 Steemit.com은 데이터를 조회할 수 있는 몇 가지 endpoint를 제공하고 있습니다. 사용자 프로필 JSON 데이터는 요청URL 끝에 .json만 붙여서 호출하면 됩니다. 사용자 프로필 JSON 조회 URL https://steemit.com/@anpigon.json를 브라우저에서 조회하면, 아래와 같은 User Object JSON 데이터를 얻을 수 있습니다. 1234567891011121314151617181920｛ \"user\":｛ \"id\":810995, \"name\":\"anpigon\", \"json_metadata\":｛ \"profile\":｛ \"profile_image\":\"https://steemitimages.com/DQm~.png\", \"name\":\"안피곤\", \"cover_image\":\"https://steemitimages.com/DQm~.jpg\", \"github\":\"anpigon\", \"about\":\"안녕하세요 \" ｝ ｝, ... 생략 ... \"voting_power\":8925, \"last_vote_time\":\"2018-07-23T04:27:03\", ... 생략 ... ｝, \"status\":\"200\"｝ 데이터가 너무 많아서 중간 중간 생략하였습니다. 현재 보팅파워 계산하기 보팅할때마다 일정 비율로 보팅파워가 줄어들며 하루에 20％(5일 동안 100％)의 비율로 재생됩니다. 따라서 **현재 보팅파워current voting power**를 계산하는 공식은 아래와 같습니다. 계산 공식 12345마지막 보팅 후 경과된 시간 = 현재 시간 - 마지막 보팅 시간재생된 보팅파워 = 100％ / 5일 * 마지막 보팅 후 경과된 시간현재 보팅파워 = 마지막 보팅파워 + 재생된 보팅파워 시간은 모두 초 단위로 계산됩니다. **5일Days**는 60(초) * 60(분) * 24(시간) * 5(일)로 초단위 값을 구할 수 있습니다. **“마지막 보팅 후 경과 시간”**은 **“현재 시간”**에서 last_vote_time[1]값을 빼면 알수 있습니다. **“마지막 보팅파워”**는 voting_power[2] 값을 사용합니다. 마지막으로 **“현재 보팅파워”**는 100％를 넘을 수 없습니다. 자바스크립트javascript 코드로 나타내면 아래와 같습니다. 백분율은 계산하기 쉽게 10000로 표현하였습니다. JS Code 1234567891011121314// 마지막 보팅 시각var last_vote_time = \"2018-07-23T04:27:03\";// 마지막 보팅 파워var voting_power = 8925;// 마지막 보팅 후 경과 시각(단위: 초)var elapsed_seconds = (new Date() - new Date(last_vote_time + \"Z\")) / 1000;// 재생된 보팅파워var regenerated_power = 10000 / (60 * 60 * 24 * 5) * elapsed_seconds;// 현재 보팅파워var current_power = Math.round(Math.min(voting_power + regenerated_power, 10000)); 코드를 돌려보면 current_power는 9659가 나옵니다. 이것을 백분율로 환산하면 현재 보팅파워는 **96.59％**가 됩니다. 보팅파워 재생시간 계산 위의 계산 공식을 역으로 계산하면 보팅파워의 재생시간을 알아 낼 수 있습니다. 계산 공식 1재생시간 = (100％ - 현재 보팅파워％) * 5일 / (1시간 * 100％) 자바스크립트javascript 코드로 나타내면 아래와 같습니다. 백분율은 계산하기 쉽게 10000로 표현하였습니다. JS Code 12345// 현재 보팅파워var voting_power = 9700; // 보팅파워 재생시간var remain_hours = (10000 - voting_power) * (5 * 60 * 60 * 24) / (60 * 60 * 10000) remain_hours는 3.6이 나옵니다. 현재 보팅파워가 97％라면 재생시간은 3.6시간이 됩니다. 보팅파워에 따른 회복 시간을 표로 나타내면 아래와 같습니다. 보팅 파워 회복 시간 비고 99％ 1.2시간 98％ 2.4시간 95％ 6시간 80％ 24시간 1일 70％ 36시간 1일 12시간 60％ 48시간 2일 50％ 60시간 2일 12시간 40％ 72시간 3일 30％ 84시간 3일 12시간 20％ 96시간 4일 10％ 108시간 4일 12시간 0％ 120시간 5일 여기까지 읽어주셔서 감사합니다. 꾸벅 -_- 사용자 프로필 JSON 데이터의 last_vote_time값 ↩︎ 사용자 프로필 JSON 데이터의 voting_power값 ↩︎","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"스팀잇(Steemit)","slug":"개발-이야기/스팀잇-steemit","permalink":"https://anpigon.github.io/categories/개발-이야기/스팀잇-steemit/"}],"tags":[{"name":"스팀잇","slug":"스팀잇","permalink":"https://anpigon.github.io/tags/스팀잇/"},{"name":"Steemit","slug":"steemit","permalink":"https://anpigon.github.io/tags/steemit/"}],"author":"anpigon"},{"title":"스텔라 루멘(Stellar Lumens) 토큰 만드는 방법","slug":"개발 이야기/블록체인/2018-07-20-how-to-make-a-custom-token-on-stellar","date":"2018-07-19T15:00:00.000Z","updated":"2019-11-11T13:41:49.829Z","comments":true,"path":"개발 이야기/블록체인/2018-07-20-how-to-make-a-custom-token-on-stellar/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-07-20-how-to-make-a-custom-token-on-stellar/","excerpt":"대부분의 ICO는 이더리움Ethereum의 토큰으로 발행하고 있습니다. 이렇게 하는 이유는 이더리움은 생태계가 매우 잘되어 있고, 많은 사람들이 이더리움을 사용하고 있기 때문입니다.그러나 단점도 있습니다. 이더리움은 초당 약 15건의 트랜잭션만 처리할 수 있습니다. 이것은 이미 문제가 되고 있으며 일부 기존의 dApp들은 이더리움 플랫폼에서 벗어나고 있습니다.","text":"대부분의 ICO는 이더리움Ethereum의 토큰으로 발행하고 있습니다. 이렇게 하는 이유는 이더리움은 생태계가 매우 잘되어 있고, 많은 사람들이 이더리움을 사용하고 있기 때문입니다.그러나 단점도 있습니다. 이더리움은 초당 약 15건의 트랜잭션만 처리할 수 있습니다. 이것은 이미 문제가 되고 있으며 일부 기존의 dApp들은 이더리움 플랫폼에서 벗어나고 있습니다. 하지만 우리에게는 스텔라루멘(XLM)Stellar Lumens이 있습니다. 스텔라에서 나만의 토큰을 만드는 방법을 알아봅니다. 이 글에서는 스텔라에서 토큰을 발행하는 방법을 설명합니다. 스텔라루멘을 처음 시작하는 분들은 아래 글을 먼저 읽고 오시기 바랍니다. 스텔라루멘(STELLAR LUMENS) 시작하기 스텔라 계정 생성하기 신규 토큰을 발행하기 위해서는 두 개의 계정이 필요합니다. 토큰을 발행하는데 사용하는 계정과 토큰을 배포하는데 사용되는 계정입니다. 발행계정(issuing account): 토큰 발행 및 파기에만 사용. 배포계정(base account): 다른 계정과 거래하는 데 사용되는 기본 계정. 발행계정에서 발행한 토큰을 소유합니다. 두 개의 계정이 필요한 이유는, 만약 발행계정에서 토큰을 무한으로 발행한다면 토큰의 가치가 점점 떨어지게 됩니다. 그것을 방지하기 위해 발행계정을 중단할 수 있는 방법이 없습니다. 따라서 발행계정은 토큰을 생성하고 배포계정에게 발행합니다. 그런 다음 발행계정은 더 이상 토큰을 발행 할 수 없도록 영구적으로 잠궈버립니다. 이것으로 토큰이 더 이상 발행되지 않을 것임을 모두에게 보장합니다. 참고로 테스트넷 계정은 https://www.stellar.org/laboratory 에서 생성가능합니다. 두 계정의 트러스트(Trust) 변경하기 이더리움과 다르게 스텔라는 완벽한 스마트 컨트랙트를 제공하지는 않습니다. 이더리움 방식의 스마트 컨트랙트는 최대한의 유연성을 제공하지만 DAO와 같은 주요 해킹 사건과 비교적 최근 패리티(parity) 지갑 오류로 입증되는 것처럼 위험도가 높고 오류가 발생하기 쉽습니다. 스텔라에서의 스마트 컨트랙트라고 하면 일종의 트랜잭션으로 다양한 유형이 있습니다. 이러한 트랜잭션 유형 중에 하나는 &quot;Change Trust&quot;입니다. 토큰을 발행하기 위해서는 배포계정과 발행계정 간에 Change Trust 트랜잭션이 선행되어야 합니다. 배포계정이 배포하는 토큰이 발행계정에서 발행한 신뢰할 수 있는 토큰이라고 선언하는 과정입니다. 아래와 같이 트랜잭션을 빌드하여 실행합니다. 12345678910111213141516171819202122232425// 배포계정(base account)var keyPair = StellarSdk.Keypair.fromSecret(secret);server .loadAccount(keyPair.publicKey()) // 1. 배포계정의 Account 정보 로드 .then(function (account) &#123; // 2. 트랜잭션 빌드 var transaction = new StellarSdk.TransactionBuilder(account) .addOperation(StellarSdk.Operation.changeTrust(&#123; asset: new StellarSdk.Asset('ANPIGON', 'GCCJZXGB5QRWNVUV2IYCEIFPLU2GB2FF7U4Y25MCCWYSVQYYE4O3ZIJT') &#125;)) .build(); // 3. 트랜잭션 서명 transaction.sign(keyPair); // 4. 트랜잭션 전송 return server.submitTransaction(transaction); &#125;) .then(function (transactionResult) &#123; console.log(transactionResult); &#125;) .catch(function(err) &#123; console.log(err); &#125;); changeTrust 오퍼레이션의 asset에는 new Asset('&lt;asset code&gt;', '&lt;issuer&gt;')와 같이 자산코드asset code와 발행자Issuer가 포함됩니다. 자산코드는 관례에 따라 ISO 4217 code로 표현합니다. 또는 자신만의 자산코드를 만들 수도 있습니다. 이 글에서는 자산코드에 &quot;ANPIGON&quot;을 입력하였습니다. 토큰 발행하기 토큰 생성은 발행계정에서 배포계정으로 payment 트랜잭션을 보내면 됩니다. 1234567891011121314151617181920212223242526272829// 발행계정(issuing account)var issuer = StellarSdk.Keypair.fromSecret(secret);// 토큰발행server .loadAccount(issuer.publicKey()) // 1. 발행계정의 Account 정보 로드 .then(function(account) &#123; // 2. 트랜잭션 빌드 var transaction = new StellarSdk.TransactionBuilder(account) .addOperation(StellarSdk.Operation.payment(&#123; destination: keyPair.publicKey(), // 배포계정의 주소 asset: new StellarSdk.Asset(assetCode, issuer.publicKey()), amount: '10000', &#125;)) .addMemo(StellarSdk.Memo.text(assetCode + ' 토큰 발행')) .build(); // 3. 트랜잭션 서명 transaction.sign(issuer); // 4. 트랜잭션 전송 return server.submitTransaction(transaction); &#125;) .then(function (transactionResult) &#123; console.log(transactionResult); &#125;) .catch(function (err) &#123; console.log(err); &#125;); 자, 이제 테스트넷에 우리가 만든 토큰을 10,000개를 발행했습니다. 토큰 발행 계정 잠그기 이제 우리에게는 10,000개의 토큰이 존재하기 때문에 발행계정을 영원히 잠글 시간입니다. 이것은 스텔라에서 제공하는 멀티시그multi-sig 옵션을 사용하여 수행합니다. Set Options 트랜잭션을 사용할 것입니다. Set Options을 사용하여 발행계정의 가중치weight를 &quot;0&quot;으로 설정하고 트랜잭션을 실행하기 위한 임계값threshold를 &quot;1&quot;로 설정합니다. 이렇게 하면 이 발행계정에서는 더 이상 어떤 트랜잭션도 실행할 수 없습니다. 아래와 같이 Set Options 트랜잭션를 서명하고 전송하면 완료됩니다! 12345678910111213141516171819202122232425262728// 발행계정(issuing account)var issuer = StellarSdk.Keypair.fromSecret(secret);// 토큰발행server .loadAccount(issuer.publicKey()) // 1. 발행계정의 Account 정보 로드 .then(function(account) &#123; // 2. 트랜잭션 빌드 var transaction = new StellarSdk.TransactionBuilder(account) .addOperation(StellarSdk.Operation.setOptions(&#123; masterWeight: 0, // 발행계정 가중치 lowThreshold: 1, medThreshold: 1, highThreshold: 1 &#125;)) // 3. 트랜잭션 서명 transaction.sign(issuer); // 4. 트랜잭션 전송 return server.submitTransaction(transaction); &#125;) .then(function (transactionResult) &#123; console.log(transactionResult); &#125;) .catch(function (err) &#123; console.log(err); &#125;); 테스트넷에 토큰이 있는지 보려면 아래와 같이 배포계정 링크로 조회할 수 있습니다. https://horizon-testnet.stellar.org/accounts/GAHST5MT3VALXJGCEVETQVYMCO2CODTW3DXVXIDQ5SISEZJIPBI62ITI 보시다시피 10,000개의 ANPIGON 토큰이 있습니다. 12345678910111213\"balances\": [ &#123; \"balance\": \"10000.0000000\", \"limit\": \"10000.0000000\", \"asset_type\": \"credit_alphanum12\", \"asset_code\": \"ANPIGON\", \"asset_issuer\": \"GCCJZXGB5QRWNVUV2IYCEIFPLU2GB2FF7U4Y25MCCWYSVQYYE4O3ZIJT\" &#125;, &#123; \"balance\": \"9999.9999900\", \"asset_type\": \"native\" &#125; ] 자! 방금 스텔라 테스트넷에 우리가 만든 토큰을 발행했습니다. 이상 마칩니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"스텔라 루멘","slug":"스텔라-루멘","permalink":"https://anpigon.github.io/tags/스텔라-루멘/"}]},{"title":"스텔라 루멘(Stellar lumens) 시작하기","slug":"개발 이야기/블록체인/2018-07-17-steller-lumens-get-started","date":"2018-07-16T15:00:00.000Z","updated":"2019-11-11T13:41:49.828Z","comments":true,"path":"개발 이야기/블록체인/2018-07-17-steller-lumens-get-started/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-07-17-steller-lumens-get-started/","excerpt":"스텔라Stellar는 리플Ripple에서 하드포크하여 개발되었습니다. 현재 비영리 기업인 스텔라 재단에서 운영하고 있습니다. 거래코드는 XLM이고 총 발행량은 1,000억 개입니다.리플과 스텔라가 다른 점은 리플은 수수료를 소각하지만, 스텔라는 계속 잔류하여 1% 수준의 인플레이션을 유발합니다. 리플이 기업간의 자금송금을 목적으로 하고 있다면 스텔라루멘은 개인간의 거래를 목적으로 만들어진 화폐입니다. 합의 매커니즘은 SCP(Stellar Consensus Protocol)를 사용합니다.","text":"스텔라Stellar는 리플Ripple에서 하드포크하여 개발되었습니다. 현재 비영리 기업인 스텔라 재단에서 운영하고 있습니다. 거래코드는 XLM이고 총 발행량은 1,000억 개입니다.리플과 스텔라가 다른 점은 리플은 수수료를 소각하지만, 스텔라는 계속 잔류하여 1% 수준의 인플레이션을 유발합니다. 리플이 기업간의 자금송금을 목적으로 하고 있다면 스텔라루멘은 개인간의 거래를 목적으로 만들어진 화폐입니다. 합의 매커니즘은 SCP(Stellar Consensus Protocol)를 사용합니다. 스텔라 SDK 스텔라stellar SDK는 아래와 같이 2종류가 존재합니다. js-stellar-base: https://github.com/stellar/js-stellar-base js-stellar-sdk: https://github.com/stellar/js-stellar-sdk js-stellar-base js-stellar-base library는 lowest-level 라이브러리입니다. 이 라이브러리를 사용하면 stellar-core에서 사용되는 XDR 형태의 데이터를 읽고 쓰고 해싱하고 서명할 수 있습니다. JavaScript로 구현되어 있어 Node.js 또는 웹브라우저에서 사용할 수 있습니다. js-stellar-sdk js-stellar-sdk는 Stellar Horizon 서버와 통신하는 Javascript라이브러리입니다. js-stellar-sdk도 내부적으로는 js-stellar-base 라이브러리를 사용하고 있습니다. 스텔라 SDK 설치 및 사용 이 문서에서는 js-stellar-sdk 라이브러리를 사용합니다. 아래와 같이 설치하여 사용할 수 있습니다. 설치하기 1234# stellar-sdk Installnpm install --save stellar-sdk# oryarn add stellar-sdk 사용하기 12// stellar-sdk Usagevar StellarSdk = require('stellar-sdk'); 계정(Account) 생성 스텔라 네트워크에서 거래를 하기 위해서는 계정을 생성하여야 합니다. 계정account은 public key와 secret seed 로 구성됩니다. 아래와 같이 public Key와 secret를 생성 할 수 있습니다. 1234var pair = StellarSdk.Keypair.random(); pair.secret(); // SAV76USXIJOBMEQXPANUOQM6F5LIOTLPDIDVRJBFFE2MDJXG24TAPUU7 pair.publicKey(); // GCFXHS4GXL6BVUCXBWXGTITROWLVYXQKQLF4YH5O5JT3YZXCYPAFBJZB 생성된 secret seed 와 public key를 이용해서 거래를 하기 위해서는 스텔라 네트워크에 계정 생성 요청을 해야합니다. 스텔라에서는 무분별한 불필요한 계정 생성을 막기 위해서 계정의 최소 잔액을 1루멘lumen을 정의하고 있습니다. 계정을 생성하기 위해서는 루멘을 가지고 있는 계정이 필요합니다. 다만 테스트넷에서는 계정을 생성 할 수 있는 Friendbot API를 제공하고 있습니다. Friendbot API로 계정(Account) 생성 테스트넷에서는 friendbot API를 이용하여 아래와 같이 계정 생성 요청을 할 수 있습니다. 12345678910111213141516var StellarSdk = require('stellar-sdk');StellarSdk.Network.useTestNetwork();var server = new StellarSdk.Server('https://horizon-testnet.stellar.org');var keypair = StellarSdk.Keypair.random();console.log('Secret Key:', keypair.secret());console.log('Public Key:', keypair.publicKey()); //addressserver.friendbot(keypair.publicKey()) .call() .then(function(resp) &#123; console.log(resp); &#125;) .catch(function(err) &#123; console.log(err); &#125;); stellar-sdk 를 사용하지 않는다면 아래와 같은 방법으로도 가능합니다. 123456789101112var request = require('request');request.get(&#123; url: 'https://friendbot.stellar.org', qs: &#123; addr: keypair.publicKey() &#125;, json: true&#125;, function(error, response, body) &#123; if (error || response.statusCode !== 200) &#123; console.error('ERROR!', error || body); &#125; else &#123; console.log('SUCCESS! You have a new account :)\\n', body); &#125;&#125;); 이제 마지막으로 계정의 잔액을 확인해보도록 하겠습니다. 스텔라는 여러 통화 유형의 거래를 허용하기 때문에 계정에는 통화 유형별로 잔액을 가지고 있습니다. 아래와 같이 계정 정보를 조회할 수 있습니다. 123456server.loadAccount(pair.publicKey()).then(function(account) &#123; console.log('Balances for account: ' + pair.publicKey()); account.balances.forEach(function(balance) &#123; console.log('Type:', balance.asset_type, ', Balance:', balance.balance); &#125;); &#125;); createAccount 오퍼레이션으로 계성 생성 createAccount 오퍼레이션operation를 사용하여 계정 생성하는 방법은 아래와 같습니다. 트랜잭션을 서명하는 계정에는 계정 생성에 필요한 1루멘와 수수료를 포함한 잔액을 가지고 있어야합니다. 1234567891011121314151617var secretKey = '루멘을 가지고 있는 계정의 secret key';var keypair = StellarSdk.Keypair.fromSecret(secretKey);var newKeypair = StellarSdk.Keypair.random(); // 신규 생성할 계정server .loadAccount(keypair.publicKey()) .then(function (account) &#123; var transaction = new StellarSdk.TransactionBuilder(account) .addOperation(StellarSdk.Operation.createAccount(&#123; destination: newKeypair.publicKey(), startingBalance: \"1\" // 최소 1 XLM 필요 &#125;)).build(); transaction.sign(keypair); // 트랜잭션 서명 return server.submitTransaction(transaction); // 트랜잭션 전송 &#125;) .then(function (transactionResult) &#123; console.log('tx hash:', transactionResult.hash); &#125;); 여러분이 생성한 계정과 트랜잭션 정보는 stellar expert expolorer에서 조회 가능합니다. https://stellar.expert/explorer/testnet 이상 마칩니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"스텔라 루멘","slug":"스텔라-루멘","permalink":"https://anpigon.github.io/tags/스텔라-루멘/"}]},{"title":"이더리움 ERC20 토큰(또는 코인) 만들기","slug":"개발 이야기/블록체인/2018-07-07-erc20-token-create","date":"2018-07-06T15:00:00.000Z","updated":"2019-11-11T13:41:49.828Z","comments":true,"path":"개발 이야기/블록체인/2018-07-07-erc20-token-create/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-07-07-erc20-token-create/","excerpt":"이더리움의 스마트 컨트랙트를 사용하여 토큰(코인)을 만드는 방법을 알아보겠습니다. 이더리움 네트워크에 토큰 컨트랙트를 배포하면 해당 컨트랙트를 코인처럼 사용할 수 있습니다. ERC20 토큰 컨트랙트 구현ERC20 토큰 컨트랙트는 [EIP-20] 규격문서 참고하여 구현합니다. 이미 구현된 오픈소스들이 있으므로 github에서 가져오겠습니다.","text":"이더리움의 스마트 컨트랙트를 사용하여 토큰(코인)을 만드는 방법을 알아보겠습니다. 이더리움 네트워크에 토큰 컨트랙트를 배포하면 해당 컨트랙트를 코인처럼 사용할 수 있습니다. ERC20 토큰 컨트랙트 구현ERC20 토큰 컨트랙트는 [EIP-20] 규격문서 참고하여 구현합니다. 이미 구현된 오픈소스들이 있으므로 github에서 가져오겠습니다. 아래는 ERC20 토큰 컨트랙트를 구현하는 EIP20.sol 내용입니다. 소스코드 전체가 아니므로 giuhub에서 컨트랙트 전체 소스코드를 확인바랍니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.21;import \"./EIP20Interface.sol\";contract EIP20 is EIP20Interface &#123; uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address =&gt; uint256) public balances; mapping (address =&gt; mapping (address =&gt; uint256)) public allowed; string public name; //fancy name: eg Simon Bucks uint8 public decimals; //How many decimals to show. string public symbol; //An identifier: eg SBX function EIP20( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public &#123; balances[msg.sender] = _initialAmount; // Give the creator all initial tokens totalSupply = _initialAmount; // Update total supply name = _tokenName; // Set the name for display purposes decimals = _decimalUnits; // Amount of decimals for display purposes symbol = _tokenSymbol; // Set the symbol for display purposes &#125; function transfer(address _to, uint256 _value) public returns (bool success) &#123; require(balances[msg.sender] &gt;= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars return true; &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] &gt;= _value &amp;&amp; allowance &gt;= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance &lt; MAX_UINT256) &#123; allowed[_from][msg.sender] -= _value; &#125; emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars return true; &#125; function balanceOf(address _owner) public view returns (uint256 balance) &#123; return balances[_owner]; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars return true; &#125; function allowance(address _owner, address _spender) public view returns (uint256 remaining) &#123; return allowed[_owner][_spender]; &#125;&#125; 컨트랙트 컴파일 및 배포 컨트랙트를 배포하기 위해 Ropsten 테스트넷을 사용합니다. 테스트넷 연결 web3를 이용하여 테스트넷에 접속하기 위해서 www.infura.io 에 회원가입하여 API_KEY를 발급받습니다.테스트넷 접속 URL는 https://ropsten.infura.io/[API_KEY]의 형태가 됩니다. 아래와 같이 테스트넷에 연결합니다. 12345var Web3 = require('web3');// 이더리움 테스트넷 연결var TEST_NET_URL = 'https://ropsten.infura.io/[infura_api_key_here]';var web3 = new Web3(new Web3.providers.HttpProvider(TEST_NET_URL)); 컨트랙트 컴파일 이제 소스코드 EIP20.sol 파일을 컴파일합니다. 그리고 이더리움 노드에 등록할 토큰 컨트랙트를 생성하도록 하겠습니다. 12345678910111213141516var path = require('path');var solc = require('solc');// 컴파일 하기var contractSource = fs.readFileSync(path.resolve(__dirname, 'ERC20Token.sol'), 'utf8');var compiledCode = solc.compile(contractSource.toString(), 1).contracts[':EIP20'];var bytecode = compiledCode.bytecode;var abiDefinition = JSON.parse(compiledCode.interface);var contract = web3.eth.contract(abiDefinition);// 토큰 정보 입력var name = '안피곤 코인'; // 코인 이름var symbol = 'ANP'; // 코인 기호var amount = 10000; // 초기 코인량var decimals = 18; // 자연 단위수(10^18)var txInputData = '0x' + contract.new.getData(amount, name, decimals, symbol, &#123;data: bytecode&#125;); 개인키 생성 트랜잭션을 서명할 개인키는 니모닉 워드를 사용하여 생성하겠습니다. 123456789var Bitcore = require('bitcore-lib');var Mnemonic = require('bitcore-mnemonic');// 니모닉 워드(보통 12단어로 구성)var mnemonicWords = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about';var xPriKey = Mnemonic(mnemonicWords).toHDPrivateKey('', 'testnet'); // 확장 개인키 생성var privkey = xPriKey.deriveChild(\"m/44'/60'/0'/0/0\").privateKey; // 서명할 개인키var fromAddress = '0x' + ethUtil.privateToAddress(privkey.toBuffer()).toString('hex'); console.log('fromAddress:', fromAddress); // 이더리움 주소 트랙잭션 서명 이제 트랜잭션을 구성하고 개인키로 트랜잭션을 서명 합니다. 1234567891011121314151617181920var EthTx = require('ethereumjs-tx');var ethUtil = require('ethereumjs-util');// 서명자의 주소var fromAddress = '0x' + ethUtil.privateToAddress(privkey).toString('hex'); // 트랜잭션 생성var nonce = web3.eth.getTransactionCount(fromAddress); // 트랜잭션 Nonce값 조회var gasPrice = web3.eth.gasPrice; // 네트워크 가스 가격 조회const rawTx = &#123; nonce: web3.toHex(nonce), gasPrice: web3.toHex(gasPrice), // 가스 1개당 가격(wei 단위) gasLimit: web3.toHex(3000000), // 가스 최대 사용량 data: txInputData, // 컨트랙트 excute 함수 호출 데이터 chainId: 3, //네트워크 ID&#125;// 트랜잭션 서명const tx = new EthTx(rawTx); // 트랜잭션 객체 생성tx.sign(privkey); // tx 서명 트랜잭션 전송 및 컨트랙트 배포 이제 이더리움 네트워크에 트랜잭션을 전송합니다. 참고로 컨트랙트를 배포하기 위해서는 수수료를 지불할 수 있을 정도의 Ether가 있어야합니다. 테스트넷의 Ether를 받는 방법은 Faucet를 이용하는 것입니다. 12345678var serializedTx = tx.serialize(); // hex serialize binary 생성web3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), function(err, hash) &#123; if (err) &#123; console.log(err); return; &#125; console.log('txHash:', hash); // tx hash 생성&#125;); 트랜잭션을 전송하고 나서 출력된 txHash값을 이용하여 테스트넷 이더스캔(https://ropsten.etherscan.io/)에서 컨트랙트 주소를 확인합니다. 채굴이 완료되면 방금 등록한 토큰의 address가 보일 것 입니다. 토큰 확인 컨트랙트 주소가 생성되면 아래와 같이 토큰을 확인 할 수 있다. 123456var contractAddress = '[컨트랙트 주소]';var contractInstance = web3.eth.contract(abiDefinition).at(contractAddress);console.log('symbol:', contractInstance.symbol.call());console.log('decimals:', contractInstance.decimals.call().toNumber());console.log('name:', contractInstance.name.call());console.log('balance:', contractInstance.balanceOf.call(fromAddress).toNumber()); Result: 1234symbol: ANPdrcimals: 18name: 안피곤 코인balance: 10000 이상 마칩니다. 다음에는 우리가 만든 토큰을 거래 할 수 있는 지갑을 구현해볼 예정입니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}]},{"title":"이더리움 클라이언트 geth 맥에 설치하기","slug":"개발 이야기/블록체인/2018-7-1-ethereum-geth-install-for-mac-md","date":"2018-06-30T15:00:00.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"개발 이야기/블록체인/2018-7-1-ethereum-geth-install-for-mac-md/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-7-1-ethereum-geth-install-for-mac-md/","excerpt":"이더리움 클라이언트 중 하나인 geth를 맥에 설치하여 사용하는 방법을 알아보겠습니다. brew 설치brew는 Mac용 패키지 관리자입니다.1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","text":"이더리움 클라이언트 중 하나인 geth를 맥에 설치하여 사용하는 방법을 알아보겠습니다. brew 설치brew는 Mac용 패키지 관리자입니다.1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Go 설치 Go 공식 웹 사이트에 가서 Mac OSX 용 패키지를 다운로드 받아 설치합니다. 본 글에서는 1.10.2 을 사용합니다. go다운로드 페이지: http://golang.org/dl go1.10.2.darwin-amd64.pkg (124MB) 를 다운로드 받습니다. Geth 설치 여기서는 현재 최신버전인 Titanium(v1.8.7)를 사용합니다. Geth 설치방법은 2가지가 있습니다. (1) geth 바이너리 다운로드하는 방법 다운로드 페이지: https://geth.ethereum.org/downloads/ geth-darwin-amd64-1.8.7-66432f38.tar.gz를 다운받아서 압축을 해제한다. 그리고 /usr/local/bin/ 디렉토리에 geth 를 복사한 후 버전을 확인한다. 12345678910111213$ sudo cp ~/Downloads/geth-darwin-amd64-1.8.7-66432f38/geth /usr/local/bin/$ geth versionGethVersion: 1.8.7-stableGit Commit: 66432f3821badf24d526f2d9205f36c0543219deArchitecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.10.1Operating System: darwinGOPATH=GOROOT=/Users/travis/.gimme/versions/go1.10.1.darwin.amd64 (2) git에서 소스코드를 다운받아 컴파일하는 방법 1$ git clone -b release/1.8 https://github.com/ethereum/go-ethereum 다운로드가 완료되면 폴더로 이동한다음 컴파일을 실행한다. 참고로 Geth는 Go 언어로 개발되었기때문에 Go 컴파일러가 반드시 필요하다. 12$ cd go-ethereum/$ make geth Geth 실행하기 1$ geth --networkid 4649 --nodiscover --maxpeers 0 --datadir ~/data_testnet --rpc --rpcaddr \"0.0.0.0\" --rpcport 8545 --rpccorsdomain \"*\" --rpcapi \"admin,db,eth,debug,miner,net,shh,txpool,personal,web3\" --verbosity 6 console 2&gt;&gt; ~/data_testnet/geth.log geth의 Command line options에 대한 설명은 다음을 참고한다. https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options 매번 구동시 마다 편의를 위해서 alias를 설정합니다. 1$ echo \"alias gethstart='geth --networkid 4649 --nodiscover --maxpeers 0 --datadir ~/data_testnet --rpc --rpcaddr \"0.0.0.0\" --rpcport 8545 --rpccorsdomain \"*\" --rpcapi \"admin,db,eth,debug,miner,net,shh,txpool,personal,web3\" --verbosity 6 console 2&gt;&gt; ~/data_testnet/geth.log'\" &gt;&gt; ~/.bashrc 그리고 로그인시 마다 적용하기 위해서는 .profile 에 해당 내용을 Shell에 반영합니다. 1$ source ~/.bashrc 이상 마칩니다. 참고: https://steemit.com/ethreum/@wisefree/1","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}]},{"title":"이더리움 멀티시그 지갑 컨트랙트에서 송금하기","slug":"개발 이야기/블록체인/2018-6-28-ethereum-multisig-wallet-contract-use","date":"2018-06-27T15:00:00.000Z","updated":"2019-11-11T13:41:49.830Z","comments":true,"path":"개발 이야기/블록체인/2018-6-28-ethereum-multisig-wallet-contract-use/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-6-28-ethereum-multisig-wallet-contract-use/","excerpt":"이번에는 이더리움 멀티시그 지갑 컨트랙트를 이용하여 송금하는 것을 알아봅니다.이더리움 멀티시그 지갑 컴트랙트 배포 방법은 이전글을 참고바랍니다. 이더리움 멀티시그 지갑 컨트랙트 배포하기 컨트랙트에 이더 송금하기멀티시그 지갑 컨트랙트에서 이더를 송금하기 위해서는 우선 컨트랙트에 잔액이 있어야 합니다. 그래서 컨트랙트 주소로 0.1 ether를 송금하여 컨트랙트가 잔액을 가지도록 합니다.","text":"이번에는 이더리움 멀티시그 지갑 컨트랙트를 이용하여 송금하는 것을 알아봅니다.이더리움 멀티시그 지갑 컴트랙트 배포 방법은 이전글을 참고바랍니다. 이더리움 멀티시그 지갑 컨트랙트 배포하기 컨트랙트에 이더 송금하기멀티시그 지갑 컨트랙트에서 이더를 송금하기 위해서는 우선 컨트랙트에 잔액이 있어야 합니다. 그래서 컨트랙트 주소로 0.1 ether를 송금하여 컨트랙트가 잔액을 가지도록 합니다. 12345678910111213141516171819202122232425262728// 이전에 배포한 컨트랙트 주소var contractAddress = '0x57FC45cc929f84eC95cd6C6903bBcA8d1164d0B3'; // 가스비를 지출할 계정 주소var fromAddress = '0xf6d0B5f612dEecB00345D...'; // 1. nonce 값 조회var nonce = web3.eth.getTransactionCount(fromAddress); // 2. 트랙잭션 데이터 생성 var tx = new ethTx(&#123; nonce: web3.toHex(nonce), to: contractAddress, value: web3.toHex(web3.toWei(0.1, 'ether').toNumber()), gasPrice: web3.toHex(1), // 가스 가격(wei 단위) gasLimit: web3.toHex(3000000), // 가스 최대 사용량 chainId: 3, //네트워크 ID(3=Ropsten Tesetnet) &#125;);// 3. 트랜잭션 서명tx.sign(privateKey);// 4. 트랜잭션 전송하기web3.eth.sendRawTransaction('0x' + tx.serialize().toString('hex'), function(err, txId) &#123; if (!err) &#123; console.log('txId: ', txId); // 트랜잭션ID값 &#125;&#125;); 트랜잭션과 잔액 확인하기 컨트랙트 주소로 송금하는 트랜잭션이 성공하였으면, 컨트랙트에 잔액이 추가되었는지 확인합니다. 트래잭션과 잔액은 아래 사이트에서 확인가능합니다. https://ropsten.etherscan.io/ 아래 화면은 아직 채굴전이라서 트랜잭션이 아직 pending 상태이고, 컨트랙트 잔액이 0 Ether 입니다. 채굴이 되어 트랜잭션이 블록에 포함되면, 트랜잭션 상태가 바뀌고 컨트랙트가 0.1 Ether를 가지고 있는 것을 확인할 수 있습니다. 컨트랙트 멀티시그 함수 호출하기 이제 컨트랙트에 들어있는 0.1 ether를 멀티시그를 이용하여 송금해보겠습니다. 아래 코드에 보이는 abiDefinition에는 컨트랙트 소스를 컴파일해서 나온 abi 데이터를 사용합니다. 1234567891011121314151617181920212223242526272829var abiDefinition = &#123; /* 컨트랙트 abi 데이터 */ &#125;;var contract = web3.eth.contract(abiDefinition).at(contractAddress);// 1. 컨트랙트 실행하기 위한 데이터 생성 var destination = '&lt;ehter를 수신받는 address&gt;';var value = web3.toWei(new BigNumber(0.01), 'ether');var data = '0x';var sigs = createSigs(signers, contract.address, nonce, destination, value, '0x')var txInputData = contract.execute.getData(sigs.sigV, sigs.sigR, sigs.sigS, destination, web3.toHex(value), ata);// 2. 트랙잭션 데이터 생성 var tx = new ethTx(&#123; nonce: web3.toHex(nonce), to: contract.address, gasPrice: web3.toHex(1), gasLimit: web3.toHex(3000000), data: txInputData, chainId: 3, //네트워크 ID(3=Ropsten Tesetnet) &#125;); // 3. 트랜잭션 서명하기 tx.sign(privateKey); // 4. 트랜잭션 전송하기 web3.eth.sendRawTransaction('0x' + tx.serialize().toString('hex'), function(err, txId) &#123; if (!err) &#123; console.log('txId: ', txId); // 트랜잭션ID값 &#125; &#125;); createSigs 함수 구현방법은 simplemultisig.js 소스를 참고해주세요. 트랜잭션 요청이 끝나면 이더 스캔에서 확인가능합니다. 채굴이 완료되어 컨트랙트에 있던 0.1 Ether 가 destination으로 전송되었는지 확인합니다. 이상 마칩니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}]},{"title":"이더리움 멀티시그 지갑 컨트랙트 배포하기","slug":"개발 이야기/블록체인/2018-6-24-ethereum-multisig-wallet-contract-deploy","date":"2018-06-23T15:00:00.000Z","updated":"2019-11-11T13:41:49.829Z","comments":true,"path":"개발 이야기/블록체인/2018-6-24-ethereum-multisig-wallet-contract-deploy/","link":"","permalink":"https://anpigon.github.io/개발 이야기/블록체인/2018-6-24-ethereum-multisig-wallet-contract-deploy/","excerpt":"이번에는 이더리움 멀티시그 지갑 컨트랙트를 배포하는 것을 알아봅니다.해당 내용은 아래 블로그를 참고하여 구현하였습니다.참고: Exploring Simpler Ethereum Multisig Contracts - Christian Lundkvist web3 모듈 설치현재 web3 버전은 1.0.0-beta.34 까지 나왔지만, 여기서는 web3-0.20.6을 설치하여 사용합니다. 필요한 모듈들을 아래와 같이 설치합니다.","text":"이번에는 이더리움 멀티시그 지갑 컨트랙트를 배포하는 것을 알아봅니다.해당 내용은 아래 블로그를 참고하여 구현하였습니다.참고: Exploring Simpler Ethereum Multisig Contracts - Christian Lundkvist web3 모듈 설치현재 web3 버전은 1.0.0-beta.34 까지 나왔지만, 여기서는 web3-0.20.6을 설치하여 사용합니다. 필요한 모듈들을 아래와 같이 설치합니다. 1npm install web3@0.20.6 solc ethereumjs-tx ethereumjs-util bitcore-lib web 모듈은 아래와 같이 사용합니다. 예제에서는 HttpProvider 를 지정해주었으나, 이더리움 노드와 web3가 같은 서버에서 동작한다면 IpcProvider 하는것이 성능면에서 더 효율적입니다. 12var Web3 = require('web3');var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8551')); 멀티시그 컨트랙트 작성 멀티시트 컨트랙트 소스는 아래 github에서 가져왔습니다. 컨트랙트 소스 내용에 대한 설명은 생략합니다. https://github.com/christianlundkvist/simple-multisig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.22;contract SimpleMultiSig &#123; uint public nonce; // (only) mutable state uint public threshold; // immutable state mapping (address =&gt; bool) isOwner; // immutable state address[] public ownersArr; // immutable state // Note that owners_ must be strictly increasing, in order to prevent duplicates constructor(uint threshold_, address[] owners_) public &#123; require(owners_.length &lt;= 10 &amp;&amp; threshold_ &lt;= owners_.length &amp;&amp; threshold_ &gt;= 0); address lastAdd = address(0); for (uint i = 0; i &lt; owners_.length; i++) &#123; require(owners_[i] &gt; lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; &#125; ownersArr = owners_; threshold = threshold_; &#125; // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public &#123; require(sigR.length == threshold); require(sigR.length == sigS.length &amp;&amp; sigR.length == sigV.length); // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); // cannot have address(0) as an owner for (uint i = 0; i &lt; threshold; i++) &#123; address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered &gt; lastAdd &amp;&amp; isOwner[recovered]); lastAdd = recovered; &#125; // If we make it here all signatures are accounted for. // The address.call() syntax is no longer recommended, see: // https://github.com/ethereum/solidity/issues/2884 nonce = nonce + 1; bool success = false; assembly &#123; success := call(gas, destination, value, add(data, 0x20), mload(data), 0, 0) &#125; require(success); &#125; function () payable public &#123;&#125;&#125; 컨트랙트 소스 컴파일 solidity 소스를 컴파일 하는 방법은 다양하지만, 여기서는 node 에서 solc 모듈을 사용하여 컴파일하였습니다. 12345678910111213var fs = require('fs');var path = require('path');var solc = require('solc');// 1. 컨트랙트 소스 파일 읽기var contractSource = fs.readFileSync(path.resolve(__dirname, 'SimpleMultiSig.sol'), 'utf8');// 2. solc를 사용하여 컴파일var compiledCode = solc.compile(contractSource.toString(), 1).contracts[':SimpleMultiSig'];// 3. 컴파일 결과물에서 바이트코드와 abi 정보 조회var bytecode = compiledCode.bytecode;var abiDefinition = JSON.parse(compiledCode.interface); 매번 소스코드를 읽어와서 컴파일하면 시간이 오래걸리므로, 컴파일된 코드를 파일로 저장하여 사용하는 것을 권장합니다. 이더리움 블록체인에 컨트랙트 배포 컨트랙트를 배포하기 위한 과정을 차례대로 알아봅니다. 1. 개인키 생성 우선 서명하기 위한 개인키가 필요합니다. 개인키 생성은 Bitcore 모듈을 이용하였습니다. 1234567var Bitcore = require('bitcore-lib');var ethUtil = require('ethereumjs-util');// 개인키 생성var privateKey = new Bitcore.PrivateKey().toBuffer(); // 이미 테스트 중인 개인키가 있다면 아래와 같이 사용가능// var privateKey = new Buffer(\"f6fd01....fb41\", \"hex\"); 2. 트랜잭션 생성 트랜잭션은 nonce, to, value, gasPrice, gasLimit, data, v, r, s 로 구성됩니다. gasPrice 는 web3.eth.gasPrice 를 이용하여 이더리움 블록체인의 평균 gas 가격 조회가 가능합니다. 또는 아래 이더리움 가스스테이션 서비스를 이용할 수도 있습니다. https://ethgasstation.info/ 123456789101112131415161718192021222324252627282930313233// 1. 개인키에 해당하는 이더리움 주소var fromAddress = '0x' + ethUtil.privateToAddress(privkey).toString('hex'); // 2. 잔액 조회var balance = web3.eth.getBalance(fromAddress);console.log('balance: ' + web3.fromWei(balance, 'ether').toString(10) + ' ETH');// 컨트랙트를 배포하기 위해서는 gas비용이 필요하기 때문에 ether가 있어야한다.// 3. 컨트랙트 생성자(constructor)에 필요한 데이터var threshold = 2; // 필요한 서명 갯수var owners = [\"&lt;address1&gt;\", \"&lt;address2&gt;\", \"&lt;address3&gt;\"]; // 서명자 주소들// 4. 컨트랙트를 배포하기 위한 데이터 생성var contract = web3.eth.contract(abiDefinition); //컨트랙트 인스턴스 생성var txInputData = '0x' + contract.new.getData(threshold, owners, &#123;data: bytecode&#125;);// 5. 트랜잭션 Nonce값 조회var nonce = web3.eth.getTransactionCount(fromAddress); // 발생한 트랜잭션이 없다면 0이 조회됨// 6. 트랙잭션 데이터 생성const rawTx = &#123; nonce: web3.toHex(nonce), //to: '0x0', //value: '0x0', gasPrice: web3.toHex(1), // 가스 가격(wei 단위) gasLimit: web3.toHex(3000000), // 가스 최대 사용량 data: txInputData, // 컨트랙트 배포 데이터 chainId: 3, //네트워크 ID(3=Ropsten Tesetnet)&#125;var tx = new ethTx(rawTx);// 7. 트랜잭션 서명하기tx.sign(privateKey); 3. 트랜잭션 전송 컨트랙트를 배포를 위한 트랜잭션을 아래와 같이 이더리움 블록체인에 전송합니다. 123456789// 1. hex serialize binary 생성var serializedTx = tx.serialize(); // 2. 트랜잭션 전송하기web3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), function(err, txId) &#123; if (!err) &#123; console.log('txId: ', txId); // 트랜잭션ID값 &#125;&#125;); 4. 컨트랙트 주소 조회 컨트랙트 주소는 블록이 채굴된 후에 조회가능합니다. 트랜잭션이 블록에 포함되었다면, 아래와 같이 Transaction Receipt에서 조회 가능합니다. 123456// 컨트랙트 주소 조회하기web3.eth.getTransactionReceipt(txId, function(err, receipt)&#123; if (err) &#123; console.log('Contract Address: ', receipt.contractAddress); &#125;&#125;); 여기까지 이더리움 멀티시그 컨트랙트 배포에 대해 알아보았습니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"},{"name":"블록체인","slug":"개발-이야기/블록체인","permalink":"https://anpigon.github.io/categories/개발-이야기/블록체인/"}],"tags":[{"name":"블록체인","slug":"블록체인","permalink":"https://anpigon.github.io/tags/블록체인/"},{"name":"이더리움","slug":"이더리움","permalink":"https://anpigon.github.io/tags/이더리움/"}]},{"title":"레드마인(Redmine) svn 저장소 등록시 404 오류가 발생할때","slug":"/redmine/@anpigon/redmine-svn-404","date":"2018-03-08T05:43:42.000Z","updated":"2019-11-11T13:41:49.810Z","comments":true,"path":"/redmine/@anpigon/redmine-svn-404/","link":"","permalink":"https://anpigon.github.io/redmine/@anpigon/redmine-svn-404/","excerpt":"레드마인에서 SVN 저장소 연결 정보를 입력하고 저장소 페이지를 가보면 404 오류가 계속 뜨는 경우, 에러로그를 살펴보면 아래와 같이 No close tag for /lists/list 오류가 나타난다.1234567891011No close tag for /lists/listLine: 4Position: 100Last 80 unconsumed characters:Output was: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;lists&gt;&lt;list path=\"https://XXXXXXXX/svn/XX\"&gt; Rendered common/error.html.erb within layouts/base (0.4ms)","text":"레드마인에서 SVN 저장소 연결 정보를 입력하고 저장소 페이지를 가보면 404 오류가 계속 뜨는 경우, 에러로그를 살펴보면 아래와 같이 No close tag for /lists/list 오류가 나타난다.1234567891011No close tag for /lists/listLine: 4Position: 100Last 80 unconsumed characters:Output was: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;lists&gt;&lt;list path=\"https://XXXXXXXX/svn/XX\"&gt; Rendered common/error.html.erb within layouts/base (0.4ms) 이런 경우 레드마인 계정에서 아래와 같이 명령어를 실행한다. 1$ svn list --xml 'https://svn.server.address/reponame'@HEAD 아래와 같이 인증서 처리 여부를 확인하는 메세지가 나타난다. 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;lists&gt;&lt;list path=\"https://XXXXXXXX/svn/XX\"&gt;Error validating server certificate for 'https://XXXXXXXX:443': - The certificate is not issued by a trusted authority. Use the fingerprint to validate the certificate manually! - The certificate hostname does not match.Certificate information: - Hostname: xxxx - Valid: from Mon, 18 Mar 2013 02:22:40 GMT until Thu, 16 Mar 2023 02:22:40 GMT - Issuer: xxxx - Fingerprint: bd:75:a1:f0:a7:34:15:42:47:b2:27:d0:b4:ca:4f:7a:e4:0b:2a:73(R)eject, accept (t)emporarily or accept (p)ermanently? P 를 눌러 인증처리 후 저장 여부에서 yes(필요시) 까지 눌러 한번 리스팅이 완료되면 레드마인에서는 올바르게 실행된다. svn 연결이 잘되는지 다시 한번 확인한다. 1$ svn info https://svn.server.address/reponame 만약, 레드마인 계정이 www-data 와 같이 로그인 할 수 없는 계정이라면 아래와 같이 레드마인이 접근가능한 폴더에 svn 인증정보를 복사한다. 1sudo -u www-data svn list --xml 'https://svn.server.address/reponame'@HEAD (You may have to add “www-data ALL=(ALL) NOPASSWD:ALL” to /etc/sudoers) 123$ sudo cp ~/.subversion /usr/share/redmine/.subversion/$ sudo chown -R www-data:www-data /usr/share/redmine/.subversion/ 마지막으로 레드마인의 소스를 약간 수정한다. 수정파일 : /usr/share/redmine/lib/redmine/scm/adapters/subversion_adapter.rb #수정전 1234567def credentials_string str = '' str &lt;&lt; \" --username #｛shell_quote(@login)｝\" unless @login.blank? str &lt;&lt; \" --password #｛shell_quote(@password)｝\" unless @login.blank? || @password.blank? str &lt;&lt; \" --no-auth-cache --non-interactive\" str end #수정후 1234567def credentials_string str = '' str &lt;&lt; \" --username #｛shell_quote(@login)｝\" unless @login.blank? str &lt;&lt; \" --password #｛shell_quote(@password)｝\" unless @login.blank? || @password.blank? str &lt;&lt; \" --trust-server-cert-failures=unknown-ca --no-auth-cache --non-interactive --config-dir /usr/share/redmine/.subversion/ \" strend 레드마인을 리스타트 한다. 1$ sudo service apache2 restart 가이드를 마칩니다.","categories":[{"name":"개발 이야기","slug":"개발-이야기","permalink":"https://anpigon.github.io/categories/개발-이야기/"}],"tags":[{"name":"redmine","slug":"redmine","permalink":"https://anpigon.github.io/tags/redmine/"},{"name":"svn","slug":"svn","permalink":"https://anpigon.github.io/tags/svn/"}],"author":"anpigon"}]}